-- ************************************************************************
--
-- Description:
--
-- Rapid Enquiry Facility (RIF) - Tile maker - Create processed CSV tables created 
-- from shapefiles simplification
--
-- Copyright:
--
-- The Rapid Inquiry Facility (RIF) is an automated tool devised by SAHSU 
-- that rapidly addresses epidemiological and public health questions using 
-- routinely collected health and population data and generates standardised 
-- rates and relative risks for any given health outcome, for specified age 
-- and year ranges, for any given geographical area.
--
-- Copyright 2014 Imperial College London, developed by the Small Area
-- Health Statistics Unit. The work of the Small Area Health Statistics Unit 
-- is funded by the Public Health England as part of the MRC-PHE Centre for 
-- Environment and Health. Funding for this project has also been received 
-- from the Centers for Disease Control and Prevention.  
--
-- This file is part of the Rapid Inquiry Facility (RIF) project.
-- RIF is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Lesser General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- RIF is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU Lesser General Public License for more details.
--
-- You should have received a copy of the GNU Lesser General Public License
-- along with RIF. If not, see <http://www.gnu.org/licenses/>; or write 
-- to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
-- Boston, MA 02110-1301 USA
--
-- Author:
--
-- Peter Hambly, SAHSU
--
-- This script is autogenerated.
--
--
-- Postgres specific parameters
--
-- Usage: psql -w -e -f pg_USA_2014.sql
-- Connect flags if required: -U <username> -d <Postgres database name> -h <host> -p <port>
--
\pset pager off
\set ECHO all
\set ON_ERROR_STOP ON
\timing

-- SQL statement 0: Start transaction >>>
BEGIN TRANSACTION;

-- SQL statement 1: Drop table cb_2014_us_county_500k >>>
DROP TABLE IF EXISTS cb_2014_us_county_500k;

-- SQL statement 2: Create tablecb_2014_us_county_500k >>>
CREATE TABLE cb_2014_us_county_500k (
	statefp                        	text /* Current state Federal Information Processing Series (FIPS) code */,
	countyfp                       	text /* Current county Federal Information Processing Series (FIPS) code */,
	countyns                       	text /* Current county Geographic Names Information System (GNIS) code */,
	affgeoid                       	text /* American FactFinder summary level code + geovariant code + ''00US'' + GEOID */,
	geoid                          	text /* County identifier; a concatenation of current state Federal Information Processing Series (FIPS) code and county FIPS code */,
	name                           	text /* Current county name */,
	lsad                           	text /* Current legal/statistical area description code for county */,
	aland                          	text /* Current land area (square meters) */,
	awater                         	text /* Current water area (square meters) */,
	gid                            	integer	NOT NULL /* Unique geographic index */,
	areaid                         	text	NOT NULL /* Area ID (COUNTYNS): Current county Geographic Names Information System (GNIS) code */,
	areaname                       	text	NOT NULL /* Area name (NAME): Current county name */,
	area_km2                       	numeric /* Area in square km */,
	geographic_centroid_wkt        	text /* Wellknown text for geographic centroid */,
	wkt_9                          	text /* Wellknown text for zoomlevel 9 */,
	wkt_8                          	text /* Wellknown text for zoomlevel 8 */,
	wkt_7                          	text /* Wellknown text for zoomlevel 7 */,
	wkt_6                          	text /* Wellknown text for zoomlevel 6 */);

-- SQL statement 3: Comment geospatial data table >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE cb_2014_us_county_500k IS 'The County at a scale of 1:500,000';

-- SQL statement 4: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_county_500k.gid IS 'Unique geographic index';

-- SQL statement 5: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_county_500k.areaid IS 'Area ID (COUNTYNS): Current county Geographic Names Information System (GNIS) code';

-- SQL statement 6: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_county_500k.areaname IS 'Area name (NAME): Current county name';

-- SQL statement 7: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_county_500k.area_km2 IS 'Area in square km';

-- SQL statement 8: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_county_500k.geographic_centroid_wkt IS 'Wellknown text for geographic centroid';

-- SQL statement 9: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_county_500k.wkt_6 IS 'Wellknown text for zoomlevel 6';

-- SQL statement 10: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_county_500k.wkt_7 IS 'Wellknown text for zoomlevel 7';

-- SQL statement 11: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_county_500k.wkt_8 IS 'Wellknown text for zoomlevel 8';

-- SQL statement 12: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_county_500k.wkt_9 IS 'Wellknown text for zoomlevel 9';

-- SQL statement 13: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_county_500k.statefp IS 'Current state Federal Information Processing Series (FIPS) code';

-- SQL statement 14: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_county_500k.countyfp IS 'Current county Federal Information Processing Series (FIPS) code';

-- SQL statement 15: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_county_500k.countyns IS 'Current county Geographic Names Information System (GNIS) code';

-- SQL statement 16: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_county_500k.affgeoid IS 'American FactFinder summary level code + geovariant code + ''00US'' + GEOID';

-- SQL statement 17: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_county_500k.geoid IS 'County identifier; a concatenation of current state Federal Information Processing Series (FIPS) code and county FIPS code';

-- SQL statement 18: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_county_500k.name IS 'Current county name';

-- SQL statement 19: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_county_500k.lsad IS 'Current legal/statistical area description code for county';

-- SQL statement 20: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_county_500k.aland IS 'Current land area (square meters)';

-- SQL statement 21: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_county_500k.awater IS 'Current water area (square meters)';

-- SQL statement 22: Load table from CSV file >>>
\copy cb_2014_us_county_500k FROM 'cb_2014_us_county_500k.csv' DELIMITER ',' CSV HEADER;

-- SQL statement 23: Row check: 3233 >>>
DO LANGUAGE plpgsql $$
DECLARE
/*
 * SQL statement name: 	csvfile_rowcheck.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: Expected number of rows; e.g. 3233
 *						3: Column to count; e.g. gid
 *
 * Description:			Check number of rows in loaded CSV file is as expected
 * Note:				%% becomes % after substitution
 */
	c1 CURSOR FOR
		SELECT COUNT(gid) AS total
		  FROM cb_2014_us_county_500k;
	c1_rec RECORD;
BEGIN
	OPEN c1;
	FETCH c1 INTO c1_rec;
	CLOSE c1;
	IF c1_rec.total = 3233 THEN
		RAISE INFO 'Table: cb_2014_us_county_500k row check OK: %', c1_rec.total;
	ELSE
		RAISE EXCEPTION 'Table: cb_2014_us_county_500k row check FAILED: expected: 3233 got: %', c1_rec.total;
	END IF;
END;
$$;

-- SQL statement 24: Add primary key cb_2014_us_county_500k >>>
ALTER TABLE cb_2014_us_county_500k ADD PRIMARY KEY (gid);

-- SQL statement 25: Add unique key cb_2014_us_county_500k >>>
/*
 * SQL statement name: 	add_unique_key.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. cb_2014_us_nation_5m
 *						2: constraint name; e.g. cb_2014_us_nation_5m_uk
 *						3: fields; e.g. areaid
 *
 * Description:			Add unique key constraint
 * Note:				%% becomes % after substitution
 */
ALTER TABLE cb_2014_us_county_500k ADD CONSTRAINT cb_2014_us_county_500k_uk UNIQUE(areaid);

--
-- Add geometric  data
--

-- SQL statement 27: Add geometry column: geographic centroid >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_county_500k','geographic_centroid', 4326, 'POINT', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 28: Add geometry column for original SRID geometry >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_county_500k','geom_orig', 4269, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 29: Add geometry column for zoomlevel: 6 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_county_500k','geom_6', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 30: Add geometry column for zoomlevel: 7 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_county_500k','geom_7', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 31: Add geometry column for zoomlevel: 8 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_county_500k','geom_8', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 32: Add geometry column for zoomlevel: 9 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_county_500k','geom_9', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 33: Update geographic centroid, geometry columns, handle polygons and mutlipolygons, convert highest zoomlevel to original SRID >>>
UPDATE cb_2014_us_county_500k
   SET geographic_centroid = ST_GeomFromText(geographic_centroid_wkt, 4326),
       geom_6 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_6, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_6, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_6, 4326))
       		END,
       geom_7 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_7, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_7, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_7, 4326))
       		END,
       geom_8 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_8, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_8, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_8, 4326))
       		END,
       geom_9 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_9, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_9, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_9, 4326))
       		END,
       geom_orig = ST_Transform(
       		CASE ST_IsCollection(ST_GeomFromText(wkt_9, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_9, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_9, 4326))
       		END, 4269);

-- SQL statement 34: Make geometry columns valid >>>
UPDATE cb_2014_us_county_500k
   SET
       geom_6 = CASE ST_IsValid(geom_6)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_6), 3 /* Remove non polygons */)
				ELSE geom_6
			END,
       geom_7 = CASE ST_IsValid(geom_7)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_7), 3 /* Remove non polygons */)
				ELSE geom_7
			END,
       geom_8 = CASE ST_IsValid(geom_8)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_8), 3 /* Remove non polygons */)
				ELSE geom_8
			END,
       geom_9 = CASE ST_IsValid(geom_9)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_9), 3 /* Remove non polygons */)
				ELSE geom_9
			END,
       geom_orig = CASE ST_IsValid(geom_orig)
			WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_orig), 3 /* Remove non polygons */)
			ELSE geom_orig
		END;

--
-- Test geometry and make valid if required
--

-- SQL statement 36: Check validity of geometry columns >>>
DO LANGUAGE plpgsql $$
DECLARE
	c1 CURSOR FOR
SELECT areaname,
       6::Text AS geolevel,
       ST_IsValidReason(geom_6) AS reason
  FROM cb_2014_us_county_500k
 WHERE NOT ST_IsValid(geom_6)
UNION
SELECT areaname,
       7::Text AS geolevel,
       ST_IsValidReason(geom_7) AS reason
  FROM cb_2014_us_county_500k
 WHERE NOT ST_IsValid(geom_7)
UNION
SELECT areaname,
       8::Text AS geolevel,
       ST_IsValidReason(geom_8) AS reason
  FROM cb_2014_us_county_500k
 WHERE NOT ST_IsValid(geom_8)
UNION
SELECT areaname,
       9::Text AS geolevel,
       ST_IsValidReason(geom_9) AS reason
  FROM cb_2014_us_county_500k
 WHERE NOT ST_IsValid(geom_9)
UNION
SELECT areaname,
       'geom_orig'::Text AS geolevel,
       ST_IsValidReason(geom_orig) AS reason
  FROM cb_2014_us_county_500k
 WHERE NOT ST_IsValid(geom_orig)
 ORDER BY 1, 2;
	c1_rec RECORD;
	total INTEGER:=0;
BEGIN
	FOR c1_rec IN c1 LOOP
		total:=total+1;
		RAISE INFO 'Area: %, geolevel: %: %', c1_rec.areaname, c1_rec.geolevel, c1_rec.reason;
	END LOOP;
	IF total = 0 THEN
		RAISE INFO 'Table: cb_2014_us_county_500k no invalid geometry check OK';
	ELSE
		RAISE EXCEPTION 'Table: cb_2014_us_county_500k no invalid geometry check FAILED: % invalid', total;
	END IF;
END;
$$;

--
-- Make all polygons right handed
--

-- SQL statement 38: Make all polygons right handed for original geometry >>>
UPDATE cb_2014_us_county_500k
   SET       geom_6 = ST_ForceRHR(geom_6),
       geom_7 = ST_ForceRHR(geom_7),
       geom_8 = ST_ForceRHR(geom_8),
       geom_9 = ST_ForceRHR(geom_9),
       geom_orig = ST_ForceRHR(geom_orig);

--
-- Test Turf and DB areas agree to within 1%
--

-- SQL statement 40: Test Turf and DB areas agree to within 1% (Postgres)/5% (SQL server) >>>
DO LANGUAGE plpgsql $$
DECLARE 
/*
 * SQL statement name: 	area_check.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Check Turf araa (area_km2) compared to SQL Server calculated area (area_km2_calc)
 *						Allow for 1% error
 *						Ignore small areas <= 10 km2
 * Note:				%% becomes % after substitution
 */
	c1 CURSOR FOR
		WITH a AS (
			SELECT areaname,
				   area_km2 AS area_km2,
				   ST_Area(geography(geom_9))/(1000*1000) AS area_km2_calc
			  FROM cb_2014_us_county_500k
		), b AS (
		SELECT SUBSTRING(a.areaname, 1, 30) AS areaname,
			   a.area_km2,
			   a.area_km2_calc,
			   CASE WHEN a.area_km2 > 0 THEN 100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2)
					WHEN a.area_km2 = a.area_km2_calc THEN 0
					ELSE NULL
			   END AS pct_km2_diff 
		  FROM a
		)
		SELECT b.areaname, b.area_km2, b.area_km2_calc, b.pct_km2_diff
		  FROM b
		 WHERE b.pct_km2_diff > 1 /* Allow for 1% error */
		   AND b.area_km2_calc > 10 /* Ignore small areas <= 10 km2 */;

	c1_rec RECORD;
	total INTEGER:=0;
BEGIN
	FOR c1_rec IN c1 LOOP
		total:=total+1;
		RAISE INFO 'Area: %, area km2: %:, calc: %, diff %',
			c1_rec.areaname, c1_rec.area_km2, c1_rec.area_km2_calc, c1_rec.pct_km2_diff;
	END LOOP;
	IF total = 0 THEN
		RAISE INFO 'Table: cb_2014_us_county_500k no invalid areas check OK';
	ELSE
		RAISE EXCEPTION 'Table: cb_2014_us_county_500k no invalid areas check FAILED: % invalid', total;
	END IF;
END;
$$;

--
-- Create spatial indexes
--

-- SQL statement 42: Index geometry column for zoomlevel: 6 >>>
CREATE INDEX cb_2014_us_county_500k_geom_6_gix ON cb_2014_us_county_500k USING GIST (geom_6);

-- SQL statement 43: Index geometry column for zoomlevel: 7 >>>
CREATE INDEX cb_2014_us_county_500k_geom_7_gix ON cb_2014_us_county_500k USING GIST (geom_7);

-- SQL statement 44: Index geometry column for zoomlevel: 8 >>>
CREATE INDEX cb_2014_us_county_500k_geom_8_gix ON cb_2014_us_county_500k USING GIST (geom_8);

-- SQL statement 45: Index geometry column for zoomlevel: 9 >>>
CREATE INDEX cb_2014_us_county_500k_geom_9_gix ON cb_2014_us_county_500k USING GIST (geom_9);

-- SQL statement 46: Index geometry column for original SRID geometry >>>
CREATE INDEX cb_2014_us_county_500k_geom_orig_gix ON cb_2014_us_county_500k USING GIST (geom_orig);

--
-- Reports
--

-- SQL statement 48: Areas and centroids report >>>
/*
 * SQL statement name: 	area_centroid_report.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Area and centroids report
 * Note:				% becomes % after substitution
 */
WITH a AS (
	SELECT areaname,
		   ROUND(area_km2::numeric, 2) AS area_km2,
		   ROUND(
				(ST_Area(geography(geom_9))/(1000*1000))::numeric, 2) AS area_km2_calc,
		   ROUND(ST_X(geographic_centroid)::numeric, 4)||','||ROUND(ST_Y(geographic_centroid)::numeric, 4) AS geographic_centroid,
		   ROUND(ST_X(ST_Centroid(geom_9))::numeric, 4)||','||ROUND(ST_Y(ST_Centroid(geom_9))::numeric, 4) AS geographic_centroid_calc,
		   ROUND(ST_Distance_Sphere(ST_Centroid(geom_9), geographic_centroid)::numeric/1000, 2) AS centroid_diff_km
	  FROM cb_2014_us_county_500k
	 GROUP BY areaname, area_km2, geom_9, geographic_centroid
)
SELECT a.areaname,
       a.area_km2,
	   a.area_km2_calc,
	   ROUND(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2_calc), 2) AS pct_km2_diff,
	   a.geographic_centroid,
      a.geographic_centroid_calc,
	   a.centroid_diff_km
  FROM a
 ORDER BY 1
 LIMIT 100;

-- SQL statement 49: Drop table cb_2014_us_nation_5m >>>
DROP TABLE IF EXISTS cb_2014_us_nation_5m;

-- SQL statement 50: Create tablecb_2014_us_nation_5m >>>
CREATE TABLE cb_2014_us_nation_5m (
	affgeoid                       	text /* American FactFinder summary level code + geovariant code + ''00US'' */,
	geoid                          	text /* Nation identifier */,
	name                           	text /* Nation name */,
	gid                            	integer	NOT NULL /* Unique geographic index */,
	areaid                         	text	NOT NULL /* Area ID (GEOID): Nation identifier */,
	areaname                       	text	NOT NULL /* Area name (NAME): Nation name */,
	area_km2                       	numeric /* Area in square km */,
	geographic_centroid_wkt        	text /* Wellknown text for geographic centroid */,
	wkt_9                          	text /* Wellknown text for zoomlevel 9 */,
	wkt_8                          	text /* Wellknown text for zoomlevel 8 */,
	wkt_7                          	text /* Wellknown text for zoomlevel 7 */,
	wkt_6                          	text /* Wellknown text for zoomlevel 6 */);

-- SQL statement 51: Comment geospatial data table >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE cb_2014_us_nation_5m IS 'The nation at a scale of 1:5,000,000';

-- SQL statement 52: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_nation_5m.gid IS 'Unique geographic index';

-- SQL statement 53: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_nation_5m.areaid IS 'Area ID (GEOID): Nation identifier';

-- SQL statement 54: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_nation_5m.areaname IS 'Area name (NAME): Nation name';

-- SQL statement 55: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_nation_5m.area_km2 IS 'Area in square km';

-- SQL statement 56: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_nation_5m.geographic_centroid_wkt IS 'Wellknown text for geographic centroid';

-- SQL statement 57: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_nation_5m.wkt_6 IS 'Wellknown text for zoomlevel 6';

-- SQL statement 58: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_nation_5m.wkt_7 IS 'Wellknown text for zoomlevel 7';

-- SQL statement 59: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_nation_5m.wkt_8 IS 'Wellknown text for zoomlevel 8';

-- SQL statement 60: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_nation_5m.wkt_9 IS 'Wellknown text for zoomlevel 9';

-- SQL statement 61: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_nation_5m.affgeoid IS 'American FactFinder summary level code + geovariant code + ''00US''';

-- SQL statement 62: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_nation_5m.geoid IS 'Nation identifier';

-- SQL statement 63: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_nation_5m.name IS 'Nation name';

-- SQL statement 64: Load table from CSV file >>>
\copy cb_2014_us_nation_5m FROM 'cb_2014_us_nation_5m.csv' DELIMITER ',' CSV HEADER;

-- SQL statement 65: Row check: 1 >>>
DO LANGUAGE plpgsql $$
DECLARE
/*
 * SQL statement name: 	csvfile_rowcheck.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: Expected number of rows; e.g. 3233
 *						3: Column to count; e.g. gid
 *
 * Description:			Check number of rows in loaded CSV file is as expected
 * Note:				%% becomes % after substitution
 */
	c1 CURSOR FOR
		SELECT COUNT(gid) AS total
		  FROM cb_2014_us_nation_5m;
	c1_rec RECORD;
BEGIN
	OPEN c1;
	FETCH c1 INTO c1_rec;
	CLOSE c1;
	IF c1_rec.total = 1 THEN
		RAISE INFO 'Table: cb_2014_us_nation_5m row check OK: %', c1_rec.total;
	ELSE
		RAISE EXCEPTION 'Table: cb_2014_us_nation_5m row check FAILED: expected: 1 got: %', c1_rec.total;
	END IF;
END;
$$;

-- SQL statement 66: Add primary key cb_2014_us_nation_5m >>>
ALTER TABLE cb_2014_us_nation_5m ADD PRIMARY KEY (gid);

-- SQL statement 67: Add unique key cb_2014_us_nation_5m >>>
/*
 * SQL statement name: 	add_unique_key.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. cb_2014_us_nation_5m
 *						2: constraint name; e.g. cb_2014_us_nation_5m_uk
 *						3: fields; e.g. areaid
 *
 * Description:			Add unique key constraint
 * Note:				%% becomes % after substitution
 */
ALTER TABLE cb_2014_us_nation_5m ADD CONSTRAINT cb_2014_us_nation_5m_uk UNIQUE(areaid);

--
-- Add geometric  data
--

-- SQL statement 69: Add geometry column: geographic centroid >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_nation_5m','geographic_centroid', 4326, 'POINT', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 70: Add geometry column for original SRID geometry >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_nation_5m','geom_orig', 4269, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 71: Add geometry column for zoomlevel: 6 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_nation_5m','geom_6', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 72: Add geometry column for zoomlevel: 7 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_nation_5m','geom_7', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 73: Add geometry column for zoomlevel: 8 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_nation_5m','geom_8', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 74: Add geometry column for zoomlevel: 9 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_nation_5m','geom_9', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 75: Update geographic centroid, geometry columns, handle polygons and mutlipolygons, convert highest zoomlevel to original SRID >>>
UPDATE cb_2014_us_nation_5m
   SET geographic_centroid = ST_GeomFromText(geographic_centroid_wkt, 4326),
       geom_6 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_6, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_6, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_6, 4326))
       		END,
       geom_7 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_7, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_7, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_7, 4326))
       		END,
       geom_8 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_8, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_8, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_8, 4326))
       		END,
       geom_9 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_9, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_9, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_9, 4326))
       		END,
       geom_orig = ST_Transform(
       		CASE ST_IsCollection(ST_GeomFromText(wkt_9, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_9, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_9, 4326))
       		END, 4269);

-- SQL statement 76: Make geometry columns valid >>>
UPDATE cb_2014_us_nation_5m
   SET
       geom_6 = CASE ST_IsValid(geom_6)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_6), 3 /* Remove non polygons */)
				ELSE geom_6
			END,
       geom_7 = CASE ST_IsValid(geom_7)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_7), 3 /* Remove non polygons */)
				ELSE geom_7
			END,
       geom_8 = CASE ST_IsValid(geom_8)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_8), 3 /* Remove non polygons */)
				ELSE geom_8
			END,
       geom_9 = CASE ST_IsValid(geom_9)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_9), 3 /* Remove non polygons */)
				ELSE geom_9
			END,
       geom_orig = CASE ST_IsValid(geom_orig)
			WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_orig), 3 /* Remove non polygons */)
			ELSE geom_orig
		END;

--
-- Test geometry and make valid if required
--

-- SQL statement 78: Check validity of geometry columns >>>
DO LANGUAGE plpgsql $$
DECLARE
	c1 CURSOR FOR
SELECT areaname,
       6::Text AS geolevel,
       ST_IsValidReason(geom_6) AS reason
  FROM cb_2014_us_nation_5m
 WHERE NOT ST_IsValid(geom_6)
UNION
SELECT areaname,
       7::Text AS geolevel,
       ST_IsValidReason(geom_7) AS reason
  FROM cb_2014_us_nation_5m
 WHERE NOT ST_IsValid(geom_7)
UNION
SELECT areaname,
       8::Text AS geolevel,
       ST_IsValidReason(geom_8) AS reason
  FROM cb_2014_us_nation_5m
 WHERE NOT ST_IsValid(geom_8)
UNION
SELECT areaname,
       9::Text AS geolevel,
       ST_IsValidReason(geom_9) AS reason
  FROM cb_2014_us_nation_5m
 WHERE NOT ST_IsValid(geom_9)
UNION
SELECT areaname,
       'geom_orig'::Text AS geolevel,
       ST_IsValidReason(geom_orig) AS reason
  FROM cb_2014_us_nation_5m
 WHERE NOT ST_IsValid(geom_orig)
 ORDER BY 1, 2;
	c1_rec RECORD;
	total INTEGER:=0;
BEGIN
	FOR c1_rec IN c1 LOOP
		total:=total+1;
		RAISE INFO 'Area: %, geolevel: %: %', c1_rec.areaname, c1_rec.geolevel, c1_rec.reason;
	END LOOP;
	IF total = 0 THEN
		RAISE INFO 'Table: cb_2014_us_nation_5m no invalid geometry check OK';
	ELSE
		RAISE EXCEPTION 'Table: cb_2014_us_nation_5m no invalid geometry check FAILED: % invalid', total;
	END IF;
END;
$$;

--
-- Make all polygons right handed
--

-- SQL statement 80: Make all polygons right handed for original geometry >>>
UPDATE cb_2014_us_nation_5m
   SET       geom_6 = ST_ForceRHR(geom_6),
       geom_7 = ST_ForceRHR(geom_7),
       geom_8 = ST_ForceRHR(geom_8),
       geom_9 = ST_ForceRHR(geom_9),
       geom_orig = ST_ForceRHR(geom_orig);

--
-- Test Turf and DB areas agree to within 1%
--

-- SQL statement 82: Test Turf and DB areas agree to within 1% (Postgres)/5% (SQL server) >>>
DO LANGUAGE plpgsql $$
DECLARE 
/*
 * SQL statement name: 	area_check.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Check Turf araa (area_km2) compared to SQL Server calculated area (area_km2_calc)
 *						Allow for 1% error
 *						Ignore small areas <= 10 km2
 * Note:				%% becomes % after substitution
 */
	c1 CURSOR FOR
		WITH a AS (
			SELECT areaname,
				   area_km2 AS area_km2,
				   ST_Area(geography(geom_9))/(1000*1000) AS area_km2_calc
			  FROM cb_2014_us_nation_5m
		), b AS (
		SELECT SUBSTRING(a.areaname, 1, 30) AS areaname,
			   a.area_km2,
			   a.area_km2_calc,
			   CASE WHEN a.area_km2 > 0 THEN 100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2)
					WHEN a.area_km2 = a.area_km2_calc THEN 0
					ELSE NULL
			   END AS pct_km2_diff 
		  FROM a
		)
		SELECT b.areaname, b.area_km2, b.area_km2_calc, b.pct_km2_diff
		  FROM b
		 WHERE b.pct_km2_diff > 1 /* Allow for 1% error */
		   AND b.area_km2_calc > 10 /* Ignore small areas <= 10 km2 */;

	c1_rec RECORD;
	total INTEGER:=0;
BEGIN
	FOR c1_rec IN c1 LOOP
		total:=total+1;
		RAISE INFO 'Area: %, area km2: %:, calc: %, diff %',
			c1_rec.areaname, c1_rec.area_km2, c1_rec.area_km2_calc, c1_rec.pct_km2_diff;
	END LOOP;
	IF total = 0 THEN
		RAISE INFO 'Table: cb_2014_us_nation_5m no invalid areas check OK';
	ELSE
		RAISE EXCEPTION 'Table: cb_2014_us_nation_5m no invalid areas check FAILED: % invalid', total;
	END IF;
END;
$$;

--
-- Create spatial indexes
--

-- SQL statement 84: Index geometry column for zoomlevel: 6 >>>
CREATE INDEX cb_2014_us_nation_5m_geom_6_gix ON cb_2014_us_nation_5m USING GIST (geom_6);

-- SQL statement 85: Index geometry column for zoomlevel: 7 >>>
CREATE INDEX cb_2014_us_nation_5m_geom_7_gix ON cb_2014_us_nation_5m USING GIST (geom_7);

-- SQL statement 86: Index geometry column for zoomlevel: 8 >>>
CREATE INDEX cb_2014_us_nation_5m_geom_8_gix ON cb_2014_us_nation_5m USING GIST (geom_8);

-- SQL statement 87: Index geometry column for zoomlevel: 9 >>>
CREATE INDEX cb_2014_us_nation_5m_geom_9_gix ON cb_2014_us_nation_5m USING GIST (geom_9);

-- SQL statement 88: Index geometry column for original SRID geometry >>>
CREATE INDEX cb_2014_us_nation_5m_geom_orig_gix ON cb_2014_us_nation_5m USING GIST (geom_orig);

--
-- Reports
--

-- SQL statement 90: Areas and centroids report >>>
/*
 * SQL statement name: 	area_centroid_report.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Area and centroids report
 * Note:				% becomes % after substitution
 */
WITH a AS (
	SELECT areaname,
		   ROUND(area_km2::numeric, 2) AS area_km2,
		   ROUND(
				(ST_Area(geography(geom_9))/(1000*1000))::numeric, 2) AS area_km2_calc,
		   ROUND(ST_X(geographic_centroid)::numeric, 4)||','||ROUND(ST_Y(geographic_centroid)::numeric, 4) AS geographic_centroid,
		   ROUND(ST_X(ST_Centroid(geom_9))::numeric, 4)||','||ROUND(ST_Y(ST_Centroid(geom_9))::numeric, 4) AS geographic_centroid_calc,
		   ROUND(ST_Distance_Sphere(ST_Centroid(geom_9), geographic_centroid)::numeric/1000, 2) AS centroid_diff_km
	  FROM cb_2014_us_nation_5m
	 GROUP BY areaname, area_km2, geom_9, geographic_centroid
)
SELECT a.areaname,
       a.area_km2,
	   a.area_km2_calc,
	   ROUND(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2_calc), 2) AS pct_km2_diff,
	   a.geographic_centroid,
      a.geographic_centroid_calc,
	   a.centroid_diff_km
  FROM a
 ORDER BY 1
 LIMIT 100;

-- SQL statement 91: Drop table cb_2014_us_state_500k >>>
DROP TABLE IF EXISTS cb_2014_us_state_500k;

-- SQL statement 92: Create tablecb_2014_us_state_500k >>>
CREATE TABLE cb_2014_us_state_500k (
	statefp                        	text /* Current state Federal Information Processing Series (FIPS) code */,
	statens                        	text /* Current state Geographic Names Information System (GNIS) code */,
	affgeoid                       	text /* American FactFinder summary level code + geovariant code + ''00US'' + GEOID */,
	geoid                          	text /* State identifier; state FIPS code */,
	stusps                         	text /* Current United States Postal Service state abbreviation */,
	name                           	text /* Current State name */,
	lsad                           	text /* Current legal/statistical area description code for state */,
	aland                          	text /* Current land area (square meters) */,
	awater                         	text /* Current water area (square meters) */,
	gid                            	integer	NOT NULL /* Unique geographic index */,
	areaid                         	text	NOT NULL /* Area ID (STATENS): Current state Geographic Names Information System (GNIS) code */,
	areaname                       	text	NOT NULL /* Area name (NAME): Current State name */,
	area_km2                       	numeric /* Area in square km */,
	geographic_centroid_wkt        	text /* Wellknown text for geographic centroid */,
	wkt_9                          	text /* Wellknown text for zoomlevel 9 */,
	wkt_8                          	text /* Wellknown text for zoomlevel 8 */,
	wkt_7                          	text /* Wellknown text for zoomlevel 7 */,
	wkt_6                          	text /* Wellknown text for zoomlevel 6 */);

-- SQL statement 93: Comment geospatial data table >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE cb_2014_us_state_500k IS 'The State at a scale of 1:500,000';

-- SQL statement 94: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_state_500k.gid IS 'Unique geographic index';

-- SQL statement 95: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_state_500k.areaid IS 'Area ID (STATENS): Current state Geographic Names Information System (GNIS) code';

-- SQL statement 96: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_state_500k.areaname IS 'Area name (NAME): Current State name';

-- SQL statement 97: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_state_500k.area_km2 IS 'Area in square km';

-- SQL statement 98: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_state_500k.geographic_centroid_wkt IS 'Wellknown text for geographic centroid';

-- SQL statement 99: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_state_500k.wkt_6 IS 'Wellknown text for zoomlevel 6';

-- SQL statement 100: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_state_500k.wkt_7 IS 'Wellknown text for zoomlevel 7';

-- SQL statement 101: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_state_500k.wkt_8 IS 'Wellknown text for zoomlevel 8';

-- SQL statement 102: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_state_500k.wkt_9 IS 'Wellknown text for zoomlevel 9';

-- SQL statement 103: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_state_500k.statefp IS 'Current state Federal Information Processing Series (FIPS) code';

-- SQL statement 104: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_state_500k.statens IS 'Current state Geographic Names Information System (GNIS) code';

-- SQL statement 105: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_state_500k.affgeoid IS 'American FactFinder summary level code + geovariant code + ''00US'' + GEOID';

-- SQL statement 106: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_state_500k.geoid IS 'State identifier; state FIPS code';

-- SQL statement 107: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_state_500k.stusps IS 'Current United States Postal Service state abbreviation';

-- SQL statement 108: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_state_500k.name IS 'Current State name';

-- SQL statement 109: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_state_500k.lsad IS 'Current legal/statistical area description code for state';

-- SQL statement 110: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_state_500k.aland IS 'Current land area (square meters)';

-- SQL statement 111: Comment geospatial data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN cb_2014_us_state_500k.awater IS 'Current water area (square meters)';

-- SQL statement 112: Load table from CSV file >>>
\copy cb_2014_us_state_500k FROM 'cb_2014_us_state_500k.csv' DELIMITER ',' CSV HEADER;

-- SQL statement 113: Row check: 56 >>>
DO LANGUAGE plpgsql $$
DECLARE
/*
 * SQL statement name: 	csvfile_rowcheck.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: Expected number of rows; e.g. 3233
 *						3: Column to count; e.g. gid
 *
 * Description:			Check number of rows in loaded CSV file is as expected
 * Note:				%% becomes % after substitution
 */
	c1 CURSOR FOR
		SELECT COUNT(gid) AS total
		  FROM cb_2014_us_state_500k;
	c1_rec RECORD;
BEGIN
	OPEN c1;
	FETCH c1 INTO c1_rec;
	CLOSE c1;
	IF c1_rec.total = 56 THEN
		RAISE INFO 'Table: cb_2014_us_state_500k row check OK: %', c1_rec.total;
	ELSE
		RAISE EXCEPTION 'Table: cb_2014_us_state_500k row check FAILED: expected: 56 got: %', c1_rec.total;
	END IF;
END;
$$;

-- SQL statement 114: Add primary key cb_2014_us_state_500k >>>
ALTER TABLE cb_2014_us_state_500k ADD PRIMARY KEY (gid);

-- SQL statement 115: Add unique key cb_2014_us_state_500k >>>
/*
 * SQL statement name: 	add_unique_key.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. cb_2014_us_nation_5m
 *						2: constraint name; e.g. cb_2014_us_nation_5m_uk
 *						3: fields; e.g. areaid
 *
 * Description:			Add unique key constraint
 * Note:				%% becomes % after substitution
 */
ALTER TABLE cb_2014_us_state_500k ADD CONSTRAINT cb_2014_us_state_500k_uk UNIQUE(areaid);

--
-- Add geometric  data
--

-- SQL statement 117: Add geometry column: geographic centroid >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_state_500k','geographic_centroid', 4326, 'POINT', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 118: Add geometry column for original SRID geometry >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_state_500k','geom_orig', 4269, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 119: Add geometry column for zoomlevel: 6 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_state_500k','geom_6', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 120: Add geometry column for zoomlevel: 7 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_state_500k','geom_7', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 121: Add geometry column for zoomlevel: 8 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_state_500k','geom_8', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 122: Add geometry column for zoomlevel: 9 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_state_500k','geom_9', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 123: Update geographic centroid, geometry columns, handle polygons and mutlipolygons, convert highest zoomlevel to original SRID >>>
UPDATE cb_2014_us_state_500k
   SET geographic_centroid = ST_GeomFromText(geographic_centroid_wkt, 4326),
       geom_6 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_6, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_6, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_6, 4326))
       		END,
       geom_7 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_7, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_7, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_7, 4326))
       		END,
       geom_8 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_8, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_8, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_8, 4326))
       		END,
       geom_9 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_9, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_9, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_9, 4326))
       		END,
       geom_orig = ST_Transform(
       		CASE ST_IsCollection(ST_GeomFromText(wkt_9, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_9, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_9, 4326))
       		END, 4269);

-- SQL statement 124: Make geometry columns valid >>>
UPDATE cb_2014_us_state_500k
   SET
       geom_6 = CASE ST_IsValid(geom_6)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_6), 3 /* Remove non polygons */)
				ELSE geom_6
			END,
       geom_7 = CASE ST_IsValid(geom_7)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_7), 3 /* Remove non polygons */)
				ELSE geom_7
			END,
       geom_8 = CASE ST_IsValid(geom_8)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_8), 3 /* Remove non polygons */)
				ELSE geom_8
			END,
       geom_9 = CASE ST_IsValid(geom_9)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_9), 3 /* Remove non polygons */)
				ELSE geom_9
			END,
       geom_orig = CASE ST_IsValid(geom_orig)
			WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_orig), 3 /* Remove non polygons */)
			ELSE geom_orig
		END;

--
-- Test geometry and make valid if required
--

-- SQL statement 126: Check validity of geometry columns >>>
DO LANGUAGE plpgsql $$
DECLARE
	c1 CURSOR FOR
SELECT areaname,
       6::Text AS geolevel,
       ST_IsValidReason(geom_6) AS reason
  FROM cb_2014_us_state_500k
 WHERE NOT ST_IsValid(geom_6)
UNION
SELECT areaname,
       7::Text AS geolevel,
       ST_IsValidReason(geom_7) AS reason
  FROM cb_2014_us_state_500k
 WHERE NOT ST_IsValid(geom_7)
UNION
SELECT areaname,
       8::Text AS geolevel,
       ST_IsValidReason(geom_8) AS reason
  FROM cb_2014_us_state_500k
 WHERE NOT ST_IsValid(geom_8)
UNION
SELECT areaname,
       9::Text AS geolevel,
       ST_IsValidReason(geom_9) AS reason
  FROM cb_2014_us_state_500k
 WHERE NOT ST_IsValid(geom_9)
UNION
SELECT areaname,
       'geom_orig'::Text AS geolevel,
       ST_IsValidReason(geom_orig) AS reason
  FROM cb_2014_us_state_500k
 WHERE NOT ST_IsValid(geom_orig)
 ORDER BY 1, 2;
	c1_rec RECORD;
	total INTEGER:=0;
BEGIN
	FOR c1_rec IN c1 LOOP
		total:=total+1;
		RAISE INFO 'Area: %, geolevel: %: %', c1_rec.areaname, c1_rec.geolevel, c1_rec.reason;
	END LOOP;
	IF total = 0 THEN
		RAISE INFO 'Table: cb_2014_us_state_500k no invalid geometry check OK';
	ELSE
		RAISE EXCEPTION 'Table: cb_2014_us_state_500k no invalid geometry check FAILED: % invalid', total;
	END IF;
END;
$$;

--
-- Make all polygons right handed
--

-- SQL statement 128: Make all polygons right handed for original geometry >>>
UPDATE cb_2014_us_state_500k
   SET       geom_6 = ST_ForceRHR(geom_6),
       geom_7 = ST_ForceRHR(geom_7),
       geom_8 = ST_ForceRHR(geom_8),
       geom_9 = ST_ForceRHR(geom_9),
       geom_orig = ST_ForceRHR(geom_orig);

--
-- Test Turf and DB areas agree to within 1%
--

-- SQL statement 130: Test Turf and DB areas agree to within 1% (Postgres)/5% (SQL server) >>>
DO LANGUAGE plpgsql $$
DECLARE 
/*
 * SQL statement name: 	area_check.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Check Turf araa (area_km2) compared to SQL Server calculated area (area_km2_calc)
 *						Allow for 1% error
 *						Ignore small areas <= 10 km2
 * Note:				%% becomes % after substitution
 */
	c1 CURSOR FOR
		WITH a AS (
			SELECT areaname,
				   area_km2 AS area_km2,
				   ST_Area(geography(geom_9))/(1000*1000) AS area_km2_calc
			  FROM cb_2014_us_state_500k
		), b AS (
		SELECT SUBSTRING(a.areaname, 1, 30) AS areaname,
			   a.area_km2,
			   a.area_km2_calc,
			   CASE WHEN a.area_km2 > 0 THEN 100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2)
					WHEN a.area_km2 = a.area_km2_calc THEN 0
					ELSE NULL
			   END AS pct_km2_diff 
		  FROM a
		)
		SELECT b.areaname, b.area_km2, b.area_km2_calc, b.pct_km2_diff
		  FROM b
		 WHERE b.pct_km2_diff > 1 /* Allow for 1% error */
		   AND b.area_km2_calc > 10 /* Ignore small areas <= 10 km2 */;

	c1_rec RECORD;
	total INTEGER:=0;
BEGIN
	FOR c1_rec IN c1 LOOP
		total:=total+1;
		RAISE INFO 'Area: %, area km2: %:, calc: %, diff %',
			c1_rec.areaname, c1_rec.area_km2, c1_rec.area_km2_calc, c1_rec.pct_km2_diff;
	END LOOP;
	IF total = 0 THEN
		RAISE INFO 'Table: cb_2014_us_state_500k no invalid areas check OK';
	ELSE
		RAISE EXCEPTION 'Table: cb_2014_us_state_500k no invalid areas check FAILED: % invalid', total;
	END IF;
END;
$$;

--
-- Create spatial indexes
--

-- SQL statement 132: Index geometry column for zoomlevel: 6 >>>
CREATE INDEX cb_2014_us_state_500k_geom_6_gix ON cb_2014_us_state_500k USING GIST (geom_6);

-- SQL statement 133: Index geometry column for zoomlevel: 7 >>>
CREATE INDEX cb_2014_us_state_500k_geom_7_gix ON cb_2014_us_state_500k USING GIST (geom_7);

-- SQL statement 134: Index geometry column for zoomlevel: 8 >>>
CREATE INDEX cb_2014_us_state_500k_geom_8_gix ON cb_2014_us_state_500k USING GIST (geom_8);

-- SQL statement 135: Index geometry column for zoomlevel: 9 >>>
CREATE INDEX cb_2014_us_state_500k_geom_9_gix ON cb_2014_us_state_500k USING GIST (geom_9);

-- SQL statement 136: Index geometry column for original SRID geometry >>>
CREATE INDEX cb_2014_us_state_500k_geom_orig_gix ON cb_2014_us_state_500k USING GIST (geom_orig);

--
-- Reports
--

-- SQL statement 138: Areas and centroids report >>>
/*
 * SQL statement name: 	area_centroid_report.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Area and centroids report
 * Note:				% becomes % after substitution
 */
WITH a AS (
	SELECT areaname,
		   ROUND(area_km2::numeric, 2) AS area_km2,
		   ROUND(
				(ST_Area(geography(geom_9))/(1000*1000))::numeric, 2) AS area_km2_calc,
		   ROUND(ST_X(geographic_centroid)::numeric, 4)||','||ROUND(ST_Y(geographic_centroid)::numeric, 4) AS geographic_centroid,
		   ROUND(ST_X(ST_Centroid(geom_9))::numeric, 4)||','||ROUND(ST_Y(ST_Centroid(geom_9))::numeric, 4) AS geographic_centroid_calc,
		   ROUND(ST_Distance_Sphere(ST_Centroid(geom_9), geographic_centroid)::numeric/1000, 2) AS centroid_diff_km
	  FROM cb_2014_us_state_500k
	 GROUP BY areaname, area_km2, geom_9, geographic_centroid
)
SELECT a.areaname,
       a.area_km2,
	   a.area_km2_calc,
	   ROUND(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2_calc), 2) AS pct_km2_diff,
	   a.geographic_centroid,
      a.geographic_centroid_calc,
	   a.centroid_diff_km
  FROM a
 ORDER BY 1
 LIMIT 100;

--
-- Geography meta data
--

--
-- Drop depedent objects: tiles view and generate_series() [MS SQL Server only]
--

-- SQL statement 141: Drop depedent object - view tiles_usa_2014 >>>
DROP VIEW IF EXISTS tiles_usa_2014;

-- SQL statement 142: Drop depedent object - FK table geolevels_usa_2014 >>>
DROP TABLE IF EXISTS geolevels_usa_2014;

-- SQL statement 143: Drop table geography_usa_2014 >>>
DROP TABLE IF EXISTS geography_usa_2014;

-- SQL statement 144: Create geography meta data table >>>
/*
 * SQL statement name: 	create_geography_table.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: geography table; e.g. geography_cb_2014_us_county_500k
 *
 * Description:			Create geography table compatible with RIF40_GEOGRAPHIES
 *
 *		CREATE TABLE rif40_geographies
 *		(
 *		  geography character varying(50) NOT NULL, -- Geography name
 *		  description character varying(250) NOT NULL, -- Description
 *		  hierarchytable character varying(30) NOT NULL, -- Hierarchy table
 *		  tiletable character varying(30) NOT NULL, -- Tile table
 *		  geometrytable character varying(30) NOT NULL, -- Geometry table
 *		  srid integer DEFAULT 0, -- Postgres projection SRID
 *		  defaultcomparea character varying(30), -- Default comparison area
 *		  defaultstudyarea character varying(30), -- Default study area
 *		  postal_population_table character varying(30), -- Postal population table. Table of postal points (e.g. postcodes, ZIP codes); geolevels; X and YCOORDINATES (in projection SRID); male, female and total populations. Converted to SRID points by loader [not in 4326 Web Mercator lat/long]. Used in creating population wieght centroids and in converting postal points to geolevels. Expected columns &lt;postal_point_column&gt;, XCOORDINATE, YCOORDINATE, 1+ &lt;GEOLEVEL_NAME&gt;, MALES, FEMALES, TOTAL
 *		  postal_point_column character varying(30), -- Column name for postal points (e.g. POSTCODE, ZIP_CODE)
 *		  partition smallint DEFAULT 0, -- Enable partitioning. Extract tables will be partition if the number of years >= 2x the RIF40_PARAMETERS parameters Parallelisation [which has a default of 4, so extracts covering 8 years or more will be partitioned].
 *		  max_geojson_digits smallint DEFAULT 8, -- Max digits in ST_AsGeoJson() [optimises file size by removing unecessary precision, the default value of 8 is normally fine.]
 *		  CONSTRAINT rif40_geographies_pk PRIMARY KEY (geography),
 *		  CONSTRAINT partition_ck CHECK (partition = ANY (ARRAY[0, 1])),
 *		  CONSTRAINT postal_population_table_ck CHECK (postal_population_table IS NOT NULL AND postal_point_column IS NOT NULL OR postal_population_table IS NULL AND postal_point_column IS NULL)
 *		)
 *		 
 * Note:				%% becomes % after substitution
 */
CREATE TABLE geography_usa_2014 (
       geography               VARCHAR(50)  NOT NULL,
       description             VARCHAR(250) NOT NULL,
       hierarchytable          VARCHAR(30)  NOT NULL,
       geometrytable           VARCHAR(30)  NOT NULL,
       tiletable               VARCHAR(30)  NOT NULL,			/* New for DB */
       srid                    INTEGER      NOT NULL DEFAULT 0,
       defaultcomparea         VARCHAR(30)  NULL,
       defaultstudyarea        VARCHAR(30)  NULL,
       minzoomlevel       	   INTEGER      NOT NULL DEFAULT 6,  /* New for DB */
       maxzoomlevel       	   INTEGER      NOT NULL DEFAULT 11, /* New for DB */
       postal_population_table VARCHAR(30)  NULL,
       postal_point_column 	   VARCHAR(30)  NULL,
       partition 			   INTEGER      NOT NULL DEFAULT 0, 
       max_geojson_digits 	   INTEGER      NOT NULL DEFAULT 8, 	   
       CONSTRAINT geography_usa_2014_pk PRIMARY KEY(geography),
	   CONSTRAINT geography_usa_2014_part_ck CHECK (partition IN (0, 1)),
	   CONSTRAINT geography_usa_2014_ppt_ck CHECK (
			postal_population_table IS NOT NULL AND postal_point_column IS NOT NULL OR postal_population_table IS NULL AND postal_point_column IS NULL)
	);

-- SQL statement 145: Comment geography meta data table >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE geography_usa_2014 IS 'Hierarchial geographies. Usually based on Census geography';

-- SQL statement 146: Populate geography meta data table >>>
/*
 * SQL statement name: 	insert_geography.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. GEOGRAPHY_CB_2014_US_COUNTY_500K
 *						2: geography; e.g. CB_2014_US_500K
 *						3: geography description; e.g. United states to county level
 *						4: hierarchytable; e.g. HIERARCHY_CB_2014_US_500K
 *						5: geometrytable; e.g. GEOMETRY_CB_2014_US_500K
 *						6: tiletable; e.g. TILES_CB_2014_US_500K
 * 						7: SRID; e.g. 4269
 *						8: Default comparision area, e.g. GEOID
 *						9: Default study area, e.g. STATENS
 *						10: Min zoomlevel
 *						11: Max zoomlevel
 *           			12: Postal population table (quote enclosed or NULL)
 *      				13: Postal point column (quote enclosed or NULL)
 *						14: Partition (0/1)
 *						15: Max geojson digits
 *
 * Description:			Insert into geography table
 * Note:				%% becomes % after substitution
 */
INSERT INTO geography_USA_2014 (
geography, description, hierarchytable, geometrytable, tiletable, srid, defaultcomparea, defaultstudyarea, minzoomlevel, maxzoomlevel,
		postal_population_table, postal_point_column, partition, max_geojson_digits)
SELECT 'USA_2014' AS geography,
       'US 2014 Census geography to county level' AS description,
       'HIERARCHY_USA_2014' AS hierarchytable,
	   'GEOMETRY_USA_2014' AS geometrytable,
	   'TILES_USA_2014' AS tiletable,
       4269   AS srid,
       'GEOID' AS defaultcomparea,
       'STATENS' AS defaultstudyarea,
	   6  AS minzoomlevel,
	   9  AS maxzoomlevel,
	   NULL  AS postal_population_table,
       NULL  AS postal_point_column,
       1  AS partition, 
       6  AS max_geojson_digits;

-- SQL statement 147: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_usa_2014.geography IS 'Geography name';

-- SQL statement 148: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_usa_2014.description IS 'Description';

-- SQL statement 149: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_usa_2014.hierarchytable IS 'Hierarchy table';

-- SQL statement 150: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_usa_2014.geometrytable IS 'Geometry table';

-- SQL statement 151: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_usa_2014.tiletable IS 'Tile table';

-- SQL statement 152: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_usa_2014.srid IS 'Projection SRID';

-- SQL statement 153: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_usa_2014.defaultcomparea IS 'Default comparison area: lowest resolution geolevel';

-- SQL statement 154: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_usa_2014.defaultstudyarea IS 'Default study area: highest resolution geolevel';

-- SQL statement 155: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_usa_2014.minzoomlevel IS 'Min zoomlevel';

-- SQL statement 156: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_usa_2014.maxzoomlevel IS 'Max zoomlevel';

-- SQL statement 157: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_usa_2014.postal_population_table IS 'Postal_population_table';

-- SQL statement 158: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_usa_2014.postal_point_column IS 'Postal_point_column';

-- SQL statement 159: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_usa_2014.partition IS 'Partition geometry and tile tables (0/1)';

-- SQL statement 160: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_usa_2014.max_geojson_digits IS 'Maximum digits in geojson (topojson quantisation)';

--
-- Geolevels meta data
--

-- SQL statement 162: Create geolevels meta data table >>>
/*
 * SQL statement name: 	create_geolevels_table.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: geolevels table; e.g. geolevels_cb_2014_us_county_500k
 *						2: geography table; e.g. geography_cb_2014_us_county_500k
 *
 * Description:			Create geography table compatible with RIF40_GEOGRAPHIES
 *
 *	CREATE TABLE t_rif40_geolevels
 *	(
 *	  geography character varying(50) NOT NULL, -- Geography (e.g EW2001)
 *	  geolevel_name character varying(30) NOT NULL, -- Name of geolevel. This will be a column name in the numerator/denominator tables
 *	  geolevel_id smallint NOT NULL, -- ID for ordering (1=lowest resolution). Up to 99 supported.
 *	  description character varying(250) NOT NULL, -- Description
 *	  lookup_table character varying(30) NOT NULL, -- Lookup table name. This is used to translate codes to the common names, e.g a LADUA of 00BK is &quot;Westminster&quot;
 *	  lookup_desc_column character varying(30) NOT NULL, -- Lookup table description column name.
 *	  centroidxcoordinate_column character varying(30), -- Lookup table centroid X co-ordinate column name. Can also use CENTROIDSFILE instead.
 *	  centroidycoordinate_column character varying(30), -- Lookup table centroid Y co-ordinate column name.
 *	  shapefile character varying(512), -- Location of the GIS shape file. NULL if PostGress/PostGIS used. Can also use SHAPEFILE_GEOMETRY instead,
 *	  centroidsfile character varying(512), -- Location of the GIS centroids file. Can also use CENTROIDXCOORDINATE_COLUMN, CENTROIDYCOORDINATE_COLUMN instead.
 *	  shapefile_table character varying(30), -- Table containing GIS shape file data (created using shp2pgsql).
 *	  shapefile_area_id_column character varying(30), -- Column containing the AREA_IDs in SHAPEFILE_TABLE
 *	  shapefile_desc_column character varying(30), -- Column containing the AREA_ID descriptions in SHAPEFILE_TABLE
 *	  centroids_table character varying(30), -- Table containing GIS shape file data with Arc GIS calculated population weighted centroids (created using shp2pgsql). PostGIS does not support population weighted centroids.
 *	  centroids_area_id_column character varying(30), -- Column containing the AREA_IDs in CENTROIDS_TABLE. X and Y co-ordinates ciolumns are asummed to be named after CENTROIDXCOORDINATE_COLUMN and CENTROIDYCOORDINATE_COLUMN.
 *	  covariate_table character varying(30), -- Name of table used for covariates at this geolevel
 *	  restricted smallint DEFAULT 0, -- Is geolevel access rectricted by Inforamtion Governance restrictions (0/1). If 1 (Yes) then a) students cannot access this geolevel and b) if the system parameter ExtractControl=1 then the user must be granted permission by a RIF_MANAGER to extract from the database the results, data extract and maps tables. This is enforced by the RIF application.
 *	  resolution smallint NOT NULL, -- Can use a map for selection at this resolution (0/1)
 *	  comparea smallint NOT NULL, -- Able to be used as a comparison area (0/1)
 *	  listing smallint NOT NULL, -- Able to be used in a disease map listing (0/1)
 *	  CONSTRAINT t_rif40_geolevels_pk PRIMARY KEY (geography, geolevel_name),
 *	  CONSTRAINT t_rif40_geol_comparea_ck CHECK (comparea IN (0, 1)),
 *	  CONSTRAINT t_rif40_geol_listing_ck CHECK (listing iN (0, 1)),
 *	  CONSTRAINT t_rif40_geol_resolution_ck CHECK (resolution IN (0, 1)),
 *	  CONSTRAINT t_rif40_geol_restricted_ck CHECK (restricted IN (0, 1))
 *	)
 *		 
 * Note:				%% becomes % after substitution
*/
CREATE TABLE geolevels_usa_2014 (
       geography                       VARCHAR(50)  NOT NULL,
       geolevel_name                   VARCHAR(30)  NOT NULL,
       geolevel_id			           INTEGER	    NOT NULL,
       description                     VARCHAR(250) NOT NULL,
       lookup_table                    VARCHAR(30)  NOT NULL,
       lookup_desc_column              VARCHAR(30)  NOT NULL,
       shapefile                       VARCHAR(512) NOT NULL,
       shapefile_table                 VARCHAR(30)  NULL,
       shapefile_area_id_column        VARCHAR(30)  NOT NULL,
       shapefile_desc_column           VARCHAR(30)  NULL,
	   centroids_table 				   VARCHAR(30)  NULL, 
	   centroids_area_id_column 	   VARCHAR(30)  NULL,
	   covariate_table 				   VARCHAR(30)  NULL, 
       restricted 					   INTEGER      NULL DEFAULT 0,
       resolution                      INTEGER      NULL,
       comparea                        INTEGER      NULL,
       listing                         INTEGER      NULL,
	   areaid_count 				   INTEGER      NULL,
       CONSTRAINT geolevels_usa_2014_pk PRIMARY KEY(geography, geolevel_name),
	   CONSTRAINT geolevels_usa_2014_fk FOREIGN KEY (geography)
			REFERENCES geography_usa_2014 (geography), 
	   CONSTRAINT geolevels_usa_2014_comparea_ck CHECK (comparea IN (0, 1)),
	   CONSTRAINT geolevels_usa_2014_listing_ck CHECK (listing iN (0, 1)),
	   CONSTRAINT geolevels_usa_2014_resolution_ck CHECK (resolution IN (0, 1)),
	   CONSTRAINT geolevels_usa_2014_restricted_ck CHECK (restricted IN (0, 1))
);

-- SQL statement 163: Comment geolevels meta data table >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE geolevels_usa_2014 IS 'Geolevels: hierarchy of level within a geography';

-- SQL statement 164: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_usa_2014.geography IS 'Geography (e.g EW2001)';

-- SQL statement 165: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_usa_2014.geolevel_name IS 'Name of geolevel. This will be a column name in the numerator/denominator tables';

-- SQL statement 166: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_usa_2014.geolevel_id IS 'ID for ordering (1=lowest resolution). Up to 99 supported.';

-- SQL statement 167: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_usa_2014.description IS 'Description';

-- SQL statement 168: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_usa_2014.lookup_table IS 'Lookup table name. This is used to translate codes to the common names, e.g a LADUA of 00BK is "Westminster"';

-- SQL statement 169: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_usa_2014.lookup_desc_column IS 'Lookup table description column name.';

-- SQL statement 170: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_usa_2014.shapefile IS 'Location of the GIS shape file. NULL if PostGress/PostGIS used. Can also use SHAPEFILE_GEOMETRY instead';

-- SQL statement 171: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_usa_2014.shapefile_table IS 'Table containing GIS shape file data.';

-- SQL statement 172: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_usa_2014.shapefile_area_id_column IS 'Column containing the AREA_IDs in SHAPEFILE_TABLE';

-- SQL statement 173: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_usa_2014.shapefile_desc_column IS 'Column containing the AREA_ID descriptions in SHAPEFILE_TABLE';

-- SQL statement 174: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_usa_2014.resolution IS 'Can use a map for selection at this resolution (0/1)';

-- SQL statement 175: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_usa_2014.comparea IS 'Able to be used as a comparison area (0/1)';

-- SQL statement 176: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_usa_2014.listing IS 'Able to be used in a disease map listing (0/1)';

-- SQL statement 177: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_usa_2014.areaid_count IS 'Total number of area IDs within the geolevel';

-- SQL statement 178: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_usa_2014.centroids_table IS 'Centroids table';

-- SQL statement 179: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_usa_2014.centroids_area_id_column IS 'Centroids area id column';

-- SQL statement 180: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_usa_2014.covariate_table IS 'Covariate table';

-- SQL statement 181: Insert geolevels meta data for: cb_2014_us_nation_5m >>>
/*
 * SQL statement name: 	insert_geolevel.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. GEOLEVELS_CB_2014_US_COUNTY_500K
 *						2: geography; e.g. CB_2014_US_500K
 *						3: Geolevel name; e.g. CB_2014_US_COUNTY_500K
 *						4: Geolevel id; e.g. 3
 *						5: Geolevel description; e.g. "The State-County at a scale of 1:500,000"
 *						6: lookup table; e.g. LOOKUP_CB_2014_US_COUNTY_500K
 * 						7: shapefile; e.g. cb_2014_us_county_500k.shp
 *						8: shapefile table; e.g. CB_2014_US_COUNTY_500K
 *						9: covariate_table; e.g. CB_2014_US_500K_COVARIATES_CB_2014_US_COUNTY_500K
 *						10: shapefile_area_id_column; e.g. COUNTYNS
 *						11: shapefile_desc_column; e.g. NAME
 * 						12: lookup_desc_column; e.g. AREANAME
 *						13: resolution: Can use a map for selection at this resolution (0/1)
 *						14: comparea: Able to be used as a comparison area (0/1)
 *						15: listing: Able to be used in a disease map listing (0/1)
 *
 * Description:			Insert into geography table
 * Note:				%% becomes % after substitution
 */
INSERT INTO geolevels_usa_2014 (
   geography, geolevel_name, geolevel_id, description, lookup_table,
   lookup_desc_column, shapefile, shapefile_table, shapefile_area_id_column, shapefile_desc_column,
   resolution, comparea, listing, covariate_table)
SELECT 'USA_2014' AS geography,
       'CB_2014_US_NATION_5M' AS geolevel_name,
       1 AS geolevel_id,
       'The nation at a scale of 1:5,000,000' AS description,
       'LOOKUP_CB_2014_US_NATION_5M' AS lookup_table,
       'AREANAME' AS lookup_desc_column,
       'cb_2014_us_nation_5m.shp' AS shapefile,
       'CB_2014_US_NATION_5M' AS shapefile_table,
       'GEOID' AS shapefile_area_id_column,
       'NAME' AS shapefile_desc_column,
       1 AS resolution,
       1 AS comparea,
       0 AS listing,
	   NULL AS covariate_table;

-- SQL statement 182: Insert geolevels meta data for: cb_2014_us_state_500k >>>
/*
 * SQL statement name: 	insert_geolevel.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. GEOLEVELS_CB_2014_US_COUNTY_500K
 *						2: geography; e.g. CB_2014_US_500K
 *						3: Geolevel name; e.g. CB_2014_US_COUNTY_500K
 *						4: Geolevel id; e.g. 3
 *						5: Geolevel description; e.g. "The State-County at a scale of 1:500,000"
 *						6: lookup table; e.g. LOOKUP_CB_2014_US_COUNTY_500K
 * 						7: shapefile; e.g. cb_2014_us_county_500k.shp
 *						8: shapefile table; e.g. CB_2014_US_COUNTY_500K
 *						9: covariate_table; e.g. CB_2014_US_500K_COVARIATES_CB_2014_US_COUNTY_500K
 *						10: shapefile_area_id_column; e.g. COUNTYNS
 *						11: shapefile_desc_column; e.g. NAME
 * 						12: lookup_desc_column; e.g. AREANAME
 *						13: resolution: Can use a map for selection at this resolution (0/1)
 *						14: comparea: Able to be used as a comparison area (0/1)
 *						15: listing: Able to be used in a disease map listing (0/1)
 *
 * Description:			Insert into geography table
 * Note:				%% becomes % after substitution
 */
INSERT INTO geolevels_usa_2014 (
   geography, geolevel_name, geolevel_id, description, lookup_table,
   lookup_desc_column, shapefile, shapefile_table, shapefile_area_id_column, shapefile_desc_column,
   resolution, comparea, listing, covariate_table)
SELECT 'USA_2014' AS geography,
       'CB_2014_US_STATE_500K' AS geolevel_name,
       2 AS geolevel_id,
       'The State at a scale of 1:500,000' AS description,
       'LOOKUP_CB_2014_US_STATE_500K' AS lookup_table,
       'AREANAME' AS lookup_desc_column,
       'cb_2014_us_state_500k.shp' AS shapefile,
       'CB_2014_US_STATE_500K' AS shapefile_table,
       'STATENS' AS shapefile_area_id_column,
       'NAME' AS shapefile_desc_column,
       1 AS resolution,
       0 AS comparea,
       1 AS listing,
	   'COV_CB_2014_US_STATE_500K' AS covariate_table;

-- SQL statement 183: Insert geolevels meta data for: cb_2014_us_county_500k >>>
/*
 * SQL statement name: 	insert_geolevel.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. GEOLEVELS_CB_2014_US_COUNTY_500K
 *						2: geography; e.g. CB_2014_US_500K
 *						3: Geolevel name; e.g. CB_2014_US_COUNTY_500K
 *						4: Geolevel id; e.g. 3
 *						5: Geolevel description; e.g. "The State-County at a scale of 1:500,000"
 *						6: lookup table; e.g. LOOKUP_CB_2014_US_COUNTY_500K
 * 						7: shapefile; e.g. cb_2014_us_county_500k.shp
 *						8: shapefile table; e.g. CB_2014_US_COUNTY_500K
 *						9: covariate_table; e.g. CB_2014_US_500K_COVARIATES_CB_2014_US_COUNTY_500K
 *						10: shapefile_area_id_column; e.g. COUNTYNS
 *						11: shapefile_desc_column; e.g. NAME
 * 						12: lookup_desc_column; e.g. AREANAME
 *						13: resolution: Can use a map for selection at this resolution (0/1)
 *						14: comparea: Able to be used as a comparison area (0/1)
 *						15: listing: Able to be used in a disease map listing (0/1)
 *
 * Description:			Insert into geography table
 * Note:				%% becomes % after substitution
 */
INSERT INTO geolevels_usa_2014 (
   geography, geolevel_name, geolevel_id, description, lookup_table,
   lookup_desc_column, shapefile, shapefile_table, shapefile_area_id_column, shapefile_desc_column,
   resolution, comparea, listing, covariate_table)
SELECT 'USA_2014' AS geography,
       'CB_2014_US_COUNTY_500K' AS geolevel_name,
       3 AS geolevel_id,
       'The County at a scale of 1:500,000' AS description,
       'LOOKUP_CB_2014_US_COUNTY_500K' AS lookup_table,
       'AREANAME' AS lookup_desc_column,
       'cb_2014_us_county_500k.shp' AS shapefile,
       'CB_2014_US_COUNTY_500K' AS shapefile_table,
       'COUNTYNS' AS shapefile_area_id_column,
       'NAME' AS shapefile_desc_column,
       1 AS resolution,
       1 AS comparea,
       1 AS listing,
	   'COV_CB_2014_US_COUNTY_500K' AS covariate_table;

--
-- Geolevels lookup tables
--

-- SQL statement 185: Drop table lookup_cb_2014_us_nation_5m >>>
DROP TABLE IF EXISTS lookup_cb_2014_us_nation_5m;

-- SQL statement 186: Create table lookup_cb_2014_us_nation_5m >>>
CREATE TABLE lookup_cb_2014_us_nation_5m (
	cb_2014_us_nation_5m			VARCHAR(100)  NOT NULL,
	areaname	VARCHAR(1000)
);

-- SQL statement 187: Insert table lookup_cb_2014_us_nation_5m >>>
INSERT INTO lookup_cb_2014_us_nation_5m(cb_2014_us_nation_5m, areaname)
SELECT areaid, areaname
  FROM cb_2014_us_nation_5m
 ORDER BY 1;

-- SQL statement 188: Add primary key lookup_cb_2014_us_nation_5m >>>
ALTER TABLE lookup_cb_2014_us_nation_5m ADD PRIMARY KEY (cb_2014_us_nation_5m);

-- SQL statement 189: Comment table lookup_cb_2014_us_nation_5m >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE lookup_cb_2014_us_nation_5m IS 'Lookup table for The County at a scale of 1:500,000';

-- SQL statement 190: Comment lookup_cb_2014_us_nation_5m columns >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN lookup_cb_2014_us_nation_5m.cb_2014_us_nation_5m IS 'Area ID field';

-- SQL statement 191: Comment lookup_cb_2014_us_nation_5m columns >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN lookup_cb_2014_us_nation_5m.areaname IS 'Area Name field';

-- SQL statement 192: Drop table lookup_cb_2014_us_state_500k >>>
DROP TABLE IF EXISTS lookup_cb_2014_us_state_500k;

-- SQL statement 193: Create table lookup_cb_2014_us_state_500k >>>
CREATE TABLE lookup_cb_2014_us_state_500k (
	cb_2014_us_state_500k			VARCHAR(100)  NOT NULL,
	areaname	VARCHAR(1000)
);

-- SQL statement 194: Insert table lookup_cb_2014_us_state_500k >>>
INSERT INTO lookup_cb_2014_us_state_500k(cb_2014_us_state_500k, areaname)
SELECT areaid, areaname
  FROM cb_2014_us_state_500k
 ORDER BY 1;

-- SQL statement 195: Add primary key lookup_cb_2014_us_state_500k >>>
ALTER TABLE lookup_cb_2014_us_state_500k ADD PRIMARY KEY (cb_2014_us_state_500k);

-- SQL statement 196: Comment table lookup_cb_2014_us_state_500k >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE lookup_cb_2014_us_state_500k IS 'Lookup table for The nation at a scale of 1:5,000,000';

-- SQL statement 197: Comment lookup_cb_2014_us_state_500k columns >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN lookup_cb_2014_us_state_500k.cb_2014_us_state_500k IS 'Area ID field';

-- SQL statement 198: Comment lookup_cb_2014_us_state_500k columns >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN lookup_cb_2014_us_state_500k.areaname IS 'Area Name field';

-- SQL statement 199: Drop table lookup_cb_2014_us_county_500k >>>
DROP TABLE IF EXISTS lookup_cb_2014_us_county_500k;

-- SQL statement 200: Create table lookup_cb_2014_us_county_500k >>>
CREATE TABLE lookup_cb_2014_us_county_500k (
	cb_2014_us_county_500k			VARCHAR(100)  NOT NULL,
	areaname	VARCHAR(1000)
);

-- SQL statement 201: Insert table lookup_cb_2014_us_county_500k >>>
INSERT INTO lookup_cb_2014_us_county_500k(cb_2014_us_county_500k, areaname)
SELECT areaid, areaname
  FROM cb_2014_us_county_500k
 ORDER BY 1;

-- SQL statement 202: Add primary key lookup_cb_2014_us_county_500k >>>
ALTER TABLE lookup_cb_2014_us_county_500k ADD PRIMARY KEY (cb_2014_us_county_500k);

-- SQL statement 203: Comment table lookup_cb_2014_us_county_500k >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE lookup_cb_2014_us_county_500k IS 'Lookup table for The State at a scale of 1:500,000';

-- SQL statement 204: Comment lookup_cb_2014_us_county_500k columns >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN lookup_cb_2014_us_county_500k.cb_2014_us_county_500k IS 'Area ID field';

-- SQL statement 205: Comment lookup_cb_2014_us_county_500k columns >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN lookup_cb_2014_us_county_500k.areaname IS 'Area Name field';

--
-- Hierarchy table
--

-- SQL statement 207: Drop table hierarchy_usa_2014 >>>
DROP TABLE IF EXISTS hierarchy_usa_2014;

-- SQL statement 208: Create table hierarchy_usa_2014 >>>
CREATE TABLE hierarchy_usa_2014 (
	cb_2014_us_county_500k	VARCHAR(100)  NOT NULL,
	cb_2014_us_nation_5m	VARCHAR(100)  NOT NULL,
	cb_2014_us_state_500k	VARCHAR(100)  NOT NULL);

-- SQL statement 209: Add primary key hierarchy_usa_2014 >>>
ALTER TABLE hierarchy_usa_2014 ADD PRIMARY KEY (cb_2014_us_county_500k);

-- SQL statement 210: Add index key hierarchy_usa_2014_cb_2014_us_state_500k >>>
CREATE INDEX hierarchy_usa_2014_cb_2014_us_state_500k ON hierarchy_usa_2014 (cb_2014_us_state_500k);

-- SQL statement 211: Comment table: hierarchy_usa_2014 >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE hierarchy_usa_2014 IS 'Hierarchy lookup table for US 2014 Census geography to county level';

-- SQL statement 212: Create function check_hierarchy_usa_2014 >>>
CREATE OR REPLACE FUNCTION check_hierarchy_usa_2014(l_geography VARCHAR, l_hierarchytable VARCHAR, l_type VARCHAR)
RETURNS integer 
SECURITY INVOKER
AS $body$
/*
 * SQL statement name: 	check_hierarchy_function.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: function name; e.g. check_hierarchy_cb_2014_us_500k
 *
 * Description:			Create hierarchy check function
 * Note:				%% becomes % after substitution
 */
 
/*
Function: 		check_hierarchy_usa_2014()
Parameters:		Geography, hierarchy table, type: 'missing', 'spurious additional' or 'multiple hierarchy'
Returns:		Nothing
Description:	Diff geography hierarchy table using dynamic method 4
				Also tests the hierarchy, i.e. all a higher resolutuion is contained by one of the next higher and so on
 */
DECLARE
	c2 CURSOR(l_geography VARCHAR) FOR
		SELECT * 
		  FROM geolevels_usa_2014
		 WHERE geography = l_geography
		 ORDER BY geolevel_id;
	c3 REFCURSOR;
	c4 CURSOR(l_geography VARCHAR, l_geolevel_id INTEGER) FOR
		SELECT * 
		  FROM geolevels_usa_2014
		 WHERE geography   = l_geography
		   AND geolevel_id = l_geolevel_id
		 ORDER BY geolevel_id;
--
	c2_rec geolevels_usa_2014%ROWTYPE;
	c3_rec RECORD;
	c4_rec geolevels_usa_2014%ROWTYPE;
--
	sql_stmt 		VARCHAR;
	previous_geolevel_name 	VARCHAR:=NULL;
	i INTEGER;
	e INTEGER:=0;
	field INTEGER;
BEGIN
--
	sql_stmt:='WITH /* '||l_type||' */ ';
	i:=0;
	FOR c2_rec IN c2(l_geography) LOOP
		i:=i+1;
		IF l_type = 'multiple hierarchy' THEN
			IF i = 1 THEN
				NULL;
			ELSIF i > 2 THEN
				sql_stmt:=sql_stmt||', '||quote_ident('a'||c2_rec.geolevel_id)||' AS ('||E'\n';
				sql_stmt:=sql_stmt||E'\t'||'SELECT COUNT(*) AS '||quote_ident(LOWER(c2_rec.geolevel_name)||'_total')||E'\n';
				sql_stmt:=sql_stmt||E'\t'||'  FROM ('||E'\n';
			ELSE
				sql_stmt:=sql_stmt||quote_ident('a'||c2_rec.geolevel_id)||' AS ('||E'\n';
				sql_stmt:=sql_stmt||E'\t'||'SELECT COUNT(*) AS '||quote_ident(LOWER(c2_rec.geolevel_name)||'_total')||E'\n';
				sql_stmt:=sql_stmt||E'\t'||'  FROM ('||E'\n';
			END IF;
		ELSE
			IF i != 1 THEN
				sql_stmt:=sql_stmt||', '||quote_ident('a'||c2_rec.geolevel_id)||' AS ('||E'\n';
			ELSE
				sql_stmt:=sql_stmt||quote_ident('a'||c2_rec.geolevel_id)||' AS ('||E'\n';
			END IF;
			sql_stmt:=sql_stmt||E'\t'||'SELECT COUNT(*) AS '||quote_ident(LOWER(c2_rec.geolevel_name)||'_total')||E'\n';
			sql_stmt:=sql_stmt||E'\t'||'  FROM ('||E'\n';
		END IF;
		IF l_type = 'missing' THEN
			sql_stmt:=sql_stmt||E'\t'||E'\t'||'SELECT '||quote_ident(LOWER(c2_rec.geolevel_name))||' FROM '||quote_ident(LOWER(l_hierarchytable))||E'\n';
			sql_stmt:=sql_stmt||E'\t'||E'\t'||'EXCEPT'||E'\n';
			sql_stmt:=sql_stmt||E'\t'||E'\t'||'SELECT '||quote_ident(LOWER(c2_rec.geolevel_name))||' FROM '||quote_ident(LOWER(c2_rec.lookup_table))||
				') '||quote_ident('as'||c2_rec.geolevel_id)||')'||E'\n';
		ELSIF l_type = 'spurious additional' THEN
			sql_stmt:=sql_stmt||E'\t'||E'\t'||'SELECT '||quote_ident(LOWER(c2_rec.geolevel_name))||' FROM '||quote_ident(LOWER(c2_rec.lookup_table))||E'\n';
			sql_stmt:=sql_stmt||E'\t'||E'\t'||'EXCEPT'||E'\n';
			sql_stmt:=sql_stmt||E'\t'||E'\t'||'SELECT '||quote_ident(LOWER(c2_rec.geolevel_name))||' FROM '||quote_ident(LOWER(l_hierarchytable))||
				') '||quote_ident('as'||c2_rec.geolevel_id)||')'||E'\n';
		ELSIF l_type = 'multiple hierarchy' THEN
			IF previous_geolevel_name IS NOT NULL THEN
				sql_stmt:=sql_stmt||E'\t'||E'\t'||'SELECT '||quote_ident(LOWER(c2_rec.geolevel_name))||
					', COUNT(DISTINCT('||previous_geolevel_name||')) AS total'||E'\n';
				sql_stmt:=sql_stmt||E'\t'||E'\t'||'  FROM '||quote_ident(LOWER(l_hierarchytable))||E'\n';
				sql_stmt:=sql_stmt||E'\t'||E'\t'||' GROUP BY '||quote_ident(LOWER(c2_rec.geolevel_name))||E'\n';
				sql_stmt:=sql_stmt||E'\t'||E'\t'||'HAVING COUNT(DISTINCT('||previous_geolevel_name||')) > 1'||
					') '||quote_ident('as'||c2_rec.geolevel_id)||')'||E'\n';
			END IF;
		ELSE
			RAISE EXCEPTION 'Invalid check type: %, valid types are: ''missing'', ''spurious additional'', or ''multiple hierarchy''', 
				l_type::VARCHAR 	/* Check type */;
		END IF;
		previous_geolevel_name:=quote_ident(LOWER(c2_rec.geolevel_name));
	END LOOP;
	sql_stmt:=sql_stmt||'SELECT ARRAY[';
	i:=0;
	FOR c2_rec IN c2(l_geography) LOOP
		i:=i+1;
		IF l_type = 'multiple hierarchy' THEN
			IF i = 1 THEN
				NULL;
			ELSIF i > 2 THEN
				sql_stmt:=sql_stmt||', '||quote_ident('a'||c2_rec.geolevel_id)||'.'||quote_ident(LOWER(c2_rec.geolevel_name)||'_total');
			ELSE
				sql_stmt:=sql_stmt||quote_ident('a'||c2_rec.geolevel_id)||'.'||quote_ident(LOWER(c2_rec.geolevel_name)||'_total');
			END IF;
		ELSE
			IF i != 1 THEN
				sql_stmt:=sql_stmt||', '||quote_ident('a'||c2_rec.geolevel_id)||'.'||quote_ident(LOWER(c2_rec.geolevel_name)||'_total');
			ELSE
				sql_stmt:=sql_stmt||quote_ident('a'||c2_rec.geolevel_id)||'.'||quote_ident(LOWER(c2_rec.geolevel_name)||'_total');
			END IF;
		END IF;
	END LOOP;
	sql_stmt:=sql_stmt||'] AS res_array'||E'\n'||'FROM ';
	i:=0;
	FOR c2_rec IN c2(l_geography) LOOP
		i:=i+1;
		IF l_type = 'multiple hierarchy' THEN
			IF i = 1 THEN
				NULL;
			ELSIF i > 2 THEN
				sql_stmt:=sql_stmt||', '||quote_ident('a'||c2_rec.geolevel_id);
			ELSE
				sql_stmt:=sql_stmt||quote_ident('a'||c2_rec.geolevel_id);
			END IF;
		ELSE
			IF i != 1 THEN
				sql_stmt:=sql_stmt||', '||quote_ident('a'||c2_rec.geolevel_id);
			ELSE
				sql_stmt:=sql_stmt||quote_ident('a'||c2_rec.geolevel_id);
			END IF;
		END IF;
	END LOOP;
--
	RAISE INFO 'SQL> %;', sql_stmt::VARCHAR;
	OPEN c3 FOR EXECUTE sql_stmt;
	FETCH c3 INTO c3_rec;
--
-- Process results array
--
	i:=0;
	FOREACH field IN ARRAY c3_rec.res_array LOOP
		i:=i+1;
		OPEN c4(l_geography, i);
		FETCH c4 INTO c4_rec;
		CLOSE c4;
		IF field != 0 THEN
			RAISE WARNING 'Geography: % geolevel %: [%] % codes: %', 
				l_geography::VARCHAR		/* Geography */, 
				i::VARCHAR					/* Geolevel ID */, 
				LOWER(c4_rec.geolevel_name)::VARCHAR	/* Geolevel name */, 
				l_type::VARCHAR				/* Check type */, 
				field::VARCHAR				/* Area ID */;
			e:=e+1;
		ELSE
			RAISE INFO 'Geography: % geolevel %: [%] no % codes', 
				l_geography::VARCHAR		/* Geography */, 
				i::VARCHAR					/* Geolevel ID */, 
				LOWER(c4_rec.geolevel_name)::VARCHAR	/* Geolevel name */, 
				l_type::VARCHAR				/* Check type */;
		END IF;
	END LOOP;
--
	RETURN e;
END;
$body$
LANGUAGE PLPGSQL;

-- SQL statement 213: Comment function check_hierarchy_usa_2014 >>>
COMMENT /*
 * SQL statement name: 	check_hierarchy_function_comment.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: function name; e.g. check_hierarchy_cb_2014_us_500k
 *
 * Description:			Create hierarchy check function comment
 * Note:				%% becomes % after substitution
 */
	ON FUNCTION check_hierarchy_usa_2014(VARCHAR, VARCHAR, VARCHAR) IS 'Function: 		check_hierarchy_usa_2014()
Parameters:		Geography, hierarchy table, type: "missing", "spurious additional" or "multiple hierarchy"
Returns:		Nothing
Description:	Diff geography hierarchy table using dynamic method 4
				Also tests the hierarchy, i.e. all a higher resolutuion is contained by one of the next higher and so on

Example of dynamic SQL. Note the use of an array return type to achieve method 4

WITH /* missing */ a1 AS (
        SELECT COUNT(*) AS cb_2014_us_nation_5m_total
          FROM (
                SELECT cb_2014_us_nation_5m FROM hierarchy_cb_2014_us_500k
                EXCEPT
                SELECT cb_2014_us_nation_5m FROM lookup_cb_2014_us_nation_5m) as1)
, a2 AS (
        SELECT COUNT(*) AS cb_2014_us_state_500k_total
          FROM (
                SELECT cb_2014_us_state_500k FROM hierarchy_cb_2014_us_500k
                EXCEPT
                SELECT cb_2014_us_state_500k FROM lookup_cb_2014_us_state_500k) as2)
, a3 AS (
        SELECT COUNT(*) AS cb_2014_us_county_500k_total
          FROM (
                SELECT cb_2014_us_county_500k FROM hierarchy_cb_2014_us_500k
                EXCEPT
                SELECT cb_2014_us_county_500k FROM lookup_cb_2014_us_county_500k) as3)
SELECT ARRAY[a1.cb_2014_us_nation_5m_total, a2.cb_2014_us_state_500k_total, a3.cb_2014_us_county_500k_total] AS res_array
FROM a1, a2, a3;

Or: 

WITH /* multiple hierarchy */ a2 AS (
        SELECT COUNT(*) AS cb_2014_us_state_500k_total
          FROM (
                SELECT cb_2014_us_state_500k, COUNT(DISTINCT(cb_2014_us_nation_5m)) AS total
                  FROM hierarchy_cb_2014_us_500k
                 GROUP BY cb_2014_us_state_500k
                HAVING COUNT(DISTINCT(cb_2014_us_nation_5m)) > 1) as2)
, a3 AS (
        SELECT COUNT(*) AS cb_2014_us_county_500k_total
          FROM (
                SELECT cb_2014_us_county_500k, COUNT(DISTINCT(cb_2014_us_state_500k)) AS total
                  FROM hierarchy_cb_2014_us_500k
                 GROUP BY cb_2014_us_county_500k
                HAVING COUNT(DISTINCT(cb_2014_us_state_500k)) > 1) as3)
SELECT ARRAY[a2.cb_2014_us_state_500k_total, a3.cb_2014_us_county_500k_total] AS res_array
FROM a2, a3;
';

-- SQL statement 214: Insert into hierarchy_usa_2014 >>>
DO LANGUAGE plpgsql $$
DECLARE
/*
 * SQL statement name: 	insert_hierarchy.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: geography; e.g. cb_2014_us_500k
 *						2: Max zoomlevel
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 */
	l_geography VARCHAR:='USA_2014';
--
	c1_hier CURSOR(l_geography VARCHAR) FOR
		SELECT * 
		  FROM geolevels_USA_2014
		 WHERE geography = l_geography
		 ORDER BY geography, geolevel_id;
	c2_hier CURSOR(l_geography VARCHAR) FOR
		SELECT * FROM pg_indexes
		 WHERE schemaname = USER
		   AND tablename IN (SELECT DISTINCT LOWER(hierarchytable)
				       FROM geography_USA_2014
				      WHERE geography = l_geography)
		 ORDER BY 1;	
	c3 REFCURSOR;
	c4_hier CURSOR(l_geography VARCHAR) FOR
		SELECT *
		  FROM geography_USA_2014
		 WHERE geography = l_geography;
	c1_rec geolevels_USA_2014%ROWTYPE;
	c2_rec geography_USA_2014%ROWTYPE;
	c3_rec	RECORD;
	c4_rec geography_USA_2014%ROWTYPE;
--
	columns			VARCHAR;
	sql_stmt	 	VARCHAR;
	i				INTEGER:=0;
	num_geolevels	INTEGER:=0;
--
	geolevel_name			VARCHAR[];
	shapefile_table      		VARCHAR[];
 	shapefile_area_id_column	VARCHAR[];
 	shapefile_desc_column		VARCHAR[];
--
BEGIN
--
	OPEN c4_hier(l_geography);
	FETCH c4_hier INTO c4_rec;
	CLOSE c4_hier;
--
	IF c4_rec.geography IS NULL THEN
		RAISE EXCEPTION 'geography: % not found', 
			l_geography::VARCHAR	/* Geography */;
	END IF;	
--
	 RAISE INFO 'Populating % geography hierarchy table: %',
		l_geography, c4_rec.hierarchytable;
--
-- INSERT statement
--
	sql_stmt:='INSERT INTO '||quote_ident(LOWER(c4_rec.hierarchytable))||' (';
	FOR c1_rec IN c1_hier(l_geography) LOOP
		i:=i+1;
		geolevel_name[i]:=quote_ident(LOWER(c1_rec.geolevel_name));
		shapefile_table[i]:=quote_ident(LOWER(c1_rec.shapefile_table));      	
 		shapefile_area_id_column[i]:=quote_ident(LOWER(c1_rec.shapefile_area_id_column));	
 		shapefile_desc_column[i]:=quote_ident(LOWER(c1_rec.shapefile_desc_column));	
		IF i = 1 THEN
			columns:=geolevel_name[i];
		ELSE
			columns:=columns||', '||geolevel_name[i];
		END IF;
	END LOOP;
	num_geolevels:=i;
	IF num_geolevels = 0 THEN
		RAISE EXCEPTION 'No rows found in: geolevels_USA_2014 for geography %', 
			l_geography::VARCHAR /* Geography */;
	END IF;
	sql_stmt:=sql_stmt||columns||')'||E'\n';
--
-- Start SELECT statement; WITH clause; aggreagate geometries
--
-- Removed ST_Union for performance reasons
--

--
-- WITH clause - INTERSECTION
--
	FOR i IN 1 .. num_geolevels LOOP /* WITH clause - INTERSECTION */
/* E.g

x23 AS (
	SELECT a2.areaid AS level2, a3.areaid AS level3,
  	       ST_Area(a3.geom) AS a3_area,
	       ST_Area(ST_Intersection(a2.geom, a3.geom)) a23_area
          FROM a2 CROSS JOIN a3
	 WHERE ST_Intersects(a2.geom, a3.geom)
 */
		IF i = 1 THEN
			sql_stmt:=sql_stmt||
				'WITH x'||i||i+1||' AS ( /* Subqueries x'||i||i+1||' ... x'||num_geolevels-1||num_geolevels||': intersection aggregate geometries starting from the lowest resolution.'||E'\n'||
         		      	E'\t'||'       Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.'||E'\n'||
 	       			E'\t'||'       Calculate the area of the higher resolution geolevel and the area of the intersected area */'||E'\n'||
				'SELECT a'||i||'.areaid AS '||geolevel_name[i]||', a'||i+1||'.areaid AS '||geolevel_name[i+1]||','||E'\n'||
				'       ST_Area(a'||i+1||'.geom_9) AS a'||i+1||'_area,'||E'\n'||
				'       ST_Area(ST_Intersection(a'||i||'.geom_9, a'||i+1||'.geom_9)) AS a'||i||i+1||'_area'||E'\n'||
				'  FROM '||shapefile_table[i]||' a'||i||' CROSS JOIN '||shapefile_table[i+1]||' a'||i+1||''||E'\n'||
				' WHERE ST_Intersects(a'||i||'.geom_9, a'||i+1||'.geom_9)'||E'\n'||
				'), ';
		ELSIF i < (num_geolevels-1) THEN
			sql_stmt:=sql_stmt||
				'x'||i||i+1||' AS ( /* Subqueries x'||i||i+1||' ... x'||num_geolevels-1||num_geolevels||': intersection aggregate geometries starting from the lowest resolution.'||E'\n'||
         		      	E'\t'||'       Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.'||E'\n'||
 	       			E'\t'||'       Calculate the area of the higher resolution geolevel and the area of the intersected area */'||E'\n'||
				'SELECT a'||i||'.areaid AS '||geolevel_name[i]||', a'||i+1||'.areaid AS '||geolevel_name[i+1]||','||E'\n'||
				'       ST_Area(a'||i+1||'.geom_9) AS a'||i+1||'_area,'||E'\n'||
				'       ST_Area(ST_Intersection(a'||i||'.geom_9, a'||i+1||'.geom_9)) AS a'||i||i+1||'_area'||E'\n'||
				'  FROM '||shapefile_table[i]||' a'||i||' CROSS JOIN '||shapefile_table[i+1]||' a'||i+1||''||E'\n'||
				' WHERE ST_Intersects(a'||i||'.geom_9, a'||i+1||'.geom_9)'||E'\n'||
				'), ';
		ELSIF i < num_geolevels THEN
/* E.g.

 x34 AS (
	SELECT a3.level3, a4.level4,
	       total_a3_gid, total_a4_gid,
  	       ST_Area(a4.geom) AS a4_area,
	       ST_Area(ST_Intersection(a3.geom, a4.geom)) a34_area
          FROM a3 CROSS JOIN a4
	 WHERE ST_Intersects(a3.geom, a4.geom)
*/
			sql_stmt:=sql_stmt||
				'x'||i||i+1||' AS ( /* Subqueries x'||i||i+1||' ... x'||num_geolevels-1||num_geolevels||': intersection aggregate geometries starting from the lowest resolution.'||E'\n'||
         		      	E'\t'||'       Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.'||E'\n'||
 	       			E'\t'||'       Calculate the area of the higher resolution geolevel and the area of the intersected area */'||E'\n'||
				'SELECT a'||i||'.areaid AS '||geolevel_name[i]||', a'||i+1||'.areaid AS '||geolevel_name[i+1]||','||E'\n'||
				'       ST_Area(a'||i+1||'.geom_9) AS a'||i+1||'_area,'||E'\n'||
				'       ST_Area(ST_Intersection(a'||i||'.geom_9, a'||i+1||'.geom_9)) AS a'||i||i+1||'_area'||E'\n'||
				'  FROM '||shapefile_table[i]||' a'||i||' CROSS JOIN '||shapefile_table[i+1]||' a'||i+1||''||E'\n'||
				' WHERE ST_Intersects(a'||i||'.geom_9, a'||i+1||'.geom_9)'||E'\n'||
				'), ';
		END IF;
	END LOOP;
--
-- Compute intersected area, order analytically
--

/*
y AS ( 
	SELECT x12.level1, x12.level2, x23.level3, x34.level4, 
	       CASE WHEN a2_area > 0 THEN a12_area/a2_area ELSE NULL END test12,
	       CASE WHEN a3_area > 0 THEN a23_area/a3_area ELSE NULL END test23,
	       CASE WHEN a4_area > 0 THEN a34_area/a4_area ELSE NULL END test34,
	       MAX(a12_area/a2_area) OVER (PARTITION BY x12.level2) AS max12,
	       MAX(a23_area/a3_area) OVER (PARTITION BY x23.level3) AS max23,
	       MAX(a34_area/a4_area) OVER (PARTITION BY x34.level4) AS max34
	  FROM x12, x23, x34
	 WHERE x12.level2 = x23.level2
   	   AND x23.level3 = x34.level3
)
 */
	sql_stmt:=sql_stmt||
		'y AS ( /* Join x'||i||i+1||' ... x'||num_geolevels-1||num_geolevels||
			'intersections, pass through the computed areas, compute intersected area/higher resolution geolevel area,'||E'\n'||
		E'\t'||'     compute maximum intersected area/higher resolution geolevel area using an analytic partition of all'||E'\n'||
		E'\t'||'     duplicate higher resolution geolevels */'||E'\n';
	FOR i IN 1 .. num_geolevels LOOP /* x12.level1, x12.level2, x23.level3, x34.level4, */
		IF i < num_geolevels THEN
			IF i = 1 THEN
				sql_stmt:=sql_stmt||
					'SELECT x'||i||i+1||'.'||geolevel_name[i]||', '||E'\n';
			END IF;
			sql_stmt:=sql_stmt||
				'       x'||i||i+1||'.'||geolevel_name[i+1]||', '||E'\n';
		END IF;
	END LOOP;
	FOR i IN 1 .. num_geolevels LOOP /* CASE MAX analytic clause */ 
		IF i < num_geolevels THEN
			sql_stmt:=sql_stmt||
	    		   	'       CASE WHEN x'||i||i+1||'.a'||i+1||'_area > 0 THEN x'||i||i+1||'.a'||i||i+1||'_area/x'||i||i+1||'.a'||i+1||
				'_area ELSE NULL END test'||i||i+1||','||E'\n';
			sql_stmt:=sql_stmt||
				'       MAX(x'||i||i+1||'.a'||i||i+1||'_area/x'||i||i+1||'.a'||i+1||'_area)'||
				' OVER (PARTITION BY x'||i||i+1||'.'||geolevel_name[i+1]||') AS max'||i||i+1||','||E'\n';
		END IF;
	END LOOP;
	sql_stmt:=SUBSTR(sql_stmt, 1, LENGTH(sql_stmt)-LENGTH(','||E'\n')) /* Chop off last ",\n" */||E'\n';
	FOR i IN 1 .. num_geolevels LOOP /* FROM clause */ 
		IF i < num_geolevels THEN
			IF i = 1 THEN
				sql_stmt:=sql_stmt||
					'  FROM x'||i||i+1;
			ELSE
				sql_stmt:=sql_stmt||
					', x'||i||i+1;
			END IF;
		END IF;
	END LOOP;
	FOR i IN 1 .. (num_geolevels-2) LOOP /* WHERE clause */ 
		IF i = 1 THEN
			sql_stmt:=sql_stmt||E'\n'||
				' WHERE x'||i||i+1||'.'||geolevel_name[i+1]||' = x'||i+1||i+2||'.'||geolevel_name[i+1];
		ELSE
			sql_stmt:=sql_stmt||E'\n'||
				'   AND x'||i||i+1||'.'||geolevel_name[i+1]||' = x'||i+1||i+2||'.'||geolevel_name[i+1];
		END IF;
	END LOOP;
	sql_stmt:=sql_stmt||E'\n'||')'||E'\n';
--
-- Final SELECT
--
	sql_stmt:=sql_stmt||'SELECT /* Select y intersection, eliminating duplicates using selecting the lower geolevel resolution'||E'\n'||
         E'\t'||' with the largest intersection by area for each (higher resolution) geolevel */'||E'\n'||'       '||columns||E'\n';
	sql_stmt:=sql_stmt||'  FROM y'||E'\n';
/*
SELECT level1, level2, level3, level4,
  FROM y
 WHERE max12 = test12
   AND max23 = test23
   AND max34 = test34
 ORDER BY 1, 2, 3, 4;  
 */
	FOR i IN 1 .. num_geolevels LOOP /* FROM clause */ 
		IF i < num_geolevels THEN
			IF i = 1 THEN
				sql_stmt:=sql_stmt||' WHERE max'||i||i+1||' = test'||i||i+1||E'\n';
			ELSE
				sql_stmt:=sql_stmt||'   AND max'||i||i+1||' = test'||i||i+1||E'\n';
			END IF;
		END IF;
	END LOOP;
	
	sql_stmt:=sql_stmt||' ORDER BY 1';
	FOR i IN 2 .. num_geolevels LOOP /* ORDER BY clause */ 	
		sql_stmt:=sql_stmt||', '||i;
	END LOOP;
	
	RAISE NOTICE 'SQL> %;', sql_stmt;
	EXECUTE sql_stmt;
--
-- Check rows were inserted
--
	sql_stmt:='SELECT COUNT(*) AS total FROM '||quote_ident(LOWER(c4_rec.hierarchytable));
	OPEN c3 FOR EXECUTE sql_stmt;
	FETCH c3 INTO c3_rec;
	CLOSE c3;	
	IF c3_rec.total = 0 THEN
		RAISE EXCEPTION 'No rows found in % geography hierarchy table: %', 
			l_geography::VARCHAR 			/* Geography */,
			quote_ident(LOWER(c4_rec.hierarchytable))	/* Hierarchy table */;
	END IF;
--
-- Re-index
--
	FOR c2_rec IN c2_hier(l_geography) LOOP
		sql_stmt:='REINDEX INDEX /* '||quote_ident(c2_rec.tablename)||' */ '||quote_ident(c2_rec.indexname);
		RAISE NOTICE 'SQL> %;', sql_stmt;
		EXECUTE sql_stmt;
	END LOOP;
--
-- Analyze
--
	sql_stmt:='ANALYZE VERBOSE '||quote_ident(LOWER(c4_rec.hierarchytable));
	RAISE NOTICE 'SQL> %;', sql_stmt;
	EXECUTE sql_stmt;
END;
$$;

-- SQL statement 215: Check intersctions  for geograpy: usa_2014 >>>
DO LANGUAGE plpgsql $$
DECLARE
/*
 * SQL statement name: 	check_intersections.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: geography; e.g. cb_2014_us_500k
 *
 * Description:			Check intersections
 * Note:				%% becomes % after substitution
 */
	l_geography VARCHAR:='USA_2014';
--
	c1 CURSOR(l_geography VARCHAR) FOR
		SELECT *
		  FROM geography_USA_2014
		 WHERE geography = l_geography;
	c1_rec geography_USA_2014%ROWTYPE;
--
	e INTEGER:=0;
	f INTEGER:=0;
	g INTEGER:=0;
BEGIN
--
	OPEN c1(l_geography);
	FETCH c1 INTO c1_rec;
	CLOSE c1;
--
	IF c1_rec.geography IS NULL THEN
		RAISE EXCEPTION 'geography: % not found', 
			l_geography::VARCHAR	/* Geography */;
	END IF;	
--
-- Call diff and multiple hierarchy tests
--
	e:=check_hierarchy_USA_2014(c1_rec.geography, c1_rec.hierarchytable, 'missing');
	f:=check_hierarchy_USA_2014(c1_rec.geography, c1_rec.hierarchytable, 'spurious additional');
	g:=check_hierarchy_USA_2014(c1_rec.geography, c1_rec.hierarchytable, 'multiple hierarchy');
--
	IF e+f > 0 THEN
		RAISE EXCEPTION 'Geography: % codes check % missing, % spurious additional, % hierarchy fails', 
			c1_rec.geography	/* Geography */, 
			e::VARCHAR		/* Missing */, 
			f::VARCHAR		/* Spurious additional */, 
			g::VARCHAR		/* Multiple hierarchy */;
	ELSE
		RAISE INFO 'Geography: % codes check OK', 
			c1_rec.geography::VARCHAR	/* Geography */;
	END IF;
END;
$$;

--
-- Create geometry tables
--

-- SQL statement 217: Drop geometry table geometry_usa_2014 >>>
DROP TABLE IF EXISTS geometry_usa_2014 CASCADE;

-- SQL statement 218: Create geometry table geometry_usa_2014 >>>
/*
 * SQL statement name: 	create_geometry_table.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. geometry_cb_2014_us_500k
 *
 * Description:			Create geometry table
 * Note:				% becomes % after substitution
 */
CREATE TABLE geometry_usa_2014 (
	geolevel_id		INTEGER			NOT NULL,
	areaid			VARCHAR(200)	NOT NULL,
	zoomlevel		INTEGER			NOT NULL);

-- SQL statement 219: Add geom geometry column >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('geometry_usa_2014','geom', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 220: Comment geometry table >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE geometry_usa_2014 IS 'All geolevels geometry combined into a single table for a single geography';

-- SQL statement 221: Comment geometry table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geometry_usa_2014.geolevel_id IS 'ID for ordering (1=lowest resolution). Up to 99 supported.';

-- SQL statement 222: Comment geometry table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geometry_usa_2014.zoomlevel IS 'Zoom level: 0 to maxoomlevel (11). Number of tiles is 2**<zoom level> * 2**<zoom level>; i.e. 1, 2x2, 4x4 ... 2048x2048 at zoomlevel 11';

-- SQL statement 223: Comment geometry table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geometry_usa_2014.areaid IS 'Area ID.';

-- SQL statement 224: Comment geometry table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geometry_usa_2014.geom IS 'Geometry data in SRID 4326 (WGS84).';

-- SQL statement 225: Create partitioned tables and insert function for geometry table; comment partitioned tables and columns >>>
DO LANGUAGE plpgsql $$
DECLARE
/*
 * SQL statement name: 	partition_geometry_table1.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: geometry table; e.g. geometry_cb_2014_us_500k
 *						2: Max zoomlevel; e.g. 11
 *
 * Description:			Create partitioned tables and insert function for geometry table; comment partitioned tables and columns
 * Note:				%% becomes % after substitution
 */
	l_table 	Text:='geometry_usa_2014';
	sql_stmt	VARCHAR[];
	trigger_sql	VARCHAR;
BEGIN
	FOR i IN 1 .. 3 LOOP
		FOR j IN 6 .. 9 LOOP
			sql_stmt[COALESCE(array_length(sql_stmt, 1), 0)]:='CREATE TABLE '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||' ('||E'\n'||
					  '    CHECK ( geolevel_id = '||i::Text||' AND zoomlevel = '||j::Text||' )'||E'\n'||
					  ') INHERITS ('||l_table||')';	
			sql_stmt[array_length(sql_stmt, 1)]:='COMMENT ON TABLE '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text|| 
					  ' IS ''All geolevels geometry combined into a single table.  Geolevel '||
							i::Text||', zoomlevel '||j::Text||' partition.''';
			sql_stmt[array_length(sql_stmt, 1)]:='COMMENT ON COLUMN '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text|| 
							'.zoomlevel IS ''Zoom level: 0 to Max zoomlevel (11). Number of tiles is 2**<zoom level> * 2**<zoom level>; i.e. 1, 2x2, 4x4 ... 2048x2048 at zoomlevel 11.''';
			sql_stmt[array_length(sql_stmt, 1)]:='COMMENT ON COLUMN '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text|| 
							'.areaid IS ''Area ID.''';
			sql_stmt[array_length(sql_stmt, 1)]:='COMMENT ON COLUMN '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text|| 
							'.geolevel_id IS ''ID for ordering (1=lowest resolution). Up to 99 supported.''';
			sql_stmt[array_length(sql_stmt, 1)]:='COMMENT ON COLUMN '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text|| 
							'.geom IS ''Geometry data in SRID 4326 (WGS84).''';
			IF trigger_sql IS NULL THEN
				trigger_sql:='IF ( NEW.zoomlevel = '||j::Text||' AND NEW.geolevel_id = '||i::Text||' ) THEN'||E'\n'||
							' 	INSERT INTO '||l_table||'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||' VALUES (NEW.*);'||E'\n';
			ELSE
				trigger_sql:=trigger_sql||
							'ELSIF ( NEW.zoomlevel = '||j::Text||' AND NEW.geolevel_id = '||i::Text||' ) THEN'||E'\n'||
							' 	INSERT INTO '||l_table||'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||' VALUES (NEW.*);'||E'\n';
			END IF;
		END LOOP;
	END LOOP;
	
	sql_stmt[array_length(sql_stmt, 1)]:='CREATE OR REPLACE FUNCTION '||l_table||'_insert_trigger()'||E'\n'||
		'RETURNS TRIGGER AS $trigger$'||E'\n'||
		'BEGIN'||E'\n'||
		trigger_sql||
		'    ELSE'||E'\n'||
		'        RAISE EXCEPTION ''Zoomlevel (%) or geolevel_id(%) out of range. '||
					'Fix the '||l_table||'_insert_trigger() function!'','||E'\n'||
		'			NEW.zoomlevel, NEW.geolevel_id;'||E'\n'||
		'    END IF;'||E'\n'||
		'    RETURN NULL;'||E'\n'||
		'END;'||E'\n'||
		'$trigger$'||E'\n'||
		'LANGUAGE plpgsql';
--
	FOR i IN 0 .. (array_length(sql_stmt, 1)-1) LOOP
		RAISE INFO 'SQL> %;', sql_stmt[i];
		EXECUTE sql_stmt[i];
	END LOOP;
END;
$$;

-- SQL statement 226: Partition geometry table: insert trigger >>>
/*
 * SQL statement name: 	partition_trigger.sql
 * Type:				Postgres/PostGIS psql
 * Parameters:
 *						1: geometry table; e.g. geometry_cb_2014_us_500k
 *
 * Description:			Create partitioned tables insert trigger
 * Note:				%% becomes % after substitution
 */
 CREATE TRIGGER insert_geometry_usa_2014_trigger
    BEFORE INSERT ON geometry_usa_2014
    FOR EACH ROW EXECUTE PROCEDURE geometry_usa_2014_insert_trigger();

-- SQL statement 227: Insert into geometry table >>>
INSERT INTO geometry_usa_2014(geolevel_id, areaid, zoomlevel, geom)
SELECT 3 geolevel_id,
       areaid,
        6 AS zoomlevel,
       geom_6 AS geom
  FROM cb_2014_us_county_500k
ORDER BY 1, 3, 2;

-- SQL statement 228: Insert into geometry table >>>
INSERT INTO geometry_usa_2014(geolevel_id, areaid, zoomlevel, geom)
SELECT 3 geolevel_id,
       areaid,
        7 AS zoomlevel,
       geom_7 AS geom
  FROM cb_2014_us_county_500k
ORDER BY 1, 3, 2;

-- SQL statement 229: Insert into geometry table >>>
INSERT INTO geometry_usa_2014(geolevel_id, areaid, zoomlevel, geom)
SELECT 3 geolevel_id,
       areaid,
        8 AS zoomlevel,
       geom_8 AS geom
  FROM cb_2014_us_county_500k
ORDER BY 1, 3, 2;

-- SQL statement 230: Insert into geometry table >>>
INSERT INTO geometry_usa_2014(geolevel_id, areaid, zoomlevel, geom)
SELECT 3 geolevel_id,
       areaid,
        9 AS zoomlevel,
       geom_9 AS geom
  FROM cb_2014_us_county_500k
ORDER BY 1, 3, 2;

-- SQL statement 231: Insert into geometry table >>>
INSERT INTO geometry_usa_2014(geolevel_id, areaid, zoomlevel, geom)
SELECT 1 geolevel_id,
       areaid,
        6 AS zoomlevel,
       geom_6 AS geom
  FROM cb_2014_us_nation_5m
ORDER BY 1, 3, 2;

-- SQL statement 232: Insert into geometry table >>>
INSERT INTO geometry_usa_2014(geolevel_id, areaid, zoomlevel, geom)
SELECT 1 geolevel_id,
       areaid,
        7 AS zoomlevel,
       geom_7 AS geom
  FROM cb_2014_us_nation_5m
ORDER BY 1, 3, 2;

-- SQL statement 233: Insert into geometry table >>>
INSERT INTO geometry_usa_2014(geolevel_id, areaid, zoomlevel, geom)
SELECT 1 geolevel_id,
       areaid,
        8 AS zoomlevel,
       geom_8 AS geom
  FROM cb_2014_us_nation_5m
ORDER BY 1, 3, 2;

-- SQL statement 234: Insert into geometry table >>>
INSERT INTO geometry_usa_2014(geolevel_id, areaid, zoomlevel, geom)
SELECT 1 geolevel_id,
       areaid,
        9 AS zoomlevel,
       geom_9 AS geom
  FROM cb_2014_us_nation_5m
ORDER BY 1, 3, 2;

-- SQL statement 235: Insert into geometry table >>>
INSERT INTO geometry_usa_2014(geolevel_id, areaid, zoomlevel, geom)
SELECT 2 geolevel_id,
       areaid,
        6 AS zoomlevel,
       geom_6 AS geom
  FROM cb_2014_us_state_500k
ORDER BY 1, 3, 2;

-- SQL statement 236: Insert into geometry table >>>
INSERT INTO geometry_usa_2014(geolevel_id, areaid, zoomlevel, geom)
SELECT 2 geolevel_id,
       areaid,
        7 AS zoomlevel,
       geom_7 AS geom
  FROM cb_2014_us_state_500k
ORDER BY 1, 3, 2;

-- SQL statement 237: Insert into geometry table >>>
INSERT INTO geometry_usa_2014(geolevel_id, areaid, zoomlevel, geom)
SELECT 2 geolevel_id,
       areaid,
        8 AS zoomlevel,
       geom_8 AS geom
  FROM cb_2014_us_state_500k
ORDER BY 1, 3, 2;

-- SQL statement 238: Insert into geometry table >>>
INSERT INTO geometry_usa_2014(geolevel_id, areaid, zoomlevel, geom)
SELECT 2 geolevel_id,
       areaid,
        9 AS zoomlevel,
       geom_9 AS geom
  FROM cb_2014_us_state_500k
ORDER BY 1, 3, 2;

-- SQL statement 239: Add primary key, index and cluster (convert to index organized table) >>>
DO LANGUAGE plpgsql $$
DECLARE
/*
 * SQL statement name: 	partition_geometry_table2.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: geometry table; e.g. geometry_cb_2014_us_500k
 *						2: Max zoomlevel; e.g. 11
 *
 * Description:			Add primary key, index and cluster (convert to index organized table)
 * Note:				%% becomes % after substitution
 */
	l_table 	Text:='geometry_usa_2014';
	sql_stmt	VARCHAR[];
BEGIN
	FOR i IN 1 .. 3 LOOP
		FOR j IN 6 .. 9 LOOP
			sql_stmt[COALESCE(array_length(sql_stmt, 1), 0)]:='ALTER TABLE '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||E'\n'||
					  ' ADD CONSTRAINT '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||'_pk PRIMARY KEY (areaid)';	
			sql_stmt[array_length(sql_stmt, 1)]:='CREATE INDEX '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||'_geom_gix'||E'\n'||
					  ' ON '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||' USING GIST (geom);';
-- Convert to IOT
			sql_stmt[array_length(sql_stmt, 1)]:='CLUSTER VERBOSE '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||E'\n'||
					  ' USING '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||'_pk';
-- Analyze
			sql_stmt[array_length(sql_stmt, 1)]:='ANALYZE '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text;
		END LOOP;
	END LOOP;
--
	FOR i IN 0 .. (array_length(sql_stmt, 1)-1) LOOP
		RAISE INFO 'SQL> %;', sql_stmt[i];
		EXECUTE sql_stmt[i];
	END LOOP;
END;
$$;

-- SQL statement 240: Update areaid_count column in geolevels table using geometry table >>>
/*
 * SQL statement name: 	geolevels_areaid_update.sql
 * Type:				Postgres SQL statement
 * Parameters:
 *						1: Geolevels table; e.g. geolevels_cb_2014_us_500k
 *						2: Geometry table geometry_cb_2014_us_500k
 *
 * Description:			Update areaid_count column in geolevels table using geometry table
 * Note:				% becomes % after substitution
 */
UPDATE geolevels_usa_2014 a
   SET areaid_count = (
			SELECT COUNT(DISTINCT(areaid)) AS areaid_count
			  FROM geometry_usa_2014 b
			 WHERE a.geolevel_id = b.geolevel_id);

--
-- Create tiles functions
--

-- SQL statement 242: Create function: longitude2tile.sql >>>
/*
 * SQL statement name: 	longitude2tile.sql
 * Type:				Postgres/PostGIS PL/pgsql function
 * Parameters:			None
 *
 * Description:			Convert longitude (WGS84 - 4326) to OSM tile x
 * Note:				% becomes % after substitution
 */
DROP FUNCTION IF EXISTS tileMaker_longitude2tile(DOUBLE PRECISION, INTEGER);

CREATE OR REPLACE FUNCTION tileMaker_longitude2tile(longitude DOUBLE PRECISION, zoom_level INTEGER)
RETURNS INTEGER AS
$$
    SELECT FLOOR( (longitude + 180) / 360 * (1 << zoom_level) )::INTEGER
$$
LANGUAGE sql IMMUTABLE;
  
COMMENT ON FUNCTION tileMaker_longitude2tile(DOUBLE PRECISION, INTEGER) IS 'Function: 	 tileMaker_longitude2tile()
Parameters:	 Longitude, zoom level
Returns:	 OSM Tile x
Description: Convert longitude (WGS84 - 4326) to OSM tile x

Derivation of the tile X/Y 

* Reproject the coordinates to the Mercator projection (from EPSG:4326 to EPSG:3857):

x = lon
y = arsinh(tan(lat)) = log[tan(lat) + sec(lat)]
(lat and lon are in radians)

* Transform range of x and y to 0 � 1 and shift origin to top left corner:

x = [1 + (x / p)] / 2
y = [1 - (y / p)] / 2

* Calculate the number of tiles across the map, n, using 2**zoom
* Multiply x and y by n. Round results down to give tilex and tiley.';

-- SQL statement 243: Create function: latitude2tile.sql >>>
/*
 * SQL statement name: 	latitude2tile.sql
 * Type:				Postgres/PostGIS PL/pgsql function
 * Parameters:			None
 *
 * Description:			Convert latitude (WGS84 - 4326) to OSM tile y
 * Note:				% becomes % after substitution
 */
DROP FUNCTION IF EXISTS tileMaker_latitude2tile(DOUBLE PRECISION, INTEGER);

CREATE OR REPLACE FUNCTION tileMaker_latitude2tile(latitude DOUBLE PRECISION, zoom_level INTEGER)
RETURNS INTEGER AS
$$
    SELECT FLOOR( (1.0 - LN(TAN(RADIANS(latitude)) + 1.0 / COS(RADIANS(latitude))) / PI()) / 2.0 * (1 << zoom_level) )::INTEGER
$$
LANGUAGE sql IMMUTABLE;
  
COMMENT ON FUNCTION tileMaker_latitude2tile(DOUBLE PRECISION, INTEGER) IS 'Function: 	 tileMaker_latitude2tile()
Parameters:	 Latitude, zoom level
Returns:	 OSM Tile y
Description: Convert latitude (WGS84 - 4326) to OSM tile x

Derivation of the tile X/Y 

* Reproject the coordinates to the Mercator projection (from EPSG:4326 to EPSG:3857):

x = lon
y = arsinh(tan(lat)) = log[tan(lat) + sec(lat)]
(lat and lon are in radians)

* Transform range of x and y to 0 � 1 and shift origin to top left corner:

x = [1 + (x / p)] / 2
y = [1 - (y / p)] / 2

* Calculate the number of tiles across the map, n, using 2**zoom
* Multiply x and y by n. Round results down to give tilex and tiley.';

-- SQL statement 244: Create function: tile2longitude.sql >>>
/*
 * SQL statement name: 	tile2longitude.sql
 * Type:				Postgres/PostGIS PL/pgsql function
 * Parameters:			None
 *
 * Description:			Convert OSM tile x to longitude (WGS84 - 4326) 
 * Note:				% becomes % after substitution
 */
DROP FUNCTION IF EXISTS tileMaker_tile2longitude(INTEGER, INTEGER);

CREATE OR REPLACE FUNCTION tileMaker_tile2longitude(x INTEGER, zoom_level INTEGER)
RETURNS DOUBLE PRECISION AS
$$
	SELECT ( ( (x * 1.0) / (1 << zoom_level) * 360.0) - 180.0)::DOUBLE PRECISION
$$
LANGUAGE sql IMMUTABLE;
  
COMMENT ON FUNCTION tileMaker_tile2longitude(INTEGER, INTEGER) IS 'Function: 	 tileMaker_tile2longitude()
Parameters:	 OSM Tile x, zoom level
Returns:	 Longitude
Description: Convert OSM tile x to longitude (WGS84 - 4326)';

-- SQL statement 245: Create function: tile2latitude.sql >>>
/*
 * SQL statement name: 	tileMaker_tile2latitude.sql
 * Type:				Postgres/PostGIS PL/pgsql function
 * Parameters:			None
 *
 * Description:			Convert OSM tile y to latitude (WGS84 - 4326)
 * Note:				% becomes % after substitution
 */
DROP FUNCTION IF EXISTS tileMaker_tile2latitude(INTEGER, INTEGER);

CREATE OR REPLACE FUNCTION tileMaker_tile2latitude(y INTEGER, zoom_level INTEGER)
RETURNS DOUBLE PRECISION AS
$BODY$
DECLARE
	n FLOAT;
	sinh FLOAT;
	E FLOAT = 2.7182818284;
BEGIN
    n = PI() - (2.0 * PI() * y) / POWER(2.0, zoom_level);
    sinh = (1 - POWER(E, -2*n)) / (2 * POWER(E, -n));
    RETURN DEGREES(ATAN(sinh));
END;
$BODY$
LANGUAGE plpgsql IMMUTABLE;
  
COMMENT ON FUNCTION tileMaker_tile2latitude(INTEGER, INTEGER) IS 'Function: 	 tileMaker_tile2latitude()
Parameters:	 OSM Tile y, zoom level
Returns:	 Latitude
Description: Convert OSM tile y to latitude (WGS84 - 4326)';

-- SQL statement 246: Tile check >>>
/*
 * SQL statement name: 	tile_check.sql
 * Type:				Postgres/PostGIS PL/pgsql function
 * Parameters:			
 *						1: Lowest resolution geolevels table
 *						2: Geography
 *						3: min_zoomlevel
 *						4: max_zoomlevel
 *						5: Geolevel id = 1 geometry table
 *
 * Description:			Convert OSM tile y to latitude (WGS84 - 4326)
 * Note:				% becomes % after substitution
 */
WITH a AS ( /* Geolevel summary */
		SELECT a1.geography, 
		       a1.geolevel_name AS min_geolevel_name,
               MIN(geolevel_id) AS min_geolevel_id,
               9::INTEGER AS zoomlevel,
               a2.max_geolevel_id
          FROM geolevels_usa_2014 a1, (
                        SELECT geography, MAX(geolevel_id) AS max_geolevel_id
  						  FROM geolevels_usa_2014 
						 GROUP BY geography
						) a2
         WHERE a1.geography     = 'USA_2014' 
           AND a1.geography     = a2.geography
         GROUP BY a1.geography, a1.geolevel_name, a2.max_geolevel_id
        HAVING MIN(geolevel_id) = 1
), b AS ( /* Get bounds of geography */
        SELECT a2.geography,
               a2.min_geolevel_id,
               a2.max_geolevel_id,
               a2.zoomlevel,
          CASE
                                WHEN a2.zoomlevel <= 6 THEN ST_XMax(b.geom_6)                 	/* Optimised for zoom level 6 */
                                WHEN a2.zoomlevel BETWEEN (6+1) AND 9 THEN ST_XMax(b.geom_9)	/* Optimised for zoom level 6-11 */
                                ELSE NULL
                   END AS Xmax,
          CASE
                                WHEN a2.zoomlevel <= 6 THEN ST_XMin(b.geom_6)                 	/* Optimised for zoom level 6 */
                                WHEN a2.zoomlevel BETWEEN (6+1) AND 9 THEN ST_XMin(b.geom_9)	/* Optimised for zoom level 6-11 */
                                ELSE NULL
                   END AS Xmin,
          CASE
                                WHEN a2.zoomlevel <= 6 THEN ST_YMax(b.geom_6)                 	/* Optimised for zoom level 6 */
                                WHEN a2.zoomlevel BETWEEN (6+1) AND 9 THEN ST_YMax(b.geom_9)	/* Optimised for zoom level 6-11 */
                                ELSE NULL
                   END AS Ymax,
          CASE
                                WHEN a2.zoomlevel <= 6 THEN ST_YMin(b.geom_6)                 	/* Optimised for zoom level 6 */
                                WHEN a2.zoomlevel BETWEEN (6+1) AND 9 THEN ST_YMin(b.geom_9)	/* Optimised for zoom level 6-11 */
                                ELSE NULL
                   END AS Ymin
      FROM cb_2014_us_nation_5m b, a a2  
), d AS ( /* Convert XY bounds to tile numbers */
        SELECT geography, min_geolevel_id, max_geolevel_id, zoomlevel,
                   Xmin AS area_Xmin, Xmax AS area_Xmax, Ymin AS area_Ymin, Ymax AS area_Ymax,
           tileMaker_latitude2tile(Ymin, zoomlevel) AS Y_mintile,
           tileMaker_latitude2tile(Ymax, zoomlevel) AS Y_maxtile,
           tileMaker_longitude2tile(Xmin, zoomlevel) AS X_mintile,
           tileMaker_longitude2tile(Xmax, zoomlevel) AS X_maxtile
      FROM b
)
SELECT * FROM d;

--
-- Create tiles tables
--

-- SQL statement 248: Drop table t_tiles_usa_2014 >>>
DROP TABLE IF EXISTS t_tiles_usa_2014;

-- SQL statement 249: Create tiles table >>>
/*
 * SQL statement name: 	create_tiles_table.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. t_tiles_cb_2014_us_county_500k
 *						2: JSON datatype (Postgres JSON, SQL server Text)
 *
 * Description:			Create tiles table
 * Note:				%% becomes % after substitution
 */
CREATE TABLE t_tiles_usa_2014 (
	geolevel_id			INTEGER			NOT NULL,
	zoomlevel			INTEGER			NOT NULL,
	x					INTEGER			NOT NULL, 
	y					INTEGER			NOT NULL,
	optimised_geojson	JSON,
	optimised_topojson	JSON,
	tile_id				VARCHAR(200)	NOT NULL
);

-- SQL statement 250: Comment tiles table >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE t_tiles_usa_2014 IS 'Maptiles for geography; empty tiles are added to complete zoomlevels for zoomlevels 0 to 11';

-- SQL statement 251: Comment tiles table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN t_tiles_usa_2014.geolevel_id IS 'ID for ordering (1=lowest resolution). Up to 99 supported.';

-- SQL statement 252: Comment tiles table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN t_tiles_usa_2014.zoomlevel IS 'Zoom level: 0 to 11. Number of tiles is 2**<zoom level> * 2**<zoom level>; i.e. 1, 2x2, 4x4 ... 2048x2048 at zoomlevel 11';

-- SQL statement 253: Comment tiles table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN t_tiles_usa_2014.x IS 'X tile number. From 0 to (2**<zoomlevel>)-1';

-- SQL statement 254: Comment tiles table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN t_tiles_usa_2014.y IS 'Y tile number. From 0 to (2**<zoomlevel>)-1';

-- SQL statement 255: Comment tiles table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN t_tiles_usa_2014.optimised_geojson IS 'Tile multipolygon in GeoJSON format, optimised for zoomlevel N.';

-- SQL statement 256: Comment tiles table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN t_tiles_usa_2014.optimised_topojson IS 'Tile multipolygon in TopoJSON format, optimised for zoomlevel N. The SRID is always 4326.';

-- SQL statement 257: Comment tiles table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN t_tiles_usa_2014.tile_id IS 'Tile ID in the format <geolevel number>_<geolevel name>_<zoomlevel>_<X tile number>_<Y tile number>';

-- SQL statement 258: Create tiles view >>>
/*
 * SQL statement name: 	create_tiles_view.sql
 * Type:				Postgres/PostGIS SQL statement
 * Parameters:
 *						1: tiles view; e.g. tiles_cb_2014_us_county_500k
 *						2: geolevel table; e.g. geolevels_cb_2014_us_county_500k
 *						3: JSON datatype (Postgres JSON, SQL server VARCHAR) [No longer used]
 *						4: tiles table; e.g. t_tiles_cb_2014_us_500k
 *  					5: Max zoomlevel; e.g. 11
 *
 * Description:			Create tiles view
 * Note:				%% becomes % after substitution
 */
CREATE VIEW tiles_usa_2014 AS 
WITH a AS (
        SELECT geography,
               MAX(geolevel_id) AS max_geolevel_id
          FROM geolevels_usa_2014
         GROUP BY geography
), b AS (
         SELECT a.geography,
                generate_series(1, a.max_geolevel_id::INTEGER, 1) AS geolevel_id
           FROM a
), c AS (
        SELECT b2.geolevel_name,
               b.geolevel_id,
               b.geography,
			   b2.areaid_count
          FROM b, geolevels_usa_2014 b2
		 WHERE b.geolevel_id = b2.geolevel_id
), d AS (
        SELECT generate_series(0, 9, 1) AS zoomlevel
), ex AS (
         SELECT d.zoomlevel,
                generate_series(0, POWER(2::DOUBLE PRECISION, d.zoomlevel::DOUBLE PRECISION)::INTEGER - 1, 1) AS xy_series
           FROM d
), ey AS (
        SELECT c.geolevel_name,
			   c.areaid_count,
               c.geolevel_id,
               c.geography,
               ex.zoomlevel,
               ex.xy_series
          FROM c,
               ex 
), z AS ( 
		SELECT ey.geolevel_name,
				ey.areaid_count,
                ey.geolevel_id,
                ey.geography,
                ex.zoomlevel,
                ex.xy_series AS x,
                ey.xy_series AS y
           FROM ey, ex /* Cross join */
          WHERE ex.zoomlevel = ey.zoomlevel
)
SELECT z.geography,
       z.geolevel_id,
       z.geolevel_name,
       CASE
            WHEN h1.tile_id IS NULL AND h2.tile_id IS NULL THEN 1
            ELSE 0
       END AS no_area_ids, 
       COALESCE(h1.tile_id, 
				h2.tile_id, 
				z.geolevel_id::VARCHAR||'_'||z.geolevel_name||'_'||z.zoomlevel::VARCHAR||'_'||z.x::VARCHAR||'_'||z.y::VARCHAR) AS tile_id,
       z.x,
       z.y,
       z.zoomlevel,
       COALESCE(h1.optimised_geojson, 
				h2.optimised_geojson, 
				'{"type": "FeatureCollection","features":[]}'::JSON) AS optimised_geojson,
       COALESCE(h1.optimised_topojson, 
				h2.optimised_topojson, 
				'{"type": "FeatureCollection","features":[]}'::JSON) AS optimised_topojson
  FROM z 
		 LEFT JOIN t_tiles_usa_2014 h1 ON ( /* Multiple area ids in the geolevel */
				z.areaid_count > 1 AND
				z.zoomlevel    = h1.zoomlevel AND 
				z.x            = h1.x AND 
				z.y            = h1.y AND 
				z.geolevel_id  = h1.geolevel_id)
		 LEFT JOIN t_tiles_usa_2014 h2 ON ( /* Single area ids in the geolevel */
				z.areaid_count = 1 AND
				h2.zoomlevel   = 0 AND 
				h2.x           = 0 AND 
				h2.y           = 0 AND 
				h2.geolevel_id = 1);

-- SQL statement 259: Comment tiles view >>>
COMMENT /*
 * SQL statement name: 	comment_view.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: view; e.g. tiles_cb_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment view
 * Note:				%% becomes % after substitution
 */
	ON VIEW tiles_usa_2014 IS 'Maptiles view for geography; empty tiles are added to complete zoomlevels for zoomlevels 0 to 11. This view is efficent!';

-- SQL statement 260: Comment tiles view column >>>
COMMENT /*
 * SQL statement name: 	comment_view_column.sql
 * Type:				Postgres/PostGIS psql
 * Parameters:
 *						1: view; e.g. tiles_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tiles_usa_2014.geography IS 'Geography';

-- SQL statement 261: Comment tiles view column >>>
COMMENT /*
 * SQL statement name: 	comment_view_column.sql
 * Type:				Postgres/PostGIS psql
 * Parameters:
 *						1: view; e.g. tiles_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tiles_usa_2014.geolevel_id IS 'ID for ordering (1=lowest resolution). Up to 99 supported.';

-- SQL statement 262: Comment tiles view column >>>
COMMENT /*
 * SQL statement name: 	comment_view_column.sql
 * Type:				Postgres/PostGIS psql
 * Parameters:
 *						1: view; e.g. tiles_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tiles_usa_2014.zoomlevel IS 'Zoom level: 0 to 11. Number of tiles is 2**<zoom level> * 2**<zoom level>; i.e. 1, 2x2, 4x4 ... 2048x2048 at zoomlevel 11';

-- SQL statement 263: Comment tiles view column >>>
COMMENT /*
 * SQL statement name: 	comment_view_column.sql
 * Type:				Postgres/PostGIS psql
 * Parameters:
 *						1: view; e.g. tiles_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tiles_usa_2014.x IS 'X tile number. From 0 to (2**<zoomlevel>)-1';

-- SQL statement 264: Comment tiles view column >>>
COMMENT /*
 * SQL statement name: 	comment_view_column.sql
 * Type:				Postgres/PostGIS psql
 * Parameters:
 *						1: view; e.g. tiles_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tiles_usa_2014.y IS 'Y tile number. From 0 to (2**<zoomlevel>)-1';

-- SQL statement 265: Comment tiles view column >>>
COMMENT /*
 * SQL statement name: 	comment_view_column.sql
 * Type:				Postgres/PostGIS psql
 * Parameters:
 *						1: view; e.g. tiles_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tiles_usa_2014.optimised_geojson IS 'Tile multipolygon in GeoJSON format, optimised for zoomlevel N.';

-- SQL statement 266: Comment tiles view column >>>
COMMENT /*
 * SQL statement name: 	comment_view_column.sql
 * Type:				Postgres/PostGIS psql
 * Parameters:
 *						1: view; e.g. tiles_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tiles_usa_2014.optimised_topojson IS 'Tile multipolygon in TopoJSON format, optimised for zoomlevel N. The SRID is always 4326.';

-- SQL statement 267: Comment tiles view column >>>
COMMENT /*
 * SQL statement name: 	comment_view_column.sql
 * Type:				Postgres/PostGIS psql
 * Parameters:
 *						1: view; e.g. tiles_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tiles_usa_2014.tile_id IS 'Tile ID in the format <geolevel number>_<geolevel name>_<zoomlevel>_<X tile number>_<Y tile number>';

-- SQL statement 268: Comment tiles view column >>>
COMMENT /*
 * SQL statement name: 	comment_view_column.sql
 * Type:				Postgres/PostGIS psql
 * Parameters:
 *						1: view; e.g. tiles_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tiles_usa_2014.geolevel_name IS 'Name of geolevel. This will be a column name in the numerator/denominator tables';

-- SQL statement 269: Comment tiles view column >>>
COMMENT /*
 * SQL statement name: 	comment_view_column.sql
 * Type:				Postgres/PostGIS psql
 * Parameters:
 *						1: view; e.g. tiles_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tiles_usa_2014.no_area_ids IS 'Tile contains no area_ids flag: 0/1';

--
-- Create tile limits table
--

-- SQL statement 271: Drop table tile_limits_usa_2014 >>>
DROP TABLE IF EXISTS tile_limits_usa_2014;

-- SQL statement 272: Create table tile_limits_usa_2014 >>>
/*
 * SQL statement name: 	create_tile_limits_table.sql
 * Type:				Postgres/PostGIS psql
 * Parameters:
 *						1: Tile limits table; e.g. tile_limits_cb_2014_us_500k
 *						2: Geometry table; e.g. geometry_cb_2014_us_500k
 *						3: max_zoomlevel
 *
 * Description:			Comment table
 * Note:				% becomes % after substitution
 */
CREATE TABLE tile_limits_usa_2014
AS 
WITH a AS (
	SELECT generate_series(0, 9, 1) AS zoomlevel
 ), b AS ( /* Get bounds of geography */
        SELECT a.zoomlevel,
		       ST_XMax(b.geom) AS Xmax,
		       ST_XMin(b.geom) AS Xmin,
		       ST_YMax(b.geom) AS Ymax,
		       ST_YMin(b.geom) AS Ymin
      FROM a 
			LEFT OUTER JOIN geometry_usa_2014 b ON (b.geolevel_id = 1 AND a.zoomlevel = b.zoomlevel)
), c AS (
        SELECT b.zoomlevel,
		       ST_XMax(b.geom) AS Xmax,
		       ST_XMin(b.geom) AS Xmin,
		       ST_YMax(b.geom) AS Ymax,
		       ST_YMin(b.geom) AS Ymin
      FROM geometry_usa_2014 b
	 WHERE b.geolevel_id  = 1
	   AND b.zoomlevel = 6
), d AS ( /* Convert XY bounds to tile numbers */
        SELECT b.zoomlevel,
               COALESCE(b.Xmin, c.Xmin) AS x_min, 
			   COALESCE(b.Xmax, c.Xmax) AS x_max, 
			   COALESCE(b.Ymin, c.Ymin) AS y_min, 
			   COALESCE(b.Ymax, c.Ymax) AS y_max,
               tileMaker_latitude2tile(COALESCE(b.Ymax, c.Ymax), b.zoomlevel) AS Y_mintile,
               tileMaker_latitude2tile(COALESCE(b.Ymin, c.Ymin), b.zoomlevel) AS Y_maxtile,
               tileMaker_longitude2tile(COALESCE(b.Xmin, c.Xmin), b.zoomlevel) AS X_mintile,
               tileMaker_longitude2tile(COALESCE(b.Xmax, c.Xmax), b.zoomlevel) AS X_maxtile
      FROM b, c
)
SELECT d.*,
       ST_MakeEnvelope(d.x_min, d.y_min, d.x_max, d.y_max, 4326) AS bbox
  FROM d;

-- SQL statement 273: Comment tile limits table >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE tile_limits_usa_2014 IS 'Tile limits';

-- SQL statement 274: Comment tile limits table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_limits_usa_2014.zoomlevel IS 'Zoom level: 0 to 11. Number of tiles is 2**<zoom level> * 2**<zoom level>; i.e. 1, 2x2, 4x4 ... 2048x2048 at max zooomlevel (11)';

-- SQL statement 275: Comment tile limits table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_limits_usa_2014.x_min IS 'Min X (longitude)';

-- SQL statement 276: Comment tile limits table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_limits_usa_2014.x_max IS 'Max X (longitude)';

-- SQL statement 277: Comment tile limits table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_limits_usa_2014.y_min IS 'Min Y (latitude)';

-- SQL statement 278: Comment tile limits table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_limits_usa_2014.y_max IS 'Max Y (latitude)';

-- SQL statement 279: Comment tile limits table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_limits_usa_2014.y_mintile IS 'Min Y tile number (latitude)';

-- SQL statement 280: Comment tile limits table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_limits_usa_2014.y_maxtile IS 'Max Y tile number (latitude)';

-- SQL statement 281: Comment tile limits table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_limits_usa_2014.x_mintile IS 'Min X tile number (longitude)';

-- SQL statement 282: Comment tile limits table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_limits_usa_2014.x_maxtile IS 'Max X tile number (longitude)';

-- SQL statement 283: Comment tile limits table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_limits_usa_2014.bbox IS 'Bounding box polygon for geolevel_id 1 area';

-- SQL statement 284: Add primary key >>>
ALTER TABLE tile_limits_usa_2014 ADD PRIMARY KEY (zoomlevel);

-- SQL statement 285: Analyze table >>>
ANALYZE tile_limits_usa_2014;

-- SQL statement 286: Analyze table >>>
SELECT zoomlevel, x_min, x_max, y_min, y_max, y_mintile, y_maxtile, x_mintile, x_maxtile FROM tile_limits_usa_2014;

-- SQL statement 287: Drop table tile_intersects_usa_2014 >>>
DROP TABLE IF EXISTS tile_intersects_usa_2014 CASCADE;

-- SQL statement 288: Create tile intersects table >>>
/*
 * SQL statement name: 	create_tile_intersects_table.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. tile_intersects_cb_2014_us_500k
 *						2: JSON datatype (Postgres: JSON, MS SQL Server: Text)
 *						3: ST_Within()/STWithin() return datatype: bit (SQL Server: 0/1) or BOOLEAN (Postgres)
 *
 * Description:			Create tile intersects table
 * Note:				% becomes % after substitution
 */
CREATE TABLE tile_intersects_usa_2014 (
	geolevel_id				INTEGER			NOT NULL,
	zoomlevel				INTEGER			NOT NULL, 
	areaid					VARCHAR(200)	NOT NULL,
	x						INTEGER			NOT NULL, 
	y						INTEGER			NOT NULL, 
    optimised_geojson		JSON,
	within					BOOLEAN				NOT NULL,
	optimised_wkt			Text
);

-- SQL statement 289: Add geometry column: bbox >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('tile_intersects_usa_2014','bbox', 4326, 'POLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 290: Add geometry column: geom >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('tile_intersects_usa_2014','geom', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);

-- SQL statement 291: Comment tile intersects table >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE tile_intersects_usa_2014 IS 'Tile area id intersects';

-- SQL statement 292: Comment tile intersects table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_intersects_usa_2014.geolevel_id IS 'ID for ordering (1=lowest resolution). Up to 99 supported.';

-- SQL statement 293: Comment tile intersects table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_intersects_usa_2014.zoomlevel IS 'Zoom level: 0 to 11. Number of tiles is 2**<zoom level> * 2**<zoom level>; i.e. 1, 2x2, 4x4 ... 2048x2048 at zoomlevel 11';

-- SQL statement 294: Comment tile intersects table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_intersects_usa_2014.areaid IS 'Area ID';

-- SQL statement 295: Comment tile intersects table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_intersects_usa_2014.x IS 'X tile number. From 0 to (2**<zoomlevel>)-1';

-- SQL statement 296: Comment tile intersects table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_intersects_usa_2014.y IS 'Y tile number. From 0 to (2**<zoomlevel>)-1';

-- SQL statement 297: Comment tile intersects table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_intersects_usa_2014.optimised_geojson IS 'Tile areaid intersect multipolygon in GeoJSON format, optimised for zoomlevel N.';

-- SQL statement 298: Comment tile intersects table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_intersects_usa_2014.within IS 'Defined as: ST_Within(bbox, geom). Used to exclude any tile bounding completely within the area.';

-- SQL statement 299: Comment tile intersects table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_intersects_usa_2014.optimised_wkt IS 'Tile areaid intersect multipolygon in WKT format, optimised for zoomlevel N.';

-- SQL statement 300: Comment tile intersects table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_intersects_usa_2014.bbox IS 'Bounding box of tile as a polygon.';

-- SQL statement 301: Comment tile intersects table column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN tile_intersects_usa_2014.geom IS 'Geometry of area.';

-- SQL statement 302: Create partitioned tables and insert function for tile intersects table; comment partitioned tables and columns >>>
DO LANGUAGE plpgsql $$
DECLARE
/*
 * SQL statement name: 	partition_tile_intersects_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: tile intersects table; e.g. tile_intersects_cb_2014_us_500k
 *						2: Max zoomlevel; e.g. 11
 *						3: Geolevels table; e.g. geolevels_cb_2014_us_500k
 *
 * Description:			Create partitioned tables and insert function for tile intersects table; comment partitioned tables and columns
 * Note:				%% becomes % after substitution
 */
DECLARE
	c2_areaid_count 	CURSOR FOR	
		SELECT areaid_count
		  FROM geolevels_usa_2014	
		 WHERE geolevel_id = 1;
	l_areaid_count	INTEGER;
	end_zoomlevel	INTEGER;
--	
	l_table 	Text:='tile_intersects_usa_2014';
	sql_stmt	VARCHAR[];
	trigger_sql	VARCHAR;
BEGIN
	OPEN c2_areaid_count;
	FETCH c2_areaid_count INTO l_areaid_count;
	CLOSE c2_areaid_count;	
--
	FOR i IN 1 .. 3 LOOP
		IF i = 1 AND l_areaid_count = 1 THEN
			end_zoomlevel=0;	
		ELSE
			end_zoomlevel=9;
		END IF;
--	
		FOR j IN 0 .. end_zoomlevel LOOP
			sql_stmt[COALESCE(array_length(sql_stmt, 1), 0)]:='CREATE TABLE '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||' ('||E'\n'||
					  '    CHECK ( geolevel_id = '||i::Text||' AND zoomlevel = '||j::Text||' )'||E'\n'||
					  ') INHERITS ('||l_table||')';	
--
			sql_stmt[array_length(sql_stmt, 1)]:='COMMENT ON TABLE '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||' IS ''Tile area ID intersects''';
			sql_stmt[array_length(sql_stmt, 1)]:='COMMENT ON COLUMN '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||
							'.geolevel_id IS ''ID for ordering (1=lowest resolution). Up to 99 supported.''';
			sql_stmt[array_length(sql_stmt, 1)]:='COMMENT ON COLUMN '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||
							'.zoomlevel IS ''Zoom level: 0 to 9. Number of tiles is 2**<zoom level> * 2**<zoom level>; i.e. 1, 2x2, 4x4 ... 2048x2048 at zoomlevel 9.''';
			sql_stmt[array_length(sql_stmt, 1)]:='COMMENT ON COLUMN '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||
							'.areaid IS ''Area ID.''';
			sql_stmt[array_length(sql_stmt, 1)]:='COMMENT ON COLUMN '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||
							'.x IS ''X tile number. From 0 to (2**<zoomlevel>)-1.''';
			sql_stmt[array_length(sql_stmt, 1)]:='COMMENT ON COLUMN '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||
							'.y IS ''Y tile number. From 0 to (2**<zoomlevel>)-1.''';
			sql_stmt[array_length(sql_stmt, 1)]:='COMMENT ON COLUMN '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||
							'.optimised_geojson IS ''Tile multipolygon in GeoJSON format, optimised for zoomlevel N.''';
			sql_stmt[array_length(sql_stmt, 1)]:='COMMENT ON COLUMN '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||
							'.within IS ''Defined as: ST_Within(bbox, geom). Used to exclude any tile bounding completely within the area.''';
			sql_stmt[array_length(sql_stmt, 1)]:='COMMENT ON COLUMN '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||
							'.bbox IS ''Bounding box of tile as a polygon.''';
			sql_stmt[array_length(sql_stmt, 1)]:='COMMENT ON COLUMN '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||
							'.geom IS ''Geometry of area.''';
--
			sql_stmt[array_length(sql_stmt, 1)]:='ALTER TABLE '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||E'\n'||
					  ' ADD CONSTRAINT '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||'_pk PRIMARY KEY (areaid, x, y)';
			sql_stmt[array_length(sql_stmt, 1)]:='CREATE INDEX '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||'_geom_gix'||E'\n'||
					  ' ON '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||' USING GIST (geom);';
-- Analyze
			sql_stmt[array_length(sql_stmt, 1)]:='ANALYZE '||l_table||
							'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text;
							
			IF trigger_sql IS NULL THEN
				trigger_sql:='IF ( NEW.zoomlevel = '||j::Text||' AND NEW.geolevel_id = '||i::Text||' ) THEN'||E'\n'||
							' 	INSERT INTO '||l_table||'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||' VALUES (NEW.*);'||E'\n';
			ELSE
				trigger_sql:=trigger_sql||
							'ELSIF ( NEW.zoomlevel = '||j::Text||' AND NEW.geolevel_id = '||i::Text||' ) THEN'||E'\n'||
							' 	INSERT INTO '||l_table||'_geolevel_id_'||i::Text||'_zoomlevel_'||j::Text||' VALUES (NEW.*);'||E'\n';
			END IF;
		END LOOP;
	END LOOP;

	sql_stmt[array_length(sql_stmt, 1)]:='CREATE OR REPLACE FUNCTION '||l_table||'_insert_trigger()'||E'\n'||
		'RETURNS TRIGGER AS $trigger$'||E'\n'||
		'BEGIN'||E'\n'||
		trigger_sql||
		'    ELSE'||E'\n'||
		'        RAISE EXCEPTION ''Zoomlevel (%) or geolevel_id(%) out of range. '||
					'Fix the %_insert_trigger() function!'','||E'\n'||
		'			NEW.zoomlevel, NEW.geolevel_id, l_table;'||E'\n'||
		'    END IF;'||E'\n'||
		'    RETURN NULL;'||E'\n'||
		'END;'||E'\n'||
		'$trigger$'||E'\n'||
		'LANGUAGE plpgsql';
--
	FOR i IN 0 .. (array_length(sql_stmt, 1)-1) LOOP
		RAISE INFO 'SQL> %;', sql_stmt[i];
		EXECUTE sql_stmt[i];
	END LOOP;
END;
$$ ;

-- SQL statement 303: Partition tile intersects table: insert trigger >>>
/*
 * SQL statement name: 	partition_trigger.sql
 * Type:				Postgres/PostGIS psql
 * Parameters:
 *						1: geometry table; e.g. geometry_cb_2014_us_500k
 *
 * Description:			Create partitioned tables insert trigger
 * Note:				%% becomes % after substitution
 */
 CREATE TRIGGER insert_tile_intersects_usa_2014_trigger
    BEFORE INSERT ON tile_intersects_usa_2014
    FOR EACH ROW EXECUTE PROCEDURE tile_intersects_usa_2014_insert_trigger();

-- SQL statement 304: INSERT into tile intersects table >>>
/*
 * SQL statement name: 	tile_intersects_insert.sql
 * Type:				Postgres/PostGIS SQL
 * Parameters:
 *						1: Tile intersects table name; e.g. tile_intersects_cb_2014_us_500k
 *						2: Tile limits table name; e.g. tile_limits_cb_2014_us_500k
 *						3: Geometry table name; e.g. geometry_cb_2014_us_500k
 *
 * Description:			Insert into tile intersects table
 * Note:				% becomes % after substitution
 */
EXPLAIN ANALYZE INSERT INTO tile_intersects_usa_2014 (
	geolevel_id,
	zoomlevel, 
	areaid,
	x, 
	y, 
	bbox,
	geom,
    optimised_geojson,
	within
)
WITH a AS (
	SELECT zoomlevel, x_mintile, x_maxtile, y_mintile, y_maxtile	  
	  FROM tile_limits_usa_2014
	 WHERE zoomlevel = 0
), x AS (
	SELECT zoomlevel, generate_series(x_mintile, x_maxtile) AS x_series
	  FROM a
), y AS (	 
	SELECT zoomlevel, generate_series(y_mintile, y_maxtile) AS y_series	
	  FROM a       
), b AS (
	SELECT x.zoomlevel, 
	       x.x_series AS x, 
	       y.y_series AS y,      
	       tileMaker_tile2longitude(x.x_series, x.zoomlevel) AS xmin, 
		   tileMaker_tile2latitude(y.y_series, x.zoomlevel) AS ymin,
		   tileMaker_tile2longitude(x.x_series+1, x.zoomlevel) AS xmax, 
		   tileMaker_tile2latitude(y.y_series+1, x.zoomlevel) AS ymax
      FROM x, y
	 WHERE x.zoomlevel = y.zoomlevel
), c AS (
	SELECT b.zoomlevel, b.x, b.y, 
		   ST_MakeEnvelope(b.xmin, b.ymin, b.xmax, b.ymax, 4326) AS bbox,
		   c.geolevel_id,
		   c.areaid,
		   c.geom
	  FROM b, geometry_usa_2014 c
	 WHERE c.zoomlevel = 6
	   AND ST_Intersects(ST_MakeEnvelope(b.xmin, b.ymin, b.xmax, b.ymax, 4326), c.geom) /* intersects */
)
SELECT c.geolevel_id,
	   c.zoomlevel, 
	   c.areaid,
	   c.x, 
	   c.y, 
	   c.bbox,
	   c.geom,
       ST_AsGeoJson(c.geom)::JSON AS optimised_geojson,
	   ST_Within(c.bbox, c.geom) AS within /* Used to exclude any tile boundary completely within the area, i.e. there are no bounaries in the tile */
  FROM c
 ORDER BY c.geolevel_id, c.zoomlevel, c.x, c.y;

-- SQL statement 305: Add primary key >>>
ALTER TABLE tile_intersects_usa_2014 ADD PRIMARY KEY (geolevel_id, zoomlevel, areaid, x, y);

-- SQL statement 306: Analyze table >>>
ANALYZE tile_intersects_usa_2014;

-- SQL statement 307: SELECT from tile intersects table >>>
/*
 * SQL statement name: 	tile_intersects_select.sql
 * Type:				Postgres/PostGIS SQL
 * Parameters:
 *						1: Tile intersects table name; e.g. tile_intersects_cb_2014_us_500k
 *
 * Description:			Select from tile intersects table
 
 geolevel_id | zoomlevel | areaid | x | y | within |                                                                             bbox

-------------+-----------+--------+---+---+--------+--------------------------------------------------------------------------------------------------------------------------------------------------------------
           1 |         0 | US     | 0 | 0 | f      | {"type":"Polygon","coordinates":[[[-180,85.0511287794693],[-180,-85.0511287794693],[180,-85.0511287794693],[180,85.0511287794693],[-180,85.0511287794693]]]}
(1 row)

 * Note:				% becomes % after substitution
 */
SELECT geolevel_id,
	   zoomlevel, 
	   areaid,
	   x, 
	   y, 
	   within,
	   ST_AsGeoJson(bbox) AS bbox
  FROM tile_intersects_usa_2014
 WHERE zoomlevel = 0 AND geolevel_id = 1;

-- SQL statement 308: Create tile intersects table INSERT function >>>
CREATE OR REPLACE FUNCTION tileMaker_intersector_usa_2014(
	l_geolevel_id INTEGER, 
	l_zoomlevel INTEGER, 
	l_use_zoomlevel INTEGER, 
	l_debug BOOLEAN DEFAULT FALSE)
RETURNS INTEGER
AS
$BODY$
/*
 * SQL statement name: 	tileMaker_intersector_function.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: function name; e.g. tileMaker_intersector_cb_2014_us_500k
 *						2: tile intersects table; e.g. tile_intersects_cb_2014_us_500k
 *						3: tile limits table; e.g. tile_limits_cb_2014_us_500k
 *						4: geometry table; e.g. geometry_cb_2014_us_500k
 *
 * Description:			Create tile intersects table INSERT function
 * Note:				%% becomes % after substitution
 */
 
/*
Function: 		tileMaker_intersector_usa_2014()
Parameters:		geolevel_id, zoomlevel, use zoomlevel (source of data), debug (TRUE/FALSE)
Returns:		Nothing
Description:	tile intersects table INSERT function. Zoomlevels <6 use zoomlevel 6 data
				Insert tile area id intersections.  
 */
DECLARE
	c1_i1	CURSOR FOR
		SELECT COUNT(areaid) AS total
		  FROM tile_intersects_usa_2014
		 WHERE geolevel_id = l_geolevel_id
		   AND zoomlevel   = l_zoomlevel;
--
	num_rows INTEGER;
	explain_line	text;
	explain_text	text:='';
BEGIN
	FOR explain_line IN EXPLAIN ANALYZE 
	INSERT INTO tile_intersects_usa_2014(geolevel_id, zoomlevel, areaid, x, y, bbox, geom, optimised_geojson, within) 
	WITH a	AS (
		SELECT b.zoomlevel AS zoomlevel, b.x_mintile, b.x_maxtile, b.y_mintile, b.y_maxtile	  
		  FROM tile_limits_usa_2014 b
		 WHERE l_zoomlevel = b.zoomlevel
	), x AS (
		SELECT zoomlevel, generate_series(x_mintile, x_maxtile) AS x_series
		  FROM a
	), y AS (	 
		SELECT zoomlevel, generate_series(y_mintile, y_maxtile) AS y_series	
		  FROM a       
	), b AS (
		SELECT x.zoomlevel, 
			   x.x_series AS x, 
			   y.y_series AS y,      
			   tileMaker_tile2longitude(x.x_series, x.zoomlevel) AS xmin, 
			   tileMaker_tile2latitude(y.y_series, x.zoomlevel) AS ymin,
			   tileMaker_tile2longitude(x.x_series+1, x.zoomlevel) AS xmax, 
			   tileMaker_tile2latitude(y.y_series+1, x.zoomlevel) AS ymax
		  FROM x, y
		 WHERE x.zoomlevel = y.zoomlevel
	), c AS ( /* Calculate bounding box, parent X/Y min */
		SELECT b.zoomlevel, 
		       b.x,
			   b.y, 
			   ST_MakeEnvelope(b.xmin, b.ymin, b.xmax, b.ymax, 4326) AS bbox,
			   tileMaker_latitude2tile(b.ymin, b.zoomlevel-1) AS parent_ymin,
			   tileMaker_longitude2tile(b.xmin, b.zoomlevel-1) AS parent_xmin
		  FROM b
	), d AS (
		SELECT c.zoomlevel, c.x, c.y, c.bbox, p.areaid, p.within
		  FROM c, tile_intersects_usa_2014 p /* Parent */
		 WHERE p.geolevel_id = l_geolevel_id
		   AND p.zoomlevel 	 = l_zoomlevel -1/* Join to parent tile from previous geolevel_id; i.e. exclude if not present */
		   AND c.parent_xmin = p.x  
	       AND c.parent_ymin = p.y	
	), e AS (
		SELECT d.zoomlevel, d.x, d.y, d.bbox, d.areaid
		  FROM d
		 WHERE NOT EXISTS (SELECT c2.areaid
						     FROM tile_intersects_usa_2014 c2
						    WHERE c2.geolevel_id = l_geolevel_id
						      AND c2.zoomlevel   = l_zoomlevel
						 	  AND c2.x           = d.x
					 		  AND c2.y           = d.y
							  AND c2.areaid      = d.areaid)
	), f AS (
		SELECT e.zoomlevel, l_geolevel_id AS geolevel_id, e.x, e.y, e.bbox, e2.areaid, e2.geom
		  FROM e, geometry_usa_2014 e2
	     WHERE e2.zoomlevel    = l_use_zoomlevel
		   AND e2.geolevel_id  = l_geolevel_id
		   AND e2.areaid       = e.areaid
		   AND (e.bbox && e2.geom) 			  /* Intersect by bounding box */
		   AND ST_Intersects(e.bbox, e2.geom) /* intersects: (e.bbox && e.geom) is slower as it generates many more tiles */
	)
	SELECT f.geolevel_id, f.zoomlevel, f.areaid, f.x, f.y, f.bbox, f.geom, 
	       ST_AsGeoJson(f.geom)::JSON AS optimised_geojson,
	       true::BOOLEAN AS within
	  FROM f
	 WHERE NOT ST_Within(f.bbox, f.geom) /* Exclude any tile bounding completely within the area */
	 ORDER BY f.geolevel_id, f.zoomlevel, f.areaid, f.x, f.y 
	LOOP
		IF num_rows IS NULL THEN
		END IF;
		explain_text:=explain_text||E'\n'||explain_line;	
	END LOOP; 
	IF l_debug THEN
		RAISE INFO '%', explain_text;
	END IF;
--
	OPEN c1_i1;
	FETCH c1_i1 INTO num_rows;
	CLOSE c1_i1;
--	 
	RETURN num_rows;
END;
$BODY$
LANGUAGE plpgsql VOLATILE;

-- SQL statement 309: Create second tile intersects table INSERT function (simplification errors) >>>
CREATE OR REPLACE FUNCTION tileMaker_intersector2_usa_2014(
	l_geolevel_id INTEGER, 
	l_zoomlevel INTEGER, 
	l_use_zoomlevel INTEGER, 
	l_debug BOOLEAN DEFAULT FALSE)
RETURNS INTEGER
AS
$BODY$
/*
 * SQL statement name: 	tileMaker_intersector_function2.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: function name; e.g. tileMaker_intersector2_cb_2014_us_500k
 *						2: tile intersects table; e.g. tile_intersects_cb_2014_us_500k
 *						3: geometry table; e.g. geometry_cb_2014_us_500k
 *
 * Description:			Create tile intersects table INSERT function
 * Note:				%% becomes % after substitution
 */
 
/*
Function: 		tileMaker_intersector2_usa_2014()
Parameters:		geolevel_id, zoomlevel, use zoomlevel (source of data), debug (TRUE/FALSE)
Returns:		Nothing
Description:	tile intersects table INSERT function. Zoomlevels <6 use zoomlevel 6 data
				Insert tile area id intersections missing where not in the previous layer; 
				this is usually due to it being simplified out of existance.  
 */
DECLARE
	c1_i2	CURSOR FOR
		SELECT COUNT(areaid) AS total
		  FROM tile_intersects_usa_2014
		 WHERE geolevel_id = l_geolevel_id
		   AND zoomlevel   = l_zoomlevel
		   AND NOT within;
--			  
	num_rows 		INTEGER;
	explain_line	text;
	explain_text	text:='';
BEGIN
 	FOR explain_line IN EXPLAIN ANALYZE 
	INSERT INTO tile_intersects_usa_2014(geolevel_id, zoomlevel, areaid, x, y, bbox, geom, optimised_geojson, within) 
	WITH a AS (
		SELECT DISTINCT geolevel_id, areaid
		  FROM geometry_usa_2014
		 WHERE geolevel_id = l_geolevel_id
		   AND zoomlevel   = l_zoomlevel
		EXCEPT 
		SELECT DISTINCT geolevel_id, areaid
		  FROM tile_intersects_usa_2014 a
		 WHERE zoomlevel = l_zoomlevel
		   AND geolevel_id = l_geolevel_id
	), b AS (
		SELECT a.geolevel_id, a.areaid, ST_Envelope(b.geom) AS bbox, b.geom
		  FROM a, geometry_usa_2014 b
		 WHERE a.geolevel_id = l_geolevel_id
		   AND zoomlevel     = l_zoomlevel
		   AND a.areaid      = b.areaid
		   AND NOT ST_IsEmpty(b.geom)
	), c AS (
		SELECT l_zoomlevel AS zoomlevel, 
			   b.geolevel_id, b.areaid,
			   tileMaker_latitude2tile(ST_Ymin(bbox), l_zoomlevel) AS y_mintile,
			   tileMaker_longitude2tile(ST_Xmin(bbox), l_zoomlevel) AS x_mintile,
			   tileMaker_latitude2tile(ST_Ymax(bbox), l_zoomlevel) AS y_maxtile,
			   tileMaker_longitude2tile(ST_Xmax(bbox), l_zoomlevel) AS x_maxtile,
			   b.geom
		   FROM b
	), x AS (
		SELECT c.zoomlevel, 
			   c.geolevel_id, 
			   c.areaid,
			   generate_series(x_mintile, x_maxtile) AS x_series
		  FROM c
	), y AS (	 
		SELECT c.zoomlevel, 
			   c.geolevel_id, 
			   c.areaid,
			   generate_series(y_mintile, y_maxtile) AS y_series	
		  FROM c 
	), d AS (
		SELECT x.zoomlevel, 
			   x.geolevel_id, 
			   x.areaid,
			   x.x_series AS x, 
			   y.y_series AS y,      
			   tileMaker_tile2longitude(x.x_series, x.zoomlevel) AS xmin, 
			   tileMaker_tile2latitude(y.y_series, x.zoomlevel) AS ymin,
			   tileMaker_tile2longitude(x.x_series+1, x.zoomlevel) AS xmax, 
			   tileMaker_tile2latitude(y.y_series+1, x.zoomlevel) AS ymax
		  FROM x, y
		 WHERE x.zoomlevel   = y.zoomlevel	
		   AND x.geolevel_id = y.geolevel_id
		   AND x.areaid      = y.areaid
	), e AS (
		SELECT d.zoomlevel, 
			   d.geolevel_id, 
			   d.areaid,
			   d.x,
			   d.y, 
			   ST_MakeEnvelope(d.xmin, d.ymin, d.xmax, d.ymax, 4326) AS bbox
		  FROM d
	), f AS (
		SELECT DISTINCT e.zoomlevel, 
			   e.geolevel_id, 
			   e.areaid, 
			   e.x,
			   e.y,
			   e.bbox
		  FROM e
		 WHERE NOT EXISTS (SELECT c2.areaid
							 FROM tile_intersects_usa_2014 c2
							WHERE c2.geolevel_id = l_geolevel_id
							  AND c2.zoomlevel   = l_zoomlevel
							  AND c2.x           = e.x
							  AND c2.y           = e.y	
							  AND c2.areaid      = e.areaid)
	), g AS (
			SELECT f.zoomlevel, f.geolevel_id, f.x, f.y, f.bbox, e2.areaid, e2.geom
			  FROM f, geometry_usa_2014 e2
			 WHERE e2.zoomlevel    = l_use_zoomlevel
			   AND e2.geolevel_id  = l_geolevel_id
			   AND e2.areaid       = f.areaid
			   AND (f.bbox && e2.geom) 			  /* Intersect by bounding box */
			   AND ST_Intersects(f.bbox, e2.geom) /* intersects: (e.bbox && e.geom) is slower as it generates many more tiles */
	)
	SELECT geolevel_id, zoomlevel, areaid, x, y, bbox, geom,	
	       ST_AsGeoJson(g.geom)::JSON AS optimised_geojson,
	       ST_Within(g.bbox, g.geom) AS within
 	  FROM g 
	 ORDER BY geolevel_id, zoomlevel, areaid, x, y
	LOOP		
		explain_text:=explain_text||E'\n'||explain_line;
	END LOOP;
	IF l_debug THEN
		RAISE INFO '%', explain_text;
	END IF;
--
	OPEN c1_i2;
	FETCH c1_i2 INTO num_rows;
	CLOSE c1_i2;
--	 
	RETURN num_rows;
END;
$BODY$
LANGUAGE plpgsql VOLATILE;

-- SQL statement 310: Create tiles table INSERT function (tile aggregator) >>>
CREATE OR REPLACE FUNCTION tileMaker_aggregator_usa_2014(
	l_geolevel_id INTEGER, 
	l_zoomlevel INTEGER,  
	l_debug BOOLEAN DEFAULT FALSE)
RETURNS INTEGER
AS
$BODY$
/*
 * SQL statement name: 	tileMaker_aggregator_function.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: function name; e.g. tileMaker_aggregator_cb_2014_us_500k
 *						2: tile intersects table; e.g. tile_intersects_cb_2014_us_500k
 *						3: tiles table; e.g. t_tiles_cb_2014_us_500k
 *						4: geolevels table; e.g. geolevels_cb_2014_us_500k
 *
 * Description:			Create tiles table INSERT function (tile aggregator)
 * Note:				%% becomes % after substitution
 */
 
/*
Function: 		tileMaker_aggregator_usa_2014()
Parameters:		geolevel_id, zoomlevel, use zoomlevel (source of data), debug (TRUE/FALSE)
Returns:		Nothing
Description:	tiles table INSERT function. Aggregate area_id JSON into featureCollection
 */
DECLARE
	c1_i3	CURSOR FOR
		SELECT COUNT(tile_id) AS total
		  FROM t_tiles_usa_2014
		 WHERE geolevel_id = l_geolevel_id
		   AND zoomlevel   = l_zoomlevel;
--
	num_rows 		INTEGER;
	explain_line	text;
	explain_text	text:='';
--
	sql_stmt		text;
BEGIN
 	FOR explain_line IN EXPLAIN ANALYZE 
	INSERT INTO t_tiles_usa_2014(
		geolevel_id,
		zoomlevel,
		x, 
		y,
		optimised_geojson,
		optimised_topojson,
		tile_id)
	SELECT a.geolevel_id,
		   zoomlevel,
		   x, 
		   y,
		   json_agg(optimised_geojson) AS optimised_geojson,
		   NULL::JSON AS optimised_topojson,
		   a.geolevel_id::Text||'_'||b.geolevel_name||'_'||a.zoomlevel||'_'||a.x::Text||'_'||a.y::Text AS tile_id
	  FROM tile_intersects_usa_2014 a, geolevels_usa_2014 b
	 WHERE a.geolevel_id = b.geolevel_id 
	   AND a.zoomlevel   = l_zoomlevel
	   AND a.geolevel_id = l_geolevel_id
	 GROUP BY a.geolevel_id,
			  b.geolevel_name,
			  a.zoomlevel,
			  a.x, 
			  a.y
	 ORDER BY 1, 2, 3, 4
	LOOP		
		explain_text:=explain_text||E'\n'||explain_line;
	END LOOP;
	IF l_debug THEN
		RAISE INFO '%', explain_text;
	END IF;
--
	sql_stmt:='REINDEX TABLE tile_intersects_usa_2014'||'_geolevel_id_'||l_geolevel_id::Text||'_zoomlevel_'||l_zoomlevel::Text;
	EXECUTE sql_stmt;
	sql_stmt:='ANALYZE tile_intersects_usa_2014'||'_geolevel_id_'||l_geolevel_id::Text||'_zoomlevel_'||l_zoomlevel::Text;
	EXECUTE sql_stmt;
--
	OPEN c1_i3;
	FETCH c1_i3 INTO num_rows;
	CLOSE c1_i3;
--	 
	RETURN num_rows;
END;
$BODY$
LANGUAGE plpgsql VOLATILE;

-- SQL statement 311: Create tiles table INSERT function (tile aggregator) >>>
/*
 * SQL statement name: 	tileMaker_main_function.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: geography; e.g. cb_2014_us_500k
 *						2: geometry table; e.g. geometry_cb_2014_us_500k
 *						3: geolevels table; e.g. geolevels_cb_2014_us_500k
 *
 * Description:			Main tileMaker function. Create geoJSON tiles
 * Note:				%% becomes % after substitution
 */
DO LANGUAGE plpgsql $$
DECLARE
	max_geolevel_id		INTEGER;
	max_zoomlevel 		INTEGER;
	l_areaid_count		INTEGER;
	start_geolevel_id	INTEGER;
--
	c1_maxgeolevel_id 	CURSOR FOR
		SELECT MAX(geolevel_id) AS max_geolevel_id,
	           MAX(zoomlevel) AS max_zoomlevel
	      FROM geometry_usa_2014;
	c2_areaid_count 	CURSOR FOR	
		SELECT areaid_count
		  FROM geolevels_usa_2014	
		 WHERE geolevel_id = 1;
--
	num_rows 		INTEGER:=0;
	num_rows2 		INTEGER:=0;
	num_rows3 		INTEGER:=0;
	etp 			TIMESTAMP WITH TIME ZONE;
	stp2 			TIMESTAMP WITH TIME ZONE;
	stp 			TIMESTAMP WITH TIME ZONE:=clock_timestamp();
	took 			INTERVAL;
	took2 			INTERVAL;
	took3 			INTERVAL;
	took4 			INTERVAL;
--
	tiles_per_s		NUMERIC;
--
	l_use_zoomlevel INTEGER;
	l_debug 		BOOLEAN;
BEGIN
	OPEN c1_maxgeolevel_id;
	FETCH c1_maxgeolevel_id INTO max_geolevel_id, max_zoomlevel;
	CLOSE c1_maxgeolevel_id;
	OPEN c2_areaid_count;
	FETCH c2_areaid_count INTO l_areaid_count;
	CLOSE c2_areaid_count;	
--	 
--	max_zoomlevel 	:=10;		/* Override for test purposes */
	IF l_areaid_count = 1 THEN	/* 0/0/0 tile only;  */			
		start_geolevel_id=2;	
	ELSE
		start_geolevel_id=1;
	END IF;
--
-- Create zoomleve l0 tiles. Intersect already created
--	
	FOR i IN 1 .. max_geolevel_id LOOP
--			
		stp2:=clock_timestamp();
		num_rows3:=tileMaker_aggregator_usa_2014(i, 0, l_debug);	
		etp:=clock_timestamp();
		took4:=age(etp, stp2);
--			
		took:=age(etp, stp);
		tiles_per_s:=ROUND(num_rows3::NUMERIC/EXTRACT(EPOCH FROM took4)::NUMERIC, 1);
		RAISE INFO 'Processed % tile for geolevel id %/% zoomlevel: %/% in %s, %s total;% tiles/s', 
			num_rows3, 
			i, max_geolevel_id, 0, max_zoomlevel,  
			ROUND(EXTRACT(EPOCH FROM took4)::NUMERIC, 1), 
			ROUND(EXTRACT(EPOCH FROM took)::NUMERIC, 1),
			tiles_per_s;	
	END LOOP;
		
--
-- Timing; 3 zoomlevels to:
--
-- Zoomlevel 7: 1 minute (75)
-- Zoomlevel 8: 3 minutes (321..260..154..218..230..217..166 seconds with tile aggregation)
-- Zoomlevel 9: 8 minutes (673..627..460)
-- Zoomlevel 10: 24 minutes (1473)
-- Zoomlevel 11: 80 minutes (4810)
--
	FOR i IN start_geolevel_id .. max_geolevel_id LOOP
		FOR j IN 1 .. max_zoomlevel LOOP
			l_debug:=FALSE;
			IF j = max_zoomlevel AND i = max_geolevel_id THEN
				l_debug:=TRUE;
			END IF;
			l_use_zoomlevel=j;
			IF j<6 THEN 
				l_use_zoomlevel=6;
			END IF;
			stp2:=clock_timestamp();
			num_rows:=tileMaker_intersector_usa_2014(i, j, l_use_zoomlevel, l_debug);
			etp:=clock_timestamp();
			took2:=age(etp, stp2);
--			
			stp2:=clock_timestamp();
			num_rows2:=tileMaker_intersector2_usa_2014(i, j, l_use_zoomlevel, l_debug);	
			etp:=clock_timestamp();
			took3:=age(etp, stp2);
--			
			stp2:=clock_timestamp();
--			num_rows3:=tileMaker_aggregator_cb_2014_us_500k(i, j, l_debug);	/* Replaced by pgTileMaker.js */
			etp:=clock_timestamp();
			took4:=age(etp, stp2);
--			
			took:=age(etp, stp);
			tiles_per_s:=ROUND((num_rows+num_rows2+num_rows3)::NUMERIC/EXTRACT(EPOCH FROM took2)::NUMERIC, 1);
			RAISE INFO 'Processed %+% total areaid intersects, % tiles for geolevel id %/% zoomlevel: %/% in %+%s+%s, %s total; % intesects/s', 
				num_rows, num_rows2, num_rows3, 
				i, max_geolevel_id, j, max_zoomlevel, 
				ROUND(EXTRACT(EPOCH FROM took2)::NUMERIC, 1), 
				ROUND(EXTRACT(EPOCH FROM took3)::NUMERIC, 1), 
				ROUND(EXTRACT(EPOCH FROM took4)::NUMERIC, 1), 
				ROUND(EXTRACT(EPOCH FROM took)::NUMERIC, 1),
				tiles_per_s;			
		END LOOP;	
	END LOOP;
END;
$$;

-- SQL statement 312: Tile intersects table % savings >>>
/*
 * SQL statement name: 	tile_intersects_select2.sql
 * Type:				Postgres/PostGIS SQL
 * Parameters:
 *						1: Tile intersects table name; e.g. tile_intersects_cb_2014_us_500k
 *
 * Description:			Select from tile intersects table
 
 geolevel_id | zoomlevel | areas | xmin | ymin | xmax | ymax | possible_tiles | tiles | pct_saving
-------------+-----------+-------+------+------+------+------+----------------+-------+------------
           1 |         0 |     1 |    0 |    0 |    0 |    0 |              1 |     1 |       0.00
           2 |         0 |    56 |    0 |    0 |    0 |    0 |              1 |     1 |       0.00
           2 |         1 |    56 |    0 |    0 |    1 |    1 |              4 |     3 |      25.00
           2 |         2 |    56 |    0 |    0 |    3 |    2 |             12 |     5 |      58.33
           2 |         3 |    56 |    0 |    1 |    7 |    4 |             32 |    10 |      68.75
           2 |         4 |    56 |    0 |    3 |   15 |    8 |             96 |    22 |      77.08
           2 |         5 |    56 |    0 |    6 |   31 |   17 |            384 |    48 |      87.50
           2 |         6 |    56 |    0 |   13 |   63 |   34 |           1408 |   111 |      92.12
           2 |         7 |    56 |    0 |   27 |  127 |   69 |           5504 |   281 |      94.89
           2 |         8 |    56 |    0 |   54 |  255 |  135 |          20992 |   665 |      96.83
           3 |         0 |  3233 |    0 |    0 |    0 |    0 |              1 |     1 |       0.00
           3 |         1 |  3233 |    0 |    0 |    1 |    1 |              4 |     3 |      25.00
           3 |         2 |  3233 |    0 |    0 |    3 |    2 |             12 |     5 |      58.33
           3 |         3 |  3233 |    0 |    1 |    7 |    4 |             32 |    10 |      68.75
           3 |         4 |  3233 |    0 |    3 |   15 |    8 |             96 |    22 |      77.08
           3 |         5 |  3233 |    0 |    6 |   31 |   17 |            384 |    49 |      87.24
           3 |         6 |  3233 |    0 |   13 |   63 |   34 |           1408 |   119 |      91.55
           3 |         7 |  3233 |    0 |   27 |  127 |   69 |           5504 |   333 |      93.95
           3 |         8 |  3233 |    0 |   54 |  255 |  138 |          21760 |   992 |      95.44
(19 rows)

 * Note:				% becomes % after substitution
 */
SELECT geolevel_id, zoomlevel, 
       COUNT(DISTINCT(areaid)) AS areas,
       MIN(x) AS xmin, MIN(y) AS ymin, 
       MAX(x) AS xmax, MAX(y) AS ymax, 
	   (MAX(x)-MIN(x)+1)*(MAX(y)-MIN(y)+1) AS possible_tiles,
       COUNT(DISTINCT(x::Text||y::Text)) AS tiles,
	   ROUND((((MAX(x)-MIN(x)+1)*(MAX(y)-MIN(y)+1)-COUNT(DISTINCT(x::Text||y::Text)))::numeric/
			((MAX(x)-MIN(x)+1)*(MAX(y)-MIN(y)+1))::numeric)*100, 2) AS pct_saving
  FROM tile_intersects_usa_2014
 GROUP BY geolevel_id, zoomlevel
 ORDER BY 1, 2;

-- SQL statement 313: Tile intersects table % WKT update >>>
/*
 * SQL statement name: 	tile_intersects_wkt_update.sql
 * Type:				Postgres/PostGIS SQL
 * Parameters:
 *						1: table; e.g. tile_intersects_cb_2014_us_500k
 *
 * Description:			Update wellknown text column in tile intersects table from geometry
 * Note:				% becomes % after substitution
 */
 UPDATE tile_intersects_usa_2014
    SET optimised_wkt = ST_AsText(geom)
  WHERE optimised_wkt IS NULL;

-- SQL statement 314: Commit transaction >>>
END;

--
-- Analyze tables
--

-- SQL statement 316: Describe table cb_2014_us_county_500k >>>
\dS+ cb_2014_us_county_500k;

-- SQL statement 317: Analyze table cb_2014_us_county_500k >>>
VACUUM ANALYZE cb_2014_us_county_500k;

-- SQL statement 318: Describe table LOOKUP_CB_2014_US_NATION_5M >>>
\dS+ LOOKUP_CB_2014_US_NATION_5M;

-- SQL statement 319: Analyze table LOOKUP_CB_2014_US_NATION_5M >>>
VACUUM ANALYZE LOOKUP_CB_2014_US_NATION_5M;

-- SQL statement 320: Describe table cb_2014_us_nation_5m >>>
\dS+ cb_2014_us_nation_5m;

-- SQL statement 321: Analyze table cb_2014_us_nation_5m >>>
VACUUM ANALYZE cb_2014_us_nation_5m;

-- SQL statement 322: Describe table LOOKUP_CB_2014_US_STATE_500K >>>
\dS+ LOOKUP_CB_2014_US_STATE_500K;

-- SQL statement 323: Analyze table LOOKUP_CB_2014_US_STATE_500K >>>
VACUUM ANALYZE LOOKUP_CB_2014_US_STATE_500K;

-- SQL statement 324: Describe table cb_2014_us_state_500k >>>
\dS+ cb_2014_us_state_500k;

-- SQL statement 325: Analyze table cb_2014_us_state_500k >>>
VACUUM ANALYZE cb_2014_us_state_500k;

-- SQL statement 326: Describe table LOOKUP_CB_2014_US_COUNTY_500K >>>
\dS+ LOOKUP_CB_2014_US_COUNTY_500K;

-- SQL statement 327: Analyze table LOOKUP_CB_2014_US_COUNTY_500K >>>
VACUUM ANALYZE LOOKUP_CB_2014_US_COUNTY_500K;

-- SQL statement 328: Describe table geolevels_usa_2014 >>>
\dS+ geolevels_usa_2014;

-- SQL statement 329: Analyze table geolevels_usa_2014 >>>
VACUUM ANALYZE geolevels_usa_2014;

-- SQL statement 330: Describe table geography_usa_2014 >>>
\dS+ geography_usa_2014;

-- SQL statement 331: Analyze table geography_usa_2014 >>>
VACUUM ANALYZE geography_usa_2014;

-- SQL statement 332: Describe table hierarchy_usa_2014 >>>
\dS+ hierarchy_usa_2014;

-- SQL statement 333: Analyze table hierarchy_usa_2014 >>>
VACUUM ANALYZE hierarchy_usa_2014;

-- SQL statement 334: Describe table geometry_usa_2014 >>>
\dS+ geometry_usa_2014;

-- SQL statement 335: Analyze table geometry_usa_2014 >>>
VACUUM ANALYZE geometry_usa_2014;

-- SQL statement 336: Describe table tile_intersects_usa_2014 >>>
\dS+ tile_intersects_usa_2014;

-- SQL statement 337: Analyze table tile_intersects_usa_2014 >>>
VACUUM ANALYZE tile_intersects_usa_2014;

-- SQL statement 338: Describe table tile_limits_usa_2014 >>>
\dS+ tile_limits_usa_2014;

-- SQL statement 339: Analyze table tile_limits_usa_2014 >>>
VACUUM ANALYZE tile_limits_usa_2014;

-- SQL statement 340: Describe table t_tiles_usa_2014 >>>
\dS+ t_tiles_usa_2014;

-- SQL statement 341: Analyze table t_tiles_usa_2014 >>>
VACUUM ANALYZE t_tiles_usa_2014;


--
-- EOF
