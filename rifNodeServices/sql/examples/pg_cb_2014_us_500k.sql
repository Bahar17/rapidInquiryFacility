-- ************************************************************************
--
-- Description:
--
-- Rapid Enquiry Facility (RIF) - Tile maker - Create processed CSV tables created 
-- from shapefiles simplification
--
-- Copyright:
--
-- The Rapid Inquiry Facility (RIF) is an automated tool devised by SAHSU 
-- that rapidly addresses epidemiological and public health questions using 
-- routinely collected health and population data and generates standardised 
-- rates and relative risks for any given health outcome, for specified age 
-- and year ranges, for any given geographical area.
--
-- Copyright 2014 Imperial College London, developed by the Small Area
-- Health Statistics Unit. The work of the Small Area Health Statistics Unit 
-- is funded by the Public Health England as part of the MRC-PHE Centre for 
-- Environment and Health. Funding for this project has also been received 
-- from the Centers for Disease Control and Prevention.  
--
-- This file is part of the Rapid Inquiry Facility (RIF) project.
-- RIF is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Lesser General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- RIF is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU Lesser General Public License for more details.
--
-- You should have received a copy of the GNU Lesser General Public License
-- along with RIF. If not, see <http://www.gnu.org/licenses/>; or write 
-- to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
-- Boston, MA 02110-1301 USA
--
-- Author:
--
-- Peter Hambly, SAHSU
--
-- This script is autogenerated.
--
--
-- Postgres specific parameters
--
-- Usage: psql -w -e -f pg_cb_2014_us_500k.sql
-- Connect flags if required: -U <username> -d <Postgres database name> -h <host> -p <port>
--
\pset pager off
\set ECHO all
\set ON_ERROR_STOP ON
\timing

-- SQL statement 0: Start transaction >>>
BEGIN TRANSACTION;

-- SQL statement 1: Drop table cb_2014_us_county_500k >>>
DROP TABLE IF EXISTS cb_2014_us_county_500k;

-- SQL statement 2: Create tablecb_2014_us_county_500k >>>
CREATE TABLE cb_2014_us_county_500k (
	statefp                        	text,
	countyfp                       	text,
	countyns                       	text,
	affgeoid                       	text,
	geoid                          	text,
	name                           	text,
	lsad                           	text,
	aland                          	text,
	awater                         	text,
	gid                            	integer	NOT NULL,
	areaid                         	text	NOT NULL,
	areaname                       	text	NOT NULL,
	area_km2                       	numeric,
	geographic_centroid_wkt        	text,
	wkt_11                         	text,
	wkt_10                         	text,
	wkt_9                          	text,
	wkt_8                          	text,
	wkt_7                          	text,
	wkt_6                          	text);

-- SQL statement 3: Comment geospatial data table >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE cb_2014_us_county_500k IS 'The State-County at a scale of 1:500,000';

-- SQL statement 4: Load table from CSV file >>>
\copy cb_2014_us_county_500k FROM 'cb_2014_us_county_500k.csv' DELIMITER ',' CSV HEADER;

-- SQL statement 5: Row check: 3233 >>>
DO LANGUAGE plpgsql $$
DECLARE
/*
 * SQL statement name: 	csvfile_rowcheck.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: Expected number of rows; e.g. 3233
 *						3: Column to count; e.g. gid
 *
 * Description:			Check number of rows in loaded CSV file is as expected
 * Note:				%% becomes % after substitution
 */
	c1 CURSOR FOR
		SELECT COUNT(gid) AS total
		  FROM cb_2014_us_county_500k;
	c1_rec RECORD;
BEGIN
	OPEN c1;
	FETCH c1 INTO c1_rec;
	CLOSE c1;
	IF c1_rec.total = 3233 THEN
		RAISE INFO 'Table: cb_2014_us_county_500k row check OK: %', c1_rec.total;
	ELSE
		RAISE EXCEPTION 'Table: cb_2014_us_county_500k row check FAILED: expected: 3233 got: %', c1_rec.total;
	END IF;
END;
$$;

-- SQL statement 6: Add primary key cb_2014_us_county_500k >>>
ALTER TABLE cb_2014_us_county_500k ADD PRIMARY KEY (gid);

-- SQL statement 7: Add unique key cb_2014_us_county_500k >>>
/*
 * SQL statement name: 	add_unique_key.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. cb_2014_us_nation_5m
 *						2: constraint name; e.g. cb_2014_us_nation_5m_uk
 *						3: fields; e.g. areaid
 *
 * Description:			Add unique key constraint
 * Note:				%% becomes % after substitution
 */
ALTER TABLE cb_2014_us_county_500k ADD CONSTRAINT cb_2014_us_county_500k_uk UNIQUE(areaid);

--
-- Add geometric  data
--

-- SQL statement 9: Add geometry column: geographic centroid >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_county_500k','geographic_centroid', 4326, 'POINT', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 10: Add geometry column for original SRID geometry >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_county_500k','geom_orig', 4269, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 11: Add geometry column for zoomlevel: 6 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_county_500k','geom_6', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 12: Add geometry column for zoomlevel: 7 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_county_500k','geom_7', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 13: Add geometry column for zoomlevel: 8 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_county_500k','geom_8', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 14: Add geometry column for zoomlevel: 9 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_county_500k','geom_9', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 15: Add geometry column for zoomlevel: 10 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_county_500k','geom_10', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 16: Add geometry column for zoomlevel: 11 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_county_500k','geom_11', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 17: Update geographic centroid, geometry columns, handle polygons and mutlipolygons, convert highest zoomlevel to original SRID >>>
UPDATE cb_2014_us_county_500k
   SET geographic_centroid = ST_GeomFromText(geographic_centroid_wkt, 4326),
       geom_6 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_6, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_6, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_6, 4326))
       		END,
       geom_7 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_7, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_7, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_7, 4326))
       		END,
       geom_8 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_8, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_8, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_8, 4326))
       		END,
       geom_9 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_9, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_9, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_9, 4326))
       		END,
       geom_10 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_10, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_10, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_10, 4326))
       		END,
       geom_11 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_11, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_11, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_11, 4326))
       		END,
       geom_orig = ST_Transform(
       		CASE ST_IsCollection(ST_GeomFromText(wkt_11, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_11, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_11, 4326))
       		END, 4269);

-- SQL statement 18: Make geometry columns valid >>>
UPDATE cb_2014_us_county_500k
   SET
       geom_6 = CASE ST_IsValid(geom_6)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_6), 3 /* Remove non polygons */)
				ELSE geom_6
			END,
       geom_7 = CASE ST_IsValid(geom_7)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_7), 3 /* Remove non polygons */)
				ELSE geom_7
			END,
       geom_8 = CASE ST_IsValid(geom_8)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_8), 3 /* Remove non polygons */)
				ELSE geom_8
			END,
       geom_9 = CASE ST_IsValid(geom_9)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_9), 3 /* Remove non polygons */)
				ELSE geom_9
			END,
       geom_10 = CASE ST_IsValid(geom_10)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_10), 3 /* Remove non polygons */)
				ELSE geom_10
			END,
       geom_11 = CASE ST_IsValid(geom_11)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_11), 3 /* Remove non polygons */)
				ELSE geom_11
			END,
       geom_orig = CASE ST_IsValid(geom_orig)
			WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_orig), 3 /* Remove non polygons */)
			ELSE geom_orig
		END;

--
-- Test geometry and make valid if required
--

-- SQL statement 20: Check validity of geometry columns >>>
DO LANGUAGE plpgsql $$
DECLARE
	c1 CURSOR FOR
SELECT areaname,
       6::Text AS geolevel,
       ST_IsValidReason(geom_6) AS reason
  FROM cb_2014_us_county_500k
 WHERE NOT ST_IsValid(geom_6)
UNION
SELECT areaname,
       7::Text AS geolevel,
       ST_IsValidReason(geom_7) AS reason
  FROM cb_2014_us_county_500k
 WHERE NOT ST_IsValid(geom_7)
UNION
SELECT areaname,
       8::Text AS geolevel,
       ST_IsValidReason(geom_8) AS reason
  FROM cb_2014_us_county_500k
 WHERE NOT ST_IsValid(geom_8)
UNION
SELECT areaname,
       9::Text AS geolevel,
       ST_IsValidReason(geom_9) AS reason
  FROM cb_2014_us_county_500k
 WHERE NOT ST_IsValid(geom_9)
UNION
SELECT areaname,
       10::Text AS geolevel,
       ST_IsValidReason(geom_10) AS reason
  FROM cb_2014_us_county_500k
 WHERE NOT ST_IsValid(geom_10)
UNION
SELECT areaname,
       11::Text AS geolevel,
       ST_IsValidReason(geom_11) AS reason
  FROM cb_2014_us_county_500k
 WHERE NOT ST_IsValid(geom_11)
UNION
SELECT areaname,
       'geom_orig'::Text AS geolevel,
       ST_IsValidReason(geom_orig) AS reason
  FROM cb_2014_us_county_500k
 WHERE NOT ST_IsValid(geom_orig)
 ORDER BY 1, 2;
	c1_rec RECORD;
	total INTEGER:=0;
BEGIN
	FOR c1_rec IN c1 LOOP
		total:=total+1;
		RAISE INFO 'Area: %, geolevel: %: %', c1_rec.areaname, c1_rec.geolevel, c1_rec.reason;
	END LOOP;
	IF total = 0 THEN
		RAISE INFO 'Table: cb_2014_us_county_500k no invalid geometry check OK';
	ELSE
		RAISE EXCEPTION 'Table: cb_2014_us_county_500k no invalid geometry check FAILED: % invalid', total;
	END IF;
END;
$$;

--
-- Make all polygons right handed
--

-- SQL statement 22: Make all polygons right handed for original geometry >>>
UPDATE cb_2014_us_county_500k
   SET       geom_6 = ST_ForceRHR(geom_6),
       geom_7 = ST_ForceRHR(geom_7),
       geom_8 = ST_ForceRHR(geom_8),
       geom_9 = ST_ForceRHR(geom_9),
       geom_10 = ST_ForceRHR(geom_10),
       geom_11 = ST_ForceRHR(geom_11),
       geom_orig = ST_ForceRHR(geom_orig);

--
-- Test Turf and DB areas agree to within 1%
--

-- SQL statement 24: Test Turf and DB areas agree to within 1% (Postgres)/5% (SQL server) >>>
DO LANGUAGE plpgsql $$
DECLARE 
/*
 * SQL statement name: 	area_check.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Check Turf araa (area_km2) compared to SQL Server calculated area (area_km2_calc)
 *						Allow for 1% error
 *						Ignore small areas <= 10 km2
 * Note:				%% becomes % after substitution
 */
	c1 CURSOR FOR
		WITH a AS (
			SELECT areaname,
				   area_km2 AS area_km2,
				   ST_Area(geography(geom_11))/(1000*1000) AS area_km2_calc
			  FROM cb_2014_us_county_500k
		), b AS (
		SELECT SUBSTRING(a.areaname, 1, 30) AS areaname,
			   a.area_km2,
			   a.area_km2_calc,
			   CASE WHEN a.area_km2 > 0 THEN 100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2)
					WHEN a.area_km2 = a.area_km2_calc THEN 0
					ELSE NULL
			   END AS pct_km2_diff 
		  FROM a
		)
		SELECT b.areaname, b.area_km2, b.area_km2_calc, b.pct_km2_diff
		  FROM b
		 WHERE b.pct_km2_diff > 1 /* Allow for 1% error */
		   AND b.area_km2_calc > 10 /* Ignore small areas <= 10 km2 */;

	c1_rec RECORD;
	total INTEGER:=0;
BEGIN
	FOR c1_rec IN c1 LOOP
		total:=total+1;
		RAISE INFO 'Area: %, area km2: %:, calc: %, diff %',
			c1_rec.areaname, c1_rec.area_km2, c1_rec.area_km2_calc, c1_rec.pct_km2_diff;
	END LOOP;
	IF total = 0 THEN
		RAISE INFO 'Table: cb_2014_us_county_500k no invalid areas check OK';
	ELSE
		RAISE EXCEPTION 'Table: cb_2014_us_county_500k no invalid areas check FAILED: % invalid', total;
	END IF;
END;
$$;

--
-- Create spatial indexes
--

-- SQL statement 26: Index geometry column for zoomlevel: 6 >>>
CREATE INDEX cb_2014_us_county_500k_geom_6_gix ON cb_2014_us_county_500k USING GIST (geom_6);

-- SQL statement 27: Index geometry column for zoomlevel: 7 >>>
CREATE INDEX cb_2014_us_county_500k_geom_7_gix ON cb_2014_us_county_500k USING GIST (geom_7);

-- SQL statement 28: Index geometry column for zoomlevel: 8 >>>
CREATE INDEX cb_2014_us_county_500k_geom_8_gix ON cb_2014_us_county_500k USING GIST (geom_8);

-- SQL statement 29: Index geometry column for zoomlevel: 9 >>>
CREATE INDEX cb_2014_us_county_500k_geom_9_gix ON cb_2014_us_county_500k USING GIST (geom_9);

-- SQL statement 30: Index geometry column for zoomlevel: 10 >>>
CREATE INDEX cb_2014_us_county_500k_geom_10_gix ON cb_2014_us_county_500k USING GIST (geom_10);

-- SQL statement 31: Index geometry column for zoomlevel: 11 >>>
CREATE INDEX cb_2014_us_county_500k_geom_11_gix ON cb_2014_us_county_500k USING GIST (geom_11);

-- SQL statement 32: Index geometry column for original SRID geometry >>>
CREATE INDEX cb_2014_us_county_500k_geom_orig_gix ON cb_2014_us_county_500k USING GIST (geom_orig);

--
-- Reports
--

-- SQL statement 34: Areas and centroids report >>>
/*
 * SQL statement name: 	area_centroid_report.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Area and centroids report
 * Note:				% becomes % after substitution
 */
WITH a AS (
	SELECT areaname,
		   ROUND(area_km2::numeric, 2) AS area_km2,
		   ROUND(
				(ST_Area(geography(geom_11))/(1000*1000))::numeric, 2) AS area_km2_calc,
		   ROUND(ST_X(geographic_centroid)::numeric, 4)||','||ROUND(ST_Y(geographic_centroid)::numeric, 4) AS geographic_centroid,
		   ROUND(ST_X(ST_Centroid(geom_11))::numeric, 4)||','||ROUND(ST_Y(ST_Centroid(geom_11))::numeric, 4) AS geographic_centroid_calc,
		   ROUND(ST_Distance_Sphere(ST_Centroid(geom_11), geographic_centroid)::numeric/1000, 2) AS centroid_diff_km
	  FROM cb_2014_us_county_500k
	 GROUP BY areaname, area_km2, geom_11, geographic_centroid
)
SELECT a.areaname,
       a.area_km2,
	   a.area_km2_calc,
	   ROUND(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2_calc), 2) AS pct_km2_diff,
	   a.geographic_centroid,
      a.geographic_centroid_calc,
	   a.centroid_diff_km
  FROM a
 ORDER BY 1
 LIMIT 100;;

-- SQL statement 35: Drop table cb_2014_us_nation_5m >>>
DROP TABLE IF EXISTS cb_2014_us_nation_5m;

-- SQL statement 36: Create tablecb_2014_us_nation_5m >>>
CREATE TABLE cb_2014_us_nation_5m (
	affgeoid                       	text,
	geoid                          	text,
	name                           	text,
	gid                            	integer	NOT NULL,
	areaid                         	text	NOT NULL,
	areaname                       	text	NOT NULL,
	area_km2                       	numeric,
	geographic_centroid_wkt        	text,
	wkt_11                         	text,
	wkt_10                         	text,
	wkt_9                          	text,
	wkt_8                          	text,
	wkt_7                          	text,
	wkt_6                          	text);

-- SQL statement 37: Comment geospatial data table >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE cb_2014_us_nation_5m IS 'Theat a scale of 1:5,000,000';

-- SQL statement 38: Load table from CSV file >>>
\copy cb_2014_us_nation_5m FROM 'cb_2014_us_nation_5m.csv' DELIMITER ',' CSV HEADER;

-- SQL statement 39: Row check: 1 >>>
DO LANGUAGE plpgsql $$
DECLARE
/*
 * SQL statement name: 	csvfile_rowcheck.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: Expected number of rows; e.g. 3233
 *						3: Column to count; e.g. gid
 *
 * Description:			Check number of rows in loaded CSV file is as expected
 * Note:				%% becomes % after substitution
 */
	c1 CURSOR FOR
		SELECT COUNT(gid) AS total
		  FROM cb_2014_us_nation_5m;
	c1_rec RECORD;
BEGIN
	OPEN c1;
	FETCH c1 INTO c1_rec;
	CLOSE c1;
	IF c1_rec.total = 1 THEN
		RAISE INFO 'Table: cb_2014_us_nation_5m row check OK: %', c1_rec.total;
	ELSE
		RAISE EXCEPTION 'Table: cb_2014_us_nation_5m row check FAILED: expected: 1 got: %', c1_rec.total;
	END IF;
END;
$$;

-- SQL statement 40: Add primary key cb_2014_us_nation_5m >>>
ALTER TABLE cb_2014_us_nation_5m ADD PRIMARY KEY (gid);

-- SQL statement 41: Add unique key cb_2014_us_nation_5m >>>
/*
 * SQL statement name: 	add_unique_key.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. cb_2014_us_nation_5m
 *						2: constraint name; e.g. cb_2014_us_nation_5m_uk
 *						3: fields; e.g. areaid
 *
 * Description:			Add unique key constraint
 * Note:				%% becomes % after substitution
 */
ALTER TABLE cb_2014_us_nation_5m ADD CONSTRAINT cb_2014_us_nation_5m_uk UNIQUE(areaid);

--
-- Add geometric  data
--

-- SQL statement 43: Add geometry column: geographic centroid >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_nation_5m','geographic_centroid', 4326, 'POINT', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 44: Add geometry column for original SRID geometry >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_nation_5m','geom_orig', 4269, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 45: Add geometry column for zoomlevel: 6 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_nation_5m','geom_6', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 46: Add geometry column for zoomlevel: 7 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_nation_5m','geom_7', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 47: Add geometry column for zoomlevel: 8 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_nation_5m','geom_8', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 48: Add geometry column for zoomlevel: 9 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_nation_5m','geom_9', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 49: Add geometry column for zoomlevel: 10 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_nation_5m','geom_10', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 50: Add geometry column for zoomlevel: 11 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_nation_5m','geom_11', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 51: Update geographic centroid, geometry columns, handle polygons and mutlipolygons, convert highest zoomlevel to original SRID >>>
UPDATE cb_2014_us_nation_5m
   SET geographic_centroid = ST_GeomFromText(geographic_centroid_wkt, 4326),
       geom_6 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_6, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_6, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_6, 4326))
       		END,
       geom_7 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_7, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_7, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_7, 4326))
       		END,
       geom_8 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_8, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_8, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_8, 4326))
       		END,
       geom_9 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_9, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_9, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_9, 4326))
       		END,
       geom_10 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_10, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_10, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_10, 4326))
       		END,
       geom_11 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_11, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_11, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_11, 4326))
       		END,
       geom_orig = ST_Transform(
       		CASE ST_IsCollection(ST_GeomFromText(wkt_11, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_11, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_11, 4326))
       		END, 4269);

-- SQL statement 52: Make geometry columns valid >>>
UPDATE cb_2014_us_nation_5m
   SET
       geom_6 = CASE ST_IsValid(geom_6)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_6), 3 /* Remove non polygons */)
				ELSE geom_6
			END,
       geom_7 = CASE ST_IsValid(geom_7)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_7), 3 /* Remove non polygons */)
				ELSE geom_7
			END,
       geom_8 = CASE ST_IsValid(geom_8)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_8), 3 /* Remove non polygons */)
				ELSE geom_8
			END,
       geom_9 = CASE ST_IsValid(geom_9)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_9), 3 /* Remove non polygons */)
				ELSE geom_9
			END,
       geom_10 = CASE ST_IsValid(geom_10)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_10), 3 /* Remove non polygons */)
				ELSE geom_10
			END,
       geom_11 = CASE ST_IsValid(geom_11)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_11), 3 /* Remove non polygons */)
				ELSE geom_11
			END,
       geom_orig = CASE ST_IsValid(geom_orig)
			WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_orig), 3 /* Remove non polygons */)
			ELSE geom_orig
		END;

--
-- Test geometry and make valid if required
--

-- SQL statement 54: Check validity of geometry columns >>>
DO LANGUAGE plpgsql $$
DECLARE
	c1 CURSOR FOR
SELECT areaname,
       6::Text AS geolevel,
       ST_IsValidReason(geom_6) AS reason
  FROM cb_2014_us_nation_5m
 WHERE NOT ST_IsValid(geom_6)
UNION
SELECT areaname,
       7::Text AS geolevel,
       ST_IsValidReason(geom_7) AS reason
  FROM cb_2014_us_nation_5m
 WHERE NOT ST_IsValid(geom_7)
UNION
SELECT areaname,
       8::Text AS geolevel,
       ST_IsValidReason(geom_8) AS reason
  FROM cb_2014_us_nation_5m
 WHERE NOT ST_IsValid(geom_8)
UNION
SELECT areaname,
       9::Text AS geolevel,
       ST_IsValidReason(geom_9) AS reason
  FROM cb_2014_us_nation_5m
 WHERE NOT ST_IsValid(geom_9)
UNION
SELECT areaname,
       10::Text AS geolevel,
       ST_IsValidReason(geom_10) AS reason
  FROM cb_2014_us_nation_5m
 WHERE NOT ST_IsValid(geom_10)
UNION
SELECT areaname,
       11::Text AS geolevel,
       ST_IsValidReason(geom_11) AS reason
  FROM cb_2014_us_nation_5m
 WHERE NOT ST_IsValid(geom_11)
UNION
SELECT areaname,
       'geom_orig'::Text AS geolevel,
       ST_IsValidReason(geom_orig) AS reason
  FROM cb_2014_us_nation_5m
 WHERE NOT ST_IsValid(geom_orig)
 ORDER BY 1, 2;
	c1_rec RECORD;
	total INTEGER:=0;
BEGIN
	FOR c1_rec IN c1 LOOP
		total:=total+1;
		RAISE INFO 'Area: %, geolevel: %: %', c1_rec.areaname, c1_rec.geolevel, c1_rec.reason;
	END LOOP;
	IF total = 0 THEN
		RAISE INFO 'Table: cb_2014_us_nation_5m no invalid geometry check OK';
	ELSE
		RAISE EXCEPTION 'Table: cb_2014_us_nation_5m no invalid geometry check FAILED: % invalid', total;
	END IF;
END;
$$;

--
-- Make all polygons right handed
--

-- SQL statement 56: Make all polygons right handed for original geometry >>>
UPDATE cb_2014_us_nation_5m
   SET       geom_6 = ST_ForceRHR(geom_6),
       geom_7 = ST_ForceRHR(geom_7),
       geom_8 = ST_ForceRHR(geom_8),
       geom_9 = ST_ForceRHR(geom_9),
       geom_10 = ST_ForceRHR(geom_10),
       geom_11 = ST_ForceRHR(geom_11),
       geom_orig = ST_ForceRHR(geom_orig);

--
-- Test Turf and DB areas agree to within 1%
--

-- SQL statement 58: Test Turf and DB areas agree to within 1% (Postgres)/5% (SQL server) >>>
DO LANGUAGE plpgsql $$
DECLARE 
/*
 * SQL statement name: 	area_check.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Check Turf araa (area_km2) compared to SQL Server calculated area (area_km2_calc)
 *						Allow for 1% error
 *						Ignore small areas <= 10 km2
 * Note:				%% becomes % after substitution
 */
	c1 CURSOR FOR
		WITH a AS (
			SELECT areaname,
				   area_km2 AS area_km2,
				   ST_Area(geography(geom_11))/(1000*1000) AS area_km2_calc
			  FROM cb_2014_us_nation_5m
		), b AS (
		SELECT SUBSTRING(a.areaname, 1, 30) AS areaname,
			   a.area_km2,
			   a.area_km2_calc,
			   CASE WHEN a.area_km2 > 0 THEN 100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2)
					WHEN a.area_km2 = a.area_km2_calc THEN 0
					ELSE NULL
			   END AS pct_km2_diff 
		  FROM a
		)
		SELECT b.areaname, b.area_km2, b.area_km2_calc, b.pct_km2_diff
		  FROM b
		 WHERE b.pct_km2_diff > 1 /* Allow for 1% error */
		   AND b.area_km2_calc > 10 /* Ignore small areas <= 10 km2 */;

	c1_rec RECORD;
	total INTEGER:=0;
BEGIN
	FOR c1_rec IN c1 LOOP
		total:=total+1;
		RAISE INFO 'Area: %, area km2: %:, calc: %, diff %',
			c1_rec.areaname, c1_rec.area_km2, c1_rec.area_km2_calc, c1_rec.pct_km2_diff;
	END LOOP;
	IF total = 0 THEN
		RAISE INFO 'Table: cb_2014_us_nation_5m no invalid areas check OK';
	ELSE
		RAISE EXCEPTION 'Table: cb_2014_us_nation_5m no invalid areas check FAILED: % invalid', total;
	END IF;
END;
$$;

--
-- Create spatial indexes
--

-- SQL statement 60: Index geometry column for zoomlevel: 6 >>>
CREATE INDEX cb_2014_us_nation_5m_geom_6_gix ON cb_2014_us_nation_5m USING GIST (geom_6);

-- SQL statement 61: Index geometry column for zoomlevel: 7 >>>
CREATE INDEX cb_2014_us_nation_5m_geom_7_gix ON cb_2014_us_nation_5m USING GIST (geom_7);

-- SQL statement 62: Index geometry column for zoomlevel: 8 >>>
CREATE INDEX cb_2014_us_nation_5m_geom_8_gix ON cb_2014_us_nation_5m USING GIST (geom_8);

-- SQL statement 63: Index geometry column for zoomlevel: 9 >>>
CREATE INDEX cb_2014_us_nation_5m_geom_9_gix ON cb_2014_us_nation_5m USING GIST (geom_9);

-- SQL statement 64: Index geometry column for zoomlevel: 10 >>>
CREATE INDEX cb_2014_us_nation_5m_geom_10_gix ON cb_2014_us_nation_5m USING GIST (geom_10);

-- SQL statement 65: Index geometry column for zoomlevel: 11 >>>
CREATE INDEX cb_2014_us_nation_5m_geom_11_gix ON cb_2014_us_nation_5m USING GIST (geom_11);

-- SQL statement 66: Index geometry column for original SRID geometry >>>
CREATE INDEX cb_2014_us_nation_5m_geom_orig_gix ON cb_2014_us_nation_5m USING GIST (geom_orig);

--
-- Reports
--

-- SQL statement 68: Areas and centroids report >>>
/*
 * SQL statement name: 	area_centroid_report.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Area and centroids report
 * Note:				% becomes % after substitution
 */
WITH a AS (
	SELECT areaname,
		   ROUND(area_km2::numeric, 2) AS area_km2,
		   ROUND(
				(ST_Area(geography(geom_11))/(1000*1000))::numeric, 2) AS area_km2_calc,
		   ROUND(ST_X(geographic_centroid)::numeric, 4)||','||ROUND(ST_Y(geographic_centroid)::numeric, 4) AS geographic_centroid,
		   ROUND(ST_X(ST_Centroid(geom_11))::numeric, 4)||','||ROUND(ST_Y(ST_Centroid(geom_11))::numeric, 4) AS geographic_centroid_calc,
		   ROUND(ST_Distance_Sphere(ST_Centroid(geom_11), geographic_centroid)::numeric/1000, 2) AS centroid_diff_km
	  FROM cb_2014_us_nation_5m
	 GROUP BY areaname, area_km2, geom_11, geographic_centroid
)
SELECT a.areaname,
       a.area_km2,
	   a.area_km2_calc,
	   ROUND(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2_calc), 2) AS pct_km2_diff,
	   a.geographic_centroid,
      a.geographic_centroid_calc,
	   a.centroid_diff_km
  FROM a
 ORDER BY 1
 LIMIT 100;;

-- SQL statement 69: Drop table cb_2014_us_state_500k >>>
DROP TABLE IF EXISTS cb_2014_us_state_500k;

-- SQL statement 70: Create tablecb_2014_us_state_500k >>>
CREATE TABLE cb_2014_us_state_500k (
	statefp                        	text,
	statens                        	text,
	affgeoid                       	text,
	geoid                          	text,
	stusps                         	text,
	name                           	text,
	lsad                           	text,
	aland                          	text,
	awater                         	text,
	gid                            	integer	NOT NULL,
	areaid                         	text	NOT NULL,
	areaname                       	text	NOT NULL,
	area_km2                       	numeric,
	geographic_centroid_wkt        	text,
	wkt_11                         	text,
	wkt_10                         	text,
	wkt_9                          	text,
	wkt_8                          	text,
	wkt_7                          	text,
	wkt_6                          	text);

-- SQL statement 71: Comment geospatial data table >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE cb_2014_us_state_500k IS 'The State at a scale of 1:500,000';

-- SQL statement 72: Load table from CSV file >>>
\copy cb_2014_us_state_500k FROM 'cb_2014_us_state_500k.csv' DELIMITER ',' CSV HEADER;

-- SQL statement 73: Row check: 56 >>>
DO LANGUAGE plpgsql $$
DECLARE
/*
 * SQL statement name: 	csvfile_rowcheck.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: Expected number of rows; e.g. 3233
 *						3: Column to count; e.g. gid
 *
 * Description:			Check number of rows in loaded CSV file is as expected
 * Note:				%% becomes % after substitution
 */
	c1 CURSOR FOR
		SELECT COUNT(gid) AS total
		  FROM cb_2014_us_state_500k;
	c1_rec RECORD;
BEGIN
	OPEN c1;
	FETCH c1 INTO c1_rec;
	CLOSE c1;
	IF c1_rec.total = 56 THEN
		RAISE INFO 'Table: cb_2014_us_state_500k row check OK: %', c1_rec.total;
	ELSE
		RAISE EXCEPTION 'Table: cb_2014_us_state_500k row check FAILED: expected: 56 got: %', c1_rec.total;
	END IF;
END;
$$;

-- SQL statement 74: Add primary key cb_2014_us_state_500k >>>
ALTER TABLE cb_2014_us_state_500k ADD PRIMARY KEY (gid);

-- SQL statement 75: Add unique key cb_2014_us_state_500k >>>
/*
 * SQL statement name: 	add_unique_key.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. cb_2014_us_nation_5m
 *						2: constraint name; e.g. cb_2014_us_nation_5m_uk
 *						3: fields; e.g. areaid
 *
 * Description:			Add unique key constraint
 * Note:				%% becomes % after substitution
 */
ALTER TABLE cb_2014_us_state_500k ADD CONSTRAINT cb_2014_us_state_500k_uk UNIQUE(areaid);

--
-- Add geometric  data
--

-- SQL statement 77: Add geometry column: geographic centroid >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_state_500k','geographic_centroid', 4326, 'POINT', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 78: Add geometry column for original SRID geometry >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_state_500k','geom_orig', 4269, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 79: Add geometry column for zoomlevel: 6 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_state_500k','geom_6', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 80: Add geometry column for zoomlevel: 7 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_state_500k','geom_7', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 81: Add geometry column for zoomlevel: 8 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_state_500k','geom_8', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 82: Add geometry column for zoomlevel: 9 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_state_500k','geom_9', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 83: Add geometry column for zoomlevel: 10 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_state_500k','geom_10', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 84: Add geometry column for zoomlevel: 11 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 */
SELECT AddGeometryColumn('cb_2014_us_state_500k','geom_11', 4326, 'MULTIPOLYGON', 
			2 		/* Dimension */, 
			false 	/* use typmod geometry column instead of constraint-based */);;

-- SQL statement 85: Update geographic centroid, geometry columns, handle polygons and mutlipolygons, convert highest zoomlevel to original SRID >>>
UPDATE cb_2014_us_state_500k
   SET geographic_centroid = ST_GeomFromText(geographic_centroid_wkt, 4326),
       geom_6 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_6, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_6, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_6, 4326))
       		END,
       geom_7 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_7, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_7, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_7, 4326))
       		END,
       geom_8 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_8, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_8, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_8, 4326))
       		END,
       geom_9 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_9, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_9, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_9, 4326))
       		END,
       geom_10 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_10, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_10, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_10, 4326))
       		END,
       geom_11 = 
       		CASE ST_IsCollection(ST_GeomFromText(wkt_11, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_11, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_11, 4326))
       		END,
       geom_orig = ST_Transform(
       		CASE ST_IsCollection(ST_GeomFromText(wkt_11, 4326)) /* Convert to Multipolygon */
       			WHEN true THEN 	ST_GeomFromText(wkt_11, 4326)
       			ELSE 			ST_Multi(ST_GeomFromText(wkt_11, 4326))
       		END, 4269);

-- SQL statement 86: Make geometry columns valid >>>
UPDATE cb_2014_us_state_500k
   SET
       geom_6 = CASE ST_IsValid(geom_6)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_6), 3 /* Remove non polygons */)
				ELSE geom_6
			END,
       geom_7 = CASE ST_IsValid(geom_7)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_7), 3 /* Remove non polygons */)
				ELSE geom_7
			END,
       geom_8 = CASE ST_IsValid(geom_8)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_8), 3 /* Remove non polygons */)
				ELSE geom_8
			END,
       geom_9 = CASE ST_IsValid(geom_9)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_9), 3 /* Remove non polygons */)
				ELSE geom_9
			END,
       geom_10 = CASE ST_IsValid(geom_10)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_10), 3 /* Remove non polygons */)
				ELSE geom_10
			END,
       geom_11 = CASE ST_IsValid(geom_11)
				WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_11), 3 /* Remove non polygons */)
				ELSE geom_11
			END,
       geom_orig = CASE ST_IsValid(geom_orig)
			WHEN false THEN ST_CollectionExtract(ST_MakeValid(geom_orig), 3 /* Remove non polygons */)
			ELSE geom_orig
		END;

--
-- Test geometry and make valid if required
--

-- SQL statement 88: Check validity of geometry columns >>>
DO LANGUAGE plpgsql $$
DECLARE
	c1 CURSOR FOR
SELECT areaname,
       6::Text AS geolevel,
       ST_IsValidReason(geom_6) AS reason
  FROM cb_2014_us_state_500k
 WHERE NOT ST_IsValid(geom_6)
UNION
SELECT areaname,
       7::Text AS geolevel,
       ST_IsValidReason(geom_7) AS reason
  FROM cb_2014_us_state_500k
 WHERE NOT ST_IsValid(geom_7)
UNION
SELECT areaname,
       8::Text AS geolevel,
       ST_IsValidReason(geom_8) AS reason
  FROM cb_2014_us_state_500k
 WHERE NOT ST_IsValid(geom_8)
UNION
SELECT areaname,
       9::Text AS geolevel,
       ST_IsValidReason(geom_9) AS reason
  FROM cb_2014_us_state_500k
 WHERE NOT ST_IsValid(geom_9)
UNION
SELECT areaname,
       10::Text AS geolevel,
       ST_IsValidReason(geom_10) AS reason
  FROM cb_2014_us_state_500k
 WHERE NOT ST_IsValid(geom_10)
UNION
SELECT areaname,
       11::Text AS geolevel,
       ST_IsValidReason(geom_11) AS reason
  FROM cb_2014_us_state_500k
 WHERE NOT ST_IsValid(geom_11)
UNION
SELECT areaname,
       'geom_orig'::Text AS geolevel,
       ST_IsValidReason(geom_orig) AS reason
  FROM cb_2014_us_state_500k
 WHERE NOT ST_IsValid(geom_orig)
 ORDER BY 1, 2;
	c1_rec RECORD;
	total INTEGER:=0;
BEGIN
	FOR c1_rec IN c1 LOOP
		total:=total+1;
		RAISE INFO 'Area: %, geolevel: %: %', c1_rec.areaname, c1_rec.geolevel, c1_rec.reason;
	END LOOP;
	IF total = 0 THEN
		RAISE INFO 'Table: cb_2014_us_state_500k no invalid geometry check OK';
	ELSE
		RAISE EXCEPTION 'Table: cb_2014_us_state_500k no invalid geometry check FAILED: % invalid', total;
	END IF;
END;
$$;

--
-- Make all polygons right handed
--

-- SQL statement 90: Make all polygons right handed for original geometry >>>
UPDATE cb_2014_us_state_500k
   SET       geom_6 = ST_ForceRHR(geom_6),
       geom_7 = ST_ForceRHR(geom_7),
       geom_8 = ST_ForceRHR(geom_8),
       geom_9 = ST_ForceRHR(geom_9),
       geom_10 = ST_ForceRHR(geom_10),
       geom_11 = ST_ForceRHR(geom_11),
       geom_orig = ST_ForceRHR(geom_orig);

--
-- Test Turf and DB areas agree to within 1%
--

-- SQL statement 92: Test Turf and DB areas agree to within 1% (Postgres)/5% (SQL server) >>>
DO LANGUAGE plpgsql $$
DECLARE 
/*
 * SQL statement name: 	area_check.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Check Turf araa (area_km2) compared to SQL Server calculated area (area_km2_calc)
 *						Allow for 1% error
 *						Ignore small areas <= 10 km2
 * Note:				%% becomes % after substitution
 */
	c1 CURSOR FOR
		WITH a AS (
			SELECT areaname,
				   area_km2 AS area_km2,
				   ST_Area(geography(geom_11))/(1000*1000) AS area_km2_calc
			  FROM cb_2014_us_state_500k
		), b AS (
		SELECT SUBSTRING(a.areaname, 1, 30) AS areaname,
			   a.area_km2,
			   a.area_km2_calc,
			   CASE WHEN a.area_km2 > 0 THEN 100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2)
					WHEN a.area_km2 = a.area_km2_calc THEN 0
					ELSE NULL
			   END AS pct_km2_diff 
		  FROM a
		)
		SELECT b.areaname, b.area_km2, b.area_km2_calc, b.pct_km2_diff
		  FROM b
		 WHERE b.pct_km2_diff > 1 /* Allow for 1% error */
		   AND b.area_km2_calc > 10 /* Ignore small areas <= 10 km2 */;

	c1_rec RECORD;
	total INTEGER:=0;
BEGIN
	FOR c1_rec IN c1 LOOP
		total:=total+1;
		RAISE INFO 'Area: %, area km2: %:, calc: %, diff %',
			c1_rec.areaname, c1_rec.area_km2, c1_rec.area_km2_calc, c1_rec.pct_km2_diff;
	END LOOP;
	IF total = 0 THEN
		RAISE INFO 'Table: cb_2014_us_state_500k no invalid areas check OK';
	ELSE
		RAISE EXCEPTION 'Table: cb_2014_us_state_500k no invalid areas check FAILED: % invalid', total;
	END IF;
END;
$$;

--
-- Create spatial indexes
--

-- SQL statement 94: Index geometry column for zoomlevel: 6 >>>
CREATE INDEX cb_2014_us_state_500k_geom_6_gix ON cb_2014_us_state_500k USING GIST (geom_6);

-- SQL statement 95: Index geometry column for zoomlevel: 7 >>>
CREATE INDEX cb_2014_us_state_500k_geom_7_gix ON cb_2014_us_state_500k USING GIST (geom_7);

-- SQL statement 96: Index geometry column for zoomlevel: 8 >>>
CREATE INDEX cb_2014_us_state_500k_geom_8_gix ON cb_2014_us_state_500k USING GIST (geom_8);

-- SQL statement 97: Index geometry column for zoomlevel: 9 >>>
CREATE INDEX cb_2014_us_state_500k_geom_9_gix ON cb_2014_us_state_500k USING GIST (geom_9);

-- SQL statement 98: Index geometry column for zoomlevel: 10 >>>
CREATE INDEX cb_2014_us_state_500k_geom_10_gix ON cb_2014_us_state_500k USING GIST (geom_10);

-- SQL statement 99: Index geometry column for zoomlevel: 11 >>>
CREATE INDEX cb_2014_us_state_500k_geom_11_gix ON cb_2014_us_state_500k USING GIST (geom_11);

-- SQL statement 100: Index geometry column for original SRID geometry >>>
CREATE INDEX cb_2014_us_state_500k_geom_orig_gix ON cb_2014_us_state_500k USING GIST (geom_orig);

--
-- Reports
--

-- SQL statement 102: Areas and centroids report >>>
/*
 * SQL statement name: 	area_centroid_report.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Area and centroids report
 * Note:				% becomes % after substitution
 */
WITH a AS (
	SELECT areaname,
		   ROUND(area_km2::numeric, 2) AS area_km2,
		   ROUND(
				(ST_Area(geography(geom_11))/(1000*1000))::numeric, 2) AS area_km2_calc,
		   ROUND(ST_X(geographic_centroid)::numeric, 4)||','||ROUND(ST_Y(geographic_centroid)::numeric, 4) AS geographic_centroid,
		   ROUND(ST_X(ST_Centroid(geom_11))::numeric, 4)||','||ROUND(ST_Y(ST_Centroid(geom_11))::numeric, 4) AS geographic_centroid_calc,
		   ROUND(ST_Distance_Sphere(ST_Centroid(geom_11), geographic_centroid)::numeric/1000, 2) AS centroid_diff_km
	  FROM cb_2014_us_state_500k
	 GROUP BY areaname, area_km2, geom_11, geographic_centroid
)
SELECT a.areaname,
       a.area_km2,
	   a.area_km2_calc,
	   ROUND(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2_calc), 2) AS pct_km2_diff,
	   a.geographic_centroid,
      a.geographic_centroid_calc,
	   a.centroid_diff_km
  FROM a
 ORDER BY 1
 LIMIT 100;;

--
-- Geography meta data
--

-- SQL statement 104: Drop table geography_cb_2014_us_500k >>>
DROP TABLE IF EXISTS geography_cb_2014_us_500k;

-- SQL statement 105: Create geography meta data table >>>
/*
 * SQL statement name: 	create_geography_table.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. geography_cb_2014_us_county_500k
 *
 * Description:			Create geography table
 * Note:				%% becomes % after substitution
 */
CREATE TABLE geography_cb_2014_us_500k (
       geography               VARCHAR(50)  NOT NULL,
       description             VARCHAR(250) NOT NULL,
       hierarchytable          VARCHAR(30)  NOT NULL,
       srid                    INTEGER      NULL DEFAULT 0,
       defaultcomparea         VARCHAR(30)  NULL,
       defaultstudyarea        VARCHAR(30)  NULL,
       CONSTRAINT geography_cb_2014_us_500k_pk PRIMARY KEY(geography)
	);

-- SQL statement 106: Comment geography meta data table >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE geography_cb_2014_us_500k IS 'Hierarchial geographies. Usually based on Census geography';

-- SQL statement 107: Populate geography meta data table >>>
/*
 * SQL statement name: 	insert_geography.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. geography_cb_2014_us_county_500k
 *						2: geography; e.g. cb_2014_us_500k
 *						3: geography description; e.g. "United states to county level"
 *						4: hierarchytable; e.g. hierarchy_cb_2014_us_500k
 * 						5: SRID; e.g. 4269
 *						6: Default comparision area
 *						7: Default study area
 *
 * Description:			Insert into geography table
 * Note:				%% becomes % after substitution
 */
INSERT INTO geography_cb_2014_us_500k (
geography, description, hierarchytable, srid, defaultcomparea, defaultstudyarea)
SELECT 'cb_2014_us_500k' AS geography,
       'Description of: cb_2014_us_nation_5m' AS description,
       'hierarchy_cb_2014_us_500k' AS hierarchytable,
       4269 AS srid,
       'GEOID' AS defaultcomparea,
       'STATENS' AS defaultstudyarea;

-- SQL statement 108: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_cb_2014_us_500k.geography IS 'Geography name';

-- SQL statement 109: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_cb_2014_us_500k.description IS 'Description';

-- SQL statement 110: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_cb_2014_us_500k.hierarchytable IS 'Hierarchy table';

-- SQL statement 111: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_cb_2014_us_500k.srid IS 'Projection SRID';

-- SQL statement 112: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_cb_2014_us_500k.defaultcomparea IS 'Default comparison area: lowest resolution geolevel';

-- SQL statement 113: Comment geography meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geography_cb_2014_us_500k.defaultstudyarea IS 'Default study area: highest resolution geolevel';

--
-- Geolevels meta data
--

-- SQL statement 115: Drop table geolevels_cb_2014_us_500k >>>
DROP TABLE IF EXISTS geolevels_cb_2014_us_500k;

-- SQL statement 116: Create geolevels meta data table >>>
CREATE TABLE geolevels_cb_2014_us_500k (
       geography                       VARCHAR(50)  NOT NULL,
       geolevel_name                   VARCHAR(30)  NOT NULL,
       geolevel_id			        	integer	     NOT NULL,
       description                     VARCHAR(250) NOT NULL,
       lookup_table                    VARCHAR(30)  NOT NULL,
       lookup_desc_column              VARCHAR(30)  NOT NULL,
       shapefile                       VARCHAR(512) NOT NULL,
       shapefile_table                 VARCHAR(30)  NULL,
       shapefile_area_id_column        VARCHAR(30)  NOT NULL,
       shapefile_desc_column           VARCHAR(30)  NULL,
       resolution                      integer      NULL,
       comparea                        integer      NULL,
       listing                         integer      NULL,
       CONSTRAINT geolevels_cb_2014_us_500k_pk PRIMARY KEY(geography, geolevel_name)
);

-- SQL statement 117: Comment geolevels meta data table >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE geolevels_cb_2014_us_500k IS 'Geolevels: hierarchy of level within a geography';

-- SQL statement 118: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_cb_2014_us_500k.geography IS 'Geography (e.g EW2001)';

-- SQL statement 119: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_cb_2014_us_500k.geolevel_name IS 'Name of geolevel. This will be a column name in the numerator/denominator tables';

-- SQL statement 120: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_cb_2014_us_500k.geolevel_id IS 'ID for ordering (1=lowest resolution). Up to 99 supported.';

-- SQL statement 121: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_cb_2014_us_500k.description IS 'Description';

-- SQL statement 122: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_cb_2014_us_500k.lookup_table IS 'Lookup table name. This is used to translate codes to the common names, e.g a LADUA of 00BK is "Westminster"';

-- SQL statement 123: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_cb_2014_us_500k.lookup_desc_column IS 'Lookup table description column name.';

-- SQL statement 124: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_cb_2014_us_500k.shapefile IS 'Location of the GIS shape file. NULL if PostGress/PostGIS used. Can also use SHAPEFILE_GEOMETRY instead';

-- SQL statement 125: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_cb_2014_us_500k.shapefile_table IS 'Table containing GIS shape file data.';

-- SQL statement 126: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_cb_2014_us_500k.shapefile_area_id_column IS 'Column containing the AREA_IDs in SHAPEFILE_TABLE';

-- SQL statement 127: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_cb_2014_us_500k.shapefile_desc_column IS 'Column containing the AREA_ID descriptions in SHAPEFILE_TABLE';

-- SQL statement 128: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_cb_2014_us_500k.resolution IS 'Can use a map for selection at this resolution (0/1)';

-- SQL statement 129: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_cb_2014_us_500k.comparea IS 'Able to be used as a comparison area (0/1)';

-- SQL statement 130: Comment geolevels meta data column >>>
COMMENT /*
 * SQL statement name: 	comment_column.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON COLUMN geolevels_cb_2014_us_500k.listing IS 'Able to be used in a disease map listing (0/1)';

-- SQL statement 131: Insert geolevels meta data for: cb_2014_us_county_500k >>>
/*
 * SQL statement name: 	insert_geolevel.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: geography; e.g. cb_2014_us_500k
 *						3: Geolevel name; e.g. cb_2014_us_county_500k
 *						4: Geolevel id; e.g. 3
 *						5: Geolevel description; e.g. "The State-County at a scale of 1:500,000"
 *						6: lookup table; e.g. lookup_cb_2014_us_county_500k
 * 						7: shapefile; e.g. cb_2014_us_county_500k.shp
 *						8: shapefile table; e.g. cb_2014_us_county_500k
 *
 * Description:			Insert into geography table
 * Note:				%% becomes % after substitution
 */
INSERT INTO geolevels_cb_2014_us_500k (
   geography, geolevel_name, geolevel_id, description, lookup_table,
   lookup_desc_column, shapefile, shapefile_table, shapefile_area_id_column, shapefile_desc_column,
   resolution, comparea, listing)
SELECT 'cb_2014_us_500k' AS geography,
       'cb_2014_us_county_500k' AS geolevel_name,
       3 AS geolevel_id,
       'The State-County at a scale of 1:500,000' AS description,
       'lookup_cb_2014_us_county_500k' AS lookup_table,
       'areaname' AS lookup_desc_column,
       'cb_2014_us_county_500k.shp.shp' AS shapefile,
       'cb_2014_us_county_500k' AS shapefile_table,
       'areaid' AS shapefile_area_id_column,
       'areaname' AS shapefile_desc_column,
       1 AS resolution,
       1 AS comparea,
       1 AS listing;

-- SQL statement 132: Insert geolevels meta data for: cb_2014_us_nation_5m >>>
/*
 * SQL statement name: 	insert_geolevel.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: geography; e.g. cb_2014_us_500k
 *						3: Geolevel name; e.g. cb_2014_us_county_500k
 *						4: Geolevel id; e.g. 3
 *						5: Geolevel description; e.g. "The State-County at a scale of 1:500,000"
 *						6: lookup table; e.g. lookup_cb_2014_us_county_500k
 * 						7: shapefile; e.g. cb_2014_us_county_500k.shp
 *						8: shapefile table; e.g. cb_2014_us_county_500k
 *
 * Description:			Insert into geography table
 * Note:				%% becomes % after substitution
 */
INSERT INTO geolevels_cb_2014_us_500k (
   geography, geolevel_name, geolevel_id, description, lookup_table,
   lookup_desc_column, shapefile, shapefile_table, shapefile_area_id_column, shapefile_desc_column,
   resolution, comparea, listing)
SELECT 'cb_2014_us_500k' AS geography,
       'cb_2014_us_nation_5m' AS geolevel_name,
       1 AS geolevel_id,
       'Theat a scale of 1:5,000,000' AS description,
       'lookup_cb_2014_us_nation_5m' AS lookup_table,
       'areaname' AS lookup_desc_column,
       'cb_2014_us_nation_5m.shp.shp' AS shapefile,
       'cb_2014_us_nation_5m' AS shapefile_table,
       'areaid' AS shapefile_area_id_column,
       'areaname' AS shapefile_desc_column,
       1 AS resolution,
       1 AS comparea,
       1 AS listing;

-- SQL statement 133: Insert geolevels meta data for: cb_2014_us_state_500k >>>
/*
 * SQL statement name: 	insert_geolevel.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: geography; e.g. cb_2014_us_500k
 *						3: Geolevel name; e.g. cb_2014_us_county_500k
 *						4: Geolevel id; e.g. 3
 *						5: Geolevel description; e.g. "The State-County at a scale of 1:500,000"
 *						6: lookup table; e.g. lookup_cb_2014_us_county_500k
 * 						7: shapefile; e.g. cb_2014_us_county_500k.shp
 *						8: shapefile table; e.g. cb_2014_us_county_500k
 *
 * Description:			Insert into geography table
 * Note:				%% becomes % after substitution
 */
INSERT INTO geolevels_cb_2014_us_500k (
   geography, geolevel_name, geolevel_id, description, lookup_table,
   lookup_desc_column, shapefile, shapefile_table, shapefile_area_id_column, shapefile_desc_column,
   resolution, comparea, listing)
SELECT 'cb_2014_us_500k' AS geography,
       'cb_2014_us_state_500k' AS geolevel_name,
       2 AS geolevel_id,
       'The State at a scale of 1:500,000' AS description,
       'lookup_cb_2014_us_state_500k' AS lookup_table,
       'areaname' AS lookup_desc_column,
       'cb_2014_us_state_500k.shp.shp' AS shapefile,
       'cb_2014_us_state_500k' AS shapefile_table,
       'areaid' AS shapefile_area_id_column,
       'areaname' AS shapefile_desc_column,
       1 AS resolution,
       1 AS comparea,
       1 AS listing;

--
-- Geolevels lookup tables
--

-- SQL statement 135: Drop table lookup_cb_2014_us_county_500k >>>
DROP TABLE IF EXISTS lookup_cb_2014_us_county_500k;

-- SQL statement 136: Create table lookup_cb_2014_us_county_500k >>>
CREATE TABLE lookup_cb_2014_us_county_500k (
	cb_2014_us_county_500k			VARCHAR(100)  NOT NULL,
	areaname	VARCHAR(1000)
);

-- SQL statement 137: Insert table lookup_cb_2014_us_county_500k >>>
INSERT INTO lookup_cb_2014_us_county_500k(cb_2014_us_county_500k, areaname)
SELECT areaid, areaname
  FROM cb_2014_us_county_500k
 ORDER BY 1;

-- SQL statement 138: Add primary key lookup_cb_2014_us_county_500k >>>
ALTER TABLE lookup_cb_2014_us_county_500k ADD PRIMARY KEY (cb_2014_us_county_500k);

-- SQL statement 139: Comment table lookup_cb_2014_us_county_500k >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE lookup_cb_2014_us_county_500k IS 'Lookup table for The State-County at a scale of 1:500,000';

-- SQL statement 140: Drop table lookup_cb_2014_us_nation_5m >>>
DROP TABLE IF EXISTS lookup_cb_2014_us_nation_5m;

-- SQL statement 141: Create table lookup_cb_2014_us_nation_5m >>>
CREATE TABLE lookup_cb_2014_us_nation_5m (
	cb_2014_us_nation_5m			VARCHAR(100)  NOT NULL,
	areaname	VARCHAR(1000)
);

-- SQL statement 142: Insert table lookup_cb_2014_us_nation_5m >>>
INSERT INTO lookup_cb_2014_us_nation_5m(cb_2014_us_nation_5m, areaname)
SELECT areaid, areaname
  FROM cb_2014_us_nation_5m
 ORDER BY 1;

-- SQL statement 143: Add primary key lookup_cb_2014_us_nation_5m >>>
ALTER TABLE lookup_cb_2014_us_nation_5m ADD PRIMARY KEY (cb_2014_us_nation_5m);

-- SQL statement 144: Comment table lookup_cb_2014_us_nation_5m >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE lookup_cb_2014_us_nation_5m IS 'Lookup table for Theat a scale of 1:5,000,000';

-- SQL statement 145: Drop table lookup_cb_2014_us_state_500k >>>
DROP TABLE IF EXISTS lookup_cb_2014_us_state_500k;

-- SQL statement 146: Create table lookup_cb_2014_us_state_500k >>>
CREATE TABLE lookup_cb_2014_us_state_500k (
	cb_2014_us_state_500k			VARCHAR(100)  NOT NULL,
	areaname	VARCHAR(1000)
);

-- SQL statement 147: Insert table lookup_cb_2014_us_state_500k >>>
INSERT INTO lookup_cb_2014_us_state_500k(cb_2014_us_state_500k, areaname)
SELECT areaid, areaname
  FROM cb_2014_us_state_500k
 ORDER BY 1;

-- SQL statement 148: Add primary key lookup_cb_2014_us_state_500k >>>
ALTER TABLE lookup_cb_2014_us_state_500k ADD PRIMARY KEY (cb_2014_us_state_500k);

-- SQL statement 149: Comment table lookup_cb_2014_us_state_500k >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE lookup_cb_2014_us_state_500k IS 'Lookup table for The State at a scale of 1:500,000';

--
-- Hierarchy table
--

-- SQL statement 151: Drop table hierarchy_cb_2014_us_500k >>>
DROP TABLE IF EXISTS hierarchy_cb_2014_us_500k;

-- SQL statement 152: Create table hierarchy_cb_2014_us_500k >>>
CREATE TABLE hierarchy_cb_2014_us_500k (
	cb_2014_us_county_500k	VARCHAR(100)  NOT NULL,
	cb_2014_us_nation_5m	VARCHAR(100)  NOT NULL,
	cb_2014_us_state_500k	VARCHAR(100)  NOT NULL);

-- SQL statement 153: Add primary key hierarchy_cb_2014_us_500k >>>
ALTER TABLE hierarchy_cb_2014_us_500k ADD PRIMARY KEY (cb_2014_us_county_500k);

-- SQL statement 154: Add index key hierarchy_cb_2014_us_500k_cb_2014_us_state_500k >>>
CREATE INDEX hierarchy_cb_2014_us_500k_cb_2014_us_state_500k ON hierarchy_cb_2014_us_500k (cb_2014_us_state_500k);

-- SQL statement 155: Comment table: hierarchy_cb_2014_us_500k >>>
COMMENT /*
 * SQL statement name: 	comment_table.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
	ON TABLE hierarchy_cb_2014_us_500k IS 'Hierarchy lookup table for Description of: cb_2014_us_nation_5m';

-- SQL statement 156: Create function check_hierarchy_cb_2014_us_500k >>>
CREATE OR REPLACE FUNCTION check_hierarchy_cb_2014_us_500k(l_geography VARCHAR, l_hierarchytable VARCHAR, l_type VARCHAR)
RETURNS integer 
SECURITY INVOKER
AS $body$
/*
 * SQL statement name: 	check_hierarchy_function.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: function name; e.g. check_hierarchy_cb_2014_us_500k
 *
 * Description:			Create hierarchy check function
 * Note:				%% becomes % after substitution
 */
 
/*
Function: 		check_hierarchy_cb_2014_us_500k()
Parameters:		Geography, hierarchy table, type: 'missing', 'spurious additional' or 'multiple hierarchy'
Returns:		Nothing
Description:	Diff geography hierarchy table using dynamic method 4
				Also tests the hierarchy, i.e. all a higher resolutuion is contained by one of the next higher and so on
 */
DECLARE
	c2 CURSOR(l_geography VARCHAR) FOR
		SELECT * 
		  FROM geolevels_cb_2014_us_500k
		 WHERE geography = l_geography
		 ORDER BY geolevel_id;
	c3 REFCURSOR;
	c4 CURSOR(l_geography VARCHAR, l_geolevel_id INTEGER) FOR
		SELECT * 
		  FROM geolevels_cb_2014_us_500k
		 WHERE geography   = l_geography
		   AND geolevel_id = l_geolevel_id
		 ORDER BY geolevel_id;
--
	c2_rec geolevels_cb_2014_us_500k%ROWTYPE;
	c3_rec RECORD;
	c4_rec geolevels_cb_2014_us_500k%ROWTYPE;
--
	sql_stmt 		VARCHAR;
	previous_geolevel_name 	VARCHAR:=NULL;
	i INTEGER;
	e INTEGER:=0;
	field INTEGER;
BEGIN
--
	sql_stmt:='WITH /* '||l_type||' */ ';
	i:=0;
	FOR c2_rec IN c2(l_geography) LOOP
		i:=i+1;
		IF l_type = 'multiple hierarchy' THEN
			IF i = 1 THEN
				NULL;
			ELSIF i > 2 THEN
				sql_stmt:=sql_stmt||', '||quote_ident('a'||c2_rec.geolevel_id)||' AS ('||E'\n';
				sql_stmt:=sql_stmt||E'\t'||'SELECT COUNT(*) AS '||quote_ident(LOWER(c2_rec.geolevel_name)||'_total')||E'\n';
				sql_stmt:=sql_stmt||E'\t'||'  FROM ('||E'\n';
			ELSE
				sql_stmt:=sql_stmt||quote_ident('a'||c2_rec.geolevel_id)||' AS ('||E'\n';
				sql_stmt:=sql_stmt||E'\t'||'SELECT COUNT(*) AS '||quote_ident(LOWER(c2_rec.geolevel_name)||'_total')||E'\n';
				sql_stmt:=sql_stmt||E'\t'||'  FROM ('||E'\n';
			END IF;
		ELSE
			IF i != 1 THEN
				sql_stmt:=sql_stmt||', '||quote_ident('a'||c2_rec.geolevel_id)||' AS ('||E'\n';
			ELSE
				sql_stmt:=sql_stmt||quote_ident('a'||c2_rec.geolevel_id)||' AS ('||E'\n';
			END IF;
			sql_stmt:=sql_stmt||E'\t'||'SELECT COUNT(*) AS '||quote_ident(LOWER(c2_rec.geolevel_name)||'_total')||E'\n';
			sql_stmt:=sql_stmt||E'\t'||'  FROM ('||E'\n';
		END IF;
		IF l_type = 'missing' THEN
			sql_stmt:=sql_stmt||E'\t'||E'\t'||'SELECT '||quote_ident(LOWER(c2_rec.geolevel_name))||' FROM '||quote_ident(LOWER(l_hierarchytable))||E'\n';
			sql_stmt:=sql_stmt||E'\t'||E'\t'||'EXCEPT'||E'\n';
			sql_stmt:=sql_stmt||E'\t'||E'\t'||'SELECT '||quote_ident(LOWER(c2_rec.geolevel_name))||' FROM '||quote_ident(LOWER(c2_rec.lookup_table))||
				') '||quote_ident('as'||c2_rec.geolevel_id)||')'||E'\n';
		ELSIF l_type = 'spurious additional' THEN
			sql_stmt:=sql_stmt||E'\t'||E'\t'||'SELECT '||quote_ident(LOWER(c2_rec.geolevel_name))||' FROM '||quote_ident(LOWER(c2_rec.lookup_table))||E'\n';
			sql_stmt:=sql_stmt||E'\t'||E'\t'||'EXCEPT'||E'\n';
			sql_stmt:=sql_stmt||E'\t'||E'\t'||'SELECT '||quote_ident(LOWER(c2_rec.geolevel_name))||' FROM '||quote_ident(LOWER(l_hierarchytable))||
				') '||quote_ident('as'||c2_rec.geolevel_id)||')'||E'\n';
		ELSIF l_type = 'multiple hierarchy' THEN
			IF previous_geolevel_name IS NOT NULL THEN
				sql_stmt:=sql_stmt||E'\t'||E'\t'||'SELECT '||quote_ident(LOWER(c2_rec.geolevel_name))||
					', COUNT(DISTINCT('||previous_geolevel_name||')) AS total'||E'\n';
				sql_stmt:=sql_stmt||E'\t'||E'\t'||'  FROM '||quote_ident(LOWER(l_hierarchytable))||E'\n';
				sql_stmt:=sql_stmt||E'\t'||E'\t'||' GROUP BY '||quote_ident(LOWER(c2_rec.geolevel_name))||E'\n';
				sql_stmt:=sql_stmt||E'\t'||E'\t'||'HAVING COUNT(DISTINCT('||previous_geolevel_name||')) > 1'||
					') '||quote_ident('as'||c2_rec.geolevel_id)||')'||E'\n';
			END IF;
		ELSE
			RAISE EXCEPTION 'Invalid check type: %, valid types are: ''missing'', ''spurious additional'', or ''multiple hierarchy''', 
				l_type::VARCHAR 	/* Check type */;
		END IF;
		previous_geolevel_name:=quote_ident(LOWER(c2_rec.geolevel_name));
	END LOOP;
	sql_stmt:=sql_stmt||'SELECT ARRAY[';
	i:=0;
	FOR c2_rec IN c2(l_geography) LOOP
		i:=i+1;
		IF l_type = 'multiple hierarchy' THEN
			IF i = 1 THEN
				NULL;
			ELSIF i > 2 THEN
				sql_stmt:=sql_stmt||', '||quote_ident('a'||c2_rec.geolevel_id)||'.'||quote_ident(LOWER(c2_rec.geolevel_name)||'_total');
			ELSE
				sql_stmt:=sql_stmt||quote_ident('a'||c2_rec.geolevel_id)||'.'||quote_ident(LOWER(c2_rec.geolevel_name)||'_total');
			END IF;
		ELSE
			IF i != 1 THEN
				sql_stmt:=sql_stmt||', '||quote_ident('a'||c2_rec.geolevel_id)||'.'||quote_ident(LOWER(c2_rec.geolevel_name)||'_total');
			ELSE
				sql_stmt:=sql_stmt||quote_ident('a'||c2_rec.geolevel_id)||'.'||quote_ident(LOWER(c2_rec.geolevel_name)||'_total');
			END IF;
		END IF;
	END LOOP;
	sql_stmt:=sql_stmt||'] AS res_array'||E'\n'||'FROM ';
	i:=0;
	FOR c2_rec IN c2(l_geography) LOOP
		i:=i+1;
		IF l_type = 'multiple hierarchy' THEN
			IF i = 1 THEN
				NULL;
			ELSIF i > 2 THEN
				sql_stmt:=sql_stmt||', '||quote_ident('a'||c2_rec.geolevel_id);
			ELSE
				sql_stmt:=sql_stmt||quote_ident('a'||c2_rec.geolevel_id);
			END IF;
		ELSE
			IF i != 1 THEN
				sql_stmt:=sql_stmt||', '||quote_ident('a'||c2_rec.geolevel_id);
			ELSE
				sql_stmt:=sql_stmt||quote_ident('a'||c2_rec.geolevel_id);
			END IF;
		END IF;
	END LOOP;
--
	RAISE INFO 'SQL> %;', sql_stmt::VARCHAR;
	OPEN c3 FOR EXECUTE sql_stmt;
	FETCH c3 INTO c3_rec;
--
-- Process results array
--
	i:=0;
	FOREACH field IN ARRAY c3_rec.res_array LOOP
		i:=i+1;
		OPEN c4(l_geography, i);
		FETCH c4 INTO c4_rec;
		CLOSE c4;
		IF field != 0 THEN
			RAISE WARNING 'Geography: % geolevel %: [%] % codes: %', 
				l_geography::VARCHAR		/* Geography */, 
				i::VARCHAR					/* Geolevel ID */, 
				LOWER(c4_rec.geolevel_name)::VARCHAR	/* Geolevel name */, 
				l_type::VARCHAR				/* Check type */, 
				field::VARCHAR				/* Area ID */;
			e:=e+1;
		ELSE
			RAISE INFO 'Geography: % geolevel %: [%] no % codes', 
				l_geography::VARCHAR		/* Geography */, 
				i::VARCHAR					/* Geolevel ID */, 
				LOWER(c4_rec.geolevel_name)::VARCHAR	/* Geolevel name */, 
				l_type::VARCHAR				/* Check type */;
		END IF;
	END LOOP;
--
	RETURN e;
END;
$body$
LANGUAGE PLPGSQL;

-- SQL statement 157: Comment function check_hierarchy_cb_2014_us_500k >>>
COMMENT /*
 * SQL statement name: 	check_hierarchy_function_comment.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: function name; e.g. check_hierarchy_cb_2014_us_500k
 *
 * Description:			Create hierarchy check function comment
 * Note:				%% becomes % after substitution
 */
	ON FUNCTION check_hierarchy_cb_2014_us_500k(VARCHAR, VARCHAR, VARCHAR) IS 'Function: 		check_hierarchy_cb_2014_us_500k()
Parameters:		Geography, hierarchy table, type: "missing", "spurious additional" or "multiple hierarchy"
Returns:		Nothing
Description:	Diff geography hierarchy table using dynamic method 4
				Also tests the hierarchy, i.e. all a higher resolutuion is contained by one of the next higher and so on

Example of dynamic SQL. Note the use of an array return type to achieve method 4

WITH /* missing */ a1 AS (
        SELECT COUNT(*) AS cb_2014_us_nation_5m_total
          FROM (
                SELECT cb_2014_us_nation_5m FROM hierarchy_cb_2014_us_500k
                EXCEPT
                SELECT cb_2014_us_nation_5m FROM lookup_cb_2014_us_nation_5m) as1)
, a2 AS (
        SELECT COUNT(*) AS cb_2014_us_state_500k_total
          FROM (
                SELECT cb_2014_us_state_500k FROM hierarchy_cb_2014_us_500k
                EXCEPT
                SELECT cb_2014_us_state_500k FROM lookup_cb_2014_us_state_500k) as2)
, a3 AS (
        SELECT COUNT(*) AS cb_2014_us_county_500k_total
          FROM (
                SELECT cb_2014_us_county_500k FROM hierarchy_cb_2014_us_500k
                EXCEPT
                SELECT cb_2014_us_county_500k FROM lookup_cb_2014_us_county_500k) as3)
SELECT ARRAY[a1.cb_2014_us_nation_5m_total, a2.cb_2014_us_state_500k_total, a3.cb_2014_us_county_500k_total] AS res_array
FROM a1, a2, a3;

Or: 

WITH /* multiple hierarchy */ a2 AS (
        SELECT COUNT(*) AS cb_2014_us_state_500k_total
          FROM (
                SELECT cb_2014_us_state_500k, COUNT(DISTINCT(cb_2014_us_nation_5m)) AS total
                  FROM hierarchy_cb_2014_us_500k
                 GROUP BY cb_2014_us_state_500k
                HAVING COUNT(DISTINCT(cb_2014_us_nation_5m)) > 1) as2)
, a3 AS (
        SELECT COUNT(*) AS cb_2014_us_county_500k_total
          FROM (
                SELECT cb_2014_us_county_500k, COUNT(DISTINCT(cb_2014_us_state_500k)) AS total
                  FROM hierarchy_cb_2014_us_500k
                 GROUP BY cb_2014_us_county_500k
                HAVING COUNT(DISTINCT(cb_2014_us_state_500k)) > 1) as3)
SELECT ARRAY[a2.cb_2014_us_state_500k_total, a3.cb_2014_us_county_500k_total] AS res_array
FROM a2, a3;
';

-- SQL statement 158: Insert into hierarchy_cb_2014_us_500k >>>
DO LANGUAGE plpgsql $$
DECLARE
/*
 * SQL statement name: 	insert_hierarchy.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: geography; e.g. cb_2014_us_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 */
	l_geography VARCHAR:='cb_2014_us_500k';
--
	c1_hier CURSOR(l_geography VARCHAR) FOR
		SELECT * 
		  FROM geolevels_cb_2014_us_500k
		 WHERE geography = l_geography
		 ORDER BY geography, geolevel_id;
	c2_hier CURSOR(l_geography VARCHAR) FOR
		SELECT * FROM pg_indexes
		 WHERE schemaname = USER
		   AND tablename IN (SELECT DISTINCT LOWER(hierarchytable)
				       FROM geography_cb_2014_us_500k
				      WHERE geography = l_geography)
		 ORDER BY 1;	
	c3 REFCURSOR;
	c4_hier CURSOR(l_geography VARCHAR) FOR
		SELECT *
		  FROM geography_cb_2014_us_500k
		 WHERE geography = l_geography;
	c1_rec geolevels_cb_2014_us_500k%ROWTYPE;
	c2_rec geography_cb_2014_us_500k%ROWTYPE;
	c3_rec	RECORD;
	c4_rec geography_cb_2014_us_500k%ROWTYPE;
--
	columns			VARCHAR;
	sql_stmt	 	VARCHAR;
	i				INTEGER:=0;
	num_geolevels	INTEGER:=0;
--
	geolevel_name			VARCHAR[];
	shapefile_table      		VARCHAR[];
 	shapefile_area_id_column	VARCHAR[];
 	shapefile_desc_column		VARCHAR[];
--
BEGIN
--
	OPEN c4_hier(l_geography);
	FETCH c4_hier INTO c4_rec;
	CLOSE c4_hier;
--
	IF c4_rec.geography IS NULL THEN
		RAISE EXCEPTION 'geography: % not found', 
			l_geography::VARCHAR	/* Geography */;
	END IF;	
--
	 RAISE INFO 'Populating % geography hierarchy table: %',
		l_geography, c4_rec.hierarchytable;
--
-- INSERT statement
--
	sql_stmt:='INSERT INTO '||quote_ident(LOWER(c4_rec.hierarchytable))||' (';
	FOR c1_rec IN c1_hier(l_geography) LOOP
		i:=i+1;
		geolevel_name[i]:=quote_ident(LOWER(c1_rec.geolevel_name));
		shapefile_table[i]:=quote_ident(LOWER(c1_rec.shapefile_table));      	
 		shapefile_area_id_column[i]:=quote_ident(LOWER(c1_rec.shapefile_area_id_column));	
 		shapefile_desc_column[i]:=quote_ident(LOWER(c1_rec.shapefile_desc_column));	
		IF i = 1 THEN
			columns:=geolevel_name[i];
		ELSE
			columns:=columns||', '||geolevel_name[i];
		END IF;
	END LOOP;
	num_geolevels:=i;
	IF num_geolevels = 0 THEN
		RAISE EXCEPTION 'No rows found in: geolevels_cb_2014_us_500k for geography %', 
			l_geography::VARCHAR /* Geography */;
	END IF;
	sql_stmt:=sql_stmt||columns||')'||E'\n';
--
-- Start SELECT statement; WITH clause; aggreagate geometries
--
-- Removed ST_Union for performance reasons
--

--
-- WITH clause - INTERSECTION
--
	FOR i IN 1 .. num_geolevels LOOP /* WITH clause - INTERSECTION */
/* E.g

x23 AS (
	SELECT a2.areaid AS level2, a3.areaid AS level3,
  	       ST_Area(a3.geom) AS a3_area,
	       ST_Area(ST_Intersection(a2.geom, a3.geom)) a23_area
          FROM a2 CROSS JOIN a3
	 WHERE ST_Intersects(a2.geom, a3.geom)
 */
		IF i = 1 THEN
			sql_stmt:=sql_stmt||
				'WITH x'||i||i+1||' AS ( /* Subqueries x'||i||i+1||' ... x'||num_geolevels-1||num_geolevels||': intersection aggregate geometries starting from the lowest resolution.'||E'\n'||
         		      	E'\t'||'       Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.'||E'\n'||
 	       			E'\t'||'       Calculate the area of the higher resolution geolevel and the area of the intersected area */'||E'\n'||
				'SELECT a'||i||'.areaid AS '||geolevel_name[i]||', a'||i+1||'.areaid AS '||geolevel_name[i+1]||','||E'\n'||
				'       ST_Area(a'||i+1||'.geom_11) AS a'||i+1||'_area,'||E'\n'||
				'       ST_Area(ST_Intersection(a'||i||'.geom_11, a'||i+1||'.geom_11)) AS a'||i||i+1||'_area'||E'\n'||
				'  FROM '||shapefile_table[i]||' a'||i||' CROSS JOIN '||shapefile_table[i+1]||' a'||i+1||''||E'\n'||
				' WHERE ST_Intersects(a'||i||'.geom_11, a'||i+1||'.geom_11)'||E'\n'||
				'), ';
		ELSIF i < (num_geolevels-1) THEN
			sql_stmt:=sql_stmt||
				'x'||i||i+1||' AS ( /* Subqueries x'||i||i+1||' ... x'||num_geolevels-1||num_geolevels||': intersection aggregate geometries starting from the lowest resolution.'||E'\n'||
         		      	E'\t'||'       Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.'||E'\n'||
 	       			E'\t'||'       Calculate the area of the higher resolution geolevel and the area of the intersected area */'||E'\n'||
				'SELECT a'||i||'.areaid AS '||geolevel_name[i]||', a'||i+1||'.areaid AS '||geolevel_name[i+1]||','||E'\n'||
				'       ST_Area(a'||i+1||'.geom_11) AS a'||i+1||'_area,'||E'\n'||
				'       ST_Area(ST_Intersection(a'||i||'.geom_11, a'||i+1||'.geom_11)) AS a'||i||i+1||'_area'||E'\n'||
				'  FROM '||shapefile_table[i]||' a'||i||' CROSS JOIN '||shapefile_table[i+1]||' a'||i+1||''||E'\n'||
				' WHERE ST_Intersects(a'||i||'.geom_11, a'||i+1||'.geom_11)'||E'\n'||
				'), ';
		ELSIF i < num_geolevels THEN
/* E.g.

 x34 AS (
	SELECT a3.level3, a4.level4,
	       total_a3_gid, total_a4_gid,
  	       ST_Area(a4.geom) AS a4_area,
	       ST_Area(ST_Intersection(a3.geom, a4.geom)) a34_area
          FROM a3 CROSS JOIN a4
	 WHERE ST_Intersects(a3.geom, a4.geom)
*/
			sql_stmt:=sql_stmt||
				'x'||i||i+1||' AS ( /* Subqueries x'||i||i+1||' ... x'||num_geolevels-1||num_geolevels||': intersection aggregate geometries starting from the lowest resolution.'||E'\n'||
         		      	E'\t'||'       Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.'||E'\n'||
 	       			E'\t'||'       Calculate the area of the higher resolution geolevel and the area of the intersected area */'||E'\n'||
				'SELECT a'||i||'.areaid AS '||geolevel_name[i]||', a'||i+1||'.areaid AS '||geolevel_name[i+1]||','||E'\n'||
				'       ST_Area(a'||i+1||'.geom_11) AS a'||i+1||'_area,'||E'\n'||
				'       ST_Area(ST_Intersection(a'||i||'.geom_11, a'||i+1||'.geom_11)) AS a'||i||i+1||'_area'||E'\n'||
				'  FROM '||shapefile_table[i]||' a'||i||' CROSS JOIN '||shapefile_table[i+1]||' a'||i+1||''||E'\n'||
				' WHERE ST_Intersects(a'||i||'.geom_11, a'||i+1||'.geom_11)'||E'\n'||
				'), ';
		END IF;
	END LOOP;
--
-- Compute intersected area, order analytically
--

/*
y AS ( 
	SELECT x12.level1, x12.level2, x23.level3, x34.level4, 
	       CASE WHEN a2_area > 0 THEN a12_area/a2_area ELSE NULL END test12,
	       CASE WHEN a3_area > 0 THEN a23_area/a3_area ELSE NULL END test23,
	       CASE WHEN a4_area > 0 THEN a34_area/a4_area ELSE NULL END test34,
	       MAX(a12_area/a2_area) OVER (PARTITION BY x12.level2) AS max12,
	       MAX(a23_area/a3_area) OVER (PARTITION BY x23.level3) AS max23,
	       MAX(a34_area/a4_area) OVER (PARTITION BY x34.level4) AS max34
	  FROM x12, x23, x34
	 WHERE x12.level2 = x23.level2
   	   AND x23.level3 = x34.level3
)
 */
	sql_stmt:=sql_stmt||
		'y AS ( /* Join x'||i||i+1||' ... x'||num_geolevels-1||num_geolevels||
			'intersections, pass through the computed areas, compute intersected area/higher resolution geolevel area,'||E'\n'||
		E'\t'||'     compute maximum intersected area/higher resolution geolevel area using an analytic partition of all'||E'\n'||
		E'\t'||'     duplicate higher resolution geolevels */'||E'\n';
	FOR i IN 1 .. num_geolevels LOOP /* x12.level1, x12.level2, x23.level3, x34.level4, */
		IF i < num_geolevels THEN
			IF i = 1 THEN
				sql_stmt:=sql_stmt||
					'SELECT x'||i||i+1||'.'||geolevel_name[i]||', '||E'\n';
			END IF;
			sql_stmt:=sql_stmt||
				'       x'||i||i+1||'.'||geolevel_name[i+1]||', '||E'\n';
		END IF;
	END LOOP;
	FOR i IN 1 .. num_geolevels LOOP /* CASE MAX analytic clause */ 
		IF i < num_geolevels THEN
			sql_stmt:=sql_stmt||
	    		   	'       CASE WHEN x'||i||i+1||'.a'||i+1||'_area > 0 THEN x'||i||i+1||'.a'||i||i+1||'_area/x'||i||i+1||'.a'||i+1||
				'_area ELSE NULL END test'||i||i+1||','||E'\n';
			sql_stmt:=sql_stmt||
				'       MAX(x'||i||i+1||'.a'||i||i+1||'_area/x'||i||i+1||'.a'||i+1||'_area)'||
				' OVER (PARTITION BY x'||i||i+1||'.'||geolevel_name[i+1]||') AS max'||i||i+1||','||E'\n';
		END IF;
	END LOOP;
	sql_stmt:=SUBSTR(sql_stmt, 1, LENGTH(sql_stmt)-LENGTH(','||E'\n')) /* Chop off last ",\n" */||E'\n';
	FOR i IN 1 .. num_geolevels LOOP /* FROM clause */ 
		IF i < num_geolevels THEN
			IF i = 1 THEN
				sql_stmt:=sql_stmt||
					'  FROM x'||i||i+1;
			ELSE
				sql_stmt:=sql_stmt||
					', x'||i||i+1;
			END IF;
		END IF;
	END LOOP;
	FOR i IN 1 .. (num_geolevels-2) LOOP /* WHERE clause */ 
		IF i = 1 THEN
			sql_stmt:=sql_stmt||E'\n'||
				' WHERE x'||i||i+1||'.'||geolevel_name[i+1]||' = x'||i+1||i+2||'.'||geolevel_name[i+1];
		ELSE
			sql_stmt:=sql_stmt||E'\n'||
				'   AND x'||i||i+1||'.'||geolevel_name[i+1]||' = x'||i+1||i+2||'.'||geolevel_name[i+1];
		END IF;
	END LOOP;
	sql_stmt:=sql_stmt||E'\n'||')'||E'\n';
--
-- Final SELECT
--
	sql_stmt:=sql_stmt||'SELECT /* Select y intersection, eliminating duplicates using selecting the lower geolevel resolution'||E'\n'||
         E'\t'||' with the largest intersection by area for each (higher resolution) geolevel */'||E'\n'||'       '||columns||E'\n';
	sql_stmt:=sql_stmt||'  FROM y'||E'\n';
/*
SELECT level1, level2, level3, level4,
  FROM y
 WHERE max12 = test12
   AND max23 = test23
   AND max34 = test34
 ORDER BY 1, 2, 3, 4;  
 */
	FOR i IN 1 .. num_geolevels LOOP /* FROM clause */ 
		IF i < num_geolevels THEN
			IF i = 1 THEN
				sql_stmt:=sql_stmt||' WHERE max'||i||i+1||' = test'||i||i+1||E'\n';
			ELSE
				sql_stmt:=sql_stmt||'   AND max'||i||i+1||' = test'||i||i+1||E'\n';
			END IF;
		END IF;
	END LOOP;
	
	sql_stmt:=sql_stmt||' ORDER BY 1';
	FOR i IN 2 .. num_geolevels LOOP /* ORDER BY clause */ 	
		sql_stmt:=sql_stmt||', '||i;
	END LOOP;
	
	RAISE NOTICE 'SQL> %;', sql_stmt;
	EXECUTE sql_stmt;
--
-- Check rows were inserted
--
	sql_stmt:='SELECT COUNT(*) AS total FROM '||quote_ident(LOWER(c4_rec.hierarchytable));
	OPEN c3 FOR EXECUTE sql_stmt;
	FETCH c3 INTO c3_rec;
	CLOSE c3;	
	IF c3_rec.total = 0 THEN
		RAISE EXCEPTION 'No rows found in % geography hierarchy table: %', 
			l_geography::VARCHAR 			/* Geography */,
			quote_ident(LOWER(c4_rec.hierarchytable))	/* Hierarchy table */;
	END IF;
--
-- Re-index
--
	FOR c2_rec IN c2_hier(l_geography) LOOP
		sql_stmt:='REINDEX INDEX /* '||quote_ident(c2_rec.tablename)||' */ '||quote_ident(c2_rec.indexname);
		RAISE NOTICE 'SQL> %;', sql_stmt;
		EXECUTE sql_stmt;
	END LOOP;
--
-- Analyze
--
	sql_stmt:='ANALYZE VERBOSE '||quote_ident(LOWER(c4_rec.hierarchytable));
	RAISE NOTICE 'SQL> %;', sql_stmt;
	EXECUTE sql_stmt;
END;
$$;

-- SQL statement 159: Check intersctions  for geograpy: cb_2014_us_500k >>>
DO LANGUAGE plpgsql $$
DECLARE
/*
 * SQL statement name: 	check_intersections.sql
 * Type:				Postgres/PostGIS PL/pgsql anonymous block
 * Parameters:
 *						1: geography; e.g. cb_2014_us_500k
 *
 * Description:			Check intersections
 * Note:				%% becomes % after substitution
 */
	l_geography VARCHAR:='cb_2014_us_500k';
--
	c1 CURSOR(l_geography VARCHAR) FOR
		SELECT *
		  FROM geography_cb_2014_us_500k
		 WHERE geography = l_geography;
	c1_rec geography_cb_2014_us_500k%ROWTYPE;
--
	e INTEGER:=0;
	f INTEGER:=0;
	g INTEGER:=0;
BEGIN
--
	OPEN c1(l_geography);
	FETCH c1 INTO c1_rec;
	CLOSE c1;
--
	IF c1_rec.geography IS NULL THEN
		RAISE EXCEPTION 'geography: % not found', 
			l_geography::VARCHAR	/* Geography */;
	END IF;	
--
-- Call diff and multiple hierarchy tests
--
	e:=check_hierarchy_cb_2014_us_500k(c1_rec.geography, c1_rec.hierarchytable, 'missing');
	f:=check_hierarchy_cb_2014_us_500k(c1_rec.geography, c1_rec.hierarchytable, 'spurious additional');
	g:=check_hierarchy_cb_2014_us_500k(c1_rec.geography, c1_rec.hierarchytable, 'multiple hierarchy');
--
	IF e+f > 0 THEN
		RAISE EXCEPTION 'Geography: % codes check % missing, % spurious additional, % hierarchy fails', 
			c1_rec.geography	/* Geography */, 
			e::VARCHAR		/* Missing */, 
			f::VARCHAR		/* Spurious additional */, 
			g::VARCHAR		/* Multiple hierarchy */;
	ELSE
		RAISE INFO 'Geography: % codes check OK', 
			c1_rec.geography::VARCHAR	/* Geography */;
	END IF;
END;
$$;

-- SQL statement 160: Commit transaction >>>
END;

--
-- Analyze tables
--

-- SQL statement 162: Describe table cb_2014_us_county_500k >>>
\dS+ cb_2014_us_county_500k;

-- SQL statement 163: Analyze table cb_2014_us_county_500k >>>
VACUUM ANALYZE cb_2014_us_county_500k;

-- SQL statement 164: Describe table lookup_cb_2014_us_county_500k >>>
\dS+ lookup_cb_2014_us_county_500k;

-- SQL statement 165: Analyze table lookup_cb_2014_us_county_500k >>>
VACUUM ANALYZE lookup_cb_2014_us_county_500k;

-- SQL statement 166: Describe table cb_2014_us_nation_5m >>>
\dS+ cb_2014_us_nation_5m;

-- SQL statement 167: Analyze table cb_2014_us_nation_5m >>>
VACUUM ANALYZE cb_2014_us_nation_5m;

-- SQL statement 168: Describe table lookup_cb_2014_us_nation_5m >>>
\dS+ lookup_cb_2014_us_nation_5m;

-- SQL statement 169: Analyze table lookup_cb_2014_us_nation_5m >>>
VACUUM ANALYZE lookup_cb_2014_us_nation_5m;

-- SQL statement 170: Describe table cb_2014_us_state_500k >>>
\dS+ cb_2014_us_state_500k;

-- SQL statement 171: Analyze table cb_2014_us_state_500k >>>
VACUUM ANALYZE cb_2014_us_state_500k;

-- SQL statement 172: Describe table lookup_cb_2014_us_state_500k >>>
\dS+ lookup_cb_2014_us_state_500k;

-- SQL statement 173: Analyze table lookup_cb_2014_us_state_500k >>>
VACUUM ANALYZE lookup_cb_2014_us_state_500k;

-- SQL statement 174: Describe table geolevels_cb_2014_us_500k >>>
\dS+ geolevels_cb_2014_us_500k;

-- SQL statement 175: Analyze table geolevels_cb_2014_us_500k >>>
VACUUM ANALYZE geolevels_cb_2014_us_500k;

-- SQL statement 176: Describe table geography_cb_2014_us_500k >>>
\dS+ geography_cb_2014_us_500k;

-- SQL statement 177: Analyze table geography_cb_2014_us_500k >>>
VACUUM ANALYZE geography_cb_2014_us_500k;

-- SQL statement 178: Describe table hierarchy_cb_2014_us_500k >>>
\dS+ hierarchy_cb_2014_us_500k;

-- SQL statement 179: Analyze table hierarchy_cb_2014_us_500k >>>
VACUUM ANALYZE hierarchy_cb_2014_us_500k;


--
-- EOF
