<html>
  <head>
	<script src="jquery-2.2.3.js"></script> 
    <link rel="stylesheet" href="leaflet/leaflet.css" />
    <script src="leaflet/leaflet.js"></script>
    <script src="topojson.min.js"></script>
    <link rel="stylesheet" href="leaflet.zoomdisplay.css" />
    <script src="leaflet.zoomdisplay.js"></script>
    <title>Shapefile Uploading Form</title>
  </head>
  <body onload="setupMap();">
    <div id="header">
      <h4>Shapefile Upload</h4>
    </div>
  <div id="nav">
	<form action="/shpConvert" method="POST" id="shpConvert"
		  enctype="multipart/form-data">
	  Select a set/sets of shapefile files to upload: <input type="file" id="files" size="50" multiple="multiple" />
	  <!-- Use multi file submit -->

      <input type="submit" id="submit_handle" style="display: none"> 
	  <div id="conversion"><!--
	  Select conversion:
	  <input type="radio" id="output_type_geojson" name="output_type" value="shp2GeoJSON" checked>GeoJSON
	  <input type="radio" id="output_type_topojson" name="output_type" value="shp2TopoJSON">TopoJSON
	  <input type="radio" id="output_type_wkt" name="output_type" value="shp2WKT">Well Known text (WKT) --></div></br>
	  Diagnostics:
	  <input type="checkbox" id="verbose" value="true">
	  <button type="button" id="save" onclick="submitForm()">Upload Files</button></br>	  
	</form>
  </div>
  <div id="workarea">
	<div id="status"></div>
	<div id="map"></div>
	<div id="footer">
	  Copyright &copy; UK Small Area Health Statistics Unit
	</div>
   </div>
    <style>
#header {
    background-color:black;
	width: 100%;
    height: 30px;
    color:white;
    padding:0px; 
    text-align:center;
}
#header.h4 {
}
#nav {
    line-height:30px;
    background-color:#eeeeee;
    height: 60px;
	width: 100%
    float:left;
    padding-left:5px; 
    padding-right:5px; 
}
#status {
    width:600px;
    float:left;
    padding:5px; 
}
#footer {
    background-color:#eeeeee;
    color:black;
    clear:both;
    text-align:center;
    padding:5px; 
    height: 14px;
    vertical-align:bottom;
}
#save {
    float:right;
    padding:5px; 
    margin: 0 0 10px 10px;
}
#map {
	width:550px; 
	height:550px; 
    float:right;
}
#conversion {
    float:right;
}
table {
    color:rgb(0, 200, 255);
    font-family: courier;
    font-size:75%;
}
button {
    text-rendering: auto;
    color: initial;
    letter-spacing: normal;
    word-spacing: normal;
    text-transform: none;
    text-indent: 0px;
    text-shadow: none;
    display: inline-block;
    text-align: start;
    margin: 0em 0em 0em 0em;
    font: 12px Arial;
	border-radius: 12px;
}
    </style>
    <script>
						
var map;
var tileLayer;
var JSONLayer;

// Extend Leaflet to use topoJSON
L.topoJson = L.GeoJSON.extend({  
  addData: function(jsonData) {    
    if (jsonData.type === "Topology") {
      for (key in jsonData.objects) {
        geojson = topojson.feature(jsonData, jsonData.objects[key]);
        L.GeoJSON.prototype.addData.call(this, geojson);
      }
    }    
    else {
      L.GeoJSON.prototype.addData.call(this, jsonData);
    }
  }  
});
// Copyright (c) 2013 Ryan Clark

function setupMap() {	
	var w = window.innerWidth
		|| document.documentElement.clientWidth
		|| document.body.clientWidth;

	var h = window.innerHeight
		|| document.documentElement.clientHeight
		|| document.body.clientHeight;
	if (h && w) {
		var old_w=document.getElementById('map').style.width;
		var old_h=document.getElementById('map').style.height;
		var new_w=w-700;
		var new_h=h-150;
		var new_status_width=w-new_w-50;
	
		document.getElementById('map').style.width=new_w;
		document.getElementById('map').style.height=new_h;
		document.getElementById('status').style.height=new_h;
		document.getElementById('status').style.width=new_status_width;
		
		document.getElementById('status').innerHTML = "Size h x w: " + h + "+" + w +
			"; map size old: " + old_h + "+" + old_w + ", new: " + new_h + "+" + new_w +
			"; new_status_width: " + new_status_width;
	}
}
	
/*
 * Function: 	generateUUID()
 * Parameters: 	None
 * Returns: 	RFC4122 version 4 compliant UUID
 * Description:	Generate a random UUID
 */
function generateUUID() { // Post by briguy37 on stackoverflow
    var d = new Date().getTime();
    if(window.performance && typeof window.performance.now === "function"){
        d += performance.now(); //use high-precision timer if available
    }
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = (d + Math.random()*16)%16 | 0;
        d = Math.floor(d/16);
        return (c=='x' ? r : (r&0x3|0x8)).toString(16);
    });
    return uuid;
}

// Display file size nicely	
function fileSize(file_size) {
	var niceFileSize;
	if (!file_size) {
		return undefined;
	}
	else if (file_size > 1024 * 1024 * 1024) {
		niceFileSize = (Math.round(file_size * 100 / (1024 * 1024 * 1024)) / 100).toString() + 'GB';
	}
	else if (file_size > 1024 * 1024) {
		niceFileSize = (Math.round(file_size * 100 / (1024 * 1024)) / 100).toString() + 'MB';
	} 
	else {
		niceFileSize = (Math.round(file_size * 100 / 1024) / 100).toString() + 'KB';
	}
	return niceFileSize;
}

function isIE() {
	var myNav = navigator.userAgent.toLowerCase();
	return (myNav.indexOf('msie') != -1) ? parseInt(myNav.split('msie')[1]) : false;
}
	
/*
 * Function: 	submitForm()
 * Parameters: 	None
 * Returns: 	Nothing
 * Description:	Submit form button
 */
function submitForm() {

	var files_elem=document.getElementById('files');
	var verbose=document.getElementById('verbose').checked;
	var output_type="shpConvert";
	var files = files_elem.files;
	var fileno = 0;
	var totalFileSize = 0;
	var timeout = 600*1000 // 600,000 ms; 10 minutes
	
	var request = new XMLHttpRequest();

    var formData = new FormData();
	var start = new Date().getTime();
	
	if (files.length == 0) {
		document.getElementById('status').innerHTML = "ERROR! No files selected, unable to upload.";
		return;
	}
	
	// Remove old map layers
	if (map) {
		map.eachLayer(function (layer) {
			console.log('Remove tileLayer');
			map.removeLayer(layer);
		});
	}
	
	if (verbose) { // i.e. diagnostics
		console.log('Verbose mode: ' + verbose);
		formData.append('verbose', verbose);
	}
	formData.append('my_reference', generateUUID()); // Random reference

	setStatus = function(msg, errm) {
		if (document.getElementById("status").innerHTML != msg) {
			var end=new Date().getTime();
			var elapsed=(end - start)/1000; // in S
			
			if (!errm) {
				document.getElementById("status").innerHTML = msg;
				console.log("[" + elapsed + "] " + msg);
			}
			else {
				document.getElementById("status").innerHTML = msg + "; " + errm;
				console.error("[" + elapsed + "] " + msg + "; " + errm);
			}
		}
	}
	
	try {
		request.open('POST', output_type);
			// Process results
	
		request.onreadystatechange = function() {
			
			if (request.readyState == 1) { 
				setStatus("Connected...");
			}
			else if (request.readyState == 2) { 
				setStatus("Request received...");
			}		
			else if (request.readyState == 3) { 
				setStatus("Processing request...");
			}
			else if (request.readyState == 4) {
				setStatus("Processing response..."); 
				displayResponse(request.response, request.status);
			}
			else {		
				setStatus("request.onreadystatechange() unknown state: " + request.readyState, "readyState error");
			}
		}

		if (isIE() && request.timeout) {
			request.timeout = timeout;
			console.log('IE Timeout set: ' + timeout);
		}
		else {
			request.timeout = timeout;
			console.log('Timeout set: ' + timeout);
		}
		request.ontimeout = function(e) {
			var end=new Date().getTime();
			var elapsed=(end - start)/1000; // in S
			
			if (e) {
				setStatus("Processing timed out after " + (timeout/1000) + " seconds", e.message);	
			}
			else {
				setStatus("Processing timed out after " + (timeout/1000) + " seconds", "timeout error");	
			}
		}
		
	}
	catch (e) {
		var end=new Date().getTime();
		var elapsed=(end - start)/1000; // in S
			
		setStatus("ERROR! Unable to open for post to: http://127.0.0.1:3000/" + output_type, e.message);
		return;
	}
	
	// 
	request.upload.onprogress = function(evt) {
		var end=new Date().getTime();
		var elapsed=(end - start)/1000; // in S
			
		if (evt.lengthComputable) {
			var percentComplete = Math.round(evt.loaded * 100 / evt.total);
			if (percentComplete == 100) {
				var end=new Date().getTime();
				var elapsed=(end - start)/1000; // in S
		
				if (fileno != files.length) {
					setStatus("Uploaded file " + fileno + "/" + files.length + ": " + 
						percentComplete.toString() + '%' + "; total: " + fileSize(totalFileSize));	
				}
				else {
					setStatus("Uploaded all " + files.length + " files " + 
						percentComplete.toString() + '%' + "; total: " + fileSize(totalFileSize) + "; sending to server...");	
				}
			}
			else {
				document.getElementById('status').innerHTML = "Uploading file " + fileno + "/" + files.length + ": " + 
					percentComplete.toString() + '%' + "; total: " + fileSize(totalFileSize);
			}
		}
		else {
			console.error("[" + elapsed + "] " + "ERROR! Uploading files: unable to compute percent complete", "UNKNOWN");
		}
	}	

	// Process submitted files
	for (var fileno = 0; fileno < files.length; ++fileno) {
		var file=files[fileno];
		if (file !== null) {
				
			var name = file.name;
			var reader = new FileReader();

			reader.onload = function(event) {
				var arrayBuf = new Uint8Array(event.target.result);
				var arrayIndex = 0;		  
			}
			reader.onerror = function(err) {
				setStatus("ERROR! Unable to upload file + " + fileno + "/" + files.length + ": " + 
					name, err); 		
				return;
			}
			totalFileSize+=file.size;
			formData.append('file[]', file, name);
			console.log('Loading file [' + fileno + ']: ' + name + "; " + fileSize(file.size));	
			
			reader.readAsArrayBuffer(file);
		}
	}

	try {			
		setStatus("Sending to server...");
		request.send(formData);	
		return;
	}
	catch (e) {
		setStatus("ERROR! Unable to post to: http://127.0.0.1:3000/" + output_type, e.message);
		return;
	}		
//    request.sendAsBinary(formData); // Bad crash!!
  

}

function createMap(boundingBox) {
	console.log('New map');	
	var map = new L.map('map');
	var msg;
	
	try {
		map.fitBounds([
			[boundingBox.ymin, boundingBox.xmin],
			[boundingBox.ymax, boundingBox.xmax]], {maxZoom: 11}
		);
	}
	catch (e) {
		msg="Unable to create map: " + e.message;
		console.error(msg);
		document.getElementById("status").innerHTML = msg;	
		map.remove(); 
		return undefined;
	}

	try {
		document.getElementById("status").innerHTML = "Creating basemap...";															
		console.log('New tileLayer');
		tileLayer=L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpandmbXliNDBjZWd2M2x6bDk3c2ZtOTkifQ._QA7i5Mpkd_m30IGElHziw', {
			maxZoom: 9,
			attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, ' +
				'<a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
				'Imagery &copy; <a href="http://mapbox.com">Mapbox</a>',
			id: 'mapbox.light'
		});
		tileLayer.addTo(map);	
		L.control.scale().addTo(map); // Add scale
	
		console.log('Added tileLayer and scale to map');	
	
		return map;
	}
	catch (e) {
		msg="Unable to add tile layer to map: " + e.message;
		console.error(msg);
		document.getElementById("status").innerHTML = msg;	
		map.remove(); 
		return undefined;
	}

}

/*
 * Function: 	displayResponse()
 * Parameters: 	Response text (JSON as a string), status code
 * Returns: 	Nothing
 * Description:	Display reponse from submit form
 */
function displayResponse(responseText, status) {
	var response;
	var msg="";
	var responseErrors=0;
	var JSONLayer=[];
	
	document.getElementById("status").innerHTML = "Processing response from server...";
	try {
		response=JSON.parse(responseText);
	} catch (e) {  
		if (responseText) {
			document.getElementById("status").innerHTML = "<h1>Send Failed</h1><h2>Error parsing response: " +  
				e.message +"</h2><p>Reponse:" + responseText + "</p>";
		}
		else {
			document.getElementById("status").innerHTML = "<h1>Send Failed</h1><h2>Error parsing response: " +  
				e.message +"</h2><p>no response from server</p>";
		}
		return;
	}
	
	if (response.error) {
		msg+="<p>Error message" + response.error + "</p>"
	}

	if (!response.no_files) {
		msg+="<p>No processed shape files returned [ERROR!]</p>";
	}
	else {
		msg+="<p>Shape files processed: " + response.no_files;
		if (!response.file_list) {
			msg+="; no file list";	
		}
		else {
			if (response.no_files > 0) {
				if (!response.file_list[0]) {
					msg+="; problem with file list";
					console.error("First file in list (size: " + response.no_files + ") is not defined");	
				}
				else {
					msg+="<table border=\"1\" style=\"width:100%\">" + 
					"<tr><th>No.</th><th>File</th><th>JSON length</th>" +
					"<th>File size</th><th>Areas</th><th>Geojson convert time (S)</th>" +
					"<th>Geo level</th><th>Area (Km<sup>2</sup>)</th>" + 
					"<th>SRID</th>" +
					"</tr>";			
							
					if (!response.file_list[0].boundingBox) {
						msg+="; no bounding Box";
						console.log('bounding Box is not defined');	
					}
					else {
						if (!map) {
							map=createMap(response.file_list[0].boundingBox);
						}
						else {
							var centre=map.getCenter();
								
							console.log("Centre: " + centre.lat + ", " + centre.lng);
	//						if (+centre.lat.toFixed(4) == +y_avg.toFixed(4) && 
	//							+centre.lng.toFixed(4) == +x_avg.toFixed(4)) {
	//							console.log("Map centre has not changed");
	//						}
	//						else {
								map.eachLayer(function (layer) {
									console.log('Remove tileLayer');
									map.removeLayer(layer);
								});
								console.log('Remove map');
								map.remove(); // Known leaflet bug:
											  // Failed to execute 'removeChild' on 'Node': The node to be removed is not a child of this node.
								
								map=createMap(response.file_list[0].boundingBox);				
	//						}	
						}							
					
						var layerColours = [ // Some advice needed here!!!
							"#ff0000", // Red
							"#0000ff", // Blue
							"#00ff00", // Green
							"#ff00c8", // Magenta
							"#ffb700", // Orange
							"#f0f0f0", // Light grey
							"#0f0f0f"  // Onyx (nearly black)
							];
						
						var layerAddOrder = [];
						
	/*
	Add shapefiles starting from the highest resolution first:

	Add data to JSONLayer[0]; shapefile [3]: SAHSU_GRD_Level4.shp
	Add data to JSONLayer[1]; shapefile [2]: SAHSU_GRD_Level3.shp
	Add data to JSONLayer[2]; shapefile [1]: SAHSU_GRD_Level2.shp
	Add data to JSONLayer[3]; shapefile [0]: SAHSU_GRD_Level1.shp
	*/
					
						for (var i=0; i < response.no_files; i++) {	//. Re-order by geolevel_id	
							layerAddOrder[(response.no_files-response.file_list[i].geolevel_id)]=i;		
						}
						
						for (var i=0; i < response.no_files; i++) {	// Now processe					
							var weight=(response.no_files - i); // i.e. Lower numbers - high resolution have most weight
							var color=layerColours[i];	
		// Chroma.js - to be added (Node module)
		//					var colorScale = chroma  
		//						.scale(['#D5E3FF', '#003171'])
		//						.domain([0,1]);	
							var opacity;
							var fillOpacity;
		//					if (response.file_list[i].geolevel_id != response.no_files) { 
							if (i > 0) { // All but the first are transparent
								opacity=0;		
								fillOpacity=0;
							}
							else { // First - i.e. max geolevel
								opacity=1;
								fillOpacity=0.4;				
							}
		//					if (!color || response.file_list[i].geolevel_id == 1) {
							if (!color || i == (response.no_files - 1)) { // if >7 layers or lowest resolution (last layer) - make it black
								color="#000000"; // Black
								weight=response.no_files;
							}
					
							if (!response.file_list[layerAddOrder[i]] || !response.file_list[layerAddOrder[i]].file_name) {
								console.error("layerAddOrder problem: Add data to JSONLayer[" + i + "]; layerAddOrder[" + layerAddOrder[i] + "]: NO FILE");
							}
							console.log("Add data to JSONLayer[" + i + "]; shapefile [" + layerAddOrder[i] + "]: " +
								response.file_list[layerAddOrder[i]].file_name +
								"; colour: " + color + "; weight: " + weight + "; opacity: " + opacity + "; fillOpacity: " + fillOpacity);
								
							msg+="<tr style=\"color:" + color + "\"><td>" + (i+1) + "</td><td>" + response.file_list[layerAddOrder[i]].file_name + "</td><td>";
							if (response.file_list[layerAddOrder[i]].topojson) {			
								try {
//									var topojson = JSON.stringify(response.file_list[i].topojson);
									if (response.file_list[i].boundingBox && map) {
					
										if (JSONLayer[i]) {	
											console.log('Remove topoJSONLayer' + i + ']');
											map.removeLayer(JSONLayer[i]);
										}		
										
										console.log('New topoJSONLayer[' + i + '], color: ' + color);	
										document.getElementById("status").innerHTML = "Adding topoJSONLayer[" + i + "]...";	
										JSONLayer[i] = new L.topoJson(undefined, 
											{style: 
												{color: 	color,
												 fillColor: "#ccf4ff",
												 weight: 	weight, // i.e. Lower numbers have most weight
												 opacity: 	1,
												 fillOpacity: fillOpacity}
											}).addTo(map);
										JSONLayer[i].addData(response.file_list[layerAddOrder[i]].topojson);									
									}
									
									msg+=fileSize(response.file_list[layerAddOrder[i]].topojson_length) + "/" + fileSize(response.file_list[layerAddOrder[i]].geojson_length);
								} catch (e) {  							
									msg+="TopoJSON conversion error: " + e.message;
									responseErrors++;
								}
							}
							else if (response.file_list[layerAddOrder[i]].geojson) {			
								try {
//									var geojson = JSON.stringify(response.file_list[i].geojson);
									if (response.file_list[i].boundingBox && map) {
					
										if (JSONLayer[i]) {	
											console.log('Remove JSONLayer' + i + ']');
											map.removeLayer(JSONLayer[i]);
										}		
										
										console.log('New JSONLayer[' + i + '], color: ' + color);	
										document.getElementById("status").innerHTML = "Adding JSONLayer[" + i + "]...";	
										JSONLayer[i] = L.geoJson(undefined, 
											{style: 
												{color: 	color,
												 fillColor: "#ccf4ff",
												 weight: 	weight, // i.e. Lower numbers have most weight
												 opacity: 	1,
												 fillOpacity: fillOpacity}
											}).addTo(map);
										JSONLayer[i].addData(response.file_list[layerAddOrder[i]].geojson);									
									}
									
									msg+=fileSize(response.file_list[layerAddOrder[i]].geojson_length);
								} catch (e) {  							
									msg+="GeoJSON conversion error: " + e.message;
									responseErrors++;
								}
							}
							else {
								msg+="ERROR! no GeoJSON/topoJSON returned";
								responseErrors++;
							}
							msg+="</td><td>" + 
								(fileSize(response.file_list[i].file_size) || "Not Set") + "</td><td>" + 
								response.file_list[i].total_areas + "</td><td>" +
								(response.file_list[i].geojson_time || "Not converted") + "</td><td>" + 
								(response.file_list[i].geolevel_id || "N/A") + "</td><td>" + 
								(response.file_list[i].uncompress_size || "N/A") + "</td><td>" +
								(response.file_list[i].srid || "No SRID") + "</td>" +
								"</tr>";

						} // end of for loop

					} // response.file_list[0].boundingBox					
					msg+="</table>";			
				} // response.file_list[0] exists
				

			} // response.no_files > 0
			if (response.file_list[0].srid) {
				console.log("SRID: " + response.file_list[0].srid);
			}	
				
			if (response.file_list[0].projection_name) {
				console.log("Projection name: " + response.file_list[0].projection_name);
			}	
			
			if (response.file_list[0].boundingBox) {
				console.log("Bounding box [" +
							"xmin: " + response.file_list[0].boundingBox.xmin + ", " +
							"ymin: " + response.file_list[0].boundingBox.ymin + ", " +
							"xmax: " + response.file_list[0].boundingBox.xmax + ", " +
							"ymax: " + response.file_list[0].boundingBox.ymax + "]");
			}			
		}
	}
	msg+="</p>";

	if (response.fields) {
		var fieldCount=0;
		for (var field in response.fields) {
			fieldCount++;
			if (fieldCount == 1) {
				msg+="<p>Fields returned by shpConvert<ul id=\"fields\">";
			}
			msg+="<li>" + field + "=" + response.fields[field] + "</li>";
		}
		if (fieldCount > 0) {
			msg+="</ul></p>";
		}
	}	
	
	if (response.message) {
		msg+="<p>Processing diagnostic messages:</br><div id=\"div_message\" style=\"overflow:scroll; height: 400px;\"><pre>" + response.message + "</pre></div?</p>"
	}
	
	if (response.diagnostic) {
		msg+="<p>Processing diagnostic:</br><pre>" + response.diagnostic + "</pre></p>";
	}	
	
	if (status == 200 && responseErrors == 0 && map) {	
		document.getElementById("status").innerHTML = "<h1>Shapefile processed OK</h1>" + msg;
	}
	else if (status == 200 && responseErrors > 0 && map) {	
		document.getElementById("status").innerHTML = "<h1>Shapefile processed OK; but with " + 
			responseErrors + " error(s) in response</h1>" + msg;
	}
	else if (status == 200 && responseErrors > 0 && !map) {	
		document.getElementById("status").innerHTML = "<h1>Shapefile processed OK; but with " + 
			responseErrors + " error(s) in response; no map was produced</h1>" + '<h2>Error: ' + document.getElementById("status").innerHTML + '</h2>' +  msg;
	}	
	else if (status == 200 && responseErrors == 0 && !map) {	
		document.getElementById("status").innerHTML = "<h1>Shapefile processed OK; no map was produced</h1>" + '<h2>Error: ' + document.getElementById("status").innerHTML + '</h2>' + msg;
	}	
	else {
		document.getElementById("status").innerHTML = "<h1>Send Failed: " + status + "</h1>" + msg;
	}
}
</script>

  </body>
</html>