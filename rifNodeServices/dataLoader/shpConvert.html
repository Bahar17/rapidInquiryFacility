<html>
  <head>
	<script src="https://code.jquery.com/jquery-2.2.1.js"></script> 
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.css" />
    <script src="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.js"></script>
    <title>Shapefile Uploading Form</title>
  </head>
  <body onload="setupMap();">
    <div id="header">
      <h4>Shapefile Upload</h4>
    </div>
  <div id="nav">
	<form action="http://127.0.0.1:3000/shpConvert" method="POST" id="shpConvert"
		  enctype="multipart/form-data">
	  Select a set/sets of shapefile files to upload: <input type="file" id="files" size="50" multiple="multiple" />
	  <!-- Use multi file submit -->

      <input type="submit" id="submit_handle" style="display: none"> 
	  <div id="conversion"><!--
	  Select conversion:
	  <input type="radio" id="output_type_geojson" name="output_type" value="shp2GeoJSON" checked>GeoJSON
	  <input type="radio" id="output_type_topojson" name="output_type" value="shp2TopoJSON">TopoJSON
	  <input type="radio" id="output_type_wkt" name="output_type" value="shp2WKT">Well Known text (WKT) --></div></br>
	  Diagnostics:
	  <input type="checkbox" id="verbose" value="true">
	  <button type="button" id="save" onclick="submitForm()">Upload Files</button></br>	  
	</form>
  </div>
  <div id="workarea">
	<div id="status"></div>
	<div id="map"></div>
	<div id="footer">
	  Copyright &copy; UK Small Area Health Statistics Unit
	</div>
   </div>
    <style>
#header {
    background-color:black;
	width: 100%;
    height: 30px;
    color:white;
    padding:0px; 
    text-align:center;
}
#header.h4 {
}
#nav {
    line-height:30px;
    background-color:#eeeeee;
    height: 60px;
	width: 100%
    float:left;
    padding-left:5px; 
    padding-right:5px; 
}
#status {
    width:600px;
    float:left;
    padding:5px; 
}
#footer {
    background-color:#eeeeee;
    color:black;
    clear:both;
    text-align:center;
    padding:5px; 
    height: 14px;
    vertical-align:bottom;
}
#save {
    float:right;
    padding:5px; 
    margin: 0 0 10px 10px;
}
#map {
	width:550px; 
	height:550px; 
    float:right;
}
#conversion {
    float:right;
}
table {
    color:rgb(0, 200, 255);
    font-family: courier;
    font-size:75%;
}
button {
    text-rendering: auto;
    color: initial;
    letter-spacing: normal;
    word-spacing: normal;
    text-transform: none;
    text-indent: 0px;
    text-shadow: none;
    display: inline-block;
    text-align: start;
    margin: 0em 0em 0em 0em;
    font: 12px Arial;
	border-radius: 12px;
}
    </style>
    <script>
						
var map;
var tileLayer;
var geoJSONLayer;

function setupMap() {	
	var w = window.innerWidth
		|| document.documentElement.clientWidth
		|| document.body.clientWidth;

	var h = window.innerHeight
		|| document.documentElement.clientHeight
		|| document.body.clientHeight;
	if (h && w) {
		var old_w=document.getElementById('map').style.width;
		var old_h=document.getElementById('map').style.height;
		var new_w=w-700;
		var new_h=h-150;
		var new_status_width=w-new_w-50;
	
		document.getElementById('map').style.width=new_w;
		document.getElementById('map').style.height=new_h;
		document.getElementById('status').style.height=new_h;
		document.getElementById('status').style.width=new_status_width;
		
		document.getElementById('status').innerHTML = "Size h x w: " + h + "+" + w +
			"; map size old: " + old_h + "+" + old_w + ", new: " + new_h + "+" + new_w +
			"; new_status_width: " + new_status_width;
	}
}
	
/*
 * Function: 	generateUUID()
 * Parameters: 	None
 * Returns: 	RFC4122 version 4 compliant UUID
 * Description:	Generate a random UUID
 */
function generateUUID() { // Post by briguy37 on stackoverflow
    var d = new Date().getTime();
    if(window.performance && typeof window.performance.now === "function"){
        d += performance.now(); //use high-precision timer if available
    }
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = (d + Math.random()*16)%16 | 0;
        d = Math.floor(d/16);
        return (c=='x' ? r : (r&0x3|0x8)).toString(16);
    });
    return uuid;
}

// Display file size nicely	
function fileSize(file_size) {
	var niceFileSize;
	if (!file_size) {
		return undefined;
	}
	else if (file_size > 1024 * 1024 * 1024) {
		niceFileSize = (Math.round(file_size * 100 / (1024 * 1024 * 1024)) / 100).toString() + 'GB';
	}
	else if (file_size > 1024 * 1024) {
		niceFileSize = (Math.round(file_size * 100 / (1024 * 1024)) / 100).toString() + 'MB';
	} 
	else {
		niceFileSize = (Math.round(file_size * 100 / 1024) / 100).toString() + 'KB';
	}
	return niceFileSize;
}
	
/*
 * Function: 	submitForm()
 * Parameters: 	None
 * Returns: 	Nothing
 * Description:	Submit form button
 */
function submitForm() {

	var files_elem=document.getElementById('files');
	var verbose=document.getElementById('verbose').checked;
	var output_type="shpConvert";
	var files = files_elem.files;
	var fileno = 0;
	var totalFileSize = 0;
	
	var request = new XMLHttpRequest();
    var formData = new FormData();
	
	if (files.length == 0) {
		document.getElementById('status').innerHTML = "ERROR! No files selected, unable to upload.";
		return;
	}
	
	if (verbose) { // i.e. diagnostics
		console.log('Verbose mode: ' + verbose);
		formData.append('verbose', verbose);
	}
	formData.append('my_reference', generateUUID()); // Random reference
	/*
	if (output_type) {
		if (document.getElementById('output_type_geojson').checked) {
			output_type="shp2GeoJSON";	
		}		
		else if (document.getElementById('output_type_topojson').checked) {
			output_type="shp2TopoJSON";	
		}		
		else if (document.getElementById('output_type_wkt').checked) {
			output_type="shp2WKT";	
		}
		console.log('POST method: ' + output_type);
	} */

	try {
		request.open('POST', 'http://127.0.0.1:3000/' + output_type);
			// Process results
		request.onreadystatechange = function() {
			if (request.readyState == 1) { 
				document.getElementById("status").innerHTML = "Connected...";
			}
			else if (request.readyState == 2) { 
				document.getElementById("status").innerHTML = "Request received...";
			}		
			else if (request.readyState == 3) { 
				document.getElementById("status").innerHTML = "Processing request...";
			}
			else if (request.readyState == 4) { 
				document.getElementById("status").innerHTML = "Processing complete...";		
				displayResponse(request.response, request.status);
			}
	};
	}
	catch (e) {
		document.getElementById('status').innerHTML = "ERROR! Unable to post to: http://127.0.0.1:3000/" + output_type + ": " + e.messaged;
		return;
	}
	
	// 
	request.upload.onprogress = function(evt) {
		if (evt.lengthComputable) {
			var percentComplete = Math.round(evt.loaded * 100 / evt.total);
			document.getElementById('status').innerHTML = "Uploading file " + fileno + "/" + files.length + ": " + 
				percentComplete.toString() + '%' + "; total: " + fileSize(totalFileSize);
		}
		else {
			console.log("ERROR! Uploading files: unable to compute percent complete");
		}
	}	

	// Process submitted files
	for (var fileno = 0; fileno < files.length; ++fileno) {
		var file=files[fileno];
		if (file !== null) {
				
			var name = file.name;
			var reader = new FileReader();

			reader.onload = function(event) {
				var arrayBuf = new Uint8Array(event.target.result);
				var arrayIndex = 0;		  
			}
			reader.onerror = function(err) {
				document.getElementById('status').innerHTML = "ERROR! Unable to upload file + " + fileno + "/" + files.length + ": " + 
					name + "; " + err; 		
				return;
			}
			totalFileSize+=file.size;
			formData.append('file[]', file, name);
			console.log('Loading file [' + fileno + ']: ' + name + "; " + fileSize(file.size));	
			
			reader.readAsArrayBuffer(file);
		}
	}

	document.getElementById("status").innerHTML = "Sending to server...";
	try {
		request.send(formData);	
	}
	catch (e) {
		console.error("ERROR! Unable to post to: http://127.0.0.1:3000/" + output_type + ": " + e.message);
		document.getElementById('status').innerHTML = "ERROR! Unable to post to: http://127.0.0.1:3000/" + output_type + ": " + e.messaged;
		return;
	}		
//    request.sendAsBinary(formData); // Bad crash!!
  

}

function createMap(boundingBox) {
	console.log('New map');	
	var map = new L.map('map');
	map.fitBounds([
		[boundingBox.ymin, boundingBox.xmin],
		[boundingBox.ymax, boundingBox.xmax]], {maxZoom: 11}
	);
//									map.setView([y_avg, x_avg], 6);
	document.getElementById("status").innerHTML = "Creating basemap...";															
	console.log('New tileLayer');
	tileLayer=L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpandmbXliNDBjZWd2M2x6bDk3c2ZtOTkifQ._QA7i5Mpkd_m30IGElHziw', {
		maxZoom: 11,
		attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, ' +
			'<a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
			'Imagery &copy; <a href="http://mapbox.com">Mapbox</a>',
		id: 'mapbox.light'
	});
	tileLayer.addTo(map);	
	console.log('Add tileLayer to map');
	
	return map;
}

/*
 * Function: 	displayResponse()
 * Parameters: 	Response text (JSON as a string), status code
 * Returns: 	Nothing
 * Description:	Display reponse from submit form
 */
function displayResponse(responseText, status) {
	var response;
	var msg="";
	var responseErrors=0;
	var geoJSONLayer=[];
	
	document.getElementById("status").innerHTML = "Processing response from server...";
	try {
		response=JSON.parse(responseText);
	} catch (e) {  
		if (responseText) {
			document.getElementById("status").innerHTML = "<h1>Send Failed</h1><h2>Error parsing response: " +  
				e.message +"</h2><p>Reponse:" + responseText + "</p>";
		}
		else {
			document.getElementById("status").innerHTML = "<h1>Send Failed</h1><h2>Error parsing response: " +  
				e.message +"</h2><p>no response from server</p>";
		}
		return;
	}
	
	if (response.error) {
		msg+="<p>Error message" + response.error + "</p>"
	}

	if (response.no_files) {
		msg+="<p>Shape files processed: " + response.no_files;
		if (response.file_list) {
			if (response.no_files > 0) {
				msg+="<table border=\"1\" style=\"width:100%\">" + 
				"<tr><th>No.</th><th>File</th><th>GeoJSON length</th>" +
				"<th>File size</th><th>Areas</th><th>Geojson convert time (S)</th>" +
				"<th>Geo level</th><th>Area (Km<sup>2</sup>)</th>" + 
				"<th>SRID</th>" +
				"</tr>";
				if (response.file_list[0].boundingBox) {
					if (!map) {
						map=createMap(response.file_list[0].boundingBox);
					}
					else {
						var centre=map.getCenter();
							
						console.log("Centre: " + centre.lat + ", " + centre.lng);
//						if (+centre.lat.toFixed(4) == +y_avg.toFixed(4) && 
//							+centre.lng.toFixed(4) == +x_avg.toFixed(4)) {
//							console.log("Map centre has not changed");
//						}
//						else {
							map.eachLayer(function (layer) {
								console.log('Remove tileLayer');
								map.removeLayer(layer);
							});
							console.log('Remove map');
							map.remove(); // Known leaflet bug:
										  // Failed to execute 'removeChild' on 'Node': The node to be removed is not a child of this node.
							
							map=createMap(response.file_list[0].boundingBox);				
//						}	
					}				
				}
				else {
					console.error("response.file_list[0].boundingBox is not defined");				
				}
				
				var layerColours = [ // Some advice needed here!!!
					"#ff0000", // Red
					"#0000ff", // Blue
					"#00ff00", // Green
					"#ff00c8", // Magenta
					"#ffb700", // Orange
					"#f0f0f0", // Light grey
					"#0f0f0f"  // Onyx (nearly black)
					];
				
				var layerAddOrder = [];
				
/*
Add shapefiles starting from the highest resolution first:

Add data to geoJSONLayer[0]; shapefile [3]: SAHSU_GRD_Level4.shp
Add data to geoJSONLayer[1]; shapefile [2]: SAHSU_GRD_Level3.shp
Add data to geoJSONLayer[2]; shapefile [1]: SAHSU_GRD_Level2.shp
Add data to geoJSONLayer[3]; shapefile [0]: SAHSU_GRD_Level1.shp
*/
				for (var i=0; i < response.no_files; i++) {
					layerAddOrder[(response.no_files-response.file_list[i].geolevel_id)]=i;			
				} // end of for loop
				
				for (var i=0; i < response.no_files; i++) {		
					console.log("Add data to geoJSONLayer[" + i + "]; shapefile [" + layerAddOrder[i] + "]: " +
						response.file_list[layerAddOrder[i]].file_name);
						
					var weight=(response.no_files - i); // i.e. Lower numbers - high resolution have most weight
					var color=layerColours[i];	
// Chroma.js - to be added (Node module)
//					var colorScale = chroma  
//						.scale(['#D5E3FF', '#003171'])
//						.domain([0,1]);	
					var opacity;
					var fillOpacity;
//					if (response.file_list[i].geolevel_id != response.no_files) { 
					if (i > 0) { // All but the first are transparent
						opacity=0;		
						fillOpacity=0;
					}
					else { // First - i.e. max geolevel
						opacity=1;
						fillOpacity=0.4;				
					}
//					if (!color || response.file_list[i].geolevel_id == 1) {
					if (!color || i == (response.no_files - 1)) { // if >7 layers or lowest resolution (last layer) - make it black
						color="#000000"; // Black
						weight=response.no_files;
					}
					msg+="<tr style=\"color:" + color + "\"><td>" + (i+1) + "</td><td>" + response.file_list[i].file_name + "</td><td>";
					if (response.file_list[i].geojson) {			
						try {
							var geojson = JSON.stringify(response.file_list[i].geojson);
							if (response.file_list[i].boundingBox && map) {
			
								if (geoJSONLayer[i]) {	
									console.log('Remove geoJSONLayer' + i + ']');
									map.removeLayer(geoJSONLayer[i]);
								}		
								
								console.log('New geoJSONLayer[' + i + '], color: ' + color);	
								document.getElementById("status").innerHTML = "Adding geoJSONLayer[" + i + "]...";	
								geoJSONLayer[i] = L.geoJson(undefined, 
									{style: 
										{color: 	color,
										 fillColor: "#ccf4ff",
										 weight: 	weight, // i.e. Lower numbers have most weight
										 opacity: 	1,
										 fillOpacity: fillOpacity}
									}).addTo(map);
								geoJSONLayer[i].addData(response.file_list[layerAddOrder[i]].geojson);									
							}
							
							msg+=fileSize(geojson.length);
						} catch (e) {  							
							msg+="GeoJSON conversion error: " + e.message;
							responseErrors++;
						}
					}
					else {
						msg+="ERROR! no GeoJSON returned";
						responseErrors++;
					}
					msg+="</td><td>" + 
						(fileSize(response.file_list[i].file_size) || "Not Set") + "</td><td>" + 
						response.file_list[i].total_areas + "</td><td>" +
						(response.file_list[i].geojson_time || "Not converted") + "</td><td>" + 
						(response.file_list[i].geolevel_id || "N/A") + "</td><td>" + 
						(response.file_list[i].uncompress_size || "N/A") + "</td><td>" +
						(response.file_list[i].srid || "No SRID") + "</td>" +
						"</tr>";

				} // end of for loop
			}
			msg+="</table>";
			if (response.file_list[0].srid) {
				console.log("SRID: " + response.file_list[0].srid);
			}	
				
			if (response.file_list[0].projection_name) {
				console.log("Projection name: " + response.file_list[0].projection_name);
			}	
			
			if (response.file_list[0].boundingBox) {
				console.log("Bounding box [" +
							"xmin: " + response.file_list[0].boundingBox.xmin + ", " +
							"ymin: " + response.file_list[0].boundingBox.ymin + ", " +
							"xmax: " + response.file_list[0].boundingBox.xmax + ", " +
							"ymax: " + response.file_list[0].boundingBox.ymax + "]");
			}
		}
		else {
			msg+="; no file list";
		}
		msg+="</p>";
	}



	if (response.fields) {
		var fieldCount=0;
		for (var field in response.fields) {
			fieldCount++;
			if (fieldCount == 1) {
				msg+="<p>Fields returned by shpConvert<ul id=\"fields\">";
			}
			msg+="<li>" + field + "=" + response.fields[field] + "</li>";
		}
		if (fieldCount > 0) {
			msg+="</ul></p>";
		}
	}	
	
	if (response.message) {
		msg+="<p>Processing diagnostic messages:</br><div id=\"div_message\" style=\"overflow:scroll; height: 400px;\"><pre>" + response.message + "</pre></div?</p>"
	}
	
	if (response.diagnostic) {
		msg+="<p>Processing diagnostic:</br><pre>" + response.diagnostic + "</pre></p>";
	}	
	
	if (status == 200 && responseErrors == 0) {	
		document.getElementById("status").innerHTML = "<h1>Shapefile processed OK</h1>" + msg;
	}
	else if (status == 200 && responseErrors > 0) {	
		document.getElementById("status").innerHTML = "<h1>Shapefile processed OK; but with " + 
			responseErrors + " error(s) in response</h1>" + msg;
	}
	else {
		document.getElementById("status").innerHTML = "<h1>Send Failed: " + status + "</h1>" + msg;
	}
}
</script>

  </body>
</html>