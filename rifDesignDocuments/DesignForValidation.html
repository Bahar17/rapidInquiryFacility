<head>
<title>
Design for Validation
</title>

<meta 
	name="author" 
	lang="en" 
	content="Kevin Garwood">
<meta 
	name="keywords" 
	lang="en" 
	content="Rapid Inquiry Facility, RIF, environmental health, Kevin Garwood">
	
<link rel="stylesheet" href="./rifDesignManual.css" type="text/css">
</head>

<body>

<h1>Design for Validation</h1>
<p>
Designing the code base to support validation first requires us to limit our efforts to specific architecture
layers for service method calls.  Within each call, we have to identify and prioritise validation checks.  Our first
task is to decide what validation duties will be done by layers of the three-tier architecture.
</p>

<p>
Electronic forms in most end-user applications will support aspects of guided data entry to prevent errors 
occurring in the form data and aspects of validation to identify errors.  In many applications, users must 
use a specific front-end application in order to cause some change in files, databases or other forms of persistent 
storage.  As long as we can guarantee that a particular front-end will be used, we can afford to maintain
validation code within these parts of the presentation layer.
</p>

<p>
Much of the RIF's functionality is supported by web applications which issue commands as a 
sequence of parameterised URL requests.  In future, other client applications could be made which submit 
the URL requests, either from a script or from some other end-user tool.  We anticipate that as end-user 
forms change or as new tools get developed, the applications may not support a consistent set of data 
entry features which would guarantee a baseline quality of data.  Furthermore, even if the current 
applications were to support a uniform feature set, the replication of features would represent a significant 
maintenance overhead.
</p>

<p>
Therefore, we have decided to have the middleware assume that its incoming API method parameter values 
have not been validated at all.  We have already made a similar assumption to ensure that the client 
applications have a uniform level of security features supported across all tools that use 
the middleware.
</p>

<blockquote>
<font color="green">
<i>
<b>
<a href="SummaryOfDesignDecisions.html#gen_design1">
Validation-2
</a>
</b>: 
Assume the client front ends will do no validation.  Validation code will be distributed
between the business concept and data storage layers of the architecture.
</i>
</font>
</blockquote>

The next step for supporting validation is to make it easy for the client applications to rely on the middleware to
do validation.  In most client applications, form field values will be typically be Strings.  Therefore, 
if the middleware is meant to do as much validation as possible, it should accept field values as Strings.  It is best
that the business classes use mostly String fields so that the client can easily copy form fields to data fields.


<blockquote>
<font color="green">
<i>
<b>
<a href="SummaryOfDesignDecisions.html#gen_design1">
Validation-2
</a>
</b>: 
By default, the fields in business classes should be of type String.
</i>
</font>
</blockquote>


<p>
As we have concluded for issues of Security, Testing and Concurrency, limiting allowable paths of 
execution through the code helps economise on the effort to design and maintain aspects of the code 
base.  Most methods of most classes will not have to validate method parameters.  The emphasis of 
validation can be placed on checking data provided by client applications.  This validation activity
only needs to happen once, and applied to the values that client applications pass to service methods.

<blockquote>
<font color="green">
<i>
<b>
<a href="SummaryOfDesignDecisions.html#validation3">
Validation-2
</a>
</b>: 
Limit validation support to execution paths that support service API methods.  Specifically, focus 
validation efforts on validating values the client application passes to methods of service APIs.
</i>
</font>
</blockquote>


<p>
In order to eliminate the prospect that parameter values passed by a client could change during the 
execution of a method code block, we make local copies of every mutable parameter value of every service method.  
This measure ensures that once parameter values have been validated, they remain valid until the method finishes.  
(See also Concurrency).
</p>

<blockquote>
<font color="green">
<i>
<b>
<a href="SummaryOfDesignDecisions.html#concurrency">
Concurrency-XXX
</a>
</b>: 
Perform "safe copying" on parameter values of service methods.  This action will ensure that the client will not 
be able to change their values between the time when the values are initially passed to the service and when the 
service action completes.
</i>
</font>
</blockquote>

<p>
Once the parameter values have been safe-copied, we can be assured that values will remain the same when they are 
being validated.  The next step in supporting validation is to identify all the validation checks and prioritise them
so that:
<ul>
<li>
the middleware can fail as quickly as possible and
</li>
<li>
the database is used as little as possible
</li>
</ul>


<blockquote>
<font color="green">
<i>
<b>
<a href="SummaryOfDesignDecisions.html#concurrency">
Concurrency-XXX
</a>
</b>: 
Identify and prioritise the validation checks that are applied to the parameter values of service methods.
Order the validation checks so they
<ul>
<li>
cause validation to fail as quickly as possible and 
</li>
<li>
minimise the load placed on the database.
</li>
</ul>
</i>
</font>
</blockquote>


<p>
Let's consider the kinds of checks we would need for a typical service method parameter.  Suppose we are
considering the checks we need to make for the call:

<code>
<pre>
	ArrayList<GeoLevelSelect> getGeoLevelSelectValues(
		User user,
		Geography geography)
		throws RIFServiceException;
</pre>
</code>

After we safe-copy the User and Geography objects, we would:
<ol>
<li>
check that the userID was not on a blacklist for causing security exceptions in previous service calls
</li>
<li>
check that neither the <code>User</code> nor the <code>Geography</code> object are null
</li>
<li>
check that the fields of <code>User</code> and <code>Geography</code> do not contain malicious code 
(eg: a "<code>DROP DATABASE</code>" command disguised in the name field)
</li>
<li>
check that none of the required field values in <code>User</code> or <code>Geography</code> are empty or null.  
In other kinds of values, we might check for illegal combinations of field values. 
</li>
<li>
check that the <code>User</code> is known in the database
</li>
<li>
<code>Geography</code> is known in the database
</li>
</ol>

<p>
As we discuss in Security, we want the middleware service call to throw an exception as soon as possible if a
blacklisted user is repeatedly attempting to use the database.  Therefore it makes most sense if our first check 
is whether the userID field of a non-null User object has been blacklisted.  This requires consulting 
a <code>HashMap</code> that is maintained in-memory within the <code>SQLConnectionManager</code> class and it does not involve 
making a call to the database.
</p>

<p>
The next logical step is to check whether any of the required parameter values are null.  If either the User object
or the Geography object is null, there is no point doing any other checks.  The next step is to isolate the User object 
and run three checks:
<ol>
<li>
check whether there are any security violations in the fields
</li>

<li>
check whether the User object has valid fields
</li>

<li>
check whether the User is registered (has logged in)
</li>

</ol>

<p>
All three checks can be done without calling the database.  Although database interaction is needed to log users
into the database, once this has been done a list of registered users is kept in-memory by <code>SQLConnectionManager</code>

<p>
Our last checks relate to the <code>Geography</code> object.  It is more important to know whether a field value 
contains malicious code than whether it is blank, null, or can be properly converted to some data type.  
Both of these checks can be done without consulting the database.
</p>

<p>
Finally we need to check whether the <code>Geography</code> value is known in the database.  If this last check passes, then the
service is ready to try and query the database.
</p>


The following table summarises the kinds of validation checks that are used in a 
typical middleware call:
</p>

<table border="1">

<tr>
<td>
<b>Order</b>
</td>
<td>
<b>Description</b>
</td>
<td>
<b>Layer</b>
</td>
<td>
<b>Need access to the database</b>
</td>
</tr>

<tr>
<td>
1
</td>

<td>
Check that the user object has not been previously black listed due to previous security violations.  
Reject if user object is null.
</td>

<td>
data storage layer
</td>

<td>
No
</td>

</tr>



<tr>
<td>
2
</td>

<td>
Check that parameter values are not null
</td>

<td>
data storage layer
</td>

<td>
No
</td>

</tr>

<tr>
<td>
3
</td>

<td>
Check that the user Object contains no malicious field values.
</td>

<td>
business concept layer
</td>

<td>
No
</td>

</tr>

<tr>
<td>
4
</td>

<td>
Check that all the field values in the User object are valid.
</td>

<td>
business concept layer
</td>

<td>
No
</td>

</tr>

<tr>
<td>
5
</td>

<td>
Check that the userID is currently registered.
</td>

<td>
data storage layer
</td>

<td>
No
</td>

</tr>


<tr>
<td>
6
</td>

<td>
Check that none of the fields of any of the other business objects besides User has no malicious field values
</td>

<td>
business concept layer
</td>

<td>
No
</td>

</tr>

<tr>
<td>
7
</td>

<td>
Check that the fields of other business objects besides User:
<ul>
<li>
have no missing required values
</li>
<li>
have values which can be converted to an appropriate type (eg: a year String field contains a value which has 
exactly four digits)
</li>
<li>
have values which are within the constraints of the value (eg: the year is reasonable)
</li>
<li>
have field values which are valid individually, but which are invalid in combination. (eg: In Investigation, 
a start year of "2001" and an end year of "1999".
</li>
</td>

<td>
business concept layer
</td>

<td>
No
</td>

</tr>



<tr>
<td>
8
</td>

<td>
In some cases, check whether parameter values exist in the database
</td>

<td>
data storage layer
</td>

<td>
Yes
</td>

</tr>

</table>

<h2>Tour of Validation</h2>
Look for the tag TOUR_VALIDATION in the code base.  The following table summarises the main 
features of the tour.

<table>
<tr>
<td>
<b>Package</b>
</td>
<td>
<b>Class</b>
</td>
<td>
<b>Method</b>
</td>
<td>
<b>Description</b>
</td>
</tr>

<tr>
<td>
<code>dataStorageLayer</code>
</td>
<td>
<code>AbstractRIFService</code>
</td>
<td>
<code>getGeoLevelSelectValues()</code>
</td>
<td>
<ul>
<li>
</li>

<li>
</li>

</ul>
</td>
</tr>

<tr>
<td>
<code>dataStorageLayer</code>
</td>
<td>
<code>SQLRIFContextManager</code>
</td>
<td>
<code>getGeoLevelSelectValues()</code>
</td>
<td>
<ul>
<li>
</li>

<li>
</li>

</ul>
</td>
</tr>

<tr>
<td>
<code>businessConceptLayer</code>
</td>
<td>
<code>Geography</code>
</td>
<td>
<code>checkErrors()</code>
</td>
<td>
<ul>

<li>
An example of a business class implementing a <code>checkErrors()</code> method
</li>
<li>
note that it recursively calls the <code>checkErrors()</code> method of its superclass
</li>
</ul>
</td>
</tr>

<tr>
<td>
<code>businessConceptLayer</code>
</td>
<td>
<code>Investigation</code>
</td>
<td>
<code>checkErrors()</code>
</td>
<td>
<ul>
<li>
Perhaps the most complicated example of a <code>checkErrors()</code> method for a business class
</li>
<li>
checks for null child objects
</li>
<li>
checks for empty required field values
</li>
<li>
checks for data type errors
</li>
<li>
checks if a field value can be used as a valid table name
</li>
<li>
checks for empty collections it manages
</li>
<li>
recursively calls <code>checkErrors()</code> on business objects it owns.
</li>
</ul>
</td>
</tr>

</table>


</body>
</html>