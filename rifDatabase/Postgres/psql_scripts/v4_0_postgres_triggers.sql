
-- ************************************************************************
--
-- GIT Header
--
-- $Format:Git ID: (%h) %ci$
-- $Id$
-- Version hash: $Format:%H$
--
-- Description:
--
-- Rapid Enquiry Facility (RIF) - Postgres triggers
--
-- Trigger code will be split up on a per table basis
--
-- Copyright:
--
-- The Rapid Inquiry Facility (RIF) is an automated tool devised by SAHSU 
-- that rapidly addresses epidemiological and public health questions using 
-- routinely collected health and population data and generates standardised 
-- rates and relative risks for any given health outcome, for specified age 
-- and year ranges, for any given geographical area.
--
-- Copyright 2014 Imperial College London, developed by the Small Area
-- Health Statistics Unit. The work of the Small Area Health Statistics Unit 
-- is funded by the Public Health England as part of the MRC-PHE Centre for 
-- Environment and Health. Funding for this project has also been received 
-- from the Centers for Disease Control and Prevention.  
--
-- This file is part of the Rapid Inquiry Facility (RIF) project.
-- RIF is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Lesser General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- RIF is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU Lesser General Public License for more details.
--
-- You should have received a copy of the GNU Lesser General Public License
-- along with RIF. If not, see <http://www.gnu.org/licenses/>; or write 
-- to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
-- Boston, MA 02110-1301 USA
--
-- Author:
--
-- Peter Hambly, SAHSU
--
\set ECHO all
\set ON_ERROR_STOP ON
\timing

--
-- Check user is rif40
--
DO LANGUAGE plpgsql $$
BEGIN
	IF user = 'rif40' THEN
		RAISE INFO 'User check: %', user;	
	ELSE
		RAISE EXCEPTION 'C20900: User check failed: % is not rif40', user;	
	END IF;
END;
$$;

-- Generated by Ora2Pg, the Oracle database Schema converter, version 8.13
-- Copyright 2000-2012 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:eph1d

\set ON_ERROR_STOP ON
\echo  Creating TABLE triggers 

\set VERBOSITY terse
DO LANGUAGE plpgsql $$
BEGIN
	PERFORM rif40_log_pkg.rif40_add_to_debug('rif40_ddl:DEBUG1'); /* SQL statements - timing DEBUG4 */
	PERFORM rif40_log_pkg.rif40_add_to_debug('rif40_drop_table_triggers:DEBUG1'); /* SQL statements - timing DEBUG4 */
        PERFORM rif40_log_pkg.rif40_log_setup();
        PERFORM rif40_log_pkg.rif40_send_debug_to_info(TRUE);
	PERFORM rif40_trg_pkg.rif40_drop_table_triggers();
END;
$$;
\set VERBOSITY default

CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_rif40_covariates_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_rif40_covariates_checks_description>
<para>
Check <T_RIF40_GEOLEVELS.COVARIATE_TABLE>.<COVARIATE_NAME> column exists.
Check - min < max, max/min precison is appropriate to type
</para>
</trigger_rif40_covariates_checks_description>
 */
--
-- Error range:  -20140 to -20159 - RIF40_COVARIATES
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c1tcov CURSOR (l_schema VARCHAR, l_table VARCHAR, l_column VARCHAR) IS
		SELECT column_name
		  FROM information_schema.columns
		 WHERE table_schema = LOWER(l_schema)
		   AND table_name   = LOWER(l_table)
		   AND column_name  = LOWER(l_column);
	c2tcov CURSOR (l_geolevel_name VARCHAR) IS
		SELECT covariate_table
		  FROM t_rif40_geolevels
		 WHERE geolevel_name = l_geolevel_name;
	c1tcov_rec RECORD;
	c2tcov_rec RECORD;
--
	schema 		VARCHAR;
BEGIN
	IF TG_OP = 'DELETE' THEN
		RETURN NULL;
	END IF;
--
-- Check <T_RIF40_GEOLEVELS.COVARIATE_TABLE>.<COVARIATE_NAME> column exists
--
	OPEN c2tcov(NEW.geolevel_name);
	FETCH c2tcov INTO c2tcov_rec;
	CLOSE c2tcov;
	IF (c2tcov_rec.covariate_table IS NOT NULL AND c2tcov_rec.covariate_table::text <> '') THEN
		schema:=rif40_sql_pkg.rif40_object_resolve(c2tcov_rec.covariate_table::VARCHAR);
		IF coalesce(schema::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20140, 'trigger_fct_rif40_covariates_checks', 
				'Error: T_RIF40_GEOLEVELS COVARIATE_TABLE (%) not found for geolevel_name: %, covariate: %',
				LOWER(c2tcov_rec.covariate_table)::VARCHAR	/* Covariate table */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */,
				NEW.covariate_name::VARCHAR		/* Covariate name */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_covariates_checks', 
				'[20140] T_RIF40_GEOLEVELS COVARIATE_TABLE (%) found for geolevel_name: %, covariate: %',
				LOWER(c2tcov_rec.covariate_table)::VARCHAR	/* Covariate table */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */,
				NEW.covariate_name::VARCHAR		/* Covariate name */);
		END IF;
		OPEN c1tcov(schema, c2tcov_rec.covariate_table, NEW.covariate_name);
		FETCH c1tcov INTO c1tcov_rec;
		CLOSE c1tcov;
		IF (NEW.covariate_name IS NOT NULL AND NEW.covariate_name::text <> '') AND coalesce(c1tcov_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20141, 
				'trigger_fct_rif40_covariates_checks', 'Error: RIF40_COVARIATES % column not found in: % for geolevel_name: %',
				NEW.covariate_name::VARCHAR		/* Covariate name */,
				UPPER(c2tcov_rec.covariate_table)::VARCHAR		/* Covariate table */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		ELSIF (NEW.covariate_name IS NOT NULL AND NEW.covariate_name::text <> '') AND (c1tcov_rec.column_name IS NOT NULL AND c1tcov_rec.column_name::text <> '') THEN
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_covariates_checks', 
				'[20141] RIF40_COVARIATES % column found in: % for geolevel_name: %',
				NEW.covariate_name::VARCHAR		/* Covariate name */,
				UPPER(c2tcov_rec.covariate_table)::VARCHAR		/* Covariate table */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		END IF;
	END IF;
--
-- 	Check - min < max, max/min precison is appropriate to type
--
	IF NEW.min >= NEW.max THEN
		PERFORM rif40_log_pkg.rif40_error(-20142, 'trigger_fct_rif40_covariates_checks', 
			'Error: RIF40_COVARIATES min >= max: % >= % for geolevel_name: % covariate: %',
			TO_CHAR(NEW.min)::VARCHAR		/* New min */,
			TO_CHAR(NEW.max)::VARCHAR		/* New max */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	ELSIF NEW.type = 1 AND ROUND(NEW.max) != NEW.max THEN /* integer score */
		PERFORM rif40_log_pkg.rif40_error(-20143, 'trigger_fct_rif40_covariates_checks', 
			'Error: RIF40_COVARIATES type = 1 (integer score) and max is not an integer: % for geolevel_name: % covariate: % for geolevel_name: % covariate: %',
			TO_CHAR(NEW.max)::VARCHAR		/* New max */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	ELSIF NEW.type = 1 AND ROUND(NEW.min) != NEW.min THEN /* integer score */
		PERFORM rif40_log_pkg.rif40_error(-20144, 'trigger_fct_rif40_covariates_checks', 
			'Error: RIF40_COVARIATES type = 1 (integer score) and min is not an integer: % for geolevel_name: % covariate: % for geolevel_name: % covariate: %',
			TO_CHAR(NEW.min)::VARCHAR		/* New min */,
			NEW.geolevel_name::VARCHAR	/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	ELSIF NEW.type = 1 AND NEW.min < 0 THEN /* integer score */
		PERFORM rif40_log_pkg.rif40_error(-20145, 'trigger_fct_rif40_covariates_checks', 
			'Error: RIF40_COVARIATES type = 1 (integer score) and min <0: % for geolevel_name: % covariate: % for geolevel_name: % covariate: %',
			TO_CHAR(NEW.min)::VARCHAR		/* New min */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_covariates_checks', 
			'[20142-5] RIF40_COVARIATES Checked OK for geolevel_name: % covariate: %',
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	END IF;
--
-- Check covariate_name
--
	PERFORM rif40_trg_pkg.rif40_db_name_check('COVARIATE_NAME', NEW.covariate_name);
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
$BODY$
LANGUAGE 'plpgsql';

COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_rif40_covariates_checks() IS 'Check <T_RIF40_GEOLEVELS.COVARIATE_TABLE>.<COVARIATE_NAME> column exists.
Check - min < max, max/min precison is appropriate to type.
Error range:  -20140 to -20159 - RIF40_COVARIATES';

CREATE TRIGGER rif40_covariates_checks
	BEFORE INSERT OR UPDATE OF covariate_name, max, min, type ON rif40_covariates
	FOR EACH ROW
	WHEN ((NEW.covariate_name IS NOT NULL AND NEW.covariate_name::text <> '') OR (NEW.max IS NOT NULL AND NEW.max::text <> '') OR (NEW.min IS NOT NULL AND NEW.min::text <> '') OR (NEW.type IS NOT NULL AND NEW.type::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_covariates_checks();
COMMENT ON TRIGGER rif40_covariates_checks ON rif40_covariates IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_covariates_checks()';

CREATE TRIGGER rif40_covariates_checks_del
	BEFORE DELETE ON rif40_covariates
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_covariates_checks();
COMMENT ON TRIGGER rif40_covariates_checks_del ON rif40_covariates IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_covariates_checks()';

CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_rif40_error_messages_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_rif40_error_messages_checks>
<para>
Check - table_name exists.
</para>
</trigger_rif40_error_messages_checks>
 */
--
-- -20480 to -20499 - RIF40_ERROR_MESSAGES
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	schema	VARCHAR;
BEGIN
	IF TG_OP = 'DELETE' THEN
		RETURN NULL;
	END IF;
--
	schema:=rif40_sql_pkg.rif40_object_resolve(NEW.table_name::VARCHAR);
--
-- Check HIERARCHYTABLE
--
	IF (NEW.table_name IS NOT NULL AND NEW.table_name::text <> '') AND coalesce(schema::text, '') = '' THEN
--
-- This really should be an error - wait until auto generated on PostGres
--
		PERFORM rif40_log_pkg.rif40_log('WARNING', 'trigger_fct_rif40_error_messages_checks', '[20480] RIF40_ERROR_MESSAGES table_name (%) not found',
			LOWER(NEW.table_name)::VARCHAR /* table_name referenced in RIF40_ERROR_MESSAGES */);
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
$BODY$
LANGUAGE 'plpgsql';
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_rif40_error_messages_checks() IS 'Check - table_name exists.
-20480 to -20499 - RIF40_ERROR_MESSAGES';

CREATE TRIGGER rif40_error_messages_checks
	BEFORE INSERT OR UPDATE OF table_name
	ON rif40_error_messages
	FOR EACH ROW
	WHEN ((NEW.table_name IS NOT NULL AND NEW.table_name::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_error_messages_checks();
COMMENT ON TRIGGER rif40_error_messages_checks ON rif40_error_messages IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_error_messages_checks()';
CREATE TRIGGER rif40_error_messages_checks_del
	BEFORE DELETE ON rif40_error_messages
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_error_messages_checks();
COMMENT ON TRIGGER rif40_error_messages_checks_del ON rif40_error_messages IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_error_messages_checks()';

CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_rif40_geog_hierarchytable() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_rif40_geog_hierarchytable_description>
<para>
Check HIERARCHYTABLE exists.
Check postal_population_table if set and expected columns
</para>
</trigger_rif40_geog_hierarchytable_description>
 */
--
-- Error range: -20100 to -20119 - RIF40_GEOG_HIERARCHYTABLE
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c1geog CURSOR (l_schema VARCHAR, l_table VARCHAR, l_column VARCHAR) FOR
		SELECT column_name
		  FROM information_schema.columns
		 WHERE table_schema = LOWER(l_schema)
		   AND table_name   = LOWER(l_table)
		   AND column_name  = LOWER(l_column);
	c2geog CURSOR (l_geolevel VARCHAR) FOR
		SELECT *
		  FROM t_rif40_geolevels
		 WHERE geolevel_name = l_geolevel;
	c3geog CURSOR (l_geography VARCHAR) FOR
		SELECT COUNT(geolevel_name) AS total_geolevels
		  FROM t_rif40_geolevels
		 WHERE l_geography = geography;
--
	c1geog_rec 	RECORD;
	c2ageog_rec 	RECORD;
	c2bgeog_rec 	RECORD;
	c3geog_rec 	RECORD;
--
	schema		VARCHAR;
BEGIN
	IF TG_OP = 'DELETE' THEN
		RETURN NULL;
	END IF;
--
-- Check HIERARCHYTABLE
--
	schema:=rif40_sql_pkg.rif40_object_resolve(NEW.hierarchytable::VARCHAR);
	IF (NEW.hierarchytable IS NOT NULL AND NEW.hierarchytable::text <> '') AND coalesce(schema::text, '') = '' THEN
--
-- A date_built column needs to be added so the HIERARCHYTABLE can be NULL when trhe RIF builds the hierarchy table
--
--		PERFORM rif40_log_pkg.rif40_error(-20100, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES HIERARCHYTABLE (%) not found',
--			LOWER(NEW.hierarchytable)::VARCHAR /* hierarchy table */);
		NULL;
	ELSIF (NEW.hierarchytable IS NOT NULL AND NEW.hierarchytable::text <> '') AND coalesce(schema::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20100] RIF40_GEOGRAPHIES HIERARCHYTABLE (%) found',
			LOWER(NEW.hierarchytable)::VARCHAR /* hierarchy table */);
	END IF;
--
-- Check postal_population_table and postal_point_column
--
	IF (NEW.postal_population_table IS NOT NULL AND NEW.postal_population_table::text <> '') THEN
		schema:=rif40_sql_pkg.rif40_object_resolve(NEW.postal_population_table::VARCHAR);
		IF coalesce(schema::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20101, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES POSTAL_POPULATION_TABLE (%) not found',
				LOWER(NEW.postal_population_table)::VARCHAR /* hierarchy table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20101] RIF40_GEOGRAPHIES POSTAL_POPULATION_TABLE (%) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		END IF;
		OPEN c1geog(schema, NEW.postal_population_table, NEW.postal_point_column);
		FETCH c1geog INTO c1geog_rec;
		CLOSE c1geog;
		IF coalesce(c1geog_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20102, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES POSTAL_POINT_COLUMN column (%.%) not found',
				NEW.postal_population_table::VARCHAR	/* postal population table */,
				NEW.postal_point_column::VARCHAR	/* postal point column */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20102] RIF40_GEOGRAPHIES POSTAL_POINT_COLUMN column (%.%) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */,
				NEW.postal_point_column::VARCHAR	/* postal point column */);
		END IF;
		c1geog_rec.column_name:=NULL;
		OPEN c1geog(schema, NEW.postal_population_table, 'MALES');
		FETCH c1geog INTO c1geog_rec;
		CLOSE c1geog;
		IF coalesce(c1geog_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20103, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES column (%.MALES) not found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20103] RIF40_GEOGRAPHIES column (%.MALES) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		END IF;
		c1geog_rec.column_name:=NULL;
		OPEN c1geog(schema, NEW.postal_population_table, 'FEMALES');
		FETCH c1geog INTO c1geog_rec;
		CLOSE c1geog;
		IF coalesce(c1geog_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20104, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES column (%.FEMALES) not found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20104] RIF40_GEOGRAPHIES column (%.FEMALES) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		END IF;
		c1geog_rec.column_name:=NULL;
		OPEN c1geog(schema, NEW.postal_population_table, 'TOTAL');
		FETCH c1geog INTO c1geog_rec;
		CLOSE c1geog;
		IF coalesce(c1geog_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20105, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES column (%.TOTAL) not found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20105] RIF40_GEOGRAPHIES column (%.TOTAL) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		END IF;
		c1geog_rec.column_name:=NULL;
		OPEN c1geog(schema, NEW.postal_population_table, 'XCOORDINATE');
		FETCH c1geog INTO c1geog_rec;
		CLOSE c1geog;
		IF coalesce(c1geog_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20106, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES column (%.XCOORDINATE) not found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20106] RIF40_GEOGRAPHIES column (%.XCOORDINATE) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		END IF;
		c1geog_rec.column_name:=NULL;
		OPEN c1geog(schema, NEW.postal_population_table, 'YCOORDINATE');
		FETCH c1geog INTO c1geog_rec;
		CLOSE c1geog;
		IF coalesce(c1geog_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20107, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES column (%.YCOORDINATE) not found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20107] RIF40_GEOGRAPHIES column (%.YCOORDINATE) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		END IF;
	END IF;
--
--  Also check defaultcomparea, defaultstudyarea as FK is now removed
--
	OPEN c3geog(NEW.geography);
	FETCH c3geog INTO c3geog_rec;
	CLOSE c3geog;
--
	IF (c3geog_rec.total_geolevels > 0 AND NEW.defaultcomparea IS NOT NULL AND NEW.defaultcomparea::text <> '') THEN
		OPEN c2geog(NEW.defaultcomparea);
		FETCH c2geog INTO c2ageog_rec;
		CLOSE c2geog;
		IF c2ageog_rec.geolevel_name IS NULL THEN
			PERFORM rif40_log_pkg.rif40_error(-20108, 'trigger_fct_rif40_geog_hierarchytable', 
				'Error: Default comparision area column % not found in T_RIF40_GEOLEVELS for geography: %',
				NEW.defaultcomparea::VARCHAR	/* Default comparision area */,
				NEW.geography::VARCHAR		/* Geography */);
		ELSIF (NEW.defaultstudyarea IS NOT NULL AND NEW.defaultstudyarea::text <> '')  THEN
			OPEN c2geog(NEW.defaultstudyarea);
			FETCH c2geog INTO c2bgeog_rec;
			CLOSE c2geog;
			IF c2bgeog_rec.geolevel_name IS NULL THEN
				PERFORM rif40_log_pkg.rif40_error(-20108, 'trigger_fct_rif40_geog_hierarchytable', 
					'Error: Default study area column % not found in T_RIF40_GEOLEVELS for geography: %',
					NEW.defaultstudyarea::VARCHAR	/* Default study area */,
					NEW.geography::VARCHAR		/* Geography */);
			END IF;
		END IF;
	END IF;

--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END; 
$BODY$
LANGUAGE 'plpgsql';
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_rif40_geog_hierarchytable() IS 'Check HIERARCHYTABLE exists.
Check postal_population_table if set and expected columns
Error range: -20100 to -20119 - RIF40_GEOG_HIERARCHYTABLE';

CREATE TRIGGER rif40_geog_hierarchytable
	BEFORE INSERT OR UPDATE OF geography, hierarchytable, postal_population_table, postal_point_column, defaultcomparea, defaultstudyarea ON rif40_geographies
	FOR EACH ROW
	WHEN ((NEW.hierarchytable IS NOT NULL AND NEW.hierarchytable::text <> '') OR (NEW.postal_population_table IS NOT NULL AND NEW.postal_population_table::text <> '') OR (NEW.postal_point_column IS NOT NULL AND NEW.postal_point_column::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_geog_hierarchytable();
COMMENT ON TRIGGER rif40_geog_hierarchytable ON rif40_geographies IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_geog_hierarchytable()';

CREATE TRIGGER rif40_geog_hierarchytable_del
	BEFORE DELETE ON rif40_geographies
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_geog_hierarchytable();
COMMENT ON TRIGGER rif40_geog_hierarchytable_del ON rif40_geographies IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_geog_hierarchytable()';

CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_rif40_outcomes_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_rif40_outcomes_checks_description>
<para>
Check current_lookup table exists
Check current_value_Nchar AND current_description_Nchar columns exists if NOT NULL
Check previous lookup table exists if NOT NULL
Check previous_value_Nchar AND previous_description_Nchar if NOT NULL AND (previous_lookup_table IS NOT NULL AND previous_lookup_table::text <> '')
</para>
</trigger_rif40_outcomes_checks_description>
 */
--
-- -20400 to -20419 - RIF40_OUTCOMES
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	schema VARCHAR(30);
BEGIN
	IF TG_OP = 'DELETE' THEN
		RETURN NULL;
	END IF;
--
-- Check current_lookup table exists
--
	schema:=rif40_sql_pkg.rif40_object_resolve(NEW.current_lookup_table::VARCHAR);
	IF (NEW.current_lookup_table IS NOT NULL AND NEW.current_lookup_table::text <> '') AND coalesce(schema::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20400, 'trigger_fct_rif40_outcomes_checks', 'RIF40_OUTCOMES outcome type: % current_lookup_table (%) not found',
			NEW.outcome_type::VARCHAR		/* Outcome type */,
			NEW.current_lookup_table::VARCHAR	/* Current lookup table */);
	END IF;

--
-- Check current_value_Nchar AND current_description_Nchar columns exists if NOT NULL
--
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_value_1char',  schema, NEW.current_lookup_table, NEW.current_value_1char);
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_value_2char',  schema, NEW.current_lookup_table, NEW.current_value_2char);
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_value_3char',  schema, NEW.current_lookup_table, NEW.current_value_3char);
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_value_4char',  schema, NEW.current_lookup_table, NEW.current_value_4char);
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_value_5char',  schema, NEW.current_lookup_table, NEW.current_value_5char);
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_description_1char',  schema, NEW.current_lookup_table, NEW.current_description_1char);
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_description_2char',  schema, NEW.current_lookup_table, NEW.current_description_2char);
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_description_3char',  schema, NEW.current_lookup_table, NEW.current_description_3char);
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_description_4char',  schema, NEW.current_lookup_table, NEW.current_description_4char);
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_description_5char',  schema, NEW.current_lookup_table, NEW.current_description_5char);

--
-- Check previous lookup table exists if NOT NULL
--
	schema:=rif40_sql_pkg.rif40_object_resolve(NEW.previous_lookup_table::VARCHAR);
	IF (NEW.previous_lookup_table IS NOT NULL AND NEW.previous_lookup_table::text <> '') AND coalesce(schema::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20402, 'trigger_fct_rif40_outcomes_checks', 'RIF40_OUTCOMES outcome type: % previous_lookup_table (%) not found',
			NEW.outcome_type::VARCHAR		/* Outcome type */,
			NEW.previous_lookup_table::VARCHAR	/* Previous lookup table */);
	END IF;

--
-- Check previous_value_Nchar AND previous_description_Nchar if NOT NULL AND (previous_lookup_table IS NOT NULL AND previous_lookup_table::text <> '')
--
	IF (NEW.previous_lookup_table IS NOT NULL AND NEW.previous_lookup_table::text <> '') THEN
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_value_1char',  schema, NEW.previous_lookup_table, NEW.previous_value_1char);
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_value_2char',  schema, NEW.previous_lookup_table, NEW.previous_value_2char);
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_value_3char',  schema, NEW.previous_lookup_table, NEW.previous_value_3char);
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_value_4char',  schema, NEW.previous_lookup_table, NEW.previous_value_4char);
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_value_5char',  schema, NEW.previous_lookup_table, NEW.previous_value_5char);
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_description_1char',  schema, NEW.previous_lookup_table, NEW.previous_description_1char);
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_description_2char',  schema, NEW.previous_lookup_table, NEW.previous_description_2char);
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_description_3char',  schema, NEW.previous_lookup_table, NEW.previous_description_3char);
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_description_4char',  schema, NEW.previous_lookup_table, NEW.previous_description_4char);
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_description_5char',  schema, NEW.previous_lookup_table, NEW.previous_description_5char);
	END IF;
--
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_outcomes_checks', '[20400-2] RIF40_OUTCOMES outcome type: % OK',
		NEW.outcome_type::VARCHAR	/* Outcome type */);
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
$BODY$
LANGUAGE 'plpgsql';
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_rif40_outcomes_checks() IS 'Check current_lookup table exists
Check current_value_Nchar AND current_description_Nchar columns exists if NOT NULL
Check previous lookup table exists if NOT NULL
Check previous_value_Nchar AND previous_description_Nchar if NOT NULL AND (previous_lookup_table IS NOT NULL)

-20400 to -20419 - RIF40_OUTCOMES';

CREATE TRIGGER rif40_outcomes_checks
	BEFORE INSERT OR UPDATE OF outcome_type, outcome_description, current_version, current_sub_version,
		previous_version, previous_sub_version, current_lookup_table, previous_lookup_table,
		current_value_1char, current_value_2char, current_value_3char, current_value_4char, current_value_5char,
		current_description_1char, current_description_2char, current_description_3char, current_description_4char, current_description_5char,
		previous_value_1char, previous_value_2char, previous_value_3char, previous_value_4char, previous_value_5char,
		previous_description_1char, previous_description_2char, previous_description_3char, previous_description_4char, previous_description_5char
	ON rif40_outcomes
	FOR EACH ROW
	WHEN ((NEW.outcome_type IS NOT NULL AND NEW.outcome_type::text <> '') OR (NEW.outcome_description IS NOT NULL AND NEW.outcome_description::text <> '') OR (NEW.current_version IS NOT NULL AND NEW.current_version::text <> '') OR (NEW.current_lookup_table IS NOT NULL AND NEW.current_lookup_table::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_outcomes_checks();
COMMENT ON TRIGGER rif40_outcomes_checks ON rif40_outcomes IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_outcomes_checks()';

CREATE TRIGGER rif40_outcomes_checks_del
	BEFORE DELETE ON rif40_outcomes
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_outcomes_checks();
COMMENT ON TRIGGER rif40_outcomes_checks_del ON rif40_outcomes IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_outcomes_checks()';

CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_rif40_predefined_groups_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_rif40_predefined_groups_checks_description>
<para>
Check condition for SQL injection
</para>
</trigger_rif40_predefined_groups_checks_description>
 */
--
-- -20460 to -20479 - RIF40_PREDEFINED_GROUPS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
BEGIN
	IF TG_OP = 'DELETE' THEN
		RETURN NULL;
	END IF;
--
-- Check condition for SQL injection
--
	PERFORM rif40_trg_pkg.rif40_sql_injection_check(
		'RIF40_PREDEFINED_GROUPS',
		NEW.predefined_group_name		/* Predefined group name */,
		NEW.predefined_group_description	/* Description */,
		NEW.outcome_type 			/* Outcome type */,
		'CONDITION', NEW.condition);
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END; 
$BODY$
LANGUAGE 'plpgsql';

COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_rif40_predefined_groups_checks() IS 'Check condition for SQL injection
-20460 to -20479 - RIF40_PREDEFINED_GROUPS';

CREATE TRIGGER rif40_predefined_groups_checks
	BEFORE INSERT OR UPDATE OF predefined_group_name, predefined_group_description, outcome_type, condition
	ON rif40_predefined_groups
	FOR EACH ROW
	WHEN ((NEW.predefined_group_name IS NOT NULL AND NEW.predefined_group_name::text <> '') OR (NEW.predefined_group_description IS NOT NULL AND NEW.predefined_group_description::text <> '') OR (NEW.outcome_type IS NOT NULL AND NEW.outcome_type::text <> '') OR (NEW.condition IS NOT NULL AND NEW.condition::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_predefined_groups_checks();
COMMENT ON TRIGGER rif40_predefined_groups_checks ON rif40_predefined_groups IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_predefined_groups_checks()';

CREATE TRIGGER rif40_predefined_groups_checks_del
	BEFORE DELETE ON rif40_predefined_groups
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_predefined_groups_checks();
COMMENT ON TRIGGER rif40_predefined_groups_checks_del ON rif40_predefined_groups IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_predefined_groups_checks()';

CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_rif40_study_shares_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_rif40_study_shares_checks_description>
<para>
Check - Username is NOT a RIF user - i.e. username is NOT rif40 and has either or both RIF_USER and RIF_MANAGER.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
Check - Grantor is owner of the study OR has RIF_MANAGER role.
Check - grantee username.
Check - grantee username has RIF_USER or RIF_MANAGER role.
</para>
</trigger_rif40_study_shares_checks_description>
 */
--
-- -20320 to -20339 - RIF40_STUDY_SHARES
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
-- $Log: v4_0_postgres_triggers.sql,v $
-- Revision 1.6  2014/02/24 10:50:28  peterh
-- Full build from Oracle, including default study area and removal of year_start/stop min/max_age_group from T_RIF40_STUDIES
--
-- Still present in view
--
-- Revision 1.5  2013/09/25 12:12:22  peterh
-- Baseline after 2x full clean builds at Postgres level
-- TODO.txt uptodate
--
-- Revision 1.4  2013/09/18 15:20:32  peterh
-- Checkin at end of 6 week RIF focus. Got as far as SAHSULAND run study to completion for observed only
--
-- Revision 1.3  2013/09/02 14:08:33  peterh
--
-- Baseline after full trigger implmentation
--
-- Revision 1.2  2013/03/14 17:35:38  peterh
-- Baseline for TX to laptop
--
-- Revision 1.4  2013/02/14 10:48:39  peterh
-- Baseline aftyer clean build with screen mockup changes
--
-- Revision 1.12  2012/10/23 09:05:57  peterh
--
-- Baseline after full build of SAHSUland RIF schema including data
-- No triggers, Geo data and system error/logon triggers to be done
--
-- Revision 1.11  2012/09/14 15:44:53  peterh
-- Baseline after full review of check code and error messages
-- IG functionality added
--
-- Revision 1.10  2012/09/05 15:16:37  peterh
--
-- RIF update after initial build of postgres DB
--
-- Revision 1.9  2012/07/03 12:28:55  peterh
--
-- RIF schema as at 3/6/2012. All entities complete
--
-- Revision 1.8  2012/06/15 11:05:26  peterh
-- Check with working SQL generator (CREATE stmt only); bones of XML generator
-- Numerous lookup tables added.
-- Prepare for documentation
--
-- Revision 1.7  2012/05/22 15:29:41  peterh
--
-- Added RIF40_RESULTS, contextual_stats; more verification
--
-- Revision 1.6  2012/05/21 11:11:28  peterh
--
-- RIF investigattion, inv_covariates, study shares checks + SAHSU land example data
--
-- Revision 1.5  2012/04/26 15:49:48  peterh
-- Fixed view security problems
--
-- Revision 1.4  2012/04/13 15:05:02  peterh
--
-- Added RIF studies, investigations etc
--
-- Revision 1.3  2012/04/04 15:22:51  peterh
-- Easter baseline
--
-- Revision 1.2  2012/03/30 11:45:40  peterh
--
-- Baseline with working RIF40_NUM_DENOM
--
-- Revision 1.1  2012/03/28 15:39:19  peterh
--
-- Added check constraints and basic object table+column existance checks
--
-- Revision 1.2  2012/03/27 15:54:33  peterh
--
-- Added more V4 tables
--
-- Revision 1.1  2012/03/23 15:21:18  peterh
--
-- Moved from old RIF directory
--
-- Revision 1.2  2011/07/12 13:18:40  peterh
-- RIF baseline after Kerberosisation, re-doc and N_POP add
--
-- Revision 1.1  2011/05/27 10:31:21  peterh
--
-- Start of user level suppression support in RIF
--
	c1stsh CURSOR(l_study_id  integer) IS
		SELECT username, study_id
		  FROM t_rif40_studies
		 WHERE study_id = l_study_id;
	c2stsh CURSOR(l_grantee  varchar) IS
		SELECT rolname
		  FROM pg_roles
		 WHERE rolname = LOWER(l_grantee);
	c4stsh CURSOR IS
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c4stsh_rec RECORD;
	c1stsh_rec RECORD;
	c2stsh_rec RECORD;
BEGIN
	OPEN c4stsh;
	FETCH c4stsh INTO c4stsh_rec;
	CLOSE c4stsh;
--
-- RIF40_STUDY_SHARES:	Check - Username is NOT a RIF user - i.e. username is NOT rif40 and has either or both RIF_USER and RIF_MANAGER
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records

	IF NOT TG_OP = 'DELETE' AND USER = 'rif40' AND c4stsh_rec.total = 0 THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_study_shares_checks', 
			'[20320] RIF40_STUDY_SHARES study % username: %: allowed duing build before first result is added to system',
			NEW.study_id::VARCHAR	/* Study id */,
			USER::VARCHAR 		/* User */);
	ELSIF NOT TG_OP = 'DELETE' AND NEW.grantor != USER AND NOT pg_has_role(USER, 'rif_manager', 'USAGE') /* Not granted RIF_MANAGER */ THEN
		PERFORM rif40_log_pkg.rif40_error(-20320, 'trigger_fct_rif40_study_shares_checks', 
			'RIF40_STUDY_SHARES study_id: % grantor username: % is not USER: % or a RIF40_MANAGER',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.grantor::VARCHAR		/* Grantor */,
			USER::VARCHAR			/* User */);
	ELSIF USER = 'rif40' OR NOT (pg_has_role(USER, 'rif_user', 'USAGE') AND pg_has_role(USER, 'rif_manager', 'USAGE')) THEN
		PERFORM rif40_log_pkg.rif40_error(-20321, 'trigger_fct_rif40_study_shares_checks', 
			'RIF40_STUDY_SHARES study_id: % username: % is not a RIF USER',
			OLD.study_id::VARCHAR		/* Study id */,
			USER::VARCHAR			/* User */);
/* Kerberos checks no longer possible 
		PERFORM rif40_log_pkg.rif40_error(-20321, 'rif40_study_shares_checks', 
			'RIF40_STUDY_SHARES study_id: % grantor username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR		-* Study id *-,
			NEW.grantor::VARCHAR		-* Grantor *-,
			USER::VARCHAR			-* User *-);  */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20322, 'trigger_fct_rif40_study_shares_checks', 
			'RIF40_STUDY_SHARES study_id: % UPDATE not allowed on RIF40_STUDY_SHARES',
			NEW.study_id		/* Study id */);
	ELSIF TG_OP = 'DELETE' AND OLD.grantor != USER AND NOT pg_has_role(USER, 'rif_manager', 'USAGE') /* Not granted RIF_MANAGER */ THEN
		PERFORM rif40_log_pkg.rif40_error(-20323, 'trigger_fct_rif40_study_shares_checks', 
			'RIF40_STUDY_SHARES study_id: % DELETE only allowed on own records or by RIF40_MANAGER in RIF40_STUDY_SHARES, record owned by: %',
			OLD.study_id::VARCHAR		/* Study id */,
			OLD.grantor::VARCHAR		/* INSERTER */);
	END IF;

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
     
--
-- Grantor is owner of the study OR has RIF_MANAGER role
--
	OPEN c1stsh(NEW.study_id);
	FETCH c1stsh INTO c1stsh_rec;
	IF c1stsh_rec.study_id IS NULL THEN
		CLOSE c1stsh;
		PERFORM rif40_log_pkg.rif40_error(-20324, 'trigger_fct_rif40_study_shares_checks', 
			'RIF40_STUDY_SHARES study_id: % not found',
			NEW.study_id::VARCHAR			/* Study id */);
	END IF;
	CLOSE c1stsh;
	IF pg_has_role(USER, 'rif_manager', 'USAGE') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_study_shares_checks', 
			'[20325] RIF40_STUDY_SHARES study_id: % not owned by grantor: %; owned by: %; but grantor is a RIF_MANAGER',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.grantor::VARCHAR		/* Grantor */,
			c1stsh_rec.username::VARCHAR	/* Study user */);
	ELSIF c1stsh_rec.username != NEW.grantor THEN
		PERFORM rif40_log_pkg.rif40_error(-20325, 'trigger_fct_rif40_study_shares_checks', 
			'RIF40_STUDY_SHARES study_id: % not owned by grantor: %; owned by: %',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.grantor::VARCHAR		/* Grantor */,
			c1stsh_rec.username::VARCHAR	/* Study user */);
	END IF;
--
-- Check - grantee username.
--
	OPEN c2stsh(NEW.grantee_username);
	FETCH c2stsh INTO c2stsh_rec;
	IF c2stsh_rec.rolname IS NULL THEN
		CLOSE c2stsh;
		PERFORM rif40_log_pkg.rif40_error(-20326, 'trigger_fct_rif40_study_shares_checks', 
			'RIF40_STUDY_SHARES study_id: % grantee username: % not a valid database user',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.grantee_username::VARCHAR	/* Grantee username */);
	END IF;
	CLOSE c2stsh;
--
-- Check grantee_username has RIF_USER or RIF_MANAGER role.
--
	IF pg_has_role(NEW.grantee_username, 'rif_user', 'USAGE') OR pg_has_role(NEW.grantee_username, 'rif_manager', 'USAGE') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_study_shares_checks', 
			'[20327] RIF40_STUDY_SHARES study_id: % grantee username: % is a RIF_USER/RIF_MANAGER',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.grantee_username::VARCHAR	/* Study user */);
	ELSE
		PERFORM rif40_log_pkg.rif40_error(-20327, 'trigger_fct_rif40_study_shares_checks', 
			'[20327] RIF40_STUDY_SHARES study_id: % grantee username: % is NOT a RIF_USER/RIF_MANAGER',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.grantee_username::VARCHAR	/* Study user */);
	END IF;
--
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_study_shares_checks', 
		'[20320-7] RIF40_STUDY_SHARES study: % CRUD checks OK',
		NEW.study_id::VARCHAR			/* Study id */);
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
$BODY$
LANGUAGE 'plpgsql';
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_rif40_study_shares_checks() IS 'Check - Username is NOT a RIF user - i.e. username is NOT rif40 and has either or both RIF_USER and RIF_MANAGER.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
Check - Grantor is owner of the study OR has RIF_MANAGER role.
Check - grantee username.
Check - grantee username has RIF_USER or RIF_MANAGER role.

 -20320 to -20339 - RIF40_STUDY_SHARES';

CREATE TRIGGER rif40_study_shares_checks
	BEFORE INSERT OR UPDATE OF grantor, grantee_username, study_id  ON rif40_study_shares
	FOR EACH ROW
	WHEN ((NEW.grantor IS NOT NULL AND NEW.grantor::text <> '') OR (NEW.grantee_username IS NOT NULL AND NEW.grantee_username::text <> '') OR (NEW.study_id IS NOT NULL AND NEW.study_id::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_study_shares_checks();
COMMENT ON TRIGGER rif40_study_shares_checks ON rif40_study_shares IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_study_shares_checks()';
CREATE TRIGGER rif40_study_shares_checks_del
	BEFORE DELETE ON rif40_study_shares
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_study_shares_checks();
COMMENT ON TRIGGER rif40_study_shares_checks_del ON rif40_study_shares IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_study_shares_checks()';

CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_rif40_tables_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_rif40_tables_checks_description>
<para>
Check TABLE_NAME exists. DO NOT RAISE AN ERROR IF IT DOES; otherwise check, column <TABLE_NAME>.TOTAL_FIELD,  column <TABLE_NAME>.ICD_FIELD_NAME exists. This allows the RIF40 schema owner to not have access to the tables. Access is checked in RIF40_NUM_DENOM. Automatic (Able to be used in automatic RIF40_NUM_DENOM (0/1, default 0). A user specific T_RIF40_NUM_DENOM is supplied for other combinations. Cannot be applied to direct standardisation denominator) is restricted to 1 denominator per geography.
Check table_name, total_field, sex_field_name, age_group_field_name, age_sex_group_field_name Oracle names.
</para>
</trigger_rif40_tables_checks_description>
 */
--
-- Error range: -20180 to -20199 - RIF40_TABLES
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c1rt CURSOR (l_schema VARCHAR, l_table VARCHAR, l_column VARCHAR) FOR
		WITH all_tab_columns AS (
			SELECT UPPER(a.tablename) AS tablename, UPPER(b.attname) AS columnname, UPPER(schemaname) AS schemaname	/* Tables */
			  FROM pg_tables a, pg_attribute b, pg_class c
			 WHERE c.oid        = b.attrelid
			   AND c.relname    = a.tablename
			   AND c.relkind    = 'r' /* Relational table */
			   AND c.relpersistence IN ('p', 'u') /* Persistence: permanent/unlogged */ 
			 UNION
			SELECT UPPER(a.viewname) AS tablename, UPPER(b.attname) AS columnname, UPPER(schemaname) AS schemaname	/* Views */
			  FROM pg_views a, pg_attribute b, pg_class c
			 WHERE c.oid        = b.attrelid
			   AND c.relname    = a.viewname
			   AND c.relkind    = 'v' /* View */
			 UNION
			SELECT UPPER(a.relname) AS tablename, UPPER(d.attname) AS columnname, UPPER(n.nspname) AS schemaname				/* User FDW foreign tables */
			  FROM pg_foreign_table b, pg_roles r, pg_attribute d, pg_class a
				LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
			 WHERE b.ftrelid  = a.oid
			   AND a.relowner = (SELECT oid FROM pg_roles WHERE rolname = USER)
			   AND a.relowner = r.oid
			   AND n.nspname  = USER
			   AND a.oid      = d.attrelid
		)
		SELECT columnname
		  FROM all_tab_columns
		 WHERE schemaname = UPPER(l_schema)
		   AND tablename  = UPPER(l_table)
		   AND columnname = UPPER(l_column);
	c1_rec RECORD;
--
	schema		varchar(30);
--	msg 		varchar(4000)	:= NULL;
BEGIN
--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
     
	schema:=rif40_sql_pkg.rif40_object_resolve(NEW.table_name::VARCHAR);
--
-- Normally the schema owner will not be able to see the data tables, so there is no error here
-- You must have access to automatic indirect standardisation denominators
--
	IF (schema IS NOT NULL) THEN
		IF (NEW.total_field IS NOT NULL AND NEW.total_field::text <> '') THEN
			OPEN c1rt(schema, NEW.table_name, NEW.total_field);
			FETCH c1rt INTO c1_rec;
			CLOSE c1rt;
			IF coalesce(c1_rec.columnname::text, '') = '' THEN
				PERFORM rif40_log_pkg.rif40_error(-20180, 'trigger_fct_rif40_tables_checks', '[20180] Error: RIF40_TABLES TOTAL_FIELD % column not found in table: %',
					NEW.total_field::VARCHAR	/* Total field */,
					NEW.table_name::VARCHAR		/* Table name */);
			ELSE
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_tables_checks', '[20180] RIF40_TABLES TOTAL_FIELD % column found in table: %',
					NEW.total_field::VARCHAR	/* Total field */,
					NEW.table_name::VARCHAR		/* Table name */);
			END IF;
		END IF;
	END IF;
--
-- Check direct standardised denominators exist system wide
--
	IF NEW.isdirectdenominator = 1 THEN
		IF coalesce(NEW.table_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20181, 'trigger_fct_rif40_tables_checks', '[20181] RIF40_TABLES direct standardised denominator TABLE_NAME (%) not found',
				NEW.table_name::VARCHAR		/* Table name */);
		END IF;
	END IF;
--
-- Automatic
--
--	IF NEW.automatic = 1 AND NEW.isindirectdenominator = 1 THEN
--		IF coalesce(table_or_view::text, '') = '' THEN
--			PERFORM rif40_log_pkg.rif40_error(-20182, 'RIF40_TABLES TABLE_NAME ('||NEW.table_name||') not found');
--		END IF;
--
-- This causes:
-- ORA-04091: table RIF40.RIF40_TABLES is mutating, trigger/function may not see it
--
-- Enforced in RIF40_NUM_DENOM
--
--		msg:=PERFORM rif40_log_pkg.rif40_auto_indirect_checks(table_or_view);
--		IF (msg IS NOT NULL AND msg::text <> '') THEN
--			PERFORM rif40_log_pkg.rif40_error(-20183, 'RIF40_TABLES table: '||UPPER(table_or_view)||
--				' (automatic indirect denominator) has >1 per geography: '||msg);
--		END IF;
--
--	END IF;
--
-- Check table_name, total_field, sex_field_name, age_group_field_name, age_sex_group_field_name Oracle names
--
	PERFORM rif40_trg_pkg.rif40_db_name_check('TABLE_NAME', NEW.table_name);
	PERFORM rif40_trg_pkg.rif40_db_name_check('TOTAL_FIELD', NEW.total_field);
	IF (NEW.sex_field_name IS NOT NULL AND NEW.sex_field_name::text <> '') THEN
		PERFORM rif40_trg_pkg.rif40_db_name_check('SEX_FIELD_NAME', NEW.sex_field_name);
	END IF;
	IF (NEW.age_group_field_name IS NOT NULL AND NEW.age_group_field_name::text <> '') THEN
		PERFORM rif40_trg_pkg.rif40_db_name_check('AGE_GROUP_FIELD_NAME', NEW.age_group_field_name);
	END IF;
	IF (NEW.age_sex_group_field_name IS NOT NULL AND NEW.age_sex_group_field_name::text <> '') THEN
		PERFORM rif40_trg_pkg.rif40_db_name_check('AGE_SEX_GROUP_FIELD_NAME', NEW.age_sex_group_field_name);
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END; 
$BODY$
LANGUAGE 'plpgsql';
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_rif40_tables_checks() IS 'Check TABLE_NAME exists. DO NOT RAISE AN ERROR IF IT DOES; otherwise check, column <TABLE_NAME>.TOTAL_FIELD,  column <TABLE_NAME>.ICD_FIELD_NAME exists. This allows the RIF40 schema owner to not have access to the tables. Access is checked in RIF40_NUM_DENOM. Automatic (Able to be used in automatic RIF40_NUM_DENOM (0/1, default 0). A user specific T_RIF40_NUM_DENOM is supplied for other combinations. Cannot be applied to direct standardisation denominator) is restricted to 1 denominator per geography.
Check table_name, total_field, sex_field_name, age_group_field_name, age_sex_group_field_name Oracle names.

Error range: -20180 to -20199 - RIF40_TABLES';

CREATE TRIGGER rif40_tables_checks
	BEFORE INSERT OR UPDATE OF isdirectdenominator, table_name, total_field,
		sex_field_name, age_group_field_name, age_sex_group_field_name ON rif40_tables
	FOR EACH ROW
	WHEN ((NEW.table_name IS NOT NULL AND NEW.table_name::text <> '') OR 
		(NEW.isdirectdenominator IS NOT NULL AND NEW.isdirectdenominator::text <> '') OR 
		(NEW.table_name IS NOT NULL AND NEW.table_name::text <> '') OR 
		(NEW.total_field IS NOT NULL AND NEW.total_field::text <> '') OR
		(NEW.sex_field_name IS NOT NULL AND NEW.sex_field_name::text <> '') OR 
		(NEW.age_group_field_name IS NOT NULL AND NEW.age_group_field_name::text <> '') OR 
		(NEW.age_sex_group_field_name IS NOT NULL AND NEW.age_sex_group_field_name::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_tables_checks();
COMMENT ON TRIGGER rif40_tables_checks ON rif40_tables IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_tables_checks()';
CREATE TRIGGER rif40_tables_checks_del
	BEFORE DELETE ON rif40_tables
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_tables_checks();
COMMENT ON TRIGGER rif40_tables_checks_del ON rif40_tables IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_tables_checks()';

CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_rif40_table_outcomes_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_rif40_table_outcomes_checks_description>
<para>
Check current_version_start_year (if not NULL) BETWEEN rif40_tables.year_start AND rif40_tables.year_stop
Check numer_tab is a numerator
</para>
</trigger_rif40_table_outcomes_checks_description>
 */
--
-- -20440 to -20459 - RIF40_TABLE_OUTCOMES
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
        c1rto CURSOR(l_table VARCHAR) FOR
		SELECT *
		  FROM rif40_tables
		 WHERE table_name = l_table;
	c1_rec RECORD;
BEGIN
--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
--
	OPEN c1rto(NEW.numer_tab);
	FETCH c1rto INTO c1_rec;
	IF c1_rec.table_name IS NULL THEN
		CLOSE c1rto;
		PERFORM rif40_log_pkg.rif40_error(-20440, 'trigger_fct_rif40_table_outcomes_checks', '[20440] RIF40_TABLE_OUTCOMES outcome group name % numerator (%) not found in RIF tables',
			NEW.outcome_group_name::VARCHAR	/* Outcome group */,
			NEW.numer_tab::VARCHAR 		/* Numerator table */);
	END IF;
	CLOSE c1rto;
--
-- Check current_version_start_year (if not NULL) BETWEEN rif40_tables.year_start AND rif40_tables.year_stop
--
	IF NOT NEW.current_version_start_year BETWEEN c1_rec.year_start AND c1_rec.year_stop THEN
		PERFORM rif40_log_pkg.rif40_error(-20441, 'trigger_fct_rif40_table_outcomes_checks', '[20441] RIF40_TABLE_OUTCOMES outcome group name % current_version_start_year (%) not NOT between % and %',
			NEW.outcome_group_name::VARCHAR		/* Outcome group */,
			NEW.current_version_start_year::VARCHAR	/* Current version start year */,
			c1_rec.year_start::VARCHAR		/* Year start */,
			c1_rec.year_stop::VARCHAR		/* Year stop */);
	END IF;

--
-- Check numer_tab is a numerator
--
	IF c1_rec.isnumerator != 1 THEN
		PERFORM rif40_log_pkg.rif40_error(-20442, 'trigger_fct_rif40_table_outcomes_checks', '[20442] RIF40_TABLE_OUTCOMES outcome group name % numerator (%) is not a numerator',
			NEW.outcome_group_name::VARCHAR	/* Outcome group */,
			NEW.numer_tab::VARCHAR 		/* Numerator table */);
	END IF;
--
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_table_outcomes_checks', '[20440-2] RIF40_TABLE_OUTCOMES outcome group name % numerator (%) OK',
		NEW.outcome_group_name::VARCHAR	/* Outcome group */,
		NEW.numer_tab::VARCHAR 		/* Numerator table */);
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
$BODY$
LANGUAGE 'plpgsql';
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_rif40_table_outcomes_checks() IS 'Check current_version_start_year (if not NULL) BETWEEN rif40_tables.year_start AND rif40_tables.year_stop
Check numer_tab is a numerator
 
-20440 to -20459 - RIF40_TABLE_OUTCOMES';

CREATE TRIGGER rif40_table_outcomes_checks
	BEFORE INSERT OR UPDATE OF outcome_group_name, numer_tab, current_version_start_year
	ON rif40_table_outcomes
	FOR EACH ROW
	WHEN ((NEW.outcome_group_name IS NOT NULL AND NEW.outcome_group_name::text <> '') OR 
		(NEW.numer_tab IS NOT NULL AND NEW.numer_tab::text <> '') OR 
		(NEW.current_version_start_year IS NOT NULL AND NEW.current_version_start_year::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_table_outcomes_checks();
COMMENT ON TRIGGER rif40_table_outcomes_checks ON rif40_table_outcomes IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_table_outcomes_checks()';
CREATE TRIGGER rif40_table_outcomes_checks_del
	BEFORE DELETE ON rif40_table_outcomes
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_table_outcomes_checks();
COMMENT ON TRIGGER rif40_table_outcomes_checks_del ON rif40_table_outcomes IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_table_outcomes_checks()';

CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_rif40_version_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_rif40_version_checks_description>
<para>
Check - single column, populate schema_amended. Prevent DELETE or INSERT
</para>
</trigger_rif40_version_checks_description>
 */
--
-- Error range: -20160 to -20179 - RIF40_VERSION
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c1vc CURSOR FOR
		SELECT COUNT(*) AS total
		  FROM rif40_version;
	c1_rec RECORD;
BEGIN
	IF TG_OP = 'INSERT' THEN
		OPEN c1vc;
		FETCH c1vc INTO c1_rec;
		CLOSE c1vc;
--
		IF c1_rec.total > 0 THEN
			PERFORM rif40_log_pkg.rif40_error(-20160, 'trigger_fct_rif40_version_checks', '[20160] Error: RIF40_VERSION INSERT disallowed, rows: %',
				c1_rec.total::VARCHAR /* rows */);
		END IF;
	ELSIF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20161, 'trigger_fct_rif40_version_checks', '[20161] Error: RIF40_VERSION DELETE disallowed');
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
--
		NEW.schema_amended := LOCALTIMESTAMP;
		RETURN NEW;
	END IF;
END;
$BODY$
LANGUAGE 'plpgsql';
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_rif40_version_checks() IS 'Check - single column, populate schema_amended. Prevent DELETE or INSERT
Error range: -20160 to -20179 - RIF40_VERSION';

CREATE TRIGGER rif40_version_checks
	BEFORE INSERT OR UPDATE OF version ON rif40_version
	FOR EACH ROW
	WHEN ((NEW.version IS NOT NULL AND NEW.version::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_version_checks();
COMMENT ON TRIGGER rif40_version_checks ON rif40_version IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_version_checks()';
CREATE TRIGGER rif40_version_checks_del
	BEFORE DELETE ON rif40_version
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_version_checks();
COMMENT ON TRIGGER rif40_version_checks_del ON rif40_version IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_version_checks()';

DROP TRIGGER IF EXISTS t_rif40_studies_checks ON "t_rif40_studies" CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_studies_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_t_rif40_studies_checks_description>
<para>
Check - USERNAME exists.
Check - USERNAME is Kerberos USER on INSERT.
Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT.
Check - UPDATE not allowed except for IG admin and state changes.
Check - DELETE only allowed on own records.
Check - EXTRACT_TABLE Oracle name.
Check - Comparison area geolevel name. Must be a valid GEOLEVEL_NAME for the study GEOGRPAHY in T_RIF40_GEOLEVELS, with COMPAREA=1
Check - DENOM_TAB, DIRECT_STAND_TAB are valid Oracle names and appropriate denominators, and user has access.
Check - Study area resolution (GEOLEVEL_ID) >= comparision area resolution (GEOLEVEL_ID)  [i.e study area has the same or higher resolution]

Check - suppression_value - Suppress results with low cell counts below this value. If the role RIF_NO_SUPRESSION is granted and the user is not a RIF_STUDENT then SUPPRESSION_VALUE=0; otherwise is equals the parameter "SuppressionValue". If >0 all results with the value or below will be set to 0.
Check - extract_permitted - Is extract permitted from the database: 0/1. Only a RIF MANAGER may change this value. This user is still permitted to create and run a RIF study and to view the results. Geolevel access is rectricted by the RIF40_GEOLEVELS.RESTRICTED Inforamtion Governance restrictions (0/1). If 1 (Yes) then a) students cannot access this geolevel and b) if the system parameter ExtractControl=1 then the user must be granted permission by a RIF_MANAGER to extract from the database the results, data extract and maps tables. All students must be granted permission by a RIF_MANAGER for any extract if the system parameter ExtractControl=1. This is enforced by the RIF application.

Check - authorised_by - must be a RIF MANAGER.

Check - transfer_permitted - Is transfer permitted from the Secure or Private Network: 0/1. This is for purely documentatary purposes only. Only a RIF MANAGER may change this value. The value defaults to the same as EXTRACT_PERMITTED. Only geolevels where RIF40_GEOLEVELS.RESTRICTED=0 may be transferred

Check - authorised_notes -IG authorisation notes. Must be filled in if EXTRACT_PERMITTED=1

Delayed RIF40_TABLES denominator and direct standardisation checks:
Check - Column <TABLE_NAME>.TOTAL_FIELD, SEX_FIELD_NAME, AGE_GROUP_FIELD_NAME, AGE_SEX_GROUP_FIELD_NAME exists

IF USER = NEW.username (i.e. not initial RIF40 INSERT) THEN
	grant to all shared users if not already granted
 </para>
</trigger_t_rif40_studies_checks_description>
 */
--
-- Error range: -20200 to -20259 - T_RIF40_STUDIES
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
-- $Log: v4_0_postgres_triggers.sql,v $
-- Revision 1.6  2014/02/24 10:50:28  peterh
-- Full build from Oracle, including default study area and removal of year_start/stop min/max_age_group from T_RIF40_STUDIES
--
-- Still present in view
--
-- Revision 1.5  2013/09/25 12:12:22  peterh
-- Baseline after 2x full clean builds at Postgres level
-- TODO.txt uptodate
--
-- Revision 1.4  2013/09/18 15:20:32  peterh
-- Checkin at end of 6 week RIF focus. Got as far as SAHSULAND run study to completion for observed only
--
-- Revision 1.3  2013/09/02 14:08:33  peterh
--
-- Baseline after full trigger implmentation
--
--
	c1_stck CURSOR(l_table_name VARCHAR) FOR
		SELECT a.year_start, a.year_stop, a.isindirectdenominator, a.isdirectdenominator, a.isnumerator,
		       a.age_sex_group_field_name, a.sex_field_name, a.age_group_field_name, a.total_field,
                       MIN(g.offset) AS min_age_group, MAX(g.offset) AS max_age_group
		  FROM rif40_tables a
			LEFT OUTER JOIN rif40_age_groups g ON (g.age_group_id  = a.age_group_id)
		 WHERE table_name = l_table_name
		 GROUP BY a.year_start, a.year_stop, a.isindirectdenominator, a.isdirectdenominator, a.isnumerator,
  		          a.age_sex_group_field_name, a.sex_field_name, a.age_group_field_name, a.total_field;
	c1b_rec RECORD; /* Denominator */
	c1c_rec RECORD; /* Direct standardisation table */
	c2_stck CURSOR(l_geography VARCHAR, l_geolevel_name VARCHAR) FOR
		SELECT *
		  FROM t_rif40_geolevels
		 WHERE l_geography     = geography
		   AND l_geolevel_name = geolevel_name;
	c2a_rec RECORD;
	c2b_rec RECORD;
	c3_stck CURSOR (l_study_id INTEGER) FOR
		SELECT comparison_geolevel_name
		  FROM t_rif40_studies
		 WHERE study_id = l_study_id;
	c3_rec RECORD;
	c4_stck CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c4_rec RECORD;
	c5_stck CURSOR(l_username VARCHAR /* Study owner/IG role */) FOR
		SELECT CASE WHEN rif40_sql_pkg.does_role_exist(l_username) AND
		      		pg_has_role(l_username, 'rif_manager', 'USAGE') THEN 1 /* Not RIF_MANAGER */ ELSE 0 END AS rif_manager,
     		       CASE WHEN rif40_sql_pkg.does_role_exist(l_username) AND
		      		rif40_sql_pkg.rif40_does_role_exist('rif_student') AND
				pg_has_role(l_username, 'rif_student', 'USAGE') THEN 1 /* Not RIF_STUDENT */ ELSE 0 END AS rif_student,
		       c.param_value AS suppressionvalue,
     		       p1.param_value::INTEGER AS extractcontrol
		  FROM (
			SELECT p2.param_name, 
			       CASE WHEN rif40_sql_pkg.does_role_exist(l_username) AND
		      		pg_has_role(l_username, 'rif_no_suppression', 'USAGE') THEN 1 /* Not Suppressed */ ELSE p2.param_value::INTEGER END param_value
			  FROM rif40.t_rif40_parameters p2
			 WHERE p2.param_name = 'SuppressionValue') c
			LEFT OUTER JOIN t_rif40_parameters p1 ON (p1.param_name = 'ExtractControl');
	c5_rec RECORD;
	c6_stck CURSOR (l_schema VARCHAR, l_table VARCHAR, l_column VARCHAR) IS
		SELECT column_name
		  FROM information_schema.columns
		 WHERE table_schema = LOWER(l_schema)
		   AND table_name   = LOWER(l_table)
		   AND column_name  = LOWER(l_column);
	c6_rec RECORD;
--
	schema			VARCHAR(30);
	denom_owner		VARCHAR(30);
	denom_table		VARCHAR(30);
	direct_stand_owner	VARCHAR(30);
	direct_stand_table	VARCHAR(30);
--
	study_state_only_flag 	BOOLEAN:=FALSE;
	ig_state_only_flag 	BOOLEAN:=FALSE;
BEGIN
--
-- T_RIF40_STUDIES:	Check - USERNAME is Kerberos USER on INSERT
--			Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT
-- 			Check - UPDATE not allowed except for IG admin and state changes
--			Check - DELETE only allowed on own records
--
	OPEN c4_stck;	/* Initial RIF40 insert */
	FETCH c4_stck INTO c4_rec;
	CLOSE c4_stck;
            
	IF NOT TG_OP = 'DELETE' THEN
		OPEN c5_stck(NEW.username); /* Study owner/IG role */
		FETCH c5_stck INTO c5_rec;
		CLOSE c5_stck;
        END IF;

--
-- Determine if the study state only has changed
--
	IF TG_OP = 'UPDATE' AND
	   coalesce(NEW.study_id::text, '') = coalesce(OLD.study_id::text, '') AND
	   coalesce(NEW.username::text, '') = coalesce(OLD.username::text, '') AND
	   coalesce(NEW.geography::text, '') = coalesce(OLD.geography::text, '') AND
	   coalesce(NEW.project::text, '') = coalesce(OLD.project::text, '') AND
	   coalesce(NEW.study_name::text, '') = coalesce(OLD.study_name::text, '') AND
	   coalesce(NEW.extract_table::text, '') = coalesce(OLD.extract_table::text, '') AND
	   coalesce(NEW.map_table::text, '') = coalesce(OLD.map_table::text, '') AND
	   coalesce(NEW.study_date::text, '') = coalesce(OLD.study_date::text, '') AND
	   coalesce(NEW.study_type::text, '') = coalesce(OLD.study_type::text, '') AND
	   coalesce(NEW.comparison_geolevel_name::text, '') = coalesce(OLD.comparison_geolevel_name::text, '') AND
	   coalesce(NEW.study_geolevel_name::text, '') = coalesce(OLD.study_geolevel_name::text, '') AND
	   coalesce(NEW.denom_tab::text, '') = coalesce(OLD.denom_tab::text, '') AND
	   coalesce(NEW.direct_stand_tab::text, '') = coalesce(OLD.direct_stand_tab::text, '') AND
/*
Year_stop/start, min/max_age_group removed from t_rif40_studies. Still in view

	   coalesce(NEW.year_start::text, '') = coalesce(OLD.year_start::text, '') AND
	   coalesce(NEW.year_stop::text, '') = coalesce(OLD.year_stop::text, '') AND
	   coalesce(NEW.max_age_group::text, '') = coalesce(OLD.max_age_group::text, '') AND
	   coalesce(NEW.min_age_group::text, '') = coalesce(OLD.min_age_group::text, '') AND
*/
	   coalesce(NEW.suppression_value::text, '') = coalesce(OLD.suppression_value::text, '') AND
	   coalesce(NEW.extract_permitted::text, '') = coalesce(OLD.extract_permitted::text, '') AND
	   coalesce(NEW.transfer_permitted::text, '') = coalesce(OLD.transfer_permitted::text, '') AND
	   coalesce(NEW.authorised_by::text, '') = coalesce(OLD.authorised_by::text, '') AND
	   coalesce(NEW.authorised_on::text, '') = coalesce(OLD.authorised_on::text, '') AND
	   coalesce(NEW.authorised_notes::text, '') = coalesce(OLD.authorised_notes::text, '') AND
	   coalesce(NEW.audsid::text, '') = coalesce(OLD.audsid::text, '') AND
/*
	   NEW.study_id = OLD.study_id AND
	   NEW.username = OLD.username AND
	   NEW.geography = OLD.geography AND
	   NEW.project = OLD.project AND
	   NEW.study_name = OLD.study_name AND
	   NEW.extract_table = OLD.extract_table AND
	   NEW.map_table = OLD.map_table AND
	   NEW.study_date = OLD.study_date AND
	   NEW.study_type = OLD.study_type AND
	   NEW.comparison_geolevel_name = OLD.comparison_geolevel_name AND
	   NEW.study_geolevel_name = OLD.study_geolevel_name AND
	   NEW.denom_tab = OLD.denom_tab AND
	   NEW.direct_stand_tab = OLD.direct_stand_tab AND
	   NEW.year_start = OLD.year_start AND
	   NEW.year_stop = OLD.year_stop AND
	   NEW.max_age_group = OLD.max_age_group AND
	   NEW.min_age_group = OLD.min_age_group AND
	   NEW.suppression_value = OLD.suppression_value AND
	   NEW.extract_permitted = OLD.extract_permitted AND
	   NEW.transfer_permitted = OLD.transfer_permitted AND
	   NEW.authorised_by = OLD.authorised_by AND
	   NEW.authorised_on = OLD.authorised_on AND
	   NEW.authorised_notes = OLD.authorised_notes AND
	   NEW.audsid = OLD.audsid AND       */
 	 	  NEW.study_state != OLD.study_state THEN
		study_state_only_flag:=TRUE;
	END IF;

--
-- Determine if the IG state only has changed
--
	IF TG_OP = 'UPDATE' AND
/*
	   NEW.study_id = OLD.study_id AND
	   NEW.username = OLD.username AND
	   NEW.geography = OLD.geography AND
	   NEW.project = OLD.project AND
	   NEW.study_name = OLD.study_name AND
	   NEW.extract_table = OLD.extract_table AND
	   NEW.map_table = OLD.map_table AND
	   NEW.study_date = OLD.study_date AND
	   NEW.study_type = OLD.study_type AND
	   NEW.study_state = OLD.study_state AND
	   NEW.comparison_geolevel_name = OLD.comparison_geolevel_name AND
	   NEW.study_geolevel_name = OLD.study_geolevel_name AND
	   NEW.denom_tab = OLD.denom_tab AND
	   NEW.direct_stand_tab = OLD.direct_stand_tab AND
	   NEW.year_start = OLD.year_start AND
	   NEW.year_stop = OLD.year_stop AND
	   NEW.max_age_group = OLD.max_age_group AND
	   NEW.min_age_group = OLD.min_age_group AND
	   NEW.suppression_value = OLD.suppression_value AND
	   NEW.audsid = OLD.audsid AND (
	 	   NEW.extract_permitted != OLD.extract_permitted OR
		   NEW.transfer_permitted != OLD.transfer_permitted OR
		   NEW.authorised_by != OLD.authorised_by OR
		   NEW.authorised_on != OLD.authorised_on OR
		   NEW.authorised_notes != OLD.authorised_notes) THEN  */

           coalesce(NEW.study_id::text, '') = coalesce(OLD.study_id::text, '') AND
	   coalesce(NEW.username::text, '') = coalesce(OLD.username::text, '') AND
	   coalesce(NEW.geography::text, '') = coalesce(OLD.geography::text, '') AND
	   coalesce(NEW.project::text, '') = coalesce(OLD.project::text, '') AND
	   coalesce(NEW.study_name::text, '') = coalesce(OLD.study_name::text, '') AND
	   coalesce(NEW.extract_table::text, '') = coalesce(OLD.extract_table::text, '') AND
	   coalesce(NEW.map_table::text, '') = coalesce(OLD.map_table::text, '') AND
	   coalesce(NEW.study_date::text, '') = coalesce(OLD.study_date::text, '') AND
	   coalesce(NEW.study_type::text, '') = coalesce(OLD.study_type::text, '') AND
	   coalesce(NEW.comparison_geolevel_name::text, '') = coalesce(OLD.comparison_geolevel_name::text, '') AND
	   coalesce(NEW.study_geolevel_name::text, '') = coalesce(OLD.study_geolevel_name::text, '') AND
	   coalesce(NEW.denom_tab::text, '') = coalesce(OLD.denom_tab::text, '') AND
	   coalesce(NEW.direct_stand_tab::text, '') = coalesce(OLD.direct_stand_tab::text, '') AND
/*
Year_stop/start, min/max_age_group removed from t_rif40_studies. Still in view

	   coalesce(NEW.year_start::text, '') = coalesce(OLD.year_start::text, '') AND
	   coalesce(NEW.year_stop::text, '') = coalesce(OLD.year_stop::text, '') AND
	   coalesce(NEW.max_age_group::text, '') = coalesce(OLD.max_age_group::text, '') AND
	   coalesce(NEW.min_age_group::text, '') = coalesce(OLD.min_age_group::text, '') AND
 */
	   coalesce(NEW.suppression_value::text, '') = coalesce(OLD.suppression_value::text, '') AND
	   coalesce(NEW.audsid::text, '') = coalesce(OLD.audsid::text, '') AND (      
	   	coalesce(NEW.extract_permitted::text, '') != coalesce(OLD.extract_permitted::text, '') OR
	   	coalesce(NEW.transfer_permitted::text, '') != coalesce(OLD.transfer_permitted::text, '') OR
	   	coalesce(NEW.authorised_by::text, '') != coalesce(OLD.authorised_by::text, '') OR
	   	coalesce(NEW.authorised_on::text, '') != coalesce(OLD.authorised_on::text, '') OR
	   	coalesce(NEW.authorised_notes::text, '') != coalesce(OLD.authorised_notes::text, '') ) THEN  

		ig_state_only_flag:=TRUE;
	END IF;
--
	IF TG_OP = 'INSERT' AND NEW.username != USER THEN
		IF USER = 'rif40' AND c4_rec.total = 0 THEN 
			/* Allowed duing build before first result is added to system or when converting Kerberos users */
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
				'[20200] T_RIF40_STUDIES study % username: % is not USER: %; allowed duing build before first result is added to system',
				NEW.study_id::VARCHAR	/* Study id */,
				NEW.username::VARCHAR	/* New username */,
				USER::VARCHAR		/* Username */);
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20200, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study % username: % is not USER: %',
				NEW.study_id::VARCHAR	/* Study id */,
				NEW.username::VARCHAR	/* New username */,
				USER::VARCHAR		/* Username */);
		END IF;
	ELSIF TG_OP = 'UPDATE' AND NEW.username != USER THEN
		IF USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN 
			/* Allowed duing build before first result is added to system or when converting Kerberos users */
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
				'[20200] T_RIF40_STUDIES study % new username: % is not USER: %; allowed duing build before first result is added to system; Old: %',
				NEW.study_id::VARCHAR	/* Study id */,
				NEW.username::VARCHAR	/* New username */,
				USER::VARCHAR		/* Username */,
				OLD.username::VARCHAR	/* Old username */);
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20200, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study % new username: % is not USER: %; Old: %',
				NEW.study_id::VARCHAR	/* Study id */,
				NEW.username::VARCHAR	/* New username */,
				USER::VARCHAR		/* Username */,
				OLD.username::VARCHAR	/* Old username */);
		END IF;
/* Kerberos checks no longer possible 
	ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20201, 'T_RIF40_STUDIES study % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR	-* Study id *-,
			NEW.username::VARCHAR 	-* Insert username *-,
			USER::VARCHAR -* User *-); */
	END IF;
	IF TG_OP = 'INSERT' THEN
		NEW.audsid:=SYS_CONTEXT('USERENV', 'SESSIONID');
	ELSIF TG_OP = 'UPDATE' THEN /* Allow */
		IF NEW.username = OLD.username THEN
--
-- Only allow state changes
--
			IF study_state_only_flag THEN
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
					'[20202] T_RIF40_STUDIES study % UPDATE state changes allowed on T_RIF40_STUDIES by user: %',
					NEW.study_id::VARCHAR	/* Study id */,
					USER::VARCHAR 		/* username */);
--
-- Verify state change
--
				NEW.study_state:=rif40_sm_pkg.rif40_verify_state_change(NEW.study_id, OLD.study_state, NEW.study_state);
			ELSE
				PERFORM rif40_log_pkg.rif40_error(-20202, 'trigger_fct_t_rif40_studies_checks', 
					'T_RIF40_STUDIES study % non state change UPDATE not allowed on T_RIF40_STUDIES by user: %',
					NEW.study_id::VARCHAR	/* Study id */,
					USER::VARCHAR 		/* username */);
			END IF;
		ELSE
			IF c5_rec.rif_manager = 1 THEN
--
-- Only allow IG changes
--
				IF USER = 'rif40' AND strpos(OLD.username, '@PRIVATE.NET') > 0 THEN
					NULL; 		/* RIF studies update OK from @PRIVATE.NET to postgres */
				ELSIF ig_state_only_flag THEN
					NEW.username :=OLD.username; /* Keep the original user name */
					PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
						'[20203] T_RIF40_STUDIES study % UPDATE IG changes allowed on T_RIF40_STUDIES by user: %',
						NEW.study_id::VARCHAR	/* Study id */,
						USER::VARCHAR 		/* username */);
				ELSE
					PERFORM rif40_log_pkg.rif40_error(-20203, 'trigger_fct_t_rif40_studies_checks', 
						'T_RIF40_STUDIES study % non IG UPDATE not allowed on T_RIF40_STUDIES by user: %',
						NEW.study_id::VARCHAR	/* Study id */,
						USER::VARCHAR 		/* username */);
				END IF;
			ELSIF USER = 'rif40' AND strpos(OLD.username, '@PRIVATE.NET') > 0 THEN
				NULL; 		/* RIF studies update OK from @PRIVATE.NET to postgres */
			ELSE
				PERFORM rif40_log_pkg.rif40_error(-20204, 'trigger_fct_t_rif40_studies_checks', 
					'T_RIF40_STUDIES study % UPDATE not allowed on T_RIF40_STUDIES by user: %',
					NEW.study_id::VARCHAR	/* Study id */,
					USER::VARCHAR 		/* username */);
			END IF;
		END IF;
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20205, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % DELETE only allowed on own records in T_RIF40_STUDIES, record created by: %',
			OLD.study_id::VARCHAR			/* Study id */,
			OLD.username::VARCHAR 			/* Insert (old) user name */);
	END IF;

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
			'[20200-5] T_RIF40_STUDIES study % CRUD checks OK',
			OLD.study_id::VARCHAR			/* Study id */);
		RETURN OLD;
	END IF;
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
	       	'[20200-5] T_RIF40_STUDIES study % CRUD checks OK',
       		NEW.study_id::VARCHAR			/* Study id */);
    
--
-- Check - Comparison area geolevel name(COMPARISON_GEOLEVEL_NAME). Must be a valid GEOLEVEL_NAME for the study GEOGRPAHY in T_RIF40_GEOLEVELS, with COMPAREA=1.
--
	IF (NEW.comparison_geolevel_name IS NOT NULL AND NEW.comparison_geolevel_name::text <> '') THEN
		OPEN c2_stck(NEW.geography, NEW.comparison_geolevel_name);
		FETCH c2_stck INTO c2a_rec;
		IF NOT FOUND THEN
			CLOSE c2_stck;
			PERFORM rif40_log_pkg.rif40_error(-20206, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study % comparison area geolevel name: "%" not found in RIF40_GEOLEVELS',
				NEW.study_id::VARCHAR			/* Study id */,
				NEW.comparison_geolevel_name::VARCHAR 	/* comparison area geolevel name */ );
		END IF;
		IF c2a_rec.comparea != 1 THEN
			CLOSE c2_stck;
			PERFORM rif40_log_pkg.rif40_error(-20207, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study % comparison area geolevel name: "%" in RIF40_GEOLEVELS is not a comparison area',
				NEW.study_id::VARCHAR			/* Study id */,
				NEW.comparison_geolevel_name 		/* comparison area geolevel name */ );
		END IF;
		CLOSE c2_stck;
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
			'[20206-7] T_RIF40_STUDIES study % comparison area geolevel name: "%" OK',
			NEW.study_id::VARCHAR				/* Study id */,
			NEW.comparison_geolevel_name::VARCHAR 		/* comparison area geolevel name */ );
	ELSE
		PERFORM rif40_log_pkg.rif40_error(-20208, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % NULL comparison area geolevel name',
			NEW.study_id::VARCHAR				/* Study id */);
	END IF;
--
-- Check - STUDY_GEOLEVEL_NAME. Must be a valid GEOLEVEL_NAME for the study GEOGRPAHY in T_RIF40_GEOLEVELS
--
	IF (NEW.study_geolevel_name IS NOT NULL AND NEW.study_geolevel_name::text <> '') THEN
		OPEN c2_stck(NEW.geography, NEW.study_geolevel_name);
		FETCH c2_stck INTO c2b_rec;
		IF NOT FOUND THEN
			CLOSE c2_stck;
			PERFORM rif40_log_pkg.rif40_error(-20209, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study % study area geolevel name: "%" not found in RIF40_GEOLEVELS',
				NEW.study_id::VARCHAR			/* Study id */,
				NEW.study_geolevel_name::VARCHAR 	/* Study area geolevel name */);
		END IF;
/*
 * Wrong - all areas are assummed to be mappable
 *
		IF c2b_rec.resolution != 1 THEN
			CLOSE c2;
			PERFORM rif40_log_pkg.rif40x_error(-202xx, 'T_RIF40_STUDIES study area geolevel name: '||NEW.study_geolevel_name||
				' in RIF40_GEOLEVELS is not a mappable area');
		END IF;
 */
		CLOSE c2_stck;
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
			'[20209] T_RIF40_STUDIES study % study area geolevel name: "%" OK',
			NEW.study_id::VARCHAR				/* Study id */,
			NEW.study_geolevel_name::VARCHAR 		/* Study area geolevel name */);
	ELSE
		PERFORM rif40_log_pkg.rif40_error(-20210, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % NULL study area geolevel name',
			NEW.study_id::VARCHAR				/* Study id */);
	END IF;

--
-- Check - DENOM_TAB, DIRECT_STAND_TAB are valid Oracle names and appropriate denominators, and user has access.
--
	PERFORM rif40_trg_pkg.rif40_db_name_check('DENOM_TAB', NEW.denom_tab);
	IF (NEW.direct_stand_tab IS NOT NULL AND NEW.direct_stand_tab::text <> '') THEN
		PERFORM rif40_trg_pkg.rif40_db_name_check('DIRECT_STAND_TAB', NEW.direct_stand_tab);
	END IF;
--
	OPEN c1_stck(NEW.denom_tab);
	FETCH c1_stck INTO c1b_rec;
	IF NOT FOUND THEN
		CLOSE c1_stck;
		PERFORM rif40_log_pkg.rif40_error(-20211, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % denominator: % not found in RIF40_TABLES',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.denom_tab::VARCHAR 		/* Denominator */);
	END IF;
	denom_owner:=rif40_sql_pkg.rif40_object_resolve(NEW.denom_tab::VARCHAR);
	IF USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN 
		/* Allowed duing build before first result is added to system or when converting Kerberos users */
		NULL;
	ELSIF coalesce(denom_owner::text, '') = '' THEN
		CLOSE c1_stck;
		PERFORM rif40_log_pkg.rif40_error(-20212, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % denominator: % cannot be accessed',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.denom_tab::VARCHAR 		/* Denominator */);
	ELSE
		denom_table:=NEW.denom_tab::VARCHAR;
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
			'[20212] T_RIF40_STUDIES study % denominator accessible as: %.%',
			NEW.study_id::VARCHAR		/* Study id */,
			denom_owner::VARCHAR		/* Denominator owner */,
			denom_table::VARCHAR 		/* Denominator table */);
	END IF;
	CLOSE c1_stck;
--
	IF (NEW.direct_stand_tab IS NOT NULL AND NEW.direct_stand_tab::text <> '') THEN
		OPEN c1_stck(NEW.direct_stand_tab);
		FETCH c1_stck INTO c1c_rec;
		IF NOT FOUND THEN
			CLOSE c1_stck;
			PERFORM rif40_log_pkg.rif40_error(-20213, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study % direct standardisation: % not found in RIF40_TABLES',
				NEW.study_id::VARCHAR		/* Study id */,
				NEW.direct_stand_tab::VARCHAR	/* direct standardisation table */);
		END IF;
		direct_stand_owner:=rif40_sql_pkg.rif40_object_resolve(NEW.direct_stand_tab::VARCHAR);
		IF coalesce(direct_stand_owner::text, '') = '' THEN
			CLOSE c1_stck;
			PERFORM rif40_log_pkg.rif40_error(-20214, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study % direct standardisation table: % cannot be accessed',
				NEW.study_id::VARCHAR		/* Study id */,
				NEW.direct_stand_tab::VARCHAR	/* direct standardisation table */);
		ELSE
			direct_stand_table:=NEW.direct_stand_tab::VARCHAR;
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
				'[20214] T_RIF40_STUDIES study % direct standardisation table accessible as: %.%',
				NEW.study_id::VARCHAR		/* Study id */,
				direct_stand_owner::VARCHAR	/* direct standardisation owner */,
				direct_stand_table::VARCHAR	/* direct standardisation table */);
		END IF;
		CLOSE c1_stck;
	END IF;
--
-- Check -  direct denominator
--
	IF NEW.direct_stand_tab IS NOT NULL AND NEW.direct_stand_tab::text <> '' THEN
		IF c1c_rec.isdirectdenominator != 1 THEN
			PERFORM rif40_log_pkg.rif40_error(-20215, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study % direct standardisation table: % is not a direct denominator table',
				NEW.study_id::VARCHAR			/* Study id */,
				NEW.direct_stand_tab::VARCHAR		/* direct standardisation table */);
		ELSIF c1c_rec.isdirectdenominator = 1 THEN
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
				'[20215] T_RIF40_STUDIES study % direct standardisation table: % is a direct denominator table',
				NEW.study_id::VARCHAR			/* Study id */,
				NEW.direct_stand_tab::VARCHAR		/* direct standardisation table */);
		END IF;
	END IF;
/*
ONLY NEEDED IF RIF40_STUDIES_DENOMINATORS is created

	OPEN c3(NEW.study_id);
	FETCH c3 INTO c3_rec;
	IF NOT FOUND THEN
		CLOSE c3;
		PERFORM rif40_log_pkg.rif40x_error(-202xx, 'RIF40_STUDIES_DENOMINATORS no study found for study_id: '||TO_CHAR(NEW.study_id));
	END IF;
	CLOSE c3;
 */

--
-- This has been removed as analysis of the RIF30 data shows that the data is present. COMPARISON_GEOLEVEL_NAME has been made NOT NULL
-- TODO: verify this from math
--
--	IF (coalesce(NEW.comparison_geolevel_name::text, '') = ''     AND coalesce(NEW.direct_stand_tab::text, '') = '') OR
--	   ((NEW.comparison_geolevel_name IS NOT NULL AND NEW.comparison_geolevel_name::text <> '') AND (NEW.direct_stand_tab IS NOT NULL AND NEW.direct_stand_tab::text <> '')) THEN
--		PERFORM rif40_log_pkg.rif40x_error(-202xx, 'T_RIF40_STUDIES study % one and only one of COMPARISON_GEOLEVEL_NAME and DIRECT_STAND_TAB must be set',
--			NEW.study_id			/* Study id */);
--	END IF;

/*
Year_stop/start, min/max_age_group removed from t_rif40_studies. Still in view

	IF (c1b_rec.year_stop IS NOT NULL AND c1b_rec.year_stop::text <> '') AND NEW.year_start > c1b_rec.year_stop  THEN
		PERFORM rif40_log_pkg.rif40_error(-20216, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % denominator: % year stop: % is after RIF40_TABLES year stop: %',
			NEW.study_id::VARCHAR			/- Study id -/,
			NEW.denom_tab::VARCHAR 			/- Denominator -/,
			NEW.year_stop::VARCHAR			/- Denominator year stop -/,
			c1b_rec.year_stop::VARCHAR		/- RIF TABLES year stop -/);
	END IF;
	IF (c1b_rec.min_age_group IS NOT NULL AND c1b_rec.min_age_group::text <> '') AND NEW.min_age_group < c1b_rec.min_age_group  THEN
		PERFORM rif40_log_pkg.rif40_error(-20217, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % denominator: % min age group: % is before RIF40_TABLES min age group: %',
			NEW.study_id::VARCHAR			/- Study id -/,
			NEW.denom_tab::VARCHAR 			/- Denominator -/,
			NEW.min_age_group::VARCHAR		/- Denominator min age group -/,
			c1b_rec.min_age_group::VARCHAR		/- RIF TABLES min age group -/);
	END IF;
	IF (c1b_rec.max_age_group IS NOT NULL AND c1b_rec.max_age_group::text <> '') AND NEW.max_age_group > c1b_rec.max_age_group  THEN
		PERFORM rif40_log_pkg.rif40_error(-20218, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % denominator: % max age group: % is after RIF40_TABLES max age group: %',
			NEW.study_id::VARCHAR			/- Study id -/,
			NEW.denom_tab::VARCHAR 			/- Denominator -/,
			NEW.max_age_group::VARCHAR		/- Denominator max age group -/,
			c1b_rec.max_age_group::VARCHAR		/- RIF TABLES max age group -/);
	END IF;
	IF (c1b_rec.year_start IS NOT NULL AND c1b_rec.year_start::text <> '') AND NEW.year_start < c1b_rec.year_start  THEN
		PERFORM rif40_log_pkg.rif40_error(-20219, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % denominator: % year start: % is before RIF40_TABLES year start: %',
			NEW.study_id::VARCHAR			/- Study id -/,
			NEW.denom_tab::VARCHAR 			/- Denominator -/,
			NEW.year_start::VARCHAR			/- Denominator year start -/,
			c1b_rec.year_start::VARCHAR		/- RIF TABLES year start -/);
	END IF;
 */
	IF c1b_rec.isindirectdenominator != 1 THEN
		PERFORM rif40_log_pkg.rif40_error(-20220, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % denominator: % is not a denominator table',
			NEW.study_id::VARCHAR			/* Study id */,
			NEW.denom_tab::VARCHAR 			/* Denominator */);
	END IF;
	IF coalesce(c1b_rec.max_age_group::text, '') = '' OR coalesce(c1b_rec.min_age_group::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20221, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % denominator: % no age group linkage',
			NEW.study_id::VARCHAR			/* Study id */,
			NEW.denom_tab::VARCHAR			/* Denominator */);
	END IF;
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
		'[20216-21] T_RIF40_STUDIES study % year/age bands checks OK against RIF40_TABLES',
		NEW.study_id::VARCHAR				/* Study id */);

--
-- Check - Study area resolution (GEOLEVEL_ID) >= comparision area resolution (GEOLEVEL_ID)
--
	IF c2b_rec.geolevel_id /* study */ >= c2a_rec.geolevel_id /* comparision */ THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 
			'trigger_fct_t_rif40_studies_checks', 
			'[20222] T_RIF40_STUDIES study % study area geolevel id (%/%) >= comparision area (%/%) [i.e study area has the same or higher resolution]',
			NEW.study_id::VARCHAR			/* Study id */,
			c2b_rec.geolevel_id::VARCHAR		/* Study area geolevel ID */,
			NEW.study_geolevel_name::VARCHAR 	/* Study area geolevel name */,
			c2a_rec.geolevel_id::VARCHAR		/* Comparison area geolevel ID */,
			NEW.comparison_geolevel_name::VARCHAR 	/* Comparison area geolevel name */ );
	ELSIF USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN 
		/* Allowed duing build before first result is added to system or when converting Kerberos users */
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 
			'trigger_fct_t_rif40_studies_checks', 
			'[20222] WARNING [OLD] T_RIF40_STUDIES study % study area geolevel id (%/%) < comparision area (%/%) [i.e study area a lower resolution]',
			NEW.study_id::VARCHAR			/* Study id */,
			c2b_rec.geolevel_id::VARCHAR		/* Study area geolevel ID */,
			NEW.study_geolevel_name::VARCHAR 	/* Study area geolevel name */,
			c2a_rec.geolevel_id::VARCHAR		/* Comparison area geolevel ID */,
			NEW.comparison_geolevel_name::VARCHAR 	/* Comparison area geolevel name */ );
	ELSE
		PERFORM rif40_log_pkg.rif40_error(-20222, 
			'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % study area geolevel id (%/%) < comparision area (%/%) [i.e study area a lower resolution than the comparison area]',
			NEW.study_id::VARCHAR			/* Study id */,
			c2b_rec.geolevel_id::VARCHAR		/* Study area geolevel ID */,
			NEW.study_geolevel_name::VARCHAR 	/* Study area geolevel name */,
			c2a_rec.geolevel_id::VARCHAR		/* Comparison area geolevel ID */,
			NEW.comparison_geolevel_name::VARCHAR 	/* Comparison area geolevel name */ );
	END IF;

--
-- Check - suppression_value - Suppress results with low cell counts below this value. If the role RIF_NO_SUPRESSION is granted and the user is not a
-- RIF_STUDENT then SUPPRESSION_VALUE=0; otherwise is equals the parameter "SuppressionValue". If >0 all results with the value or below will be set to 0.
--
	NEW.suppression_value:=c5_rec.suppressionvalue;
	IF NEW.suppression_value > 0 THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
			'[20223] T_RIF40_STUDIES study % suppressed at: %',
			NEW.study_id::VARCHAR			/* Study id */,
			NEW.suppression_value::VARCHAR		/* Suppression value*/);
	ELSIF c5_rec.rif_student = 1 THEN
		PERFORM rif40_log_pkg.rif40_error(-20223, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % not suppressed, but user % is a RIF_STUDENT',
			NEW.study_id::VARCHAR			/* Study id */,
			NEW.username::VARCHAR			/* Username */);
	END IF;

--
-- Check - extract_permitted - Is extract permitted from the database: 0/1. Only a RIF MANAGER may change this value. This user is still permitted to create
-- and run a RIF study and to view the results. Geolevel access is rectricted by the RIF40_GEOLEVELS.RESTRICTED Inforamtion Governance restrictions (0/1).
-- If 1 (Yes) then a) students cannot access this geolevel and b) if the system parameter ExtractControl=1 then the user must be granted permission by a
-- RIF_MANAGER to extract from the database the results, data extract and maps tables. All students must be granted permission by a RIF_MANAGER for any
-- extract if the system parameter ExtractControl=1. This is enforced by the RIF application.
--
	IF c5_rec.extractcontrol = 0 THEN
		NEW.extract_permitted:=1;
		NEW.transfer_permitted:=1;
		NEW.authorised_by:=NEW.username;
		NEW.authorised_on:=LOCALTIMESTAMP;
		NEW.authorised_notes:='Auto authorised; extract control is disabled';
	ELSE
		IF TG_OP = 'INSERT' THEN /* Force through IG process */
			IF c2b_rec.restricted = 0 AND c5_rec.rif_student = 1 THEN
				NEW.extract_permitted:=0;
				NEW.transfer_permitted:=0;
				NEW.authorised_by:=NULL;
				NEW.authorised_on:=NULL;
				NEW.authorised_notes:=NULL;
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 
					'trigger_fct_t_rif40_studies_checks', 
					'[20224-5] T_RIF40_STUDIES study % may NOT be extracted, study geolevel % is not restricted but the user: % is a RIF_STUDENT',
					NEW.study_id::VARCHAR			/* Study id */,
					NEW.study_geolevel_name::VARCHAR 	/* Study area geolevel name */,
					NEW.username::VARCHAR			/* Username */);
			ELSIF c2b_rec.restricted = 0 AND c5_rec.rif_student = 0 THEN
				NEW.extract_permitted:=1;
				NEW.transfer_permitted:=1;
				NEW.authorised_by:=NEW.username;
				NEW.authorised_on:=LOCALTIMESTAMP;
				NEW.authorised_notes:='Auto authorised; study geolevel is not restricted';
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 
					'trigger_fct_t_rif40_studies_checks', 
					'[20224-5] T_RIF40_STUDIES study % may be extracted, study geolevel % is not restricted for user: %',
					NEW.study_id::VARCHAR			/* Study id */,
					NEW.study_geolevel_name::VARCHAR 	/* Study area geolevel name */,
					NEW.username::VARCHAR			/* Username */);
			ELSE
				NEW.extract_permitted:=0;
				NEW.transfer_permitted:=0;
				NEW.authorised_by:=NULL;
				NEW.authorised_on:=NULL;
				NEW.authorised_notes:=NULL;
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 
					'trigger_fct_t_rif40_studies_checks', 
					'[20224-5] T_RIF40_STUDIES study % may NOT be extracted, study geolevel % is restricted for user: %. Requires authorisation by a RIF_MANAGER',
					NEW.study_id::VARCHAR			/* Study id */,
					NEW.study_geolevel_name::VARCHAR 	/* Study area geolevel name */,
					NEW.username::VARCHAR			/* Username */);
			END IF;
--
-- Check - authorised_by - must be a RIF MANAGER.
--
		ELSIF TG_OP = 'UPDATE' THEN
			IF NEW.extract_permitted = 1 THEN /* Attempting permit extraction */
				IF c5_rec.rif_student = 1 THEN
					PERFORM rif40_log_pkg.rif40_error(-20224, 'trigger_fct_t_rif40_studies_checks', 
						'T_RIF40_STUDIES study % may not be extracted, user % is a RIF_STUDENT',
						NEW.study_id::VARCHAR			/* Study id */,
						NEW.username::VARCHAR			/* Username */);
				ELSIF c5_rec.rif_manager = 1 THEN
					NEW.extract_permitted:=1;
					NEW.authorised_by:=NEW.username;
					NEW.authorised_on:=LOCALTIMESTAMP;
					PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
						'[20224-5] T_RIF40_STUDIES study % may be extracted, user % RIF_STUDENT/RIF_MANAGER tests passed',
						NEW.study_id::VARCHAR			/* Study id */,
						NEW.username::VARCHAR			/* Username */);
				ELSIF USER = 'rif40' AND strpos(OLD.username, '@PRIVATE.NET') > 0 THEN
					NULL; 		/* RIF studies update OK from @PRIVATE.NET to postgres */
				ELSE
					PERFORM rif40_log_pkg.rif40_error(-20225, 'trigger_fct_t_rif40_studies_checks', 
						'T_RIF40_STUDIES study % may not be extracted, modifying user % is NOT a RIF_MANAGER',
						NEW.study_id::VARCHAR			/* Study id */,
						USER::VARCHAR				/* Username */);
				END IF;
			END IF;
--
-- Check - transfer_permitted - Is transfer permitted from the Secure or Private Network: 0/1. This is for purely documentatary purposes only. Only a
-- RIF_MANAGER may change this value. The value defaults to the same as EXTRACT_PERMITTED. Only geolevels where RIF40_GEOLEVELS.RESTRICTED=0 may be
-- transferred
--
			IF c2b_rec.restricted = 1 THEN
				 NEW.transfer_permitted:=0;
			ELSE
				 NEW.transfer_permitted:=NEW.extract_permitted;
			END IF;
--
-- Check - authorised_notes - IG authorisation notes. Must be filled in if EXTRACT_PERMITTED=1
--
			IF NEW.transfer_permitted = 1 AND NEW.extract_permitted = 0 THEN
				PERFORM rif40_log_pkg.rif40_error(-20226, 'trigger_fct_t_rif40_studies_checks', 
					'T_RIF40_STUDIES study % may not be transferred, extract not permitted',
					NEW.study_id::VARCHAR				/* Study id */);
			ELSIF NEW.extract_permitted =  1 AND coalesce(NEW.authorised_notes::text, '') = '' THEN
				PERFORM rif40_log_pkg.rif40_error(-20227, 'trigger_fct_t_rif40_studies_checks', 
					'T_RIF40_STUDIES study % may not be extracted, no IG authorisation notes',
					NEW.study_id::VARCHAR				/* Study id */);
			ELSE
				IF NEW.transfer_permitted = 1 AND NEW.extract_permitted = 1 THEN
					PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
						'[20226-7] T_RIF40_STUDIES study % may be extracted and transferred',
						NEW.study_id::VARCHAR			/* Study id */);
				ELSIF NEW.transfer_permitted = 0 AND NEW.extract_permitted = 1 THEN
					PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
						'[20226-7] T_RIF40_STUDIES study % may be extracted but not transferred',
						NEW.study_id::VARCHAR			/* Study id */);
				END IF;
			END IF;
		END IF;
	END IF;

--
-- TODO
--
-- IF USER = NEW.username (i.e. not initial RIF40 INSERT) THEN
--	grant to all shared users if not already granted
--
	IF NEW.username != USER THEN
		NULL;
	END IF;

--
-- Check extract_table, map_table Oracle name, access (dependent on state)
--
	IF coalesce(NEW.extract_table::text, '') = '' THEN
		NEW.extract_table:='S'||NEW.study_id::Text||'_EXTRACT';
	END IF;
	PERFORM rif40_trg_pkg.rif40_db_name_check('EXTRACT_TABLE', NEW.extract_table);
	schema:=rif40_sql_pkg.rif40_object_resolve(NEW.extract_table::VARCHAR);
	IF (schema IS NOT NULL AND schema::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
			'[20228] T_RIF40_STUDIES study % extract table: % accessible',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.extract_table::VARCHAR 	/* extract_table */);
	ELSIF NEW.study_state NOT IN ('C', 'V', 'U') /* i.e. E, R */ THEN
		PERFORM rif40_log_pkg.rif40_error(-20228, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % extract table: % cannot be accessed; state: %',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.extract_table::VARCHAR 	/* extract_table */,
			NEW.study_state::VARCHAR	/* State */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
			'[20228] T_RIF40_STUDIES study % extract table: % cannot be accessed; state: % [IGNORED]',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.extract_table::VARCHAR 	/* extract_table */,
			NEW.study_state::VARCHAR	/* State */);
	END IF;
	IF coalesce(NEW.map_table::text, '') = '' THEN
		NEW.map_table:='S'||NEW.study_id::Text||'_MAP';
	END IF;
	PERFORM rif40_trg_pkg.rif40_db_name_check('MAP_TABLE', NEW.map_table);
	schema:=rif40_sql_pkg.rif40_object_resolve(NEW.map_table::VARCHAR);
	IF (schema IS NOT NULL AND schema::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
			'[20229] T_RIF40_STUDIES study % map table: % accessible',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.map_table::VARCHAR 		/* map_table */);
	ELSIF NEW.study_state NOT IN ('C', 'V', 'U', 'E') /* i.e. R */ THEN
		PERFORM rif40_log_pkg.rif40_error(-20229, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % map table: % cannot be accessed; state: %',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.map_table::VARCHAR	 	/* map_table */,
			NEW.study_state::VARCHAR	/* State */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
			'[20229] T_RIF40_STUDIES study % map table: % cannot be accessed; state: % [IGNORED]',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.map_table::VARCHAR 		/* map_table */,
			NEW.study_state::VARCHAR	/* State */);
	END IF;

--
-- Delayed RIF40_TABLES denominator checks:
-- Check - Column <TABLE_NAME>.TOTAL_FIELD, SEX_FIELD_NAME, AGE_GROUP_FIELD_NAME, AGE_SEX_GROUP_FIELD_NAME exists
--
	IF USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN 
		/* Allowed duing build before first result is added to system or when converting Kerberos users */
		NULL;
	ELSIF c1b_rec.total_field IS NOT NULL AND c1b_rec.total_field IS NOT NULL THEN
		OPEN c6_stck(denom_owner, denom_table, c1b_rec.total_field);
		FETCH c6_stck INTO c6_rec;
		IF NOT FOUND THEN
			CLOSE c6_stck;
			PERFORM rif40_log_pkg.rif40_error(-20230, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study: % denominator RIF40_TABLES total field column: %.%.% NOT found',
				NEW.study_id::VARCHAR			/* Study */,
				denom_owner::VARCHAR			/* Denominator owner */,
				denom_table::VARCHAR			/* Denominator table */,
				c1b_rec.total_field::VARCHAR		/* Total field name */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
				'[20230] T_RIF40_STUDIES study: % denominator RIF40_TABLES total field column: %.%.% found',
				NEW.study_id::VARCHAR			/* Study */,
				denom_owner::VARCHAR			/* Denominator owner */,
				denom_table::VARCHAR			/* Denominator table */,
				c1b_rec.total_field::VARCHAR		/* Total field name */);
		END IF;
		CLOSE c6_stck;
	END IF;
	IF USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN 
		/* Allowed duing build before first result is added to system or when converting Kerberos users */
		NULL;
	ELSIF c1b_rec.sex_field_name IS NOT NULL AND c1b_rec.sex_field_name IS NOT NULL THEN
		OPEN c6_stck(denom_owner, denom_table, c1b_rec.sex_field_name);
		FETCH c6_stck INTO c6_rec;
		IF NOT FOUND THEN
			CLOSE c6_stck;
			PERFORM rif40_log_pkg.rif40_error(-20231, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study: % denominator RIF40_TABLES sex field column: %.%.% NOT found',
				NEW.study_id::VARCHAR			/* Study */,
				denom_owner::VARCHAR			/* Denominator owner */,
				denom_table::VARCHAR			/* Denominator table */,
				c1b_rec.sex_field_name::VARCHAR		/* Sex field name */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
				'[20231] T_RIF40_STUDIES study: % denominator RIF40_TABLES sex field column: %.%.% found',
				NEW.study_id::VARCHAR			/* Study */,
				denom_owner::VARCHAR			/* Denominator owner */,
				denom_table::VARCHAR			/* Denominator table */,
				c1b_rec.sex_field_name::VARCHAR		/* Sex field name */);
		END IF;
		CLOSE c6_stck;
	END IF;
	IF USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN 
		/* Allowed duing build before first result is added to system or when converting Kerberos users */
		NULL;
	ELSIF c1b_rec.age_group_field_name IS NOT NULL AND c1b_rec.age_group_field_name IS NOT NULL THEN
		OPEN c6_stck(denom_owner, denom_table, c1b_rec.age_group_field_name);
		FETCH c6_stck INTO c6_rec;
		IF NOT FOUND THEN
			CLOSE c6_stck;
			PERFORM rif40_log_pkg.rif40_error(-20232, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study: % denominator RIF40_TABLES age group field name column: %.%.% NOT found',
				NEW.study_id::VARCHAR			/* Study */,
				denom_owner::VARCHAR			/* Denominator owner */,
				denom_table::VARCHAR			/* Denominator table */,
				c1b_rec.age_group_field_name::VARCHAR	/* Age group field name */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
				'[20232] T_RIF40_STUDIES study: % denominator RIF40_TABLES age group field name column: %.%.% found',
				NEW.study_id::VARCHAR			/* Study */,
				denom_owner::VARCHAR			/* Denominator owner */,
				denom_table::VARCHAR			/* Denominator table */,
				c1b_rec.age_group_field_name::VARCHAR	/* Age group field name */);
		END IF;
		CLOSE c6_stck;
	END IF;
	IF USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN 
		/* Allowed duing build before first result is added to system or when converting Kerberos users */
		NULL;
	ELSIF c1b_rec.age_sex_group_field_name IS NOT NULL AND c1b_rec.age_sex_group_field_name IS NOT NULL THEN
		OPEN c6_stck(denom_owner, denom_table, c1b_rec.age_sex_group_field_name);
		FETCH c6_stck INTO c6_rec;
		IF NOT FOUND THEN
			CLOSE c6_stck;
			PERFORM rif40_log_pkg.rif40_error(-20233, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study: % denominator RIF40_TABLES age sex group field column: %.%.% NOT found',
				NEW.study_id::VARCHAR				/* Study */,
				denom_owner::VARCHAR				/* Denominator owner */,
				denom_table::VARCHAR				/* Denominator table */,
				c1b_rec.age_sex_group_field_name::VARCHAR	/* Age sex group field name */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
				'[20233] T_RIF40_STUDIES study: % denominator RIF40_TABLES age sex group field column: %.%.% found',
				NEW.study_id::VARCHAR				/* Study */,
				denom_owner::VARCHAR				/* Denominator owner */,
				denom_table::VARCHAR				/* Denominator table */,
				c1b_rec.age_sex_group_field_name::VARCHAR	/* Age sex group field name */);
		END IF;
		CLOSE c6_stck;
	END IF;

	IF USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN 
		/* Allowed duing build before first result is added to system or when converting Kerberos users */
		NULL;
	ELSIF direct_stand_owner IS NOT NULL AND direct_stand_owner::text <> '' THEN /* Direct standardisation table exists */
--
-- Delayed RIF40_TABLES direct standardisation table checks:
-- Check - Column <TABLE_NAME>.TOTAL_FIELD, SEX_FIELD_NAME, AGE_GROUP_FIELD_NAME, AGE_SEX_GROUP_FIELD_NAME exists
--
		IF c1c_rec.total_field IS NOT NULL AND c1c_rec.total_field::text <> '' THEN
			OPEN c6_stck(direct_stand_owner, direct_stand_table, c1c_rec.total_field);
			FETCH c6_stck INTO c6_rec;
			IF NOT FOUND THEN
				CLOSE c6_stck;
				PERFORM rif40_log_pkg.rif40_error(-20234, 'trigger_fct_t_rif40_studies_checks', 
					'T_RIF40_STUDIES study: % direct standardisation RIF40_TABLES total field column: %.%.% NOT found',
					NEW.study_id::VARCHAR			/* Study */,
					direct_stand_owner::VARCHAR		/* Direct standardisation owner */,
					direct_stand_table::VARCHAR		/* Direct standardisation table */,
					c1c_rec.total_field::VARCHAR		/* Total field name */);
			ELSE
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
					'[20234] T_RIF40_STUDIES study: % direct standardisation RIF40_TABLES total field column: %.%.% found',
					NEW.study_id::VARCHAR			/* Study */,
					direct_stand_owner::VARCHAR		/* Direct standardisation owner */,
					direct_stand_table::VARCHAR		/* Direct standardisation table */,
					c1c_rec.total_field::VARCHAR		/* Total field name */);
			END IF;
			CLOSE c6_stck;
		END IF;
		IF c1c_rec.sex_field_name IS NOT NULL AND c1c_rec.sex_field_name::text <> '' THEN
			OPEN c6_stck(direct_stand_owner, direct_stand_table, c1c_rec.sex_field_name);
			FETCH c6_stck INTO c6_rec;
			IF NOT FOUND THEN
				CLOSE c6_stck;
				PERFORM rif40_log_pkg.rif40_error(-20235, 'trigger_fct_t_rif40_studies_checks', 
					'T_RIF40_STUDIES study: % direct standardisation RIF40_TABLES sex field column: %.%.% NOT found',
					NEW.study_id::VARCHAR			/* Study */,
					direct_stand_owner::VARCHAR		/* Direct standardisation owner */,
					direct_stand_table::VARCHAR		/* Direct standardisation table */,
					c1c_rec.sex_field_name::VARCHAR		/* Sex field name */);
			ELSE
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
					'[20235] T_RIF40_STUDIES study: % direct standardisation RIF40_TABLES sex field column: %.%.% found',
					NEW.study_id::VARCHAR			/* Study */,
					direct_stand_owner::VARCHAR		/* Direct standardisation owner */,
					direct_stand_table::VARCHAR		/* Direct standardisation table */,
					c1c_rec.sex_field_name::VARCHAR		/* Sex field name */);
			END IF;
			CLOSE c6_stck;
		END IF;
		IF c1c_rec.age_group_field_name IS NOT NULL AND c1c_rec.age_group_field_name::text <> '' THEN
			OPEN c6_stck(direct_stand_owner, direct_stand_table, c1c_rec.age_group_field_name);
			FETCH c6_stck INTO c6_rec;
			IF NOT FOUND THEN
				CLOSE c6_stck;
				PERFORM rif40_log_pkg.rif40_error(-20236, 
					'trigger_fct_t_rif40_studies_checks', 
					'T_RIF40_STUDIES study: % direct standardisation RIF40_TABLES age group field name column: %.%.% NOT found',
					NEW.study_id::VARCHAR			/* Study */,
					direct_stand_owner::VARCHAR		/* Direct standardisation owner */,
					direct_stand_table::VARCHAR		/* Direct standardisation table */,
					c1c_rec.age_group_field_name::VARCHAR	/* Age group field name */);
			ELSE
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 
					'trigger_fct_t_rif40_studies_checks', 
					'[20236] T_RIF40_STUDIES study: % direct standardisation RIF40_TABLES age group field name column: %.%.% found',
					NEW.study_id::VARCHAR			/* Study */,
					direct_stand_owner::VARCHAR		/* Direct standardisation owner */,
					direct_stand_table::VARCHAR		/* Direct standardisation table */,
					c1c_rec.age_group_field_name::VARCHAR	/* Age group field name */);
			END IF;
			CLOSE c6_stck;
		END IF;
		IF c1c_rec.age_sex_group_field_name IS NOT NULL AND c1c_rec.age_sex_group_field_name::text <> '' THEN
			OPEN c6_stck(direct_stand_owner, direct_stand_table, c1c_rec.age_sex_group_field_name);
			FETCH c6_stck INTO c6_rec;
			IF NOT FOUND THEN
				CLOSE c6_stck;
				PERFORM rif40_log_pkg.rif40_error(-20237, 
					'trigger_fct_t_rif40_studies_checks', 
					'T_RIF40_STUDIES study: % direct standardisation RIF40_TABLES age sex group field column: %.%.% NOT found',
					NEW.study_id::VARCHAR				/* Study */,
					direct_stand_owner::VARCHAR			/* Direct standardisation owner */,
					direct_stand_table::VARCHAR			/* Direct standardisation table */,
					c1c_rec.age_sex_group_field_name::VARCHAR	/* Age sex group field name */);
			ELSE
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 
					'trigger_fct_t_rif40_studies_checks', 
					'[20237] T_RIF40_STUDIES study: % direct standardisation RIF40_TABLES age sex group field column: %.%.% found',
					NEW.study_id::VARCHAR				/* Study */,
					direct_stand_owner::VARCHAR			/* Direct standardisation owner */,
					direct_stand_table::VARCHAR			/* Direct standardisation table */,
					c1c_rec.age_sex_group_field_name::VARCHAR	/* Age sex group field name */);
			END IF;
			CLOSE c6_stck;
		END IF;
	END IF;

--
-- Error message end: -20259, last message: -20237
--
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
$BODY$
LANGUAGE plpgsql;
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_studies_checks() IS 'Check - USERNAME exists.
Check - USERNAME is Kerberos USER on INSERT.
Check - audsid is SYS_CONTEXT(''USERENV'', ''SESSIONID'') on INSERT.
Check - UPDATE not allowed except for IG admin and state changes.
Check - DELETE only allowed on own records.
Check - EXTRACT_TABLE Oracle name.
Check - Comparison area geolevel name. Must be a valid GEOLEVEL_NAME for the study GEOGRPAHY in T_RIF40_GEOLEVELS, with COMPAREA=1
Check - DENOM_TAB, DIRECT_STAND_TAB are valid Oracle names and appropriate denominators, and user has access.
Check - Study area resolution (GEOLEVEL_ID) >= comparision area resolution (GEOLEVEL_ID)  [i.e study area has the same or higher resolution]

Check - suppression_value - Suppress results with low cell counts below this value. If the role RIF_NO_SUPRESSION is granted and the user is not a RIF_STUDENT then SUPPRESSION_VALUE=0; otherwise is equals the parameter "SuppressionValue". If >0 all results with the value or below will be set to 0.
Check - extract_permitted - Is extract permitted from the database: 0/1. Only a RIF MANAGER may change this value. This user is still permitted to create and run a RIF study and to view the results. Geolevel access is rectricted by the RIF40_GEOLEVELS.RESTRICTED Inforamtion Governance restrictions (0/1). If 1 (Yes) then a) students cannot access this geolevel and b) if the system parameter ExtractControl=1 then the user must be granted permission by a RIF_MANAGER to extract from the database the results, data extract and maps tables. All students must be granted permission by a RIF_MANAGER for any extract if the system parameter ExtractControl=1. This is enforced by the RIF application.

Check - authorised_by - must be a RIF MANAGER.

Check - transfer_permitted - Is transfer permitted from the Secure or Private Network: 0/1. This is for purely documentatary purposes only. Only a RIF MANAGER may change this value. The value defaults to the same as EXTRACT_PERMITTED. Only geolevels where RIF40_GEOLEVELS.RESTRICTED=0 may be transferred

Check - authorised_notes -IG authorisation notes. Must be filled in if EXTRACT_PERMITTED=1

Delayed RIF40_TABLES denominator and direct standardisation checks:
Check - Column <TABLE_NAME>.TOTAL_FIELD, SEX_FIELD_NAME, AGE_GROUP_FIELD_NAME, AGE_SEX_GROUP_FIELD_NAME exists

IF USER = NEW.username (i.e. not initial RIF40 INSERT) THEN
	grant to all shared users if not already granted';

CREATE TRIGGER t_rif40_studies_checks
	BEFORE INSERT OR UPDATE OR DELETE ON "t_rif40_studies" FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_studies_checks();
COMMENT ON TRIGGER t_rif40_studies_checks ON t_rif40_studies IS 'INSERT OR UPDATE OR DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_version_checks()';

DROP TRIGGER IF EXISTS t_rif40_study_areas_checks ON t_rif40_study_areas CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_t_rif40_study_areas_checks_description>
<para>
Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
</para>
</trigger_t_rif40_study_areas_checks_description>
 */
--
-- -20280 to -20299 - T_RIF40_STUDY_AREAS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c4_cksa CURSOR IS
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c4_rec RECORD;
BEGIN
--
-- T_RIF40_STUDY_AREAS: Check - USERNAME is Kerberos USER on INSERT
--			Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records
--
	OPEN c4_cksa;
	FETCH c4_cksa INTO c4_rec;
	CLOSE c4_cksa;
	IF NOT TG_OP = 'DELETE' AND NEW.username != USER THEN
		IF USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN 
			/* Allowed duing build before first result is added to system or when converting Kerberos users */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20280,  'trigger_fct_t_rif40_study_areas_checks',
				'T_RIF40_STUDY_AREAS study: % area_id: % band_id: % username: % is not USER: %',
				NEW.study_id::VARCHAR		/* Study id */,
				NEW.area_id::VARCHAR		/* Area */,
			 	NEW.band_id::VARCHAR		/* Band */,
				NEW.username::VARCHAR		/* Record username */,
				USER::VARCHAR			/* Logon username */);
		END IF;
/*	ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20281,  't_rif40_study_areas_checks',
			'T_RIF40_STUDY_AREAS study: % area_id: % band_id: % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR		/- Study id -/,
			NEW.area_id::VARCHAR		/- Area -/,
			NEW.band_id::VARCHAR		/- Band -/,
			NEW.username::VARCHAR 		/- Record username -/,
			USER::VARCHAR			/- Logon username -/); */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20282,  'trigger_fct_t_rif40_study_areas_checks',
			'T_RIF40_STUDY_AREAS UPDATE study: % area_id: % band_id: % not allowed on T_RIF40_STUDY_AREAS',
			NEW.study_id::VARCHAR		/* Study id */);
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20283,  'trigger_fct_t_rif40_study_areas_checks',
			'T_RIF40_STUDY_AREAS DELETE study: % area_id: % band_id: % only allowed on own records in T_RIF40_STUDY_AREAS, record owned by: %',
			OLD.study_id::VARCHAR		/* Study id */,
			OLD.area_id::VARCHAR		/* Area */,
			OLD.band_id::VARCHAR		/* Band */,
			OLD.username::VARCHAR		/* INSERT username */);
	END IF;
--
	IF TG_OP = 'DELETE' THEN
--
--		PERFORM rif40_log_pkg.rif40_log('DEBUG4', 'trigger_fct_t_rif40_study_areas_checks',
--	     	 	'[20280-3] T_RIF40_STUDY_AREAS study: % area_id: % band_id % CRUD checks OK',
--			OLD.study_id::VARCHAR		/* Study id */,
--			OLD.area_id::VARCHAR		/* Area */,
--		 	OLD.band_id::VARCHAR		/* Band */);
--
		RETURN OLD;
	ELSE  	
--
--		PERFORM rif40_log_pkg.rif40_log('DEBUG4', 'trigger_fct_t_rif40_study_areas_checks',
--			'[20280-3] T_RIF40_STUDY_AREAS study: % area_id: % band_id % CRUD checks OK',
--			NEW.study_id::VARCHAR		/* Study id */,
--			NEW.area_id::VARCHAR		/* Area */,
--		 	NEW.band_id::VARCHAR		/* Band */);
--
		RETURN NEW;
	END IF;
END;
$BODY$
LANGUAGE 'plpgsql';
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks() IS 'Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.';

CREATE TRIGGER t_rif40_study_areas_checks
	BEFORE INSERT OR UPDATE OF area_id, band_id, username, study_id ON t_rif40_study_areas
	FOR EACH ROW
	WHEN ((NEW.band_id IS NOT NULL AND NEW.band_id::text <> '') OR (NEW.username IS NOT NULL AND NEW.username::text <> '') OR (NEW.study_id IS NOT NULL AND NEW.study_id::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks();
COMMENT ON TRIGGER t_rif40_study_areas_checks ON t_rif40_study_areas IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks()';
CREATE TRIGGER t_rif40_study_areas_checks_del
	BEFORE DELETE ON t_rif40_study_areas
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks();
COMMENT ON TRIGGER t_rif40_study_areas_checks_del ON t_rif40_study_areas IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks()';

DROP TRIGGER IF EXISTS t_rif40_study_areas_checks2 ON "t_rif40_study_areas" CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks2() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_t_rif40_study_areas_checks2_description>
<para>
Check - area_id
</para>
</trigger_t_rif40_study_areas_checks2_description>
 */
--
-- -20280 to -20299 - T_RIF40_STUDY_AREAS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
-- $Log: v4_0_postgres_triggers.sql,v $
-- Revision 1.6  2014/02/24 10:50:28  peterh
-- Full build from Oracle, including default study area and removal of year_start/stop min/max_age_group from T_RIF40_STUDIES
--
-- Still present in view
--
-- Revision 1.5  2013/09/25 12:12:22  peterh
-- Baseline after 2x full clean builds at Postgres level
-- TODO.txt uptodate
--
-- Revision 1.4  2013/09/18 15:20:32  peterh
-- Checkin at end of 6 week RIF focus. Got as far as SAHSULAND run study to completion for observed only
--
-- Revision 1.3  2013/09/02 14:08:33  peterh
--
-- Baseline after full trigger implmentation
--
-- Revision 1.2  2013/03/14 17:35:38  peterh
-- Baseline for TX to laptop
--
-- Revision 1.4  2013/02/14 10:48:39  peterh
-- Baseline aftyer clean build with screen mockup changes
--
-- Revision 1.12  2012/10/23 09:05:57  peterh
--
-- Baseline after full build of SAHSUland RIF schema including data
-- No triggers, Geo data and system error/logon triggers to be done
--
-- Revision 1.11  2012/09/14 15:44:53  peterh
-- Baseline after full review of check code and error messages
-- IG functionality added
--
-- Revision 1.10  2012/09/05 15:16:37  peterh
--
-- RIF update after initial build of postgres DB
--
-- Revision 1.9  2012/07/03 12:28:55  peterh
--
-- RIF schema as at 3/6/2012. All entities complete
--
-- Revision 1.8  2012/06/15 11:05:26  peterh
-- Check with working SQL generator (CREATE stmt only); bones of XML generator
-- Numerous lookup tables added.
-- Prepare for documentation
--
-- Revision 1.7  2012/05/22 15:29:41  peterh
--
-- Added RIF40_RESULTS, contextual_stats; more verification
--
-- Revision 1.6  2012/05/21 11:11:28  peterh
--
-- RIF investigattion, inv_covariates, study shares checks + SAHSU land example data
--
-- Revision 1.5  2012/04/26 15:49:48  peterh
-- Fixed view security problems
--
-- Revision 1.4  2012/04/13 15:05:02  peterh
--
-- Added RIF studies, investigations etc
--
-- Revision 1.3  2012/04/04 15:22:51  peterh
-- Easter baseline
--
-- Revision 1.2  2012/03/30 11:45:40  peterh
--
-- Baseline with working RIF40_NUM_DENOM
--
-- Revision 1.1  2012/03/28 15:39:19  peterh
--
-- Added check constraints and basic object table+column existance checks
--
-- Revision 1.2  2012/03/27 15:54:33  peterh
--
-- Added more V4 tables
--
-- Revision 1.1  2012/03/23 15:21:18  peterh
--
-- Moved from old RIF directory
--
-- Revision 1.2  2011/07/12 13:18:40  peterh
-- RIF baseline after Kerberosisation, re-doc and N_POP add
--
-- Revision 1.1  2011/05/27 10:31:21  peterh
--
-- Start of user level suppression support in RIF
--
	c1_cksa2 CURSOR (l_study_id  integer) IS
		SELECT a.study_id, a.study_geolevel_name, a.comparison_geolevel_name, b.hierarchytable
		  FROM t_rif40_studies a, rif40_geographies b
		 WHERE a.geography = b.geography
		   AND a.study_id  = l_study_id;
	c3_cksa2 CURSOR IS
		SELECT currval('rif40_study_id_seq'::regclass) AS study_id;
	c1_rec RECORD;
	c3_rec RECORD;
	c4_cksa2 CURSOR IS
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c4_rec RECORD;
--
	c2_cksa2 REFCURSOR;
	sql_stmt	varchar(2000);
	total		integer;
BEGIN
--
-- Efffectively disable check during initial system load
--
	IF NOT TG_OP = 'DELETE' AND USER = 'rif40' THEN
		OPEN c4_cksa2;
		FETCH c4_cksa2 INTO c4_rec;
		CLOSE c4_cksa2;
		IF c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0 THEN  
			/* Allowed during build before first result is added to system or before Kerberos update */
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_study_areas_checks2',
				'[20300] T_RIF40_STUDY_AREAS username: % allowed during build before first result is added to system [CHECK DISABLED]',
				USER::VARCHAR		/* User */);
			RETURN NEW;
		END IF;
	END IF;

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
     
--
-- Check - area_id
--
	OPEN c3_cksa2;
	FETCH c3_cksa2 INTO c3_rec;
	IF NOT FOUND OR coalesce(c3_rec.study_id::text, '') = '' THEN
		CLOSE c3_cksa2;
		PERFORM rif40_log_pkg.rif40_error(-20284, 'trigger_fct_t_rif40_study_areas_checks2',
			'T_RIF40_STUDY_AREAS no rif40_study_id_seq.CURRVAL study_id sequence found');
	END IF;
--
	CLOSE c3_cksa2;
	OPEN c1_cksa2(c3_rec.study_id);
	FETCH c1_cksa2 INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1_cksa2;
		PERFORM rif40_log_pkg.rif40_error(-20285, 'trigger_fct_t_rif40_study_areas_checks2',
			'T_RIF40_STUDY_AREAS no study found for study_id: %',
			c3_rec.study_id::VARCHAR		/* rif40_study_id_seq.CURRVAL study_id sequence */);
	END IF;
	CLOSE c1_cksa2;
	sql_stmt:='SELECT COUNT(area_id) AS total FROM ('||E'\n'||
			'SELECT area_id FROM t_rif40_study_areas WHERE study_id = $1'||E'\n'||
			'EXCEPT '||E'\n'||
			'SELECT '||LOWER(c1_rec.study_geolevel_name)||' FROM '||c1_rec.hierarchytable||') a';
	BEGIN
		OPEN c2_cksa2 FOR EXECUTE sql_stmt USING c3_rec.study_id;
		FETCH c2_cksa2 INTO total;
		CLOSE c2_cksa2;
	EXCEPTION
		WHEN others THEN
			PERFORM rif40_log_pkg.rif40_error(-20286, 'trigger_fct_t_rif40_study_areas_checks2',
				'T_RIF40_STUDY_AREAS study_id: % % raised by: %',
				c3_rec.study_id::VARCHAR	/* rif40_study_id_seq.CURRVAL study_id sequence */,
				sqlerrm::VARCHAR		/* Error */,
				sql_stmt::VARCHAR		/* SQL */);

	END;
	IF total > 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20287, 'trigger_fct_t_rif40_study_areas_checks2',
			'T_RIF40_STUDY_AREAS study_id: %; found % areas not in: %.%'||E'\n'||'SQL> %;',
			total::VARCHAR				/* Total */,
			c3_rec.study_id::VARCHAR		/* rif40_study_id_seq.CURRVAL study_id sequence */,
			c1_rec.hierarchytable::VARCHAR		/* Hierarchy table */,
			c1_rec.study_geolevel_name::VARCHAR	/* Study geolevel column name */,
		        sql_stmt::VARCHAR			/* SQL */ );
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END; 
$BODY$
LANGUAGE 'plpgsql';
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks2() IS 'Check - area_id';

CREATE TRIGGER t_rif40_study_areas_checks2
	AFTER INSERT ON "t_rif40_study_areas" FOR EACH STATEMENT
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks2();
COMMENT ON TRIGGER t_rif40_study_areas_checks2 ON t_rif40_study_areas IS 'INSERT OR UPDATE OR DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks2()';

DROP TRIGGER IF EXISTS t_rif40_comp_areas_checks ON t_rif40_comparison_areas CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_t_rif40_comp_areas_checks_description>
<para>
Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
</para>
</trigger_t_rif40_comp_areas_checks_description>
 */
--
-- -20300 to -20319 - T_RIF40_COMPARISON_AREAS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
-- $Log: v4_0_postgres_triggers.sql,v $
-- Revision 1.6  2014/02/24 10:50:28  peterh
-- Full build from Oracle, including default study area and removal of year_start/stop min/max_age_group from T_RIF40_STUDIES
--
-- Still present in view
--
-- Revision 1.5  2013/09/25 12:12:22  peterh
-- Baseline after 2x full clean builds at Postgres level
-- TODO.txt uptodate
--
-- Revision 1.4  2013/09/18 15:20:32  peterh
-- Checkin at end of 6 week RIF focus. Got as far as SAHSULAND run study to completion for observed only
--
-- Revision 1.3  2013/09/02 14:08:33  peterh
--
-- Baseline after full trigger implmentation
--
-- Revision 1.2  2013/03/14 17:35:38  peterh
-- Baseline for TX to laptop
--
-- Revision 1.4  2013/02/14 10:48:39  peterh
-- Baseline aftyer clean build with screen mockup changes
--
-- Revision 1.12  2012/10/23 09:05:57  peterh
--
-- Baseline after full build of SAHSUland RIF schema including data
-- No triggers, Geo data and system error/logon triggers to be done
--
-- Revision 1.11  2012/09/14 15:44:53  peterh
-- Baseline after full review of check code and error messages
-- IG functionality added
--
-- Revision 1.10  2012/09/05 15:16:37  peterh
--
-- RIF update after initial build of postgres DB
--
-- Revision 1.9  2012/07/03 12:28:55  peterh
--
-- RIF schema as at 3/6/2012. All entities complete
--
-- Revision 1.8  2012/06/15 11:05:26  peterh
-- Check with working SQL generator (CREATE stmt only); bones of XML generator
-- Numerous lookup tables added.
-- Prepare for documentation
--
-- Revision 1.7  2012/05/22 15:29:41  peterh
--
-- Added RIF40_RESULTS, contextual_stats; more verification
--
-- Revision 1.6  2012/05/21 11:11:28  peterh
--
-- RIF investigattion, inv_covariates, comparison shares checks + SAHSU land example data
--
-- Revision 1.5  2012/04/26 15:49:48  peterh
-- Fixed view security problems
--
-- Revision 1.4  2012/04/13 15:05:02  peterh
--
-- Added RIF studies, investigations etc
--
-- Revision 1.3  2012/04/04 15:22:51  peterh
-- Easter baseline
--
-- Revision 1.2  2012/03/30 11:45:40  peterh
--
-- Baseline with working RIF40_NUM_DENOM
--
-- Revision 1.1  2012/03/28 15:39:19  peterh
--
-- Added check constraints and basic object table+column existance checks
--
-- Revision 1.2  2012/03/27 15:54:33  peterh
--
-- Added more V4 tables
--
-- Revision 1.1  2012/03/23 15:21:18  peterh
--
-- Moved from old RIF directory
--
-- Revision 1.2  2011/07/12 13:18:40  peterh
-- RIF baseline after Kerberosisation, re-doc and N_POP add
--
-- Revision 1.1  2011/05/27 10:31:21  peterh
--
-- Start of user level suppression support in RIF
--
	c4cack CURSOR IS
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c4_rec RECORD;
BEGIN
--
-- T_RIF40_COMPARISON_AREAS: Check - USERNAME is Kerberos USER on INSERT
--			Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records
--
	OPEN c4cack;
	FETCH c4cack INTO c4_rec;
	CLOSE c4cack;
	IF TG_OP = 'INSERT' AND NEW.username != USER THEN
		IF USER = 'rif40' AND c4_rec.total = 0 THEN 
			/* Allowed during build before first result is added to system or before Kerberos update */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20300, 'trigger_fct_t_rif40_comp_areas_checks', 
				'T_RIF40_COMPARISON_AREAS study: % area_id: % username: % is not USER: %',
				NEW.study_id::VARCHAR		/* Study id */,
				NEW.area_id::VARCHAR		/* Area */,
				NEW.username::VARCHAR		/* New username */,
				USER::VARCHAR			/* Username */);
		END IF;
	ELSIF TG_OP = 'UPDATE' AND NEW.username != USER THEN
		IF (USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0)) THEN 
			/* Allowed during build before first result is added to system or before Kerberos update */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20300, 'trigger_fct_t_rif40_comp_areas_checks', 
				'T_RIF40_COMPARISON_AREAS study: % area_id: % new username: % is not USER: %; old: %',
				NEW.study_id::VARCHAR		/* Study id */,
				NEW.area_id::VARCHAR		/* Area */,
				NEW.username::VARCHAR		/* New username */,
				USER::VARCHAR			/* Username */,
				OLD.username::VARCHAR		/* Old username */);
		END IF;
/*
	ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20301, 'trigger_fct_t_rif40_comp_areas_checks', 
			'T_RIF40_COMPARISON_AREAS study: % area_id: % username: % is not a Kerberos USER: %',
			NEW.username::VARCHAR		/- Record username -/,
			NEW.study_id::VARCHAR		/- Study id -/,
			NEW.area_id::VARCHAR		/- Area -/,
			USER::VARCHAR			/- Username -/); */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20302, 'trigger_fct_t_rif40_comp_areas_checks', 
			'T_RIF40_COMPARISON_AREAS study: % area_id: % UPDATE not allowed on T_RIF40_COMPARISON_AREAS',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.area_id::VARCHAR		/* Area */);
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20303, 'trigger_fct_t_rif40_comp_areas_checks', 
			'T_RIF40_COMPARISON_AREAS study: % area_id: % DELETE only allowed on own records in T_RIF40_COMPARISON_AREAS, record owned by: %',
			OLD.username::VARCHAR		/* INSERT Username */,
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.area_id::VARCHAR		/* Area */);
	END IF;
--
	IF TG_OP = 'DELETE' THEN
--		PERFORM rif40_log_pkg.rif40_log('DEBUG4','trigger_fct_t_rif40_comp_areas_checks', 
--     	 		'[20300-3] T_RIF40_COMPARISON_AREAS study: % area_id: % CRUD checks OK',
--     	 		OLD.study_id::VARCHAR		/* Study id */,
--			OLD.area_id::VARCHAR		/* Area */);  
		RETURN OLD;
	ELSE  	
--
--		PERFORM rif40_log_pkg.rif40_log('DEBUG4','trigger_fct_t_rif40_comp_areas_checks', 
--     	 		'[20300-3] T_RIF40_COMPARISON_AREAS study: % area_id: % CRUD checks OK',
--     	 		NEW.study_id::VARCHAR		/* Study id */,
--			NEW.area_id::VARCHAR		/* Area */);
--
		RETURN NEW;
	END IF;
END; 
$BODY$
LANGUAGE 'plpgsql';
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks() IS 'Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.';

CREATE TRIGGER t_rif40_comp_areas_checks
	BEFORE INSERT OR UPDATE OF area_id, username, study_id ON t_rif40_comparison_areas
	FOR EACH ROW
	WHEN ((NEW.username IS NOT NULL AND NEW.username::text <> '') OR (NEW.study_id IS NOT NULL AND NEW.study_id::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks();
COMMENT ON TRIGGER t_rif40_comp_areas_checks ON t_rif40_comparison_areas IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks()';

CREATE TRIGGER t_rif40_comp_areas_checks_del
	BEFORE DELETE ON t_rif40_comparison_areas
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks();
COMMENT ON TRIGGER t_rif40_comp_areas_checks_del ON t_rif40_comparison_areas IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks()';

DROP TRIGGER IF EXISTS t_rif40_comp_areas_checks2 ON "t_rif40_comparison_areas" CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks2() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_t_rif40_comp_areas_checks2_description>
<para>
Check - area_id; once per statement (for performance reasons)
</para>
</trigger_t_rif40_comp_areas_checks2_description>
 */
--
-- -20300 to -20319 - T_RIF40_COMPARISON_AREAS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c1_cack2 CURSOR (l_study_id  integer) FOR
		SELECT a.study_id, a.study_geolevel_name, a.comparison_geolevel_name, b.hierarchytable
		  FROM t_rif40_studies a, rif40_geographies b
		 WHERE a.geography = b.geography
		   AND a.study_id  = l_study_id;
	c3_cack2 CURSOR FOR
		SELECT currval('rif40_study_id_seq'::regclass) AS study_id;
	c1_rec RECORD;
	c3_rec RECORD;
	c4_cack2 CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c4_rec RECORD;
--
	c2_cack2 REFCURSOR;
	sql_stmt	varchar(2000);
	total		integer;
BEGIN
--
-- Efffectively disable check during initial syustem load
--
	IF NOT TG_OP = 'DELETE' AND USER = 'rif40' THEN
		OPEN c4_cack2;
		FETCH c4_cack2 INTO c4_rec;
		CLOSE c4_cack2;
		IF c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0 THEN  
			/* Allowed during build before first result is added to system or before Kerberos update */
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_comp_areas_checks2',
				'[20300] T_RIF40_COMPARISON_AREAS username: % allowed during build before first result is added to system [CHECK DISABLED]',
				USER::VARCHAR		/* User */);
			RETURN NEW;
		END IF;
	END IF;

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
  
--
-- Check - area_id
--
	OPEN c3_cack2;
	FETCH c3_cack2 INTO c3_rec;
	IF NOT FOUND OR coalesce(c3_rec.study_id::text, '') = '' THEN
		CLOSE c3_cack2;
		PERFORM rif40_log_pkg.rif40_error(-20304, 'trigger_fct_t_rif40_comp_areas_checks2', 'T_RIF40_COMPARISON_AREAS no study_id found');
	END IF;
	CLOSE c3_cack2;
	OPEN c1_cack2(c3_rec.study_id);
	FETCH c1_cack2 INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1_cack2;
		PERFORM rif40_log_pkg.rif40_error(-20305, 'trigger_fct_t_rif40_comp_areas_checks2', 
			'T_RIF40_COMPARISON_AREAS no comparison found for study_id: %',
			c3_rec.study_id::VARCHAR	/* rif40_study_id_seq.CURRVAL study_id sequence */);
	END IF;
	CLOSE c1_cack2;
	sql_stmt:='SELECT COUNT(area_id) AS total FROM ('||E'\n'||
			'SELECT area_id FROM t_rif40_comparison_areas WHERE study_id = $1'||E'\n'||
			'EXCEPT '||E'\n'||
			'SELECT '||LOWER(c1_rec.comparison_geolevel_name)||' FROM '||c1_rec.hierarchytable||') a';
	BEGIN
		OPEN c2_cack2 FOR EXECUTE sql_stmt USING c3_rec.study_id;
		FETCH c2_cack2 INTO total;
		CLOSE c2_cack2;
	EXCEPTION
		WHEN others THEN
			PERFORM rif40_log_pkg.rif40_error(-20306, 'trigger_fct_t_rif40_comp_areas_checks2',
				'T_RIF40_COMPARISON_AREAS study_id: % % raised by: %',
				c3_rec.study_id::VARCHAR	/* rif40_study_id_seq.CURRVAL study_id sequence */,
				sqlerrm::VARCHAR		/* Error */,
				sql_stmt::VARCHAR		/* SQL */);

	END;
	IF total > 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20307, 'trigger_fct_t_rif40_comp_areas_checks2', 
			'T_RIF40_COMPARISON_AREAS study_id: %; found % areas not in: %.%',
			c3_rec.study_id::VARCHAR			/* rif40_study_id_seq.CURRVAL study_id sequence */,
			total::VARCHAR					/* Total */,
			c1_rec.hierarchytable::VARCHAR			/* Hierarchy table */,
			c1_rec.comparison_geolevel_name::VARCHAR	/* Comparison geolevel column name */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG2', 'trigger_fct_t_rif40_comp_areas_checks2', 
			'[20307] T_RIF40_COMPARISON_AREAS study_id: %; found % areas in: %.%'||E'\n'||'SQL> %;',
			c3_rec.study_id::VARCHAR			/* rif40_study_id_seq.CURRVAL study_id sequence */,
			total::VARCHAR					/* Total */,
			c1_rec.hierarchytable::VARCHAR			/* Hierarchy table */,
			c1_rec.comparison_geolevel_name::VARCHAR	/* Comparison geolevel column name */,
			sql_stmt::VARCHAR	 		       /* SQL */);
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
$BODY$
LANGUAGE 'plpgsql';
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks2() IS 'Check - area_id; once per statement (for performance reasons)';

CREATE TRIGGER t_rif40_comp_areas_checks2
	AFTER INSERT ON "t_rif40_comparison_areas" FOR EACH STATEMENT
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks2();
COMMENT ON TRIGGER t_rif40_comp_areas_checks2 ON t_rif40_comparison_areas IS 'INSERT trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks2()';

\i ../PLpgsql/rif40_trg_pkg/trigger_fct_t_rif40_investigations_checks.sql

DROP TRIGGER IF EXISTS t_rif40_inv_conditions_checks ON t_rif40_inv_conditions CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_inv_conditions_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_t_rif40_inv_conditions_checks_description>
<para>
Check - USERNAME exists.
Check - USERNAME is Kerberos USER on INSERT.
Check - DELETE only allowed on own records.
Check - CONDITION for SQL injection
</para>
</trigger_t_rif40_inv_conditions_checks_description>
 */
--
-- Error range: -20500 to -20509 - T_RIF40_INV_CONDITIONS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
-- $Log: v4_0_postgres_triggers.sql,v $
-- Revision 1.6  2014/02/24 10:50:28  peterh
-- Full build from Oracle, including default study area and removal of year_start/stop min/max_age_group from T_RIF40_STUDIES
--
-- Still present in view
--
-- Revision 1.5  2013/09/25 12:12:22  peterh
-- Baseline after 2x full clean builds at Postgres level
-- TODO.txt uptodate
--
-- Revision 1.4  2013/09/18 15:20:32  peterh
-- Checkin at end of 6 week RIF focus. Got as far as SAHSULAND run study to completion for observed only
--
-- Revision 1.3  2013/09/02 14:08:33  peterh
--
-- Baseline after full trigger implmentation
--
-- Revision 1.2  2013/03/14 17:35:38  peterh
-- Baseline for TX to laptop
--
-- Revision 1.4  2013/02/14 10:48:39  peterh
-- Baseline aftyer clean build with screen mockup changes
--
-- Revision 1.12  2012/10/23 09:05:57  peterh
--
-- Baseline after full build of SAHSUland RIF schema including data
-- No triggers, Geo data and system error/logon triggers to be done
--
-- Revision 1.11  2012/09/14 15:44:53  peterh
-- Baseline after full review of check code and error messages
-- IG functionality added
--
-- Revision 1.10  2012/09/05 15:16:37  peterh
--
-- RIF update after initial build of postgres DB
--
-- Revision 1.9  2012/07/03 12:28:55  peterh
--
-- RIF schema as at 3/6/2012. All entities complete
--
--
-- Check - CONDITION for SQL injection
--
	c4_icck CURSOR IS
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c4_rec RECORD;
BEGIN
--
	OPEN c4_icck;
	FETCH c4_icck INTO c4_rec;
	CLOSE c4_icck;
	IF TG_OP = 'INSERT' AND NEW.username != USER THEN
		IF USER = 'rif40' AND c4_rec.total = 0 THEN 
			/* Allowed during build before first result is added to system or before Kerberos update */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20500, 'trigger_fct_t_rif40_inv_conditions_checks',
				'T_RIF40_INV_CONDITIONS  study: % investigation: % line: % new username: % is not USER: %',
				NEW.study_id::VARCHAR	/* Study */,
				NEW.inv_id::VARCHAR	/* Investigation */,
				NEW.username::VARCHAR 	/* Record username */,
				NEW.line_number::VARCHAR /* Line */,
				USER::VARCHAR		/* Username */,
				NEW.username::VARCHAR	/* New username */);
		END IF;
	ELSIF TG_OP = 'UPDATE' AND NEW.username != USER THEN
		IF (USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0)) THEN 
			/* Allowed during build before first result is added to system or before Kerberos update */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20500, 'trigger_fct_t_rif40_inv_conditions_checks',
				'T_RIF40_INV_CONDITIONS  study: % investigation: % line: % new username: % is not USER: %; old: %',
				NEW.study_id::VARCHAR	/* Study */,
				NEW.inv_id::VARCHAR	/* Investigation */,
				NEW.username::VARCHAR 	/* Record username */,
				NEW.line_number::VARCHAR /* Line */,
				USER::VARCHAR		/* Username */,
				NEW.username::VARCHAR	/* New username */,
				OLD.username::VARCHAR	/* Old username */);
		END IF;
/*	ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20501, 't_rif40_inv_conditions_checks',
			'T_RIF40_INV_CONDITIONS study: % investigation: % line: % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR	/- Study -/,
			NEW.inv_id::VARCHAR	/- Investigation -/,
			NEW.line_number::VARCHAR /- Line -/,
			NEW.username::VARCHAR 	/- Record username -/,
			USER::VARCHAR		/- Logon username -/); */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20502, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_CONDITIONS study: % investigation: % line: % UPDATE not allowed on T_RIF40_INV_CONDITIONS',
			NEW.study_id::VARCHAR		/* Study */,
			NEW.inv_id::VARCHAR		/* Investigation */,
			NNEW.line_number::VARCHAR 	/* Line */);    
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20503, 'trigger_fct_t_rif40_inv_conditions_checks',
			'T_RIF40_INV_CONDITIONS study: % investigation: % line: % DELETE only allowed on own records in T_RIF40_INV_CONDITIONS, record owned by: %',
			NEW.study_id::VARCHAR	/* Study */,
			NEW.inv_id::VARCHAR	/* Investigation */,
			NEW.line_number::VARCHAR /* Line */,
			OLD.username::VARCHAR	/* Record username */);
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_inv_conditions_checks',
       	 		'[20500-3] T_RIF40_INV_CONDITIONS study: % investigation: % line: % CRUD checks OK',
 	      	 	OLD.study_id::VARCHAR		/* Study id */,
       	 		OLD.inv_id::VARCHAR		/* Investigation */,
			OLD.line_number::VARCHAR 	/* Line */);
		RETURN OLD;
	ELSE  	
--
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_inv_conditions_checks',
       	 		'[20500-3] T_RIF40_INV_CONDITIONS study: % investigation: % line: % CRUD checks OK',
 	      	 	NEW.study_id::VARCHAR		/* Study id */,
       	 		NEW.inv_id::VARCHAR		/* Investigation */,
			NEW.line_number::VARCHAR 	/* Line */);
--
 	       PERFORM rif40_trg_pkg.rif40_sql_injection_check(
   		     	'T_RIF40_INV_CONDITIONS'::VARCHAR,
			NEW.study_id::VARCHAR			/* Study id */,
			NEW.inv_id::VARCHAR			/* Investigation */,
  		      	NEW.line_number::VARCHAR 		/* Line */,
   		     	'CONDITION'::VARCHAR, 
   		     	NEW.condition::VARCHAR);  
    	    	RETURN NEW;
	END IF;
END; 
$BODY$
LANGUAGE 'plpgsql';
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_inv_conditions_checks() IS 'Check - USERNAME exists.
Check - USERNAME is Kerberos USER on INSERT.
Check - DELETE only allowed on own records.
Check - CONDITION for SQL injection';

CREATE TRIGGER t_rif40_inv_conditions_checks
	BEFORE DELETE OR INSERT OR UPDATE OF username, condition, study_id, inv_id, line_number ON t_rif40_inv_conditions
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_inv_conditions_checks();
COMMENT ON TRIGGER t_rif40_inv_conditions_checks ON t_rif40_inv_conditions IS 'INSERT OR UPDATE OR DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_inv_conditions_checks()';

DROP TRIGGER IF EXISTS t_rif40_inv_covariates_checks ON "t_rif40_inv_covariates" CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_inv_covariates_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_t_rif40_inv_covariates_checks_description>
<para>
Check - USERNAME exists.
Check - USERNAME is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
Check - study_geolevel_name.
Check - Covariates a) MIN and MAX.  b) Limits c) Check access to covariate table, <covariate name> column exists d) Check score.
</para>
</trigger_t_rif40_inv_covariates_checks_description>
 */
--
-- Error range: -20260 to -20279 - T_RIF40_INV_COVARIATES
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c1_ckicov CURSOR (l_geography  varchar, l_geolevel_name  varchar, l_covariate_name  varchar) FOR
		SELECT *
		  FROM rif40_covariates
		 WHERE geography      = l_geography
		   AND geolevel_name  = l_geolevel_name
		   AND covariate_name = l_covariate_name;
	c2_ckicov CURSOR(l_geography  varchar, l_geolevel_name  varchar) FOR
		SELECT *
		  FROM t_rif40_geolevels
		 WHERE l_geography     = geography
		   AND l_geolevel_name = geolevel_name;
	c3_ckicov CURSOR (l_schema  varchar, l_table  varchar, l_covariate_name  varchar) FOR
		SELECT column_name
		  FROM information_schema.columns
		 WHERE table_schema = LOWER(l_schema)
		   AND table_name   = LOWER(l_table)
		   AND column_name  = LOWER(l_covariate_name);
	c4_ckicov CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c6_ckicov CURSOR FOR
		SELECT a.study_geolevel_name, b.geolevel_id, a.study_id
		  FROM t_rif40_studies a, t_rif40_geolevels b
		 WHERE currval('rif40_study_id_seq'::regclass) = study_id
		   AND b.geolevel_name = a.study_geolevel_name;
	c6_rec RECORD;
	c4_rec RECORD;
	c1_rec RECORD;
	c2b_rec RECORD;
	c3_rec RECORD;
--
	owner		varchar(30);
--
	c5_ckicov 	REFCURSOR;
	sql_stmt	varchar(2000);
	total		integer;
BEGIN
--
-- T_RIF40_INV_COVARIATES:	Check - USERNAME is Kerberos USER on INSERT
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records

	OPEN c4_ckicov;
	FETCH c4_ckicov INTO c4_rec;
	CLOSE c4_ckicov;
	IF TG_OP = 'INSERT' AND NEW.username != USER THEN
		IF USER = 'rif40' AND c4_rec.total = 0 THEN 
			/* Allowed during build before first result is added to system or before Kerberos update */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20260, 'trigger_fct_t_rif40_inv_covariates_checks',
				'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % username: % is not USER: %',
				NEW.study_id::VARCHAR		/* Study */,
				NEW.inv_id::VARCHAR		/* Investigation */,
				NEW.covariate_name::VARCHAR	/* Covariate */,
				NEW.username::VARCHAR		/* New username */,
				USER::VARCHAR			/* Username */);
		END IF;
	ELSIF TG_OP = 'UPDATE' AND NEW.username != USER THEN
		IF (USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0)) THEN 
			/* Allowed during build before first result is added to system or before Kerberos update */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20260, 'trigger_fct_t_rif40_inv_covariates_checks',
				'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % new username: % is not USER: %; old: %',
				NEW.study_id::VARCHAR		/* Study */,
				NEW.inv_id::VARCHAR		/* Investigation */,
				NEW.covariate_name::VARCHAR	/* Covariate */,
				NEW.username::VARCHAR 		/* Record username */,
				USER::VARCHAR			/* Username */,
				OLD.username::VARCHAR		/* Old username */);
		END IF;
/*
	ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20261, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR		/- Study -/,
			NEW.inv_id::VARCHAR		/- Investigation -/,
			NEW.covariate_name::VARCHAR	/- Covariate -/,
			NEW.username::VARCHAR 		/- Record username -/,
			USER::VARCHAR			/- Logon username -/); */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20262, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % UPDATE not allowed on T_RIF40_INV_COVARIATES',
			NEW.study_id::VARCHAR		/* Study */,
			NEW.inv_id::VARCHAR		/* Investigation */,
			NEW.covariate_name::VARCHAR	/* Covariate */);
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20263, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % DELETE only allowed on own records in T_RIF40_INV_COVARIATES, record owned by: ',
			OLD.study_id::VARCHAR		/* Study */,
			OLD.inv_id::VARCHAR		/* Investigation */,
			OLD.covariate_name::VARCHAR	/* Covariate */,
			OLD.username::VARCHAR		/* INSERT username */);
	END IF;

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
--
 	       PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_inv_covariates_checks',
       			'[20600-3] T_RIF40_INV_COVARIATES study: % investigation: % covariate: % CRUD checks OK',
			OLD.study_id::VARCHAR			/* Study id */,
			OLD.inv_id::VARCHAR			/* Investigation */,
			OLD.covariate_name::VARCHAR		/* Covariate */);
		RETURN OLD;
	END IF;

--
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_inv_covariates_checks',
		'[20600-3] T_RIF40_INV_COVARIATES study: % investigation: % covariate: % CRUD checks OK',
		NEW.study_id::VARCHAR			/* Study id */,
		NEW.inv_id::VARCHAR			/* Investigation */,
		NEW.covariate_name::VARCHAR		/* Covariate */);
--
-- Check - STUDY_GEOLEVEL_NAME. Must be a valid GEOLEVEL_NAME for the study GEOGRPAHY in T_RIF40_GEOLEVELS [this is now an FK and not really needed]
--
-- This inmplies that the geolevel can be different to the study
--
	IF (NEW.study_geolevel_name IS NOT NULL AND NEW.study_geolevel_name::text <> '') THEN
		OPEN c2_ckicov(NEW.geography, NEW.study_geolevel_name);
		FETCH c2_ckicov INTO c2b_rec;
		IF NOT FOUND THEN
			CLOSE c2_ckicov;
			PERFORM rif40_log_pkg.rif40_error(-20264, 'trigger_fct_t_rif40_inv_covariates_checks',
				'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % study area geolevel name: % not found in RIF40_GEOLEVELS',
				NEW.study_id::VARCHAR		/* Study */,
				NEW.inv_id::VARCHAR		/* Investigation */,
				NEW.covariate_name::VARCHAR	/* Covariate */,
				NEW.study_geolevel_name::VARCHAR /* Study geolevel */);
		END IF;
/*
 * Wrong - all areas are assummed to be mappable
 *
		IF c2b_rec.resolution != 1 THEN
			CLOSE c2_ckicov;
			PERFORM rif40_log_pkg.rif40_Xerror(-202xx, 'trigger_fct_t_rif40_inv_covariates_checks',
				'T_RIF40_INV_COVARIATES study area geolevel name: '||NEW.study_geolevel_name||
				' in RIF40_GEOLEVELS is not a mappable area');
		END IF;
*/
		CLOSE c2_ckicov;
--
-- Check study geolevel name is the same (or lower than) than study geolevel name in t_rif40_studies
--
		IF  TG_OP = 'INSERT' AND c4_rec.total = 0 THEN
			/* Allowed during build before first result is added to system */
			NULL;
		ELSIF TG_OP = 'UPDATE' AND strpos(OLD.username, '@PRIVATE.NET') > 0 THEN 
			/* Allowed Kerberos username update */
			NULL;
		ELSE
			OPEN c6_ckicov;
			FETCH c6_ckicov INTO c6_rec;
			IF NOT FOUND THEN
				CLOSE c6_ckicov;
				PERFORM rif40_log_pkg.rif40_error(-20364, 'trigger_fct_t_rif40_inv_covariates_checks',
					'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % study area geolevel name: % not found in T_RIF40_STUDIES for study %',
					NEW.study_id::VARCHAR		/* Study */,
					NEW.inv_id::VARCHAR		/* Investigation */,
					NEW.covariate_name::VARCHAR	/* Covariate */,
					NEW.study_geolevel_name::VARCHAR /* Study geolevel */,
					currval('rif40_study_id_seq'::regclass)::VARCHAR	/* Covariate geolevel_id */);
			ELSIF c2b_rec.geolevel_id = c6_rec.geolevel_id THEN
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_inv_covariates_checks',
					'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % study area geolevel name: % (id %) same as geolevel in T_RIF40_STUDIES for study %',
					NEW.study_id::VARCHAR		/* Study */,
					NEW.inv_id::VARCHAR		/* Investigation */,
					NEW.covariate_name::VARCHAR	/* Covariate */,
					NEW.study_geolevel_name::VARCHAR /* Study geolevel */,
					c2b_rec.geolevel_id::VARCHAR	/* Covariate geolevel_id */,
					currval('rif40_study_id_seq'::regclass)::VARCHAR);
			ELSIF c2b_rec.geolevel_id = c6_rec.geolevel_id THEN
				PERFORM rif40_log_pkg.rif40_log('WARNING', 'trigger_fct_t_rif40_inv_covariates_checks',
					'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % study area geolevel name: % (id %) higher resolution than geolevel in T_RIF40_STUDIES for study % geolevel (id %) [NOT CURRENTLY SUPPORTED]',
					NEW.study_id::VARCHAR		/* Study */,
					NEW.inv_id::VARCHAR		/* Investigation */,
					NEW.covariate_name::VARCHAR	/* Covariate */,
					NEW.study_geolevel_name::VARCHAR /* Study geolevel */,
					c2b_rec.geolevel_id::VARCHAR	/* Covariate geolevel_id */,
					currval('rif40_study_id_seq'::regclass)::VARCHAR,
					c6_rec.study_geolevel_name::VARCHAR	/* Study geolevel_name  */,
					c6_rec.geolevel_id::VARCHAR	/* Study geolevel_id */);
			ELSE
				PERFORM rif40_log_pkg.rif40_error(-20365, 'trigger_fct_t_rif40_inv_covariates_checks',
					'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % study area geolevel name: % (id %) lower resolution than geolevel in T_RIF40_STUDIES for study % geolevel (id %) [NOT CURRENTLY SUPPORTED]',
					NEW.study_id::VARCHAR		/* Study */,
					NEW.inv_id::VARCHAR		/* Investigation */,
					NEW.covariate_name::VARCHAR	/* Covariate */,
					NEW.study_geolevel_name::VARCHAR /* Study geolevel */,
					c2b_rec.geolevel_id::VARCHAR	/* Covariate geolevel_id */,
					currval('rif40_study_id_seq'::regclass)::VARCHAR,
					c6_rec.study_geolevel_name::VARCHAR	/* Study geolevel_name  */,
					c6_rec.geolevel_id::VARCHAR	/* Study geolevel_id */);
			END IF;
			CLOSE c6_ckicov;
		END IF;
	END IF;
--
-- Check - Covariates
--
-- a) MIN and MAX.
--
	OPEN c1_ckicov(NEW.geography, NEW.study_geolevel_name, NEW.covariate_name);
	FETCH c1_ckicov INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1_ckicov;
		PERFORM rif40_log_pkg.rif40_error(-20265, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % no % covariate: % found for study area geolevel name: %',
			NEW.study_id::VARCHAR		/* Study */,
			NEW.inv_id::VARCHAR		/* Investigation */,
			NEW.covariate_name::VARCHAR	/* Covariate */,
			NEW.study_geolevel_name::VARCHAR /* Study geolevel */);
	END IF;
	CLOSE c1_ckicov;
--
-- b) Limits
--
	IF NEW.min < c1_rec.min THEN
		PERFORM rif40_log_pkg.rif40_error(-20266, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate: min (%) < RIF40_COVARIATES min (%) for study area geolevel name: ',
			NEW.study_id::VARCHAR		/* Study */,
			NEW.inv_id::VARCHAR		/* Investigation */,
			NEW.covariate_name::VARCHAR	/* Covariate */,
			NEW.min::VARCHAR		/* T_RIF40_INV_COVARIATES min */,
			c1_rec.min::VARCHAR		/* RIF40_COVARIATES min */,
			NEW.study_geolevel_name::VARCHAR /* Study geolevel */);
	ELSIF NEW.max > c1_rec.max THEN
		PERFORM rif40_log_pkg.rif40_error(-20267, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate: max (%) > RIF40_COVARIATES max (%) for study area geolevel name: ',
			NEW.study_id::VARCHAR		/* Study */,
			NEW.inv_id::VARCHAR		/* Investigation */,
			NEW.covariate_name::VARCHAR	/* Covariate */,
			NEW.max::VARCHAR		/* T_RIF40_INV_COVARIATES max */,
			c1_rec.max::VARCHAR		/* RIF40_COVARIATES max */,
			NEW.study_geolevel_name::VARCHAR /* Study geolevel */);
--
-- Remove when supported
--
	ELSIF c1_rec.type = 2 THEN
		PERFORM rif40_log_pkg.rif40_error(-20268, 'trigger_fct_t_rif40_inv_covariates_checks',
			'Error: T_RIF40_INV_COVARIATES study: % type = 2 (continuous variable) is not currently supported for geolevel_name: % covariate: %',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.study_geolevel_name::VARCHAR	/* Study geolevel */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);

	ELSIF c1_rec.type = 1 AND ROUND(NEW.max) != NEW.max THEN /* integer score */
		PERFORM rif40_log_pkg.rif40_error(-20269, 'trigger_fct_t_rif40_inv_covariates_checks',
			'Error: T_RIF40_INV_COVARIATES study: % type = 1 (integer score) and max is not an integer: % for geolevel_name: % covariate: %',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.max::VARCHAR			/* New max */,
			NEW.study_geolevel_name::VARCHAR	/* Study geolevel */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	ELSIF c1_rec.type = 1 AND ROUND(NEW.min) != NEW.min THEN /* integer score */
		PERFORM rif40_log_pkg.rif40_error(-20270, 'trigger_fct_t_rif40_inv_covariates_checks',
			'Error: T_RIF40_INV_COVARIATES study: % type = 1 (integer score) and min is not an integer: % for geolevel_name: % covariate: %',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.min::VARCHAR			/* New min */,
			NEW.study_geolevel_name::VARCHAR	/*Study geolevel */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	ELSIF c1_rec.type = 1 AND NEW.min < 0 THEN /* integer score */
		PERFORM rif40_log_pkg.rif40_error(-20271, 'trigger_fct_t_rif40_inv_covariates_checks',
			'Error: T_RIF40_INV_COVARIATES study: % type = 1 (integer score) and min <0: % for geolevel_name: % covariate: %',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.min::VARCHAR			/* New min */,
			NEW.study_geolevel_name::VARCHAR	/* Study geolevel */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	END IF;
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_inv_covariates_checks',
			'[20266-71] T_RIF40_INV_COVARIATES study: % investigation: % covariate: % max/in checks OK',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.covariate_name::VARCHAR		/* Covariate */);

--
-- c) Check access to covariate table, <covariate name> column exists
--
	owner:=rif40_sql_pkg.rif40_object_resolve(c2b_rec.covariate_table::VARCHAR);
	IF coalesce(owner::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20272, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate table: % cannot be accessed',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.covariate_name::VARCHAR		/* Covariate */,
			c2b_rec.covariate_table::VARCHAR	/* Covariate table */);
	END IF;
	OPEN c3_ckicov(owner, c2b_rec.covariate_table, NEW.covariate_name);
	FETCH c3_ckicov INTO c3_rec;
	IF NOT FOUND THEN
		CLOSE c3_ckicov;
		PERFORM rif40_log_pkg.rif40_error(-20273, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate table column: %.%.% cannot be accessed',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.covariate_name::VARCHAR		/* Covariate */,
			owner::VARCHAR				/* Owner */,
			c2b_rec.covariate_table::VARCHAR	/* Covariate table */,
			NEW.covariate_name::VARCHAR		/* Covariate column */);
	ELSE	
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_inv_covariates_checks',
			'[20272-3] T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate table column: %.%.% can be accessed',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.covariate_name::VARCHAR		/* Covariate */,
			owner::VARCHAR				/* Owner */,
			c2b_rec.covariate_table::VARCHAR	/* Covariate table */,
			NEW.covariate_name::VARCHAR		/* Covariate column */);
	END IF;
--
	CLOSE c3_ckicov;
	OPEN c3_ckicov(owner, c2b_rec.covariate_table, 'YEAR');
	FETCH c3_ckicov INTO c3_rec;
	IF NOT FOUND THEN
		CLOSE c3_ckicov;
		PERFORM rif40_log_pkg.rif40_error(-20274, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate table column: %.%.YEAR cannot be accessed',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.covariate_name::VARCHAR		/* Covariate */,
			owner::VARCHAR				/* Owner */,
			c2b_rec.covariate_table::VARCHAR	/* Covariate table */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_inv_covariates_checks',
			'[20274] T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate table column: %.%.YEAR can be accessed',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.covariate_name::VARCHAR		/* Covariate */,
			owner::VARCHAR				/* Owner */,
			c2b_rec.covariate_table::VARCHAR	/* Covariate table */);
	END IF;
	CLOSE c3_ckicov;
	OPEN c3_ckicov(owner, c2b_rec.covariate_table, NEW.study_geolevel_name);
	FETCH c3_ckicov INTO c3_rec;
	IF NOT FOUND THEN
		CLOSE c3_ckicov;
		PERFORM rif40_log_pkg.rif40_error(-20275, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate table column: %.%.% cannot be accessed',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.covariate_name::VARCHAR		/* Covariate */,
			owner::VARCHAR				/* Owner */,
			c2b_rec.covariate_table::VARCHAR	/* Covariate table */,
			NEW.study_geolevel_name::VARCHAR 	/* Study geolevel column */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_inv_covariates_checks',
			'[20275] T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate table column: %.%.% can be accessed',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.covariate_name::VARCHAR		/* Covariate */,
			owner::VARCHAR				/* Owner */,
			c2b_rec.covariate_table::VARCHAR	/* Covariate table */,
			NEW.study_geolevel_name::VARCHAR 	/* Study geolevel column */);
	END IF;
	CLOSE c3_ckicov;

--
-- d) Check score
--
	IF TG_OP = 'INSERT' AND NEW.username != USER AND c4_rec.total = 0 THEN 
		/* Allowed during build before first result is added to system or before Kerberos update */
		NULL;
	ELSIF TG_OP = 'UPDATE' AND NEW.username != USER AND strpos(OLD.username, '@PRIVATE.NET') > 0  THEN 
		/* Allowed during build before first result is added to system or before Kerberos update */
		NULL;
	ELSIF c1_rec.type = 1 /* integer score */ THEN 
		/* Not during build before first result is added to system or before Kerberos update */
		BEGIN
			sql_stmt:='SELECT COUNT(*) AS total FROM "'||owner||'".'||c2b_rec.covariate_table||' WHERE '||NEW.covariate_name||' = $1';
			OPEN c5_ckicov FOR EXECUTE sql_stmt USING NEW.min::INTEGER;
			FETCH c5_ckicov INTO total;
			CLOSE c5_ckicov;
		EXCEPTION
			WHEN others THEN
				PERFORM rif40_log_pkg.rif40_error(-20276, 'trigger_fct_t_rif40_inv_covariates_checks',
					'T_RIF40_INV_COVARIATES Caught % for study: % investigation: % covariate: % covariate table column: %.%.% min value: %; SQL %',
					sqlerrm::VARCHAR			/* Error message */,
					NEW.study_id::VARCHAR			/* Study */,
					NEW.inv_id::VARCHAR			/* Investigation */,
					NEW.covariate_name::VARCHAR		/* Covariate */,
					owner::VARCHAR				/* Owner */,
					c2b_rec.covariate_table::VARCHAR	/* Covariate table */,
					NEW.covariate_name::VARCHAR		/* Covariate column */,
					NEW.min::VARCHAR			/* Min value */,
					sql_stmt::VARCHAR			/* SQL Statement */);
		END;
--
		IF total = 0 THEN
			PERFORM rif40_log_pkg.rif40_error(-20277, 'trigger_fct_t_rif40_inv_covariates_checks',
				'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate table column: %.%.% min value: % not found',
				NEW.study_id::VARCHAR			/* Study */,
				NEW.inv_id::VARCHAR			/* Investigation */,
				NEW.covariate_name::VARCHAR		/* Covariate */,
				owner::VARCHAR				/* Owner */,
				c2b_rec.covariate_table::VARCHAR	/* Covariate table */,
				NEW.covariate_name::VARCHAR		/* Covariate column */,
				NEW.min::VARCHAR			/* Min value */);
		END IF;
		BEGIN
			OPEN c5_ckicov FOR EXECUTE sql_stmt USING NEW.max::INTEGER;
			FETCH c5_ckicov INTO total;
			CLOSE c5_ckicov;
		EXCEPTION
			WHEN others THEN
				PERFORM rif40_log_pkg.rif40_error(-20278, 'trigger_fct_t_rif40_inv_covariates_checks',
					'T_RIF40_INV_COVARIATES Caught % for study: % investigation: % covariate: % covariate table column: %.%.% max value: %; SQL %',
					sqlerrm::VARCHAR			/* Error message */,
					NEW.study_id::VARCHAR			/* Study */,
					NEW.inv_id::VARCHAR			/* Investigation */,
					NEW.covariate_name::VARCHAR		/* Covariate */,
					owner::VARCHAR				/* Owner */,
					c2b_rec.covariate_table::VARCHAR	/* Covariate table */,
					NEW.covariate_name::VARCHAR		/* Covariate column */,
					NEW.max::VARCHAR			/* Min value */,
					sql_stmt::VARCHAR			/* SQL Statement */);
		END;
		IF total = 0 THEN
			PERFORM rif40_log_pkg.rif40_error(-20279, 'trigger_fct_t_rif40_inv_covariates_checks',
				'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate table column: %.%.% max value: % not found',
				NEW.study_id::VARCHAR			/* Study */,
				NEW.inv_id::VARCHAR			/* Investigation */,
				NEW.covariate_name::VARCHAR		/* Covariate */,
				owner::VARCHAR				/* Owner */,
				c2b_rec.covariate_table::VARCHAR	/* Covariate table */,
				NEW.covariate_name::VARCHAR		/* Covariate column */,
				NEW.max::VARCHAR			/* Max value */);
		END IF;
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END; 
$BODY$
LANGUAGE 'plpgsql';
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_inv_covariates_checks() IS 'Check - USERNAME exists.
Check - USERNAME is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
Check - study_geolevel_name.
Check - Covariates a) MIN and MAX.  b) Limits c) Check access to covariate table, <covariate name> column exists d) Check score.';

CREATE TRIGGER t_rif40_inv_covariates_checks
	BEFORE INSERT OR UPDATE OR DELETE ON "t_rif40_inv_covariates" FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_inv_covariates_checks();
COMMENT ON TRIGGER t_rif40_inv_covariates_checks ON t_rif40_inv_covariates IS 'INSERT OR UPDATE OR DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_inv_covariates_checks()';

DROP TRIGGER IF EXISTS t_rif40_geolevels_checks ON t_rif40_geolevels CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_geolevels_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_t_rif40_geolevels_checks_description>
<para>
Check LOOKUP_TABLE, COVARIATE_TABLE exist.
Check YEAR, &lt;GEOLEVEL_NAME&gt; exist in COVARIATE_TABLE
Check LOOKUP_TABLE.&lt;T_RIF40_GEOLEVELS.GEOLEVEL_NAME&gt;, LOOKUP_TABLE.LOOKUP_DESC_COLUMN,
LOOKUP_TABLE.<CENTROIDXCOORDINATE_COLUMN>, LOOKUP_TABLE.<CENTROIDYCOORDINATE_COLUMN> columns exist
Check &lt;RIF40_GEOGRAPHIES.HIERARCHYTABLE&gt;.&lt;GEOLEVEL_NAME&gt; column exists
Check &lt;postal_population_table&gt;.&lt;GEOLEVEL_NAME&gt; column exists if POSTAL_POPULATION_TABLE set if RIF40_GEOGAPHIES

TO be added:

Check
</para>
</trigger_t_rif40_geolevels_checks_description>
 */
--
-- Error range: -20120 to -20134 - T_RIF40_GEOLEVELS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c1_geock CURSOR (l_schema  varchar, l_table  varchar, l_column  varchar) IS
		SELECT column_name
		  FROM information_schema.columns
		 WHERE table_schema = LOWER(l_schema)
		   AND table_name   = LOWER(l_table)
		   AND column_name  = LOWER(l_column);
	c2_geock CURSOR (l_geography  varchar) IS
		SELECT hierarchytable, postal_population_table
		  FROM rif40_geographies
		 WHERE geography = l_geography;
	c4_geock CURSOR IS
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c1_rec RECORD;
	c2_rec RECORD;
	c4_rec RECORD;
--
	owner		varchar(30);
	table_or_view	varchar(30);
BEGIN
--
	OPEN c4_geock;
	FETCH c4_geock INTO c4_rec;
	CLOSE c4_geock;
--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSIF TG_OP = 'INSERT' AND c4_rec.total = 0 THEN /* Allowed during build before first result is added to system */
		RETURN NEW;
	END IF;
--
-- Check COVARIATE_TABLE
--
	owner:=rif40_sql_pkg.rif40_object_resolve(NEW.covariate_table);
	table_or_view:=NEW.covariate_table;
	IF (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') AND coalesce(table_or_view::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20120, 'trigger_fct_t_rif40_geolevels_checks',
			'Error: T_RIF40_GEOLEVELS COVARIATE_TABLE (%) not found',
			NEW.covariate_table::VARCHAR 		/* covariate_table */);
	ELSIF (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') AND (table_or_view IS NOT NULL AND table_or_view::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			'[20120] T_RIF40_GEOLEVELS COVARIATE_TABLE (%) found',
			NEW.covariate_table::VARCHAR 		/* covariate_table */);
	END IF;
--
-- Check YEAR, <GEOLEVEL_NAME> exist in COVARIATE_TABLE
--
	OPEN c1_geock(owner, table_or_view, 'YEAR');
	FETCH c1_geock INTO c1_rec;
	CLOSE c1_geock;
	IF (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20121, 'trigger_fct_t_rif40_geolevels_checks',
			'Error: T_RIF40_GEOLEVELS COVARIATE_TABLE column (%.%) not found for geolevel_name: ',
			NEW.covariate_table::VARCHAR		/* Covariate table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20121] T_RIF40_GEOLEVELS COVARIATE_TABLE column (%.%) found for geolevel_name: ',
			NEW.covariate_table::VARCHAR     	/* Covariate table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	END IF;
	c1_rec.column_name:=NULL;
	OPEN c1_geock(owner, table_or_view, NEW.geolevel_name);
	FETCH c1_geock INTO c1_rec;
	CLOSE c1_geock;
	IF (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20122, 'trigger_fct_t_rif40_geolevels_checks',
			 'Error: T_RIF40_GEOLEVELS COVARIATE_TABLE column (%.%) not found for geolevel_name: %',
			NEW.covariate_table::VARCHAR   	 	/* Covariate table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20122] T_RIF40_GEOLEVELS COVARIATE_TABLE column (%.%) not found for geolevel_name: %',
			NEW.covariate_table::VARCHAR		/* Covariate table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	END IF;
--
-- Check LOOKUP_TABLE
--
	owner:=rif40_sql_pkg.rif40_object_resolve(NEW.lookup_table);
	table_or_view:=NEW.lookup_table;
	IF (NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') AND coalesce(table_or_view::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20123, 'trigger_fct_t_rif40_geolevels_checks',
			 'Error: T_RIF40_GEOLEVELS LOOKUP_TABLE (%) not found for geolevel_name: %',
			NEW.lookup_table::VARCHAR  	     	/* Lookup table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') AND (table_or_view IS NOT NULL AND table_or_view::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20123] T_RIF40_GEOLEVELS LOOKUP_TABLE (%) found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	END IF;
--
-- Check LOOKUP_TABLE.<T_RIF40_GEOLEVELS.GEOLEVEL_NAME>, LOOKUP_TABLE.LOOKUP_DESC_COLUMN exists
--
	c1_rec.column_name:=NULL;
	OPEN c1_geock(owner, table_or_view, NEW.geolevel_name);
	FETCH c1_geock INTO c1_rec;
	CLOSE c1_geock;
	IF (NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20124, 'trigger_fct_t_rif40_geolevels_checks',
			 'Error: T_RIF40_GEOLEVELS LOOKUP_TABLE column (%.%) not found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20124] T_RIF40_GEOLEVELS LOOKUP_TABLE column (%.%) found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	END IF;
	c1_rec.column_name:=NULL;
	OPEN c1_geock(owner, table_or_view, NEW.lookup_desc_column);
	FETCH c1_geock INTO c1_rec;
	CLOSE c1_geock;
	IF (NEW.lookup_desc_column IS NOT NULL AND NEW.lookup_desc_column::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20125, 'trigger_fct_t_rif40_geolevels_checks',
			 'Error: T_RIF40_GEOLEVELS LOOKUP_TABLE column (%.%) not found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.lookup_desc_column::VARCHAR		/* LOOKUP_TABLE column */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.lookup_desc_column IS NOT NULL AND NEW.lookup_desc_column::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20125] T_RIF40_GEOLEVELS LOOKUP_TABLE column (%.%) found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.lookup_desc_column::VARCHAR		/* LOOKUP_TABLE column */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	END IF;
--
-- Check LOOKUP_TABLE.<CENTROIDXCOORDINATE_COLUMN>, LOOKUP_TABLE.<CENTROIDYCOORDINATE_COLUMN> column exist
--
	c1_rec.column_name:=NULL;
	OPEN c1_geock(owner, table_or_view, NEW.centroidxcoordinate_column);
	FETCH c1_geock INTO c1_rec;
	CLOSE c1_geock;
	IF (NEW.centroidxcoordinate_column IS NOT NULL AND NEW.centroidxcoordinate_column::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20126, 'trigger_fct_t_rif40_geolevels_checks',
			 'Error: T_RIF40_GEOLEVELS CENTROIDXCOORDINATE_COLUMN column (%.%) not found for geolevel_name: %',
			NEW.lookup_table::VARCHAR    	   	/* Lookup table */,
			NEW.centroidxcoordinate_column::VARCHAR	/* CENTROIDXCOORDINATE_COLUMN column */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.centroidxcoordinate_column IS NOT NULL AND NEW.centroidxcoordinate_column::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20126] T_RIF40_GEOLEVELS CENTROIDXCOORDINATE_COLUMN column (%.%) found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.centroidxcoordinate_column		/* CENTROIDXCOORDINATE_COLUMN column */,
			NEW.geolevel_name			/* Geolevel name */);
	END IF;
	c1_rec.column_name:=NULL;
	OPEN c1_geock(owner, table_or_view, NEW.centroidycoordinate_column);
	FETCH c1_geock INTO c1_rec;
	CLOSE c1_geock;
	IF (NEW.centroidycoordinate_column IS NOT NULL AND NEW.centroidycoordinate_column::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20127, 'trigger_fct_t_rif40_geolevels_checks',
			 'Error: T_RIF40_GEOLEVELS CENTROIDYCOORDINATE_COLUMN column (%.%) not found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.centroidxcoordinate_column::VARCHAR	/* CENTROIDXCOORDINATE_COLUMN column */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.centroidycoordinate_column IS NOT NULL AND NEW.centroidycoordinate_column::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20127] T_RIF40_GEOLEVELS CENTROIDYCOORDINATE_COLUMN column (%.%) found for geolevel_name: %',
			NEW.lookup_table::VARCHAR	/* Lookup table */,
			NEW.centroidxcoordinate_column::VARCHAR	/* CENTROIDXCOORDINATE_COLUMN column */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	END IF;
--
-- Check <RIF40_GEOGRAPHIES.HIERARCHYTABLE>.<GEOLEVEL_NAME> column exists
--
	OPEN c2_geock(NEW.geography);
	FETCH c2_geock INTO c2_rec;
	CLOSE c2_geock;
	IF (c2_rec.hierarchytable IS NOT NULL AND c2_rec.hierarchytable::text <> '') THEN
		owner:=rif40_sql_pkg.rif40_object_resolve(c2_rec.hierarchytable);
		table_or_view:=c2_rec.hierarchytable;
		IF coalesce(owner::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20128, 'trigger_fct_t_rif40_geolevels_checks',
			 	'Error: RIF40_GEOGRAPHIES HIERARCHYTABLE (%) not found for geolevel_name: %',
				c2_rec.hierarchytable::VARCHAR		/* HIERARCHYTABLE */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 	'[20128] RIF40_GEOGRAPHIES HIERARCHYTABLE (%) found for geolevel_name: %',
				c2_rec.hierarchytable::VARCHAR		/* HIERARCHYTABLE */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		END IF;
		c1_rec.column_name:=NULL;
		OPEN c1_geock(owner, c2_rec.hierarchytable, NEW.geolevel_name);
		FETCH c1_geock INTO c1_rec;
		CLOSE c1_geock;
		IF (NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20129, 'trigger_fct_t_rif40_geolevels_checks',
			 	'Error: RIF40_GEOGRAPHIES HIERARCHYTABLE geolevel column (%.%) not found for geolevel_name: %',
				c2_rec.hierarchytable::VARCHAR		/* HIERARCHYTABLE */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		ELSIF (NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 	'[20129] RIF40_GEOGRAPHIES HIERARCHYTABLE geolevel column (%.%) found for geolevel_name: %',
				c2_rec.hierarchytable::VARCHAR		/* HIERARCHYTABLE */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		END IF;
	END IF;
--
-- Check &lt;postal_population_table&gt;.&lt;GEOLEVEL_NAME&gt; column exists if POSTAL_POPULATION_TABLE set if RIF40_GEOGAPHIES
--
	IF (c2_rec.postal_population_table IS NOT NULL AND c2_rec.postal_population_table::text <> '') AND
		(
		 ((NEW.centroidxcoordinate_column IS NOT NULL AND NEW.centroidxcoordinate_column::text <> '') AND (NEW.centroidycoordinate_column IS NOT NULL AND NEW.centroidycoordinate_column::text <> '')) OR
		 ((NEW.centroidsfile IS NOT NULL AND NEW.centroidsfile::text <> ''))) THEN
		owner:=rif40_sql_pkg.rif40_object_resolve(c2_rec.postal_population_table);
		table_or_view:=c2_rec.postal_population_table;
		IF coalesce(table_or_view::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20130, 'trigger_fct_t_rif40_geolevels_checks',
			 	'Error: RIF40_GEOGRAPHIES POSTAL_POPULATION_TABLE (%) not found when set',
		   	     	c2_rec.postal_population_table::VARCHAR 	/* hierarchy table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 	'[20130] RIF40_GEOGRAPHIES POSTAL_POINT_COLUMN (%) found',
				c2_rec.postal_population_table::VARCHAR		/* postal population table */);
		END IF;
		c1_rec.column_name:=NULL;
		OPEN c1_geock(owner, table_or_view, NEW.geolevel_name);
		FETCH c1_geock INTO c1_rec;
		CLOSE c1_geock;
		IF coalesce(c1_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20131, 'trigger_fct_t_rif40_geolevels_checks',
				'Error: RIF40_GEOGRAPHIES geolevel column (%.%) not found',
				c2_rec.postal_population_table::VARCHAR	/* postal population table */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 	'[20131] RIF40_GEOGRAPHIES geolevel column (%.%) found',
				c2_rec.postal_population_table::VARCHAR	/* postal population table */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		END IF;
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
$BODY$
LANGUAGE 'plpgsql';

COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_geolevels_checks() IS '
Check LOOKUP_TABLE, COVARIATE_TABLE exist.
Check YEAR, <GEOLEVEL_NAME>; exist in COVARIATE_TABLE
Check LOOKUP_TABLE.<T_RIF40_GEOLEVELS.GEOLEVEL_NAME>, LOOKUP_TABLE.LOOKUP_DESC_COLUMN,
LOOKUP_TABLE.<CENTROIDXCOORDINATE_COLUMN>, LOOKUP_TABLE.<CENTROIDYCOORDINATE_COLUMN> columns exist
Check <RIF40_GEOGRAPHIES.HIERARCHYTABLE>.<GEOLEVEL_NAME> column exists
Check <postal_population_table>.<GEOLEVEL_NAME> column exists if POSTAL_POPULATION_TABLE set if RIF40_GEOGAPHIES'; 

CREATE TRIGGER t_rif40_geolevels_checks
	BEFORE INSERT OR UPDATE OF lookup_table, covariate_table, lookup_desc_column, geography, geolevel_name ON t_rif40_geolevels
	FOR EACH ROW	
	WHEN ((NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') OR (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') OR (NEW.lookup_desc_column IS NOT NULL AND NEW.lookup_desc_column::text <> '') OR
	      (NEW.centroidxcoordinate_column IS NOT NULL AND NEW.centroidxcoordinate_column::text <> '') OR (NEW.centroidycoordinate_column IS NOT NULL AND NEW.centroidycoordinate_column::text <> '') OR (NEW.geography IS NOT NULL AND NEW.geography::text <> '') OR (NEW.geolevel_name IS NOT NULL AND NEW.geolevel_name::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_geolevels_checks();
COMMENT ON TRIGGER t_rif40_geolevels_checks ON t_rif40_geolevels IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_geolevels_checks()';

CREATE TRIGGER t_rif40_geolevels_checks_del
	BEFORE DELETE ON t_rif40_geolevels
	FOR EACH ROW	
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_geolevels_checks();
COMMENT ON TRIGGER t_rif40_geolevels_checks_del ON t_rif40_geolevels IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_geolevels_checks()';
 
DROP TRIGGER IF EXISTS t_rif40_num_denom_checks ON t_rif40_num_denom CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_t_rif40_num_denom_checks_description>
<para>
Check numerator_table really is a numerator and likewise for the denominator
</para>
</trigger_t_rif40_num_denom_checks_description>
 */
--
-- $Author: peterh $
-- $timestamp: 2012/04/26 15:49:46 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c1_rnd CURSOR (l_table varchar) FOR
		SELECT *
		  FROM rif40_tables
		 WHERE table_name = UPPER(l_table);
	c1_rec RECORD;
BEGIN

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
 
	OPEN c1_rnd(NEW.numerator_table);
	FETCH c1_rnd INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1_rnd;
		PERFORM rif40_log_pkg.rif40_error(-20291, 'trigger_fct_t_rif40_num_denom_checks',  
			'T_RIF40_NUM_DENOM numerator not found in RIF40_TABLES: %',
			NEW.numerator_table::VARCHAR /* numerator table */);
	ELSIF c1_rec.isnumerator != 1 THEN
		CLOSE c1_rnd;
		PERFORM rif40_log_pkg.rif40_error(-20292, 'trigger_fct_t_rif40_num_denom_checks',  
			'T_RIF40_NUM_DENOM numerator in RIF40_TABLES: % is not a numerator table,',
			NEW.numerator_table::VARCHAR /* numerator table */);
	END IF;
	CLOSE c1_rnd;
--
	OPEN c1_rnd(NEW.denominator_table);
	FETCH c1_rnd INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1_rnd;
		PERFORM rif40_log_pkg.rif40_error(-20293, 'trigger_fct_t_rif40_num_denom_checks',  
			EXCEPTION 'T_RIF40_NUM_DENOM denominator not found in RIF40_TABLES: %',
			NEW.denominator_table::VARCHAR /* denominator table */);
	ELSIF c1_rec.isnumerator = 1 THEN
		CLOSE c1_rnd;
		PERFORM rif40_log_pkg.rif40_error(-20294, 'trigger_fct_t_rif40_num_denom_checks',  
			'T_RIF40_NUM_DENOM denominator in RIF40_TABLES: % is not a denominator table,',
			NEW.denominator_table::VARCHAR /* denominator table */);
	END IF;
	CLOSE c1_rnd;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER t_rif40_num_denom_checks
	BEFORE INSERT OR UPDATE OF geography, numerator_table, denominator_table ON t_rif40_num_denom
	FOR EACH ROW	
	WHEN ((NEW.geography IS NOT NULL AND NEW.geography::text <> '') OR (NEW.numerator_table IS NOT NULL AND NEW.numerator_table::text <> '') OR (NEW.denominator_table IS NOT NULL AND NEW.denominator_table::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks();
CREATE TRIGGER t_rif40_num_denom_checks_del
	BEFORE DELETE ON t_rif40_num_denom
	FOR EACH ROW	
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks();

GRANT EXECUTE ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks() TO rif_user;
GRANT EXECUTE ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks() TO rif_manager;

COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks() IS 'Check numerator_table really is a numerator and likewise for the denominator';
COMMENT ON TRIGGER t_rif40_num_denom_checks ON t_rif40_num_denom IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks()';
COMMENT ON TRIGGER t_rif40_num_denom_checks_del ON t_rif40_num_denom IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks()';

DROP TRIGGER IF EXISTS t_rif40_user_projects_checks ON t_rif40_user_projects CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_user_projects_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_t_rif40_geolevels_checks_description>
<para>
Check username exists and is a RIF user
Check project has not ended
</para>
</trigger_t_rif40_geolevels_checks_description>
 */
--
-- Error range: -20520 to -20529 - T_RIF40_USER_PROJECTS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c2_rup CURSOR(l_project  varchar) IS
		SELECT *
		  FROM t_rif40_projects
		 WHERE project = l_project;
	c4_rup CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;  
        c2_rec RECORD;
        c4_rec RECORD;
BEGIN
	OPEN c4_rup;
	FETCH c4_rup INTO c4_rec;
	CLOSE c4_rup;    
--
-- Check username exists and is a RIF user
--
	IF USER = 'rif40' THEN
		IF NOT TG_OP = 'DELETE' AND USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN
			/* Allowed during build before first result is added to system or before Kerberos update */
			RETURN NEW;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20522,  'trigger_fct_t_rif40_user_projects_checks',
				'T_RIF40_USER_PROJECTS project: % rif40 user insert only allowed during build before first result is added to system',
				OLD.project::VARCHAR 		/* project */);
		END IF; 
        ELSIF NOT (pg_has_role(USER, 'rif_user', 'USAGE') AND pg_has_role(USER, 'rif_manager', 'USAGE')) THEN
		PERFORM rif40_log_pkg.rif40_error(-20520, 'trigger_fct_t_rif40_user_projects_checks',
		 	'Error: T_RIF40_USER_PROJECTS user: % is not a RIF_USER',
			USER::VARCHAR 	/* username */);
	END IF;

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_user_projects_checks',
		 	'[20520] T_RIF40_USER_PROJECTS user: % is a RIF_USER',
			OLD.username::VARCHAR 	/* username */);
		RETURN OLD;
	END IF;
--
-- Check table username is a RIF user
--
	IF c4_rec.total = 0 THEN /* Allowed during build before first result is added to system */ 
		NULL;
        ELSIF NOT (pg_has_role(NEW.username, 'rif_user', 'USAGE') AND pg_has_role(NEW.username, 'rif_manager', 'USAGE')) THEN 
		PERFORM rif40_log_pkg.rif40_error(-20520, 'trigger_fct_t_rif40_user_projects_checks',
		 	'Error: T_RIF40_USER_PROJECTS username: % is not a RIF_USER',
			NEW.username::VARCHAR 	/* username */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_user_projects_checks',
		       	'[20520] T_RIF40_USER_PROJECTS username: % is a RIF_USER',
   	            	NEW.username::VARCHAR 	/* username */);
      	END IF;         
--
-- Check project has not ended
--
	OPEN c2_rup(NEW.project);
	FETCH c2_rup INTO c2_rec;
	IF coalesce(c2_rec.date_ended::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_user_projects_checks',
		  	'[20521] T_RIF40_USER_PROJECTS project: % no end set',
			NEW.project::VARCHAR 		/* project */);
	ELSIF c2_rec.date_ended < LOCALTIMESTAMP AND c4_rec.total = 0 THEN /* Allowed during build before first result is added to system */
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_user_projects_checks',
		  	'Error: T_RIF40_USER_PROJECTS project: % ended on: % [IGNORED INITIAL LOAD]',
			NEW.project::VARCHAR 		/* project */,
			c2_rec.date_ended::VARCHAR	/* date_ended */);
	ELSIF c2_rec.date_ended < LOCALTIMESTAMP AND c4_rec.total > 0 THEN 
		PERFORM rif40_log_pkg.rif40_error(-20521, 'trigger_fct_t_rif40_user_projects_checks',
		  	'Error: T_RIF40_USER_PROJECTS project: % ended on: %',
			NEW.project::VARCHAR 		/* project */,
			c2_rec.date_ended::VARCHAR	/* date_ended */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_user_projects_checks',
			'[20521] T_RIF40_USER_PROJECTS project: % ends on: %',
			NEW.project::VARCHAR 		/* project */,
			c2_rec.date_ended::VARCHAR	/* date_ended */);
	END IF;
	CLOSE c2_rup;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END; 
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER t_rif40_user_projects_checks
	BEFORE INSERT OR UPDATE OF project, username ON t_rif40_user_projects
	FOR EACH ROW	
	WHEN ((NEW.project IS NOT NULL AND NEW.project::text <> '') OR (NEW.username IS NOT NULL AND NEW.username::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_user_projects_checks();
CREATE TRIGGER t_rif40_user_projects_checks_del
	BEFORE DELETE ON t_rif40_user_projects
	FOR EACH ROW	
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_user_projects_checks();
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_user_projects_checks() IS 'Check username exists and is a RIF user Check project has not ended';
COMMENT ON TRIGGER t_rif40_user_projects_checks ON t_rif40_user_projects IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_user_projects_checks()';
COMMENT ON TRIGGER t_rif40_user_projects_checks_del ON t_rif40_user_projects IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_user_projects_checks()';

DROP TRIGGER IF EXISTS t_rif40_results_checks ON t_rif40_results CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_results_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_t_rif40_results_checks_description>
<para>
Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
Check - relative_risk, smoothed_relative_risk, posterior_probability, posterior_probability_lower95, posterior_probability_upper95,
  	smoothed_smr, smoothed_smr_lower95, smoothed_smr_upper95, residual_relative_risk, residual_rr_lower95, residual_rr_upper95
	are NULL for directly standardised results
</para>
</trigger_t_rif40_results_checks_description>
 */
--
-- -20340 to -20359 - T_RIF40_RESULTS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c4_resck CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_contextual_stats /* Loaded after t_rif40_results */
		 LIMIT 1) a;    
	c4_rec RECORD;
BEGIN
	OPEN c4_resck;
	FETCH c4_resck INTO c4_rec;
	CLOSE c4_resck;

--
-- T_RIF40_RESULTS: Check - USERNAME is Kerberos USER on INSERT
--			Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records
--
	IF NOT TG_OP = 'DELETE' AND NEW.username != USER THEN
		IF USER = 'rif40' AND c4_rec.total = 0 THEN /* Allowed during build before first result is added to system */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20340, 'trigger_fct_t_rif40_results_checks',
		 		'T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % username: % is not USER: %',
				NEW.study_id::VARCHAR	/* Study id */,
				NEW.inv_id::VARCHAR	/* Investigation */,
				NEW.band_id::VARCHAR	/* Band ID */,
				NEW.genders::VARCHAR 	/* genders */,
				NEW.adjusted::VARCHAR	/* adjusted */,
				NEW.direct_standardisation::VARCHAR	/* Direct standardisation */,
				NEW.username::VARCHAR 	/* Record username */,
				USER::VARCHAR		/* User */);
		END IF;
/*	ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20341, 'trigger_fct_t_rif40_results_checks',
		 	'T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR	/- Study id -/,
			NEW.inv_id::VARCHAR	/- Investigation -/,
			NEW.band_id::VARCHAR	/- Band ID -/,
			NEW.genders::VARCHAR 	/- genders -/,
			NEW.adjusted::VARCHAR	/- adjusted -/,
			NEW.direct_standardisation::VARCHAR	/- Direct standardisation -/,
			NEW.username::VARCHAR 	/- Record username -/,
			USER::VARCHAR		/- User -/);           */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20342, 'trigger_fct_t_rif40_results_checks',
		 	'T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % UPDATE not allowed on T_RIF40_RESULTS',
			NEW.study_id::VARCHAR	/* Study id */,
			NEW.inv_id::VARCHAR	/* Investigation */,
			NEW.band_id::VARCHAR	/* Band ID */,
			NEW.genders::VARCHAR 	/* genders */,
			NEW.adjusted::VARCHAR	/* adjusted */,
			NEW.direct_standardisation::VARCHAR	/* Direct standardisation */);
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20343, 'trigger_fct_t_rif40_results_checks',
		 	'T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % DELETE only allowed on own records in T_RIF40_RESULTS, record owned by: %',
			OLD.study_id::VARCHAR	/* Study id */,
			OLD.inv_id::VARCHAR	/* Investigation */,
			OLD.username::VARCHAR	/* INSERT username */,
			OLD.band_id::VARCHAR	/* Band ID */,
			OLD.genders::VARCHAR 	/* genders */,
			OLD.adjusted::VARCHAR	/* adjusted */,
			OLD.direct_standardisation::VARCHAR	/* Direct standardisation */);
	END IF;
--

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
--       	PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_results_checks',
--	       	 	'[20340-3] T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % CRUD checks OK',
--       		OLD.study_id::VARCHAR	/* Study id */,
--			OLD.inv_id::VARCHAR	/* Investigation */,
--			OLD.band_id::VARCHAR	/* Band ID */,
--			OLD.genders::VARCHAR 	/* genders */,
--			OLD.adjusted::VARCHAR	/* adjusted */,
--			OLD.direct_standardisation::VARCHAR	/* Direct standardisation */);
--
		RETURN OLD;
	END IF;
--	PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_results_checks',
--		  '[20340-3] T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % CRUD checks OK',
--		NEW.study_id::VARCHAR	/* Study id */,
--		NEW.inv_id::VARCHAR	/* Investigation */,
--		NEW.band_id::VARCHAR	/* Band ID */,
--		NEW.genders::VARCHAR 	/* genders */,
--		NEW.adjusted::VARCHAR	/* adjusted */,
--		NEW.direct_standardisation::VARCHAR	/* Direct standardisation */);

             
--
-- Check - relative_risk, smoothed_relative_risk, posterior_probability, posterior_probability_lower95, posterior_probability_upper95
--   	   smoothed_smr, smoothed_smr_lower95, smoothed_smr_upper95, residual_relative_risk, residual_rr_lower95, residual_rr_upper95
--	   are NULL for directly standardised results
--
	IF NEW.direct_standardisation = 1 AND c4_rec.total > 0 /* Not during build before first result is added to system */ AND (
		(NEW.relative_risk IS NOT NULL AND NEW.relative_risk::text <> '') OR
		(NEW.smoothed_relative_risk IS NOT NULL AND NEW.smoothed_relative_risk::text <> '') OR
		(NEW.posterior_probability IS NOT NULL AND NEW.posterior_probability::text <> '') OR
		(NEW.posterior_probability_lower95 IS NOT NULL AND NEW.posterior_probability_lower95::text <> '') OR
		(NEW.posterior_probability_upper95 IS NOT NULL AND NEW.posterior_probability_upper95::text <> '') OR
		(NEW.smoothed_smr IS NOT NULL AND NEW.smoothed_smr::text <> '') OR
		(NEW.smoothed_smr_lower95 IS NOT NULL AND NEW.smoothed_smr_lower95::text <> '') OR
		(NEW.smoothed_smr_upper95 IS NOT NULL AND NEW.smoothed_smr_upper95::text <> '') OR
		(NEW.residual_relative_risk IS NOT NULL AND NEW.residual_relative_risk::text <> '') OR
		(NEW.residual_rr_lower95 IS NOT NULL AND NEW.residual_rr_lower95::text <> '') OR
		(NEW.residual_rr_upper95 IS NOT NULL AND NEW.residual_rr_upper95::text <> '')) THEN
		PERFORM rif40_log_pkg.rif40_error(-20344, 'trigger_fct_t_rif40_results_checks',
			'T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % Expecting NULL relative_risk with direct standardised results',
			NEW.study_id::VARCHAR	/* Study id */,
			NEW.inv_id::VARCHAR	/* Inverstigation */,
			NEW.band_id::VARCHAR	/* Band ID */,
			NEW.genders::VARCHAR	/* genders */,
			NEW.adjusted::VARCHAR	/* adjusted */,
			NEW.direct_standardisation::VARCHAR	/* Direct standardisation */);
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END; 
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER t_rif40_results_checks
	BEFORE INSERT OR UPDATE OF username, study_id, inv_id, band_id, genders, adjusted, direct_standardisation,
				relative_risk, smoothed_relative_risk, posterior_probability, posterior_probability_lower95, posterior_probability_upper95,
				smoothed_smr, smoothed_smr_lower95, smoothed_smr_upper95, residual_relative_risk, residual_rr_lower95, residual_rr_upper95
	ON t_rif40_results
	FOR EACH ROW	
	WHEN ((NEW.username IS NOT NULL AND NEW.username::text <> '') OR (NEW.study_id IS NOT NULL AND NEW.study_id::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_results_checks();
CREATE TRIGGER t_rif40_results_checks_del
	BEFORE DELETE ON t_rif40_results
	FOR EACH ROW	
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_results_checks();
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_results_checks() IS 'Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
Check - relative_risk, smoothed_relative_risk, posterior_probability, posterior_probability_lower95, posterior_probability_upper95,
  	smoothed_smr, smoothed_smr_lower95, smoothed_smr_upper95, residual_relative_risk, residual_rr_lower95, residual_rr_upper95
	are NULL for directly standardised results   ';
COMMENT ON TRIGGER t_rif40_results_checks ON t_rif40_results IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_results_checks()';
COMMENT ON TRIGGER t_rif40_results_checks_del ON t_rif40_results IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_results_checks()';

DROP TRIGGER IF EXISTS t_rif40_contextualstats_checks ON t_rif40_contextual_stats CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_contextualstats_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_t_rif40_contextual_stats_checks_description>
<para>
Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
</para>
</trigger_t_rif40_contextual_stats_checks_description>
 */
--
-- -20360 to -20379 - T_RIF40_CONTEXTUAL_STATS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--

	c4_cstck CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;    
	c4_rec RECORD;
BEGIN
	OPEN c4_cstck;
	FETCH c4_cstck INTO c4_rec;
	CLOSE c4_cstck; 
--
-- T_RIF40_CONTEXTUAL_STATS: Check - USERNAME is Kerberos USER on INSERT
--			Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records
--
	IF NOT TG_OP = 'DELETE' AND NEW.username != USER THEN
		IF USER = 'rif40' AND c4_rec.total = 0 THEN /* Allowed duing build before first result is added to system */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20360, 'trigger_fct_t_rif40_contextualstats_checks',
			 	'T_RIF40_CONTEXTUAL_STATS study: % investigation: % area id: % username: % is not USER: %',
				NEW.study_id::VARCHAR	/* Study */,
				NEW.inv_id::VARCHAR	/* Investigation */,
				NEW.area_id::VARCHAR	/* Area */,
				NEW.username::VARCHAR	/* New user */,
				USER::VARCHAR		/* Database user */);
		END IF;
 /*       ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20361, 'trigger_fct_t_rif40_contextualstats_checks',
		 	'T_RIF40_CONTEXTUAL_STATS study: % investigation: % area id: % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR	-* Study *-,
			NEW.inv_id::VARCHAR	-* Investigation *-,
			NEW.area_id::VARCHAR	-* Area *-,
			NEW.username::VARCHAR	-* New user *-,
			USER::VARCHAR		-* Database user *-);    */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20362, 'trigger_fct_t_rif40_contextualstats_checks',
		 	'T_RIF40_CONTEXTUAL_STATS study: % investigation: % area id: UPDATE not allowed on T_RIF40_CONTEXTUAL_STATS',
			NEW.study_id::VARCHAR	/* Study */,
			NEW.inv_id::VARCHAR	/* Investigation */,
			NEW.area_id::VARCHAR	/* Area */);
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20363, 'trigger_fct_t_rif40_contextualstats_checks',
			'T_RIF40_CONTEXTUAL_STATS study: % investigation: % area id: DELETE only allowed on own records in T_RIF40_CONTEXTUAL_STATS, record owned by: %',
			OLD.study_id::VARCHAR	/* Study */,
			OLD.inv_id::VARCHAR	/* Investigation */,
			OLD.area_id::VARCHAR	/* Area */,
			OLD.username::VARCHAR	/* INSERT username */);
	END IF;
--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_contextualstats_checks',
	       	 	'[20360-3] T_RIF40_CONTEXTUAL_STATS study: % investigation: % Band ID: % area ID: % CRUD checks OK',
			OLD.study_id::VARCHAR	/* Study id */,
			OLD.inv_id::VARCHAR	/* Investigation */,
			OLD.band_id::VARCHAR	/* Band ID */,
			OLD.area_id::VARCHAR	/* Area ID */);   
		RETURN OLD;
	ELSE  	
--	PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_contextualstats_checks',
--		  '[20340-3] T_RIF40_CONTEXTUAL_STATS study: % investigation: % Band ID: % area ID: % CRUD checks OK',
--		NEW.study_id::VARCHAR	/* Study id */,
--		NEW.inv_id::VARCHAR	/* Investigation */,
--		NEW.band_id::VARCHAR	/* Band ID */,
-- 		NEW.area_id::VARCHAR	/* Area ID */);   

		RETURN NEW;
	END IF;
END; 
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER t_rif40_contextualstats_checks
	BEFORE INSERT OR UPDATE OF area_id, username, study_id, inv_id,
		area_population, area_observed, total_comparision_population, variance_high, variance_low
	ON t_rif40_contextual_stats
	FOR EACH ROW
	WHEN ((NEW.username IS NOT NULL AND NEW.username::text <> '') OR (NEW.study_id IS NOT NULL AND NEW.study_id::text <> '') OR (NEW.inv_id IS NOT NULL AND NEW.inv_id::text <> '') OR (NEW.area_id IS NOT NULL AND NEW.area_id::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_contextualstats_checks();

CREATE TRIGGER t_rif40_contextualstats_checks_del
	BEFORE DELETE ON t_rif40_contextual_stats
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_contextualstats_checks();

COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_contextualstats_checks() IS 'Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.';
COMMENT ON TRIGGER t_rif40_contextualstats_checks ON t_rif40_contextual_stats IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_contextualstats_checks()';
COMMENT ON TRIGGER t_rif40_contextualstats_checks_del ON t_rif40_contextual_stats IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_contextualstats_checks()';


DROP TRIGGER IF EXISTS trigger_fct_t_rif40_study_sql_log_checks ON t_rif40_study_sql_log CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_study_sql_log_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_fct_t_rif40_study_sql_log_checks_description>
<para>
Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
</para>
</trigger_fct_t_rif40_study_sql_log_checks_description>

-- -20560 to -20579 - T_RIF40_STUDY_SQL_LOG  
*/
	c4_sqllogck CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;    
	c4_rec RECORD;
BEGIN
	OPEN c4_sqllogck;
	FETCH c4_sqllogck INTO c4_rec;
	CLOSE c4_sqllogck; 
--
-- T_RIF40_STUDY_SQL_LOG: Check - USERNAME is Kerberos USER on INSERT
--			Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records
--
	IF NOT TG_OP = 'DELETE' AND NEW.username != USER THEN
		IF USER = 'rif40' /* AND c4_rec.total = 0 */ THEN /* [ALWAYS] Allowed during build before first result is added to system */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20560, 'trigger_fct_t_rif40_study_sql_log_checks',
			 	'T_RIF40_STUDY_SQL_LOG study: % statement number: % username: % is not USER: %',
				NEW.study_id::VARCHAR	/* Study */,
				NEW.statement_number::VARCHAR	/* Statement number */,
				NEW.username::VARCHAR	/* New user */,
				USER::VARCHAR		/* Database user */);
		END IF;
 /*       ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20561, 'trigger_fct_t_rif40_study_sql_log_checks',
		 	'T_RIF40_STUDY_SQL_LOG study: % statement number: % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR	-* Study *-,
			NEW.statement_number::VARCHAR	-* statement_number *-,
			NEW.username::VARCHAR	-* New user *-,
			USER::VARCHAR		-* Database user *-);    */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20562, 'trigger_fct_t_rif40_study_sql_log_checks',
		 	'T_RIF40_STUDY_SQL_LOG study: % statement number: % UPDATE not allowed on T_RIF40_STUDY_SQL_LOG',
			NEW.study_id::VARCHAR	/* Study */,
		       	NEW.statement_number::VARCHAR	/* Statement number */);
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20563, 'trigger_fct_t_rif40_study_sql_log_checks',
			'T_RIF40_STUDY_SQL_LOG study: % statement number: % DELETE only allowed on own records in T_RIF40_STUDY_SQL_LOG, record owned by: %',
			OLD.study_id::VARCHAR	/* Study */,
		       	OLD.statement_number::VARCHAR	/* Statement number */,
			OLD.username::VARCHAR	/* INSERT username */);
	END IF;
--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_study_sql_log_checks',
	       	 	'[20360-3] T_RIF40_STUDY_SQL_LOG study: % statement number: % CRUD checks OK',
			OLD.study_id::VARCHAR	/* Study id */,
		       	OLD.statement_number::VARCHAR	/* Statement number */);
		RETURN OLD;
	ELSE  	
--	      	PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_study_sql_log_checks',
--			'[20340-3] T_RIF40_STUDY_SQL_LOG study: % statement number: % CRUD checks OK',
--			NEW.study_id::VARCHAR	/* Study id */,
--			NEW.statement_number::VARCHAR	/* Statement number */);    

		RETURN NEW;
	END IF;
END; 
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER t_rif40_study_sql_log_checks
	BEFORE INSERT OR UPDATE OF username, study_id, statement_type, statement_number, log_message, log_sqlcode, rowcount, start_time, elapsed_time, audsid
	ON t_rif40_study_sql_log
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_study_sql_log_checks();

CREATE TRIGGER t_rif40_study_sql_log_checks_del
	BEFORE DELETE ON t_rif40_study_sql_log
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_study_sql_log_checks();

COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_study_sql_log_checks() IS 'Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.';
COMMENT ON TRIGGER t_rif40_study_sql_log_checks ON t_rif40_study_sql_log IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_study_sql_log_checks()';
COMMENT ON TRIGGER t_rif40_study_sql_log_checks_del ON t_rif40_study_sql_log IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_study_sql_log_checks()';

DROP TRIGGER IF EXISTS trigger_fct_t_rif40_study_sql_checks ON t_rif40_study_sql CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_study_sql_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_fct_t_rif40_study_sql_checks_description>
<para>
Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
</para>
</trigger_fct_t_rif40_study_sql_checks_description>

-- -20540 to -20549 - T_RIF40_STUDY_SQL_LOG  
 */
	c4_sqllogck CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;    
	c4_rec RECORD;
BEGIN
	OPEN c4_sqllogck;
	FETCH c4_sqllogck INTO c4_rec;
	CLOSE c4_sqllogck; 
--
-- T_RIF40_STUDY_SQL: Check - USERNAME is Kerberos USER on INSERT
--			Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records
--
	IF NOT TG_OP = 'DELETE' AND NEW.username != USER THEN
		IF USER = 'rif40' /* AND c4_rec.total = 0 */ THEN /* [ALWAYS] Allowed during build before first result is added to system */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20540, 'trigger_fct_t_rif40_study_sql_checks',
			 	'T_RIF40_STUDY_SQL study: % statement number: % line: % username: % is not USER: %',
				NEW.study_id::VARCHAR		/* Study */,
				NEW.statement_number::VARCHAR	/* Statement number */,
		       		NEW.line_number::VARCHAR	/* Line number */,
				NEW.username::VARCHAR		/* New user */,
				USER::VARCHAR			/* Database user */);
		END IF;
 /*       ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20541, 'trigger_fct_t_rif40_study_sql_checks',
		 	'T_RIF40_STUDY_SQL study: % statement number: % line: % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR	-* Study *-,
			NEW.statement_number::VARCHAR	-* statement_number *,   
		       	NEW.line_number::VARCHAR	-* Line number *-,
			NEW.username::VARCHAR		-* New user *-,
			USER::VARCHAR			-* Database user *-);    */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20542, 'trigger_fct_t_rif40_study_sql_checks',
		 	'T_RIF40_STUDY_SQL study: % statement number: % line: % UPDATE not allowed on T_RIF40_STUDY_SQL',
			NEW.study_id::VARCHAR		/* Study */,
		       	NEW.statement_number::VARCHAR	/* Statement number */,   
		       	NEW.line_number::VARCHAR	/* Line number */);
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20543, 'trigger_fct_t_rif40_study_sql_checks',
			'T_RIF40_STUDY_SQL study: % statement number: % line: % DELETE only allowed on own records in T_RIF40_STUDY_SQL, record owned by: %',
			OLD.study_id::VARCHAR		/* Study */,
		       	OLD.statement_number::VARCHAR	/* Statement number */,   
		       	OLD.line_number::VARCHAR	/* Line number */,
			OLD.username::VARCHAR		/* INSERT username */);
	END IF;
--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_study_sql_checks',
	       	 	'[20360-3] T_RIF40_STUDY_SQL study: % statement number: % line: % CRUD checks OK',
			OLD.study_id::VARCHAR		/* Study id */,
		       	OLD.statement_number::VARCHAR	/* Statement number */,   
		       	OLD.line_number::VARCHAR	/* Line number */);
		RETURN OLD;
	ELSE  	
--		PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_study_sql_checks',
--			'[20340-3] T_RIF40_STUDY_SQL study: % statement number: % line: % CRUD checks OK',
-- 	     		NEW.study_id::VARCHAR		/* Study id */,
-- 		     	NEW.statement_number::VARCHAR	/* Statement number */,    
--		       	NEW.line_number::VARCHAR	/* Line number */);

		RETURN NEW;
	END IF;      
END; 
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER t_rif40_study_sql_checks
	BEFORE INSERT OR UPDATE OF username, study_id, statement_type, statement_number, sql_text, line_number
	ON t_rif40_study_sql
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_study_sql_checks();

CREATE TRIGGER t_rif40_study_sql_checks_del
	BEFORE DELETE ON t_rif40_study_sql
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_study_sql_checks();

COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_study_sql_checks() IS 'Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.';
COMMENT ON TRIGGER t_rif40_study_sql_checks ON t_rif40_study_sql IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_study_sql_checks()';
COMMENT ON TRIGGER t_rif40_study_sql_checks_del ON t_rif40_study_sql IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_study_sql_checks()';

\echo All table IUD checks built...
--
-- Eof
