<?xml version="1.0" encoding="UTF-8"?>
<!--
CAUTION: Do not modify this file unless you know what you are doing.
         Unexpected results may occur if the code is changed deliberately.
-->
<dbmodel pgmodeler-ver="0.7.0">
<role name="rif40"
      inherit="true"
      login="true"
      encrypted="true"
      password="********">
</role>

<role name="pch"
      createrole="true"
      inherit="true"
      login="true"
      encrypted="true"
      password="********">
</role>

<tablespace name="sahsuland" directory="'C:\PostgresDB\sahsuland'">
	<role name="pch"/>
</tablespace>

<database name="sahsuland" encoding="UTF8" lc-collate="English_United Kingdom" lc-ctype="English_United Kingdom">
	<role name="rif40"/>
	<tablespace name="sahsuland"/>
	<comment><![CDATA[RIF V4.0 PostGres SAHSULAND Example Database]]></comment>
</database>

<schema name="public" protected="true" rect-visible="true" fill-color="#e1e1e1" sql-disabled="true">
</schema>

<schema name="rif40" rect-visible="true" fill-color="#d66b29">
	<role name="rif40"/>
</schema>

<schema name="rif40_dmp_pkg" rect-visible="true" fill-color="#a92ceb">
	<role name="rif40"/>
	<comment><![CDATA[RIF dump extract package.]]></comment>
</schema>

<schema name="rif40_geo_pkg" rect-visible="true" fill-color="#bb2103">
	<role name="rif40"/>
	<comment><![CDATA[RIF geometry/geography tools except the simplication package (rif40_sim_pkg).]]></comment>
</schema>

<schema name="rif40_log_pkg" rect-visible="true" fill-color="#5f5fef">
	<role name="rif40"/>
	<comment><![CDATA[RIF Logging.]]></comment>
</schema>

<schema name="rif40_sim_pkg" rect-visible="true" fill-color="#10fc4c">
	<role name="rif40"/>
	<comment><![CDATA[RIF geometry/geography simplication package.]]></comment>
</schema>

<schema name="rif40_sm_pkg" rect-visible="true" fill-color="#d4beec">
	<role name="rif40"/>
	<comment><![CDATA[RIF Statemachine.]]></comment>
</schema>

<schema name="rif40_sql_pkg" rect-visible="true" fill-color="#0651ed">
	<role name="rif40"/>
	<comment><![CDATA[RIF SQL tools.]]></comment>
</schema>

<schema name="rif40_trg_pkg" rect-visible="true" fill-color="#994d45">
	<role name="rif40"/>
	<comment><![CDATA[RIF Trigers .]]></comment>
</schema>

<schema name="rif40_xml_pkg" rect-visible="true" fill-color="#518e25">
	<role name="rif40"/>
	<comment><![CDATA[RIF XML support.]]></comment>
</schema>

<schema name="rif_studies" rect-visible="true" fill-color="#055365">
	<role name="rif40"/>
	<comment><![CDATA[Schema for extracts and map tables.]]></comment>
</schema>

<extension name="dblink" cur-version="1.1">
	<schema name="rif40"/>
	<comment><![CDATA[connect to other PostgreSQL databases from within a database]]></comment>
</extension>

<usertype name="delimiter_type" configuration="enumeration">
	<schema name="rif40_dmp_pkg"/>
	<role name="rif40"/>
	<enumeration values="COMMA,PIPE"/>
</usertype>

<usertype name="line_terminator" configuration="enumeration">
	<schema name="rif40_dmp_pkg"/>
	<role name="rif40"/>
	<enumeration values="DOS,UNIX,MACOS"/>
</usertype>

<usertype name="rif40_log_debug_level" configuration="enumeration">
	<schema name="rif40_log_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Error/debug/info level enumerated datatype]]></comment>
	<enumeration values="WARNING,INFO,DEBUG1,DEBUG2,DEBUG3,DEBUG4"/>
</usertype>

<usertype name="rif40_debug_record" configuration="composite">
	<schema name="rif40_log_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function name, RIF40_LOG_DEBUG_LEVEL struct]]></comment>
	<typeattrib name="function_name">
		<type name="character varying"/>
	</typeattrib>
	<typeattrib name="debug">
		<type name="rif40_log_pkg.rif40_log_debug_level"/>
	</typeattrib>
</usertype>

<function name="t_rif40_sahsu_geometry_insert"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Partition INSERT function for geography: SAHSU]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN

	IF NEW.geography = 'SAHSU' AND NEW.geolevel_name = 'LEVEL1' THEN
INSERT INTO t_rif40_geolevels_geometry_sahsu_level1 VALUES (NEW.*);
	ELSIF NEW.geography = 'SAHSU' AND NEW.geolevel_name = 'LEVEL2' THEN
INSERT INTO t_rif40_geolevels_geometry_sahsu_level2 VALUES (NEW.*);
	ELSIF NEW.geography = 'SAHSU' AND NEW.geolevel_name = 'LEVEL3' THEN
INSERT INTO t_rif40_geolevels_geometry_sahsu_level3 VALUES (NEW.*);
	ELSIF NEW.geography = 'SAHSU' AND NEW.geolevel_name = 'LEVEL4' THEN
INSERT INTO t_rif40_geolevels_geometry_sahsu_level4 VALUES (NEW.*);
	ELSE
--
-- Eventually this will automatically add a partition
--
		PERFORM rif40_log_pkg.rif40_error(-10002, 't_rif40_geolevels_geometry_insert', 'no partition for geography: %, geolevel: %',
			NEW.geography, NEW.geolevel_name);
	END IF;
	RETURN NULL;
END;
]]></definition>
</function>

<function name="csv_dump"
		window-func="false"
		returns-setof="true"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="1000">
	<schema name="rif40_dmp_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	csv_dump()
Function: 	csv_dump()
Parameters:	Table or view name, delimiter (COMMA [default] or PIPE), line terminator (DOS [default], UNIX or MAC), with header (TRUE[default]/FALSE),
                check rows and columns (TRUE/FALSE[defualt]), batch rows at (default 100 rows)
Returns:	Setof CSV rows. No line terminator on end of row (assumes output program puts on the correct type)
Description:	Dump table to CSV

Escaping is automatic as part of the array conversion mechanisms (geometry does need to be tested)
Datatype casting is as for the array interface.
Line terminators - COPY and \copy will escape them; fix with sed. As this function is designed for use with Java this is not an issue, e.g.

\copy (SELECT rif40_dmp_pkg.csv_dump('t_rif40_sahsu_geometry')) TO ../postgres/tmp/p_t_rif40_sahsu_geometry.csv WITH (FORMAT text) 
\! sed -ibak -e 's/\\r\\n/\r\n/g' ../postgres/tmp/p_t_rif40_sahsu_geometry.csv

or (for Unixen):

\! sed -ibak -e 's/\\n/\n/g' ../postgres/tmp/p_t_rif40_sahsu_geometry.csv

 a) Method 4 - Using RIF_ROW [probably FASTEST]

    Create <batch_rows_at> subcursors using MOD; union together results. No need for FOR loop

 b) Using a pg/psql FOR LOOP [probably 4xSLOWER]
 
    FETCH as an array, processiong <batch_rows_at> per output line:

SELECT TRANSLATE(array_to_string(string_to_array(x.*::Text, ','), ',', ' '), '()', '')::Text AS y 
  FROM rif40_tables AS x;

 Calling csv_escape() overhead was 25% (now deleted as it was not needed)

 Table: sahsuland_pop: statement took: 00:00:11.263311, proccessed 432960 rows in 4287 block(s) of 100 rows; 38439.85 rows/second; first block: 5933 bytes

Conventiently postgres arrays use CSV format, so string_to_array(x.*::Text, ',') does all the CSV escaping for you (including line terminators)

Todo: check rows and columns
      Automatic block resize if default to optimal 10K]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="character varying"/>
	</return-type>
	<parameter name="table_or_view_name" in="true" default-value="'COMMA'::rif40_dmp_pkg.delimiter_type">
		<type name="character varying"/>
	</parameter>
	<parameter name="delimiter" in="true" default-value="'DOS'::rif40_dmp_pkg.line_terminator">
		<type name="rif40_dmp_pkg.delimiter_type"/>
	</parameter>
	<parameter name="line_terminator" in="true" default-value="true">
		<type name="rif40_dmp_pkg.line_terminator"/>
	</parameter>
	<parameter name="with_header" in="true" default-value="false">
		<type name="boolean"/>
	</parameter>
	<parameter name="check_rows_and_columns" in="true" default-value="100">
		<type name="boolean"/>
	</parameter>
	<parameter name="batch_rows_at" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
/*
Function: 	csv_dump()
Parameters:	Table or view name, delimiter (COMMA [default] or PIPE), line terminator (DOS [default], UNIX or MAC), with header (TRUE[default]/FALSE),
                check rows and columns (TRUE/FALSE[defualt]), batch rows at (default 100 rows)
Returns:	Setof CSV rows. No line terminator on end of row (assumes output program puts on the correct type)
Description:	Dump table to CSV

Escaping is automatic as part of the array conversion mechanisms (geometry does need to be tested)
Datatype casting is as for the array interface.
Line terminators - COPY and \copy will escape them; fix with sed. As this function is designed for use with Java this is not an issue, e.g.

\copy (SELECT rif40_dmp_pkg.csv_dump('t_rif40_sahsu_geometry')) TO ../postgres/tmp/p_t_rif40_sahsu_geometry.csv WITH (FORMAT text) 
\! sed -ibak -e 's/\\r\\n/\r\n/g' ../postgres/tmp/p_t_rif40_sahsu_geometry.csv

or (for Unixen):

\! sed -ibak -e 's/\\n/\n/g' ../postgres/tmp/p_t_rif40_sahsu_geometry.csv

 a) Method 4 - Using RIF_ROW [probably FASTEST]

    Create <batch_rows_at> subcursors using MOD; union together results. No need for FOR loop

 b) Using a pg/psql FOR LOOP [probably 4xSLOWER]
 
    FETCH as an array, processiong <batch_rows_at> per output line:

SELECT TRANSLATE(array_to_string(string_to_array(x.*::Text, ','), ',', ' '), '()', '')::Text AS y 
  FROM rif40_tables AS x;

 Calling csv_escape() overhead was 25% (now deleted as it was not needed)

 Table: sahsuland_pop: statement took: 00:00:11.263311, proccessed 432960 rows in 4287 block(s) of 100 rows; 38439.85 rows/second; first block: 5933 bytes

 Conventiently postgres arrays use CSV format, so string_to_array(x.*::Text, ',') does all the CSV escaping for you (including line terminators)

Todo: check rows and columns
      Automatic block resize if default to optimal 10K

 */
DECLARE
	c1dcsv CURSOR(l_table_or_view_name VARCHAR) FOR			
		SELECT column_name
		  FROM information_schema.columns a, pg_tables b 
		 WHERE b.schemaname = a.table_schema
		   AND a.table_name = b.tablename
		   AND b.tablename  = l_table_or_view_name;
	c2dcsv REFCURSOR;
	c1dcsv_rec RECORD;
	c2dcsv_result_row	VARCHAR;
--
	sql_stmt	VARCHAR;
--
	stp 		TIMESTAMP WITH TIME ZONE;
	etp 		TIMESTAMP WITH TIME ZONE;
	took 		INTERVAL;
	rate 		NUMERIC;
	l_rows 		INTEGER:=0;
	l_columns 	INTEGER:=0;
	i 		INTEGER:=0;
	blocks 		INTEGER:=1;
	first_block_size INTEGER:=0;
--
	schema		VARCHAR;
	header_row	VARCHAR;
	line_term_text	VARCHAR;
	delimiter_text 	VARCHAR;
	has_rif_row	BOOLEAN:=FALSE;
--
	select_text 	VARCHAR;
--
	error_message 	VARCHAR;
	v_detail 	VARCHAR:='(Not supported until 9.2; type SQL statement into psql to see remote error)';
BEGIN
--
-- Must be rifupg34, rif40 or have rif_user or rif_manager role
--
	IF USER != 'rifupg34' AND NOT rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-20999, 'csv_dump', 'User % must be rif40 or have rif_user or rif_manager role', 
			USER::VARCHAR);
	END IF;
--
	IF table_or_view_name IS NULL THEN
		RETURN;
	END IF;
	stp:=clock_timestamp();
--
-- Find schema for object
--
	schema:=rif40_sql_pkg.rif40_object_resolve(table_or_view_name);
	IF schema IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-20999, 'csv_dump', 'User % cannot access table/view/amterialized view % or % does not exist', 
			USER::VARCHAR,
			table_or_view_name::VARCHAR,
			table_or_view_name::VARCHAR);
	END IF;

--
-- Line terminators. Note COPY and \copy will escape them; fix with sed. As this function is designed for use with Java this is not an issue
--
	IF line_terminator = 'DOS' THEN
		line_term_text:=E'\r'||E'\n';
	ELSIF line_terminator = 'UNIX' THEN
		line_term_text:=E'\n';
	ELSIF line_terminator = 'MACOS' THEN
		line_term_text:=E'\r';
	END IF;

--
-- Process table header
--
	FOR c1dcsv_rec IN c1dcsv(table_or_view_name) LOOP
		l_columns:=l_columns+1;
		IF c1dcsv_rec.column_name = 'rif_row' THEN
			has_rif_row:=TRUE;
		END IF;
		IF with_header THEN
			IF l_columns = 1 THEN
				header_row:=UPPER(c1dcsv_rec.column_name);
			ELSE
				header_row:=header_row||','||UPPER(c1dcsv_rec.column_name);
			END IF;
		END IF;
	END LOOP;
	IF with_header THEN
		RETURN NEXT header_row;
	END IF;
--
-- Delimiters
--
	IF delimiter = 'COMMA' THEN
		delimiter_text:=',';
	ELSIF delimiter = 'PIPE' THEN
		delimiter_text:='|';
	END IF;

--
-- a) Method 4 - Using RIF_ROW [probably FASTEST]
--
-- Create <batch_rows_at> subcursors using MOD; union together results. No need for FOR loop
--
-- b) Using a pg/psql FOR LOOP [probably 4xSLOWER]
-- 
-- FETCH as an array, processiong <batch_rows_at> per output line:
--
-- SELECT TRANSLATE(array_to_string(string_to_array(x.*::Text, ','), ',', ' '), '()', '')::Text AS y 
--  FROM rif40_tables AS x;
--
-- Calling csv_escape() overhead was 25% (now deleted as it was not needed)
--
-- Table: sahsuland_pop: statement took: 00:00:11.263311, proccessed 432960 rows in 4287 block(s) of 100 rows; 38439.85 rows/second; first block: 5933 bytes
--
-- Conventiently postgres arrays use CSV format, so string_to_array(x.*::Text, ',') does all the CSV escaping for you (including line terminators)
--
	sql_stmt:='SELECT TRANSLATE(array_to_string(string_to_array(x.*::Text /* CSV escape */, '','' /* separate array elements with , */), '||
		''''||delimiter_text||''' /* delimiter charater */, '' '' /* Nulls to space */), ''()'', '''' /* Remove array () */)||'''||
		line_term_text||'''::Text /* Add line terminator */ AS y FROM '||
		table_or_view_name||' AS x';
	PERFORM rif40_log_pkg.rif40_log('DEBUG2', 'csv_dump', 'SQL> %;', 
		sql_stmt::VARCHAR);
	OPEN c2dcsv FOR EXECUTE sql_stmt;
	LOOP
		FETCH c2dcsv INTO c2dcsv_result_row;
		IF NOT FOUND THEN EXIT; END IF;
--  
		l_rows:=l_rows+1;
		i:=i+1;
--
-- Process row array
--
		IF i = 1 THEN
			select_text:=c2dcsv_result_row;
		ELSE
			select_text:=select_text||c2dcsv_result_row;
		END IF;
--
		IF i > batch_rows_at THEN
			i:=0;
			IF blocks = 1 THEN
				first_block_size=length(select_text);
			END IF;
			blocks:=blocks+1;
			RETURN NEXT trim(trailing line_term_text from select_text); /* Remove last CRLF */
			select_text:=NULL;
		END IF;
	END LOOP;
	CLOSE c2dcsv;
	IF blocks = 1 THEN
		first_block_size=length(select_text);		/* This may be used to tune <batch_rows_at> in future if set to default value */
	END IF;
--
	RETURN NEXT trim(trailing line_term_text from select_text); /* Remove last CRLF */
--
-- Diagnostics
--
	etp:=clock_timestamp();
	took:=age(etp, stp);
	rate:=ROUND((l_rows/(EXTRACT(EPOCH FROM took) /* convert to seconds */)::NUMERIC), 2);
	IF l_rows IS NULL THEN
		PERFORM rif40_log_pkg.rif40_log('INFO', 'csv_dump', 'Table: %: statement took: %, proccessed no rows', 
			table_or_view_name::VARCHAR,
			took::VARCHAR);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('INFO', 'csv_dump', 
			'Table: %: statement took: %, proccessed % rows in % block(s) of % rows; % rows/second; first block: % bytes', 
			table_or_view_name::VARCHAR,
			took::VARCHAR, 
			l_rows::VARCHAR, 
			blocks::VARCHAR,
			batch_rows_at::VARCHAR,
			rate::VARCHAR,
			first_block_size::VARCHAR);
	END IF;
--
	RETURN;
EXCEPTION
	WHEN others THEN
-- 
-- Not supported until 9.2
--
--		GET STACKED DIAGNOTICS v_detail = PG_EXCEPTION_DETAIL;
		error_message:='csv_dump() caught: '||E'\n'||SQLERRM::VARCHAR||' in SQL (see previous trapped error)'||E'\n'||'Detail: '||v_detail::VARCHAR;
		RAISE INFO '1: %', error_message;
--
		RAISE;
END;
]]></definition>
</function>

<function name="_simplify_geometry_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	_simplify_geometry_checks()
Parameters:	Geography, geolevel, Check number
Returns:	Nothing
Description:	Simplify geography geolevel check functions

Test 0: Geometry is valid
Test 1: Check last_pointflow = one per area (should be zero)
Test 1.1: Check there are 1 or more distinct areas in simplification_points_a (i.e. filter is not broken)
Test 2: for un-detected duplicates
Test 2.1: for invalid duplicates
Test 2.2: Check array dimensions are [1:3] as expected
Test 3: for areas with no join sequence
Test 4: for areas with mis-joined sequences
Test 5: join sequence(s) used by more than one polygon_number
Test 6: polygon_number, coord_id, duplicate(s) used by more than one join sequence
Test 7: areas(s) with non unique join sequences
Test 8: areas(s) with invalid geometry in simplification_polygons
Test 9: join sequence(s) causing invalid joins and reversals]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="l_geography" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_geolevel" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="check_number" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
/*
Function: 	_simplify_geometry_checks()
Parameters:	Geography, geolevel,  check number
Returns:	Nothing
Description:	Simplify geography geolevel - checks

Test 0: Geometry is valid
Test 1: Check last_pointflow = one per area (should be zero)
Test 1.1: Check there are 1 or more distinct areas in simplification_points_a (i.e. filter is not broken)
Test 2: for un-detected duplicates
Test 2.1: for invalid duplicates
Test 2.2: Check array dimensions are [1:3] as expected
Test 3: for areas with no join sequence
Test 4: for areas with mis-joined sequences
Test 5: join sequence(s) used by more than one polygon_number
Test 6: polygon_number, coord_id, duplicate(s) used by more than one join sequence
Test 7: areas(s) with non unique join sequences
Test 8: areas(s) with invalid geometry in simplification_polygons
Test 9: join sequence(s) causing invalid joins and reversals

 */
	c0_sgck REFCURSOR;
	c11_sgck CURSOR FOR
		SELECT COUNT(DISTINCT(area_id)) AS t_areas
		  FROM simplification_points_a;
	c1_sgck CURSOR FOR
		SELECT COUNT(area_id) AS t_areas
		  FROM (
			SELECT area_id, polygon_number, COUNT(DISTINCT(last_pointflow)) t_last_pointflow	
			  FROM simplification_points_a
			 GROUP BY area_id, polygon_number
			 HAVING COUNT(DISTINCT(last_pointflow)) != 1) a;
	c2_sgck CURSOR FOR	
		SELECT SUM(distinct_polys) AS distinct_polys
		  FROM (
			SELECT coord_id, COUNT(DISTINCT(num_polygon_number)) AS distinct_polys
			  FROM simplification_points_d
			 WHERE num_polygon_number = 2
			   AND duplicate IN ('N', 'L') 
			 GROUP BY coord_id
			HAVING COUNT(DISTINCT(polygon_number)) > 2) a;
	c21_sgck CURSOR FOR	
		SELECT COUNT(polygon_number) AS t_areas
		  FROM simplification_points_c
		 WHERE duplicate = '?';
	c22_sgck CURSOR FOR	
		SELECT array_dims(path) AS array_dims, COUNT(DISTINCT(area_id)) AS total
	         FROM simplification_points_a
	        GROUP BY array_dims(path);
	c3_sgck CURSOR FOR	
		SELECT COUNT(join_seq) AS t_join_seq
		  FROM simplification_points
		 WHERE join_seq IS NULL;
	c4_sgck CURSOR FOR	
		SELECT COUNT(polygon_number) t_polygon_number
		  FROM ( 
			SELECT polygon_number, MIN(joined_polygon_number) AS joined_polygon_number, MAX(joined_polygon_number) AS joined_polygon_number2,
			       join_seq, MIN(pointflow) AS min, MAX(pointflow) AS max, COUNT(pointflow) AS total
			  FROM simplification_points
			 GROUP BY polygon_number, join_seq
			 HAVING MIN(joined_polygon_number) != MAX(joined_polygon_number)) a;
	c5_sgck CURSOR FOR	
		SELECT COUNT(join_seq) t_join_seq
		  FROM ( 
			SELECT join_seq, COUNT(DISTINCT(joined_polygon_number)) AS t_joined_polygon_number
			  FROM simplification_points_f
			 GROUP BY join_seq
		 HAVING COUNT(DISTINCT(joined_polygon_number)) > 1) a;
	c6_sgck CURSOR FOR	
		SELECT COUNT(joined_polygon_number) t_joined_polygon_number
		  FROM ( 
			SELECT joined_polygon_number, coord_id, duplicate, COUNT(DISTINCT(join_seq)) AS t_join_seq
			  FROM simplification_points_f
			 GROUP BY joined_polygon_number, coord_id, duplicate
			 HAVING COUNT(DISTINCT(join_seq)) > 1) a;
	c7_sgck CURSOR FOR	
		SELECT COUNT(join_seq) t_join_seq
		  FROM (
			SELECT join_seq, COUNT(DISTINCT(polygon_number)) AS distinct_area
			  FROM simplification_points
			 GROUP BY join_seq
			 HAVING COUNT(DISTINCT(polygon_number)) > 1) a;
	c8_sgck CURSOR FOR	
		SELECT COUNT(area_id) t_area_id
		  FROM simplification_polygons
		 WHERE ST_ISValid(geometry) = FALSE OR ST_ISValid(topo_optimised_geometry) = FALSE;
	c9_sgck CURSOR FOR	
		SELECT COUNT(join_seq) AS t_join_seq, MAX(line_test) AS max_line_test, MAX(simplified_line_test) AS max_simplified_line_test
		  FROM simplification_lines_temp
		 WHERE duplicate_join_to_be_removed = 'N/N'
		   AND reverse_line = 'N'
		   AND reverse_simplified_line = 'N';
	c90_sgck REFCURSOR;
	c0_rec RECORD;
	c1_rec RECORD;
	c11_rec RECORD;
	c2_rec RECORD;
	c21_rec RECORD;
	c22_rec RECORD;
	c3_rec RECORD;
	c4_rec RECORD;
	c5_rec RECORD;
	c6_rec RECORD;
	c7_rec RECORD;
	c8_rec RECORD;
	c9_rec RECORD;
	c90_rec RECORD;
--
	sql_stmt	VARCHAR;
--
	line_test_limit NUMERIC:=0.002; /* This is the maximum difference tolerated between joined lines when all the points are the same (i.e. the is a slight misorder) */
BEGIN
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, '_simplify_geometry_checks', 'User % must be rif40 or have rif_manager role', 
			USER::VARCHAR	/* Username */);
	END IF;
--
-- Test 0: Geometry is valid
--
	IF check_number = 0 THEN
		sql_stmt:='SELECT COUNT(DISTINCT(CASE WHEN ST_Isvalid(shapefile_geometry) = FALSE THEN area_id ELSE NULL END)) AS invalid_area_id_geometry'||E'\n'||
'          FROM '||quote_ident('t_rif40_geolevels_geometry_'||LOWER(l_geography)||'_'||LOWER(l_geolevel))||E'\n'||
'         WHERE geolevel_name = '''||UPPER(l_geolevel)||'''';
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', '_simplify_geometry_checks', 'SQL> %;', sql_stmt::VARCHAR);
		OPEN c0_sgck FOR EXECUTE sql_stmt;
		FETCH c0_sgck INTO c0_rec;	
		CLOSE c0_sgck;
		IF c0_rec.invalid_area_id_geometry > 0 THEN
			PERFORM rif40_log_pkg.rif40_error(-10070, '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: Found % areas/polygons(s) with invalid geometry',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */, 
				c0_rec.invalid_area_id_geometry::VARCHAR);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: No areas/polygons(s) with invalid geometry',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */);
		END IF;
--
	ELSIF check_number = 1 THEN
--
-- Test 1: Check last_pointflow = one per area (should be zero)
--
		OPEN c1_sgck;
		FETCH c1_sgck INTO c1_rec;	
		CLOSE c1_sgck;
--
		IF c1_rec.t_areas > 0 THEN
			PERFORM rif40_sql_pkg.rif40_method4('SELECT polygon_number, COUNT(DISTINCT(last_pointflow)) t_last_pointflow'||E'\n'||
'  FROM simplification_points_a'||E'\n'||
' GROUP BY polygon_number, polygon_number'||E'\n'||
' HAVING COUNT(DISTINCT(last_pointflow)) != 1 LIMIT 20', 'Test 1: Check last_pointflow = one per area (should be zero)');
			PERFORM rif40_log_pkg.rif40_error(-10071, '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: Found % polygons(s) with >1 last_pointflow values',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */, 
				c1_rec.t_areas::VARCHAR);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: No polygons(s) have >1 last_pointflow values',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */);
		END IF;
	ELSIF check_number = 11 THEN
--
-- Test 1.1: Check there are 1 or more distinct areas in simplification_points_a (i.e. filter is not broken)
--
		OPEN c11_sgck;
		FETCH c11_sgck INTO c11_rec;	
		CLOSE c11_sgck;
--
		IF c11_rec.t_areas = 0 THEN
			PERFORM rif40_log_pkg.rif40_error(-10072, '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: Found no areas(s)',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: Found % distinct areas(s)',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */, 
				c11_rec.t_areas::VARCHAR);
		END IF;
	ELSIF check_number = 2 THEN
--
-- Test 2: for un-detected duplicates
--
		OPEN c2_sgck;
		FETCH c2_sgck INTO c2_rec;	
		CLOSE c2_sgck;
--
		IF c2_rec.distinct_polys > 0 THEN
			PERFORM rif40_sql_pkg.rif40_method4('SELECT coord_id, COUNT(DISTINCT(num_polygon_number)) AS distinct_polygons'||E'\n'||
'  FROM simplification_points_d'||E'\n'||
' WHERE num_polygon_number = 2'||E'\n'||
'   AND duplicate IN (''N'', ''L'')'||E'\n'||
' GROUP BY coord_id'||E'\n'||
'HAVING COUNT(DISTINCT(num_polygon_number)) > 2 LIMIT 100', 'Test 2: for un-detected duplicates');
			PERFORM rif40_log_pkg.rif40_error(-10073, '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: Found % polygons(s) with undetected duplicates', 
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */,
				c2_rec.distinct_area::VARCHAR);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: No polygons(s) have undetected duplicates',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */);
		END IF;
	ELSIF check_number = 21 THEN
--
-- Test 2.1: for invalid duplicates
--
		OPEN c21_sgck;
		FETCH c21_sgck INTO c21_rec;	
		CLOSE c21_sgck;
--
		IF c21_rec.t_areas > 0 THEN
			PERFORM rif40_log_pkg.rif40_error(-10074, '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: Found % polygons(s) with invalid (''?'') duplicate codes', 
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */,
				c21_rec.t_areas::VARCHAR);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: No polygons(s) have invalid (''?'') duplicate codes',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */);
		END IF;
	ELSIF check_number = 22 THEN
--
-- Test 2.2: Check array dimensions are [1:3] as expected
--
		FOR c22_rec IN c22_sgck LOOP
			IF c22_rec.array_dims != '[1:3]' THEN
				PERFORM rif40_log_pkg.rif40_error(-10075, '_simplify_geometry_checks', 
					'Check %: % geography geolevel %: Found % area_id(s) with unsupported (%) geography_dump dimensions', 
					check_number::VARCHAR		/* Check number */,
					l_geography::VARCHAR		/* Geography */, 
					l_geolevel::VARCHAR		/* Geolevel */,
					c22_rec.total::VARCHAR		/* Total polygons */,
					c22_rec.array_dims::VARCHAR 	/* geography_dump array dimension */);
			ELSE
				
			END IF;
		END LOOP;
--
		PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_checks', 
			'Check %: % geography geolevel %: No area_id(s) unsupported (not [1:3]) geography_dump dimensions',
			check_number::VARCHAR	/* Check number */,
			l_geography::VARCHAR	/* Geography */, 
			l_geolevel::VARCHAR	/* Geolevel */);
--
	ELSIF check_number = 3 THEN
--	
-- Test 3: for areas with no join sequence
--
		OPEN c3_sgck;
		FETCH c3_sgck INTO c3_rec;	
		CLOSE c3_sgck;
--
		IF c3_rec.t_join_seq > 0 THEN
			PERFORM rif40_sql_pkg.rif40_method4('SELECT * FROM simplification_points WHERE join_seq IS NULL LIMIT 100', 'Test 3: for areas with no join sequence');
			PERFORM rif40_log_pkg.rif40_error(-10076, '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: Found % polygons(s) with no join sequence',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */,
				c3_rec.t_join_seq::VARCHAR);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: No polygons(s) with no join sequences',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */);
		END IF;
	ELSIF check_number = 4 THEN
--
-- Test 4: for areas with mis-joined sequences
--
		OPEN c4_sgck;
		FETCH c4_sgck INTO c4_rec;	
		CLOSE c4_sgck;
--
		IF c4_rec.t_polygon_number > 0 THEN
			PERFORM rif40_sql_pkg.rif40_method4('SELECT polygon_number,'||E'\n'||
'       MIN(joined_polygon_number) AS joined_polygon_number, MAX(joined_polygon_number) AS joined_polygon_number2,'||E'\n'||
'       join_seq, MIN(pointflow) AS min, MAX(pointflow) AS max, COUNT(pointflow) AS total'||E'\n'||
'  FROM simplification_points'||E'\n'||
' GROUP BY polygon_number, join_seq'||E'\n'||
' HAVING MIN(joined_polygon_number) != MAX(joined_polygon_number)'||E'\n'||
' ORDER BY polygon_number, join_seq', 'Test 4: for areas with mis-joined sequences');
			PERFORM rif40_log_pkg.rif40_error(-10077, '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: Found % polygons(s) with mis-joined sequences',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */, 
				c4_rec.t_polygon_number::VARCHAR);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: No polygons(s) with no mis-joined sequences',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */);
		END IF;
	ELSIF check_number = 5 THEN
--
-- Test 5: join sequence(s) used by more than one polygon_number
--
		OPEN c5_sgck;
		FETCH c5_sgck INTO c5_rec;	
		CLOSE c5_sgck;
		IF c5_rec.t_join_seq > 0 THEN
			PERFORM rif40_sql_pkg.rif40_method4('SELECT join_seq, COUNT(DISTINCT(joined_polygon_number)) AS t_polygon_number'||E'\n'||
'  FROM simplification_points_f'||E'\n'||
' GROUP BY join_seq'||E'\n'||
' HAVING COUNT(DISTINCT(joined_polygon_number)) > 1 LIMIT 10', 'Test 5: join sequence(s) used by more than one polygon_number');
			PERFORM rif40_log_pkg.rif40_error(-10078, '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: Found % join sequence(s) used by more than one polygon_number',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */, 
				c5_rec.t_join_seq::VARCHAR);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: No join sequence(s) not used by more than one polygon_number',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */);
		END IF;
	ELSIF check_number = 6 THEN
--
-- Test 6: polygon_number, coord_id, duplicate(s) used by more than one join sequence
--
		OPEN c6_sgck;
		FETCH c6_sgck INTO c6_rec;	
		CLOSE c6_sgck;
		IF c6_rec.t_joined_polygon_number > 0 THEN
			PERFORM rif40_sql_pkg.rif40_method4('SELECT joined_polygon_number, coord_id, duplicate, COUNT(DISTINCT(join_seq)) AS t_join_seq'||E'\n'||
'  FROM simplification_points_f'||E'\n'||
' GROUP BY joined_polygon_number, coord_id, duplicate'||E'\n'||
' HAVING COUNT(DISTINCT(join_seq)) > 1 LIMIT 10', 'Test 6: polygon_number, coord_id, duplicate(s) used by more than one join sequence');
			PERFORM rif40_log_pkg.rif40_error(-10079, '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: Found % joined_polygon_number, coord_id, duplicate(s) used by more than one join sequence',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */, 
				c6_rec.t_joined_polygon_number::VARCHAR);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: No joined_polygon_number, coord_id, duplicate(s) not used by more than one join sequence',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */);
		END IF;
	ELSIF check_number = 7 THEN
--
-- Test 7: areas(s) with non unique join sequences
--
		OPEN c7_sgck;
		FETCH c7_sgck INTO c7_rec;	
		CLOSE c7_sgck;
		IF c7_rec.t_join_seq > 0 THEN
			PERFORM rif40_sql_pkg.rif40_method4('SELECT join_seq, COUNT(DISTINCT(polygon_number)) AS distinct_polys'||E'\n'||
'  FROM simplification_points'||E'\n'||
' GROUP BY join_seq'||E'\n'||
' HAVING COUNT(DISTINCT(polygon_number)) > 1', 'Test 7: areas(s) with non unique join sequences');
			PERFORM rif40_log_pkg.rif40_error(-10080, '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: Found % polygons(s) with non unique join sequences',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */, 
				c7_rec.t_join_seq::VARCHAR);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: No polygons(s) with no non unique join sequences',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */);
		END IF;
--
-- Test 8: areas(s) with invalid geometry in simplification_polygons
--
	ELSIF check_number = 8 THEN
		OPEN c8_sgck;
		FETCH c8_sgck INTO c8_rec;	
		CLOSE c8_sgck;
		IF c8_rec.t_area_id > 0 THEN
			PERFORM rif40_log_pkg.rif40_error(-10081, '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: Found % areas/polygons(s) with invalid geometry in simplification_polygons',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */,
				c8_rec.t_area_id::VARCHAR);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: No areas/polygons(s) with invalid geometry in simplification_polygons',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */);
		END IF;
--
-- Test 9: join sequence(s) causing invalid joins and reversals
--
	ELSIF check_number = 9 THEN
		OPEN c9_sgck;
		FETCH c9_sgck INTO c9_rec;	
		CLOSE c9_sgck;
		IF c9_rec.t_join_seq > 0 THEN
			PERFORM rif40_sql_pkg.rif40_method4('SELECT polygon_number, join_seq, joined_join_seq, joined_polygon_number,'||E'\n'||
'       duplicate_join_to_be_removed, reverse_line, reverse_simplified_line, num_points_a, num_points_b,'||E'\n'||
'       simplified_line_test, line_test, simplified_line_length, line_length, line_start_endpoints_match, simplified_line_start_endpoints_match'||E'\n'||
'  FROM simplification_lines_temp'||E'\n'||
' WHERE duplicate_join_to_be_removed = ''N/N'''||E'\n'||
'   AND reverse_line = ''N'''||E'\n'||
'   AND reverse_simplified_line = ''N''', 'Invalid joins and reversals');
/*
Invalid joins and reversals
---------------------------
psql:n_ph_simplification.sql:55: INFO:  rif40_method4(): 
polygon_number       | join_seq             | joined_join_seq      | joined_polygon_number | duplicate_join_to_be_removed | reverse_line | reverse_simplified_line | num_points           | simplified_line_test | line_test | simplified_line_length | line_length         
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
60                   | 371                  | 382                  | 61                    | N/N                          | N            | N                       | 1                    | 1.000                | 1.000     | 0                      | 0                   
61                   | 382                  | 371                  | 60                    | N/N                          | N            | N                       | 1                    | 1.000                | 1.000     | 0                      | 0                   
(2 rows)

polygon_number       | join_seq             | joined_join_seq      | joined_polygon_number | duplicate_join_to_be_removed | reverse_line | reverse_simplified_line | num_points_a         | num_points_b         | simplified_line_test | line_test | simplified_line_length | line_length          | line_start_endpoints_match | simplified_line_start_endpoints_match
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
9                    | 118                  | 2223                 | 193                   | N/N                          | N            | N                       | 149                  | 149                  | 0.002                | 0.001     | 30436.8158167104       | 30529.7292139443     | 0                          | 0                                    
193                  | 2223                 | 118                  | 9                     | N/N                          | N            | N                       | 149                  | 149                  | 0.002                | 0.001     | 30378.9009040035       | 30501.8416425816     | 0                          | 0                                    
(2 rows)

 */
--
-- The usual cause of this is a misordered join
--
-- Check all the co-ordinates are the same
--

			sql_stmt:='WITH z AS ('||E'\n'||
'	SELECT a2.polygon_number, a2.joined_polygon_number, a2.join_seq, a2.joined_join_seq'||E'\n'||
'	  FROM simplification_lines_temp a2'||E'\n'||
'	 WHERE duplicate_join_to_be_removed = ''N/N'''||E'\n'||
'	   AND reverse_line = ''N'''||E'\n'||
'	   AND reverse_simplified_line = ''N'''||E'\n'||
'), a AS ('||E'\n'||
'	SELECT a1.* '||E'\n'||
'          FROM simplification_points a1, z'||E'\n'||
'  	 WHERE a1.join_seq = z.join_seq OR a1.join_seq = z.joined_join_seq'||E'\n'||
'), b AS ('||E'\n'||
'	SELECT a.polygon_number, a.joined_polygon_number, pointflow, coord_id'||E'\n'||
'	  FROM a, z'||E'\n'||
'	 WHERE a.join_seq = z.join_seq'||E'\n'||
'	EXCEPT'||E'\n'||
'	SELECT a.polygon_number, a.joined_polygon_number, pointflow, coord_id'||E'\n'||
'	  FROM a, z'||E'\n'||
'	 WHERE a.join_seq = z.joined_join_seq'||E'\n'||
'), c AS ('||E'\n'||
'	SELECT polygon_number, joined_polygon_number, COUNT(pointflow) AS total'||E'\n'||
'	  FROM b'||E'\n'||
'	 GROUP BY polygon_number, joined_polygon_number'||E'\n'||
')'||E'\n'||
'SELECT SUM(total) AS total'||E'\n'||
'  FROM c';
--
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', '_simplify_geometry_checks', 'SQL> %;', sql_stmt::VARCHAR);
			OPEN c90_sgck FOR EXECUTE sql_stmt;
			FETCH c90_sgck INTO c90_rec;	
			CLOSE c90_sgck;
--
-- line_test_limit is the maximum difference tolerated between joined lines when all the points are the same (i.e. the is a slight misorder) 
--
			IF (c90_rec.total = 0 OR c90_rec.total IS NULL) AND c9_rec.max_simplified_line_test <= line_test_limit AND c9_rec.max_line_test <= line_test_limit THEN
				PERFORM rif40_log_pkg.rif40_log('WARNING', '_simplify_geometry_checks', 
					'Check %: % geography geolevel %: Found % join sequence(s) causing invalid joins and reversals caused by misorder joins; max line test error: %, max simplified line test error: %; limit: %',
					check_number::VARCHAR				/* Check number */,
					l_geography::VARCHAR				/* Geography */, 
					l_geolevel::VARCHAR				/* Geolevel */,
					c9_rec.t_join_seq::VARCHAR			/* Invalid joins and reversals */,
					c9_rec.max_line_test::VARCHAR			/* Max error in line test */,
					c9_rec.max_simplified_line_test::VARCHAR	/* Max error in simplified line test */,
					line_test_limit::VARCHAR			/* Maximum difference tolerated between joined lines */);
--
-- Co-ordinates are the same, just misordered slightly...
-- 
				PERFORM rif40_sql_pkg.rif40_method4('WITH z AS ('||E'\n'||
'	SELECT a2.join_seq, a2.joined_join_seq'||E'\n'||
'	  FROM simplification_lines_temp a2'||E'\n'||
'	 WHERE duplicate_join_to_be_removed = ''N/N'''||E'\n'||
'	   AND reverse_line = ''N'''||E'\n'||
'	   AND reverse_simplified_line = ''N'' LIMIT 1'||E'\n'||
'), a AS ('||E'\n'||
'	SELECT a1.* '||E'\n'||
'          FROM simplification_points a1, z'||E'\n'||
'  	 WHERE a1.join_seq = z.join_seq OR a1.join_seq = z.joined_join_seq'||E'\n'||
'), b AS ('||E'\n'||
'	SELECT a.pointflow, a.coord_id'||E'\n'||
'	  FROM a, z'||E'\n'||	
'	 WHERE a.join_seq = z.join_seq'||E'\n'||
'), c AS ('||E'\n'||
'	SELECT a.pointflow, a.coord_id'||E'\n'||
'	  FROM a, z'||E'\n'||
'	 WHERE a.join_seq = z.joined_join_seq'||E'\n'||
')'||E'\n'||
'SELECT b.pointflow AS pointflow_join, b.coord_id AS coord_id_join,'||E'\n'||
'       c.pointflow AS pointflow_joined, c.coord_id AS coord_id_joined'||E'\n'||
'  FROM b, c'||E'\n'||
' WHERE b.coord_id = c.coord_id'||E'\n'||
' ORDER BY b.pointflow LIMIT 100', 'First 100 coordinates of first misordered join');
--
			ELSIF (c90_rec.total = 0 OR c90_rec.total IS NULL) AND (c9_rec.max_simplified_line_test > line_test_limit OR c9_rec.max_line_test > line_test_limit) THEN
				PERFORM rif40_log_pkg.rif40_error(-10062, '_simplify_geometry_checks', 
					'Check %: % geography geolevel %: Found % join sequence(s) causing invalid joins and reversals caused by misorder joins; max line test error: %, max simplified line test error: %; limit: %',
					check_number::VARCHAR				/* Check number */,
					l_geography::VARCHAR				/* Geography */, 
					l_geolevel::VARCHAR				/* Geolevel */,
					c9_rec.t_join_seq::VARCHAR			/* Invalid joins and reversals */,
					c9_rec.max_line_test::VARCHAR			/* Max error in line test */,
					c9_rec.max_simplified_line_test::VARCHAR	/* Max error in simplified line test */,
					line_test_limit::VARCHAR			/* Maximum difference tolerated between joined lines */);
--
-- Co-ordinates are the same, misordered too much...
-- 
				PERFORM rif40_sql_pkg.rif40_method4('WITH z AS ('||E'\n'||
'	SELECT a2.join_seq, a2.joined_join_seq'||E'\n'||
'	  FROM simplification_lines_temp a2'||E'\n'||
'	 WHERE duplicate_join_to_be_removed = ''N/N'''||E'\n'||
'	   AND reverse_line = ''N'''||E'\n'||
'	   AND reverse_simplified_line = ''N'' LIMIT 1'||E'\n'||
'), a AS ('||E'\n'||
'	SELECT a1.* '||E'\n'||
'          FROM simplification_points a1, z'||E'\n'||
'  	 WHERE a1.join_seq = z.join_seq OR a1.join_seq = z.joined_join_seq'||E'\n'||
'), b AS ('||E'\n'||
'	SELECT a.pointflow, a.coord_id'||E'\n'||
'	  FROM a, z'||E'\n'||	
'	 WHERE a.join_seq = z.join_seq'||E'\n'||
'), c AS ('||E'\n'||
'	SELECT a.pointflow, a.coord_id'||E'\n'||
'	  FROM a, z'||E'\n'||
'	 WHERE a.join_seq = z.joined_join_seq'||E'\n'||
')'||E'\n'||
'SELECT b.pointflow AS pointflow_join, b.coord_id AS coord_id_join,'||E'\n'||
'       c.pointflow AS pointflow_joined, c.coord_id AS coord_id_joined'||E'\n'||
'  FROM b, c'||E'\n'||
' WHERE b.coord_id = c.coord_id'||E'\n'||
' ORDER BY b.pointflow LIMIT 100', 'First 100 coordinates of first misordered join');
			ELSE
--
-- Co-ordinates are NOT the same
-- 
				PERFORM rif40_sql_pkg.rif40_method4('WITH z AS ('||E'\n'||
'	SELECT a2.polygon_number, a2.joined_polygon_number, a2.join_seq, a2.joined_join_seq'||E'\n'||
'	  FROM simplification_lines_temp a2'||E'\n'||
'	 WHERE duplicate_join_to_be_removed = ''N/N'''||E'\n'||
'	   AND reverse_line = ''N'''||E'\n'||
'	   AND reverse_simplified_line = ''N'''||E'\n'||
'), a AS ('||E'\n'||
'	SELECT a1.* '||E'\n'||
'          FROM simplification_points a1, z'||E'\n'||
'  	 WHERE a1.join_seq = z.join_seq OR a1.join_seq = z.joined_join_seq'||E'\n'||
'), b AS ('||E'\n'||
'	SELECT a.polygon_number, a.joined_polygon_number, pointflow, coord_id'||E'\n'||
'	  FROM a, z'||E'\n'||
'	 WHERE a.join_seq = z.join_seq'||E'\n'||
'	EXCEPT'||E'\n'||
'	SELECT a.polygon_number, a.joined_polygon_number, pointflow, coord_id'||E'\n'||
'	  FROM a, z'||E'\n'||
'	 WHERE a.join_seq = z.joined_join_seq'||E'\n'||
')'||E'\n'||
'SELECT polygon_number, joined_polygon_number, COUNT(pointflow) AS total'||E'\n'||
'  FROM b'||E'\n'||
' GROUP BY polygon_number, joined_polygon_number', 'Coordinate differences between potentially misjoined polygons');
--
				PERFORM rif40_log_pkg.rif40_error(-10082, '_simplify_geometry_checks', 
					'Check %: % geography geolevel %: Found % join sequence(s) causing invalid joins and reversals, % co-ordinates are different; max line test error: %, max simplified line test error: %; limit: %',
					check_number::VARCHAR				/* Check number */,
					l_geography::VARCHAR				/* Geography */, 
					l_geolevel::VARCHAR				/* Geolevel */,
					c9_rec.t_join_seq::VARCHAR			/* Invalid joins and reversals */,
					c90_rec.total::VARCHAR				/* Different co-ordinates */,
					c9_rec.max_line_test::VARCHAR			/* Max error in line test */,
					c9_rec.max_simplified_line_test::VARCHAR	/* Max error in simplified line test */,
					line_test_limit::VARCHAR			/* Maximum difference tolerated between joined lines */);
			END IF;
		ELSE
			PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_checks', 
				'Check %: % geography geolevel %: No join sequence(s) causing invalid joins and reversals',
				check_number::VARCHAR	/* Check number */,
				l_geography::VARCHAR	/* Geography */, 
				l_geolevel::VARCHAR	/* Geolevel */);
		END IF;
	ELSE
		PERFORM rif40_log_pkg.rif40_error(-10083, '_simplify_geometry_checks', 
			'% geography geolevel %: Invalid check number: %',
			l_geography::VARCHAR	/* Geography */, 
			l_geolevel::VARCHAR	/* Geolevel */, 
			check_number::VARCHAR 	/* Check number */); 
	END IF;
END;
]]></definition>
</function>

<function name="_simplify_geometry_phase_i"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	_simplify_geometry_phase_I()
Parameters:	Geography, geolevel, 
                geolevel; filter (for testing, no default), 
                minimum point resolution (default 1 - assumed metre, but depends on the geometry), 
                override for rif40_geoelvels.st_simplify_tolerance
Returns:	Nothing
Description:	Simplify geography geolevel - Phase I: Create the points table

Phase I: Create the points table

Test 0 for valid geometry
Create a sequence so that points are in the original order specified by ST_DumpPoints()
Create table simplification_points_a and convert geometry to points, reduce precision to <l_min_point_resolution>m
from the relevent geolevel geometry table. Give each polygon a separate polygon number

Test 11: Check there are 1 or more distinct areas in simplification_points_a (i.e. filter is not broken)
Print out polygon/points reports [limited to first 20 rows]

a) Print points per first two dimensions (i.e. [1] and [2])
b) Polygons per area
c) Multiple polygons

Test 1 - check last_pointflow = one per area (should be zero)

Create table simplification_points_b from simplification_points_a to:

a) Round first and last points in area (were not rounded in the previous step); convert to points
b) Create the variables needed to detect duplcates within co-ordinates (a side effect of the round in the previous statement)

Note that a duplicate co-ordinate is defined as being within an area_id and coordinate pair; polygons are ignored 
as self intersections were removed by ST_Buffer(geom, 0.0) during shapefile geometry load into the geography geometry table

The geometry is not checked for validity at this time; hence test 0 above. This is to allow the initial load
to complete even if there are uncorrectable errors in the geometry.

Create table simplification_points_c to detect and classify duplcates within co-ordinates (a side effect of the 
round) from simplification_points_b:

O: original - first or last point in area
N: Not a dupicate
Y: A dupicate (two or more consecutive points sharing the same co-ordinate); removed later
L: Loop duplicate (two or more NON consecutive points sharing the same co-ordinate)

Print duplicate flags
Print numbers of multiple loop and origin flags per area. There will only be one origin; but a small number  of multiple loops. 
Display first two "L" (loop) duplicates and the three rows either side
Test 2.1 for invalid duplicate flag: "?"
Create table simplification_points_d to count up number of distinct polygon_number using the same
co-ordinate from simplification_points_c

List by number of distinct polygon_number using the same co-ordinate

num_polygon_number (join type if >1)
------------------ -----------------

1            Outer edge (no join)
2            Join between two polygons
3            Triple point - junction of three polygons
...
N            Nth point - junction of N polygons

Test 2 for un-detected duplicates

Join up adjacent edges by update of simplification_points_d
List joins by number of distinct polygon_number using the same co-ordinate
List of joinable co-ordinates by duplicate type
Create table simplification_points_e to categorise join types from simplification_points_d:

 Join code	Description						Increment join sequence
 ---------	-----------						-----------------------
 A		Start of polygon					YES
 B		Junction						YES
 C		Junction (previous area_id)				YES
 D		Duplicate and change in area_id				YES
 V		End of polygon						NO
 W		next area_id == current, but previous != current	YES
		(Normally there is a three cornered point and this does not occur as there is a NULL in the next/prev area_id)
 X		next == current						NO
 Y		Previous area_id == current				NO
 Z		ELSE							YES

Create the points table: simplification_points from simplification_points_e adding in joinable points

Note that a duplicate co-ordinate is defined as being within an area_id and coordinate pair; polygons are ignored 
as self intersections were removed by ST_Buffer(geom, 0.0) during shapefile geometry load into the geography geometry table

The geometry is not checked for validity at this time; hence test 0 above. This is to allow the initial load
to complete even if there are uncorrectable errors in the geometry.

Test 3 and 4 - Checks - MUST BE 0
	
a) Areas with no join sequence
b) Areas with mis-joined sequences

Create a list of joined_polygon_numbers as temporary table simplification_points_f (i.e. the num_join_seq is 1)

Test 5: For join sequence(s) used by more than one polygon_number
Test 6: For polygon_number, coord_id, duplicate(s) used by more than one join sequence

Update simplification_points.joined_join_seq using joined_polygon_numbers in simplification_points_f (i.e. the num_join_seq is 1) 
joining on joined_polygon_number, coord_id and the duplicate flag

Display number of polygons and duplicate flag
Display number of polygons joined at a point (1=edge; 2=shared polygon boundary between 2 polygons; 3+: triple or more point)
List duplicates
Test 7: areas(s) with non unique join sequences.

Example SQL>

CREATE TEMPORARY TABLE simplification_points_a
AS
WITH a AS (
        SELECT area_id,
               ST_DumpPoints(shapefile_geometry) AS geometry_data,     /* Convert geometry to points */
               nextval('simplification_points_seq') AS point_order_seq
          FROM t_rif40_geolevels_geometry_ew01_ladua2001
         WHERE geolevel_name = 'LADUA2001'
           AND area_id IN (SELECT DISTINCT ladua2001 FROM ew2001_geography WHERE gor2001 = 'K') /* Restrict to The South West  */
), b /* Extract points and point order within a polygon */ AS (
        SELECT area_id, point_order_seq /* Point order in shapefile */,
               (geometry_data).geom AS points,                          /* Points component */
               (geometry_data).path AS path,                            /* Path component */
               CASE
                        WHEN (geometry_data).path[3] = 1 /* OR */       /* New polygon */ 
                /*           LAG((geometry_data).path[1]) OVER x < (geometry_data).path[1] OR
                             LAG((geometry_data).path[2]) OVER x < (geometry_data).path[2] */ THEN nextval('simplification_points_poly_seq')
                        ELSE                                            /* Current polygon */      currval('simplification_points_poly_seq')
               END AS polygon_number
          FROM a
        /* WINDOW x AS (ORDER BY point_order_seq) */
)
SELECT area_id, polygon_number, path, 
       ST_MakePoint(ROUND(CAST(st_X(points) AS numeric), 10),
               ROUND(CAST(st_Y(points) AS numeric), 10)) /* Reduce precision to <l_min_point_resolution> m */ AS coordinate, 
       ROW_NUMBER() OVER w AS pointflow, 
       COUNT(point_order_seq) OVER w AS last_pointflow,
       LAST_VALUE(points) OVER w AS lastpoint,                         /* Lastpoint should be the same as the first */
       FIRST_VALUE(points) OVER w AS firstpoint                        /* firstpoint should be the same as the first */
  FROM b
        WINDOW w AS (PARTITION BY polygon_number ORDER BY point_order_seq RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
                    /* Disable window sliding (i.e. COUNT/LAST_VALUE works over the whole partition) */;

CREATE TEMPORARY TABLE simplification_points_b
AS
SELECT area_id, pointflow, polygon_number, last_pointflow,
       ST_MakePoint(ROUND(CAST(st_X(firstpoint) AS numeric), 10),
                ROUND(CAST(st_Y(firstpoint) AS numeric), 10)) AS firstpoint,    /* Convert firstpoint to POINT() datatype */
       ST_MakePoint(ROUND(CAST(st_X(lastpoint) AS numeric), 10),
                ROUND(CAST(st_Y(lastpoint) AS numeric), 10)) AS lastpoint,      /* Convert lastpoint to POINT() datatype */
       coordinate,
       COUNT(pointflow) OVER w AS tot_dup_coords,               /* Total duplicate co-ordinates within an area_id and coordinate pair */
       LAG(pointflow) OVER w AS prev_pointflow,                 /* Previous pointflow within a duplicate */
       LEAD(polygon_number) OVER w AS next_polygon_number,      /* Next polygon_number */
       LAG(polygon_number) OVER w AS prev_polygon_number,       /* Previous polygon_number */
       ROW_NUMBER() OVER w AS dup_coord_order                   /* Find pointflows with the same coordinate [i.e. side effect of the ROUND()] */
  FROM simplification_points_a
WINDOW w AS (PARTITION BY polygon_number, coordinate ORDER BY pointflow)
 ORDER BY coordinate, polygon_number /* Optimise index: simplification_points_b_coordinate; not the primary key */;

CREATE TEMPORARY TABLE simplification_points_c
AS
WITH a /* First point in polygon_number */ AS (
        SELECT polygon_number, coordinate AS firstpoint, pointflow AS first_pointflow
          FROM simplification_points_b
         WHERE pointflow = 1 AND coordinate = firstpoint
), b /* Last point in polygon */ AS (
        SELECT polygon_number, coordinate AS lastpoint, pointflow AS last_pointflow
          FROM simplification_points_b
         WHERE last_pointflow = pointflow AND coordinate = lastpoint
), c /* Total polygons */ AS (
        SELECT DISTINCT polygon_number
          FROM simplification_points_b
), d AS (
        SELECT c.polygon_number,
               CASE WHEN a.firstpoint = b.lastpoint THEN 1 ELSE 0 END origin_verified
          FROM c
                LEFT OUTER JOIN a ON (c.polygon_number = a.polygon_number)
                LEFT OUTER JOIN b ON (c.polygon_number = b.polygon_number)
)
SELECT area_id, e.polygon_number, prev_polygon_number, pointflow, last_pointflow, tot_dup_coords, dup_coord_order, prev_pointflow, origin_verified,
      DENSE_RANK() OVER (ORDER BY coordinate) AS coord_id,              /* Add coordinate index number per geolevel */
      coordinate,
      CASE                                                              /* Is co-ordinate a duplicate within a polygon? */
                WHEN pointflow = 1 AND coordinate = firstpoint  THEN                                       'O' /* Origin */
                WHEN last_pointflow = pointflow AND coordinate = lastpoint AND d.origin_verified = 1 THEN  'E' /* End (same as Origin) */ 
                WHEN tot_dup_coords = 1 OR (tot_dup_coords > 1  AND dup_coord_order = 1) THEN              'N' /* No */
                WHEN tot_dup_coords > 1 AND dup_coord_order > 1 AND
                        prev_pointflow + 1 = pointflow THEN                                                'Y' /* Yes */
                WHEN tot_dup_coords > 1 AND dup_coord_order > 1 AND 
                        prev_pointflow IS NOT NULL AND prev_pointflow + 1 != pointflow THEN                'L' /* Loop */
                ELSE                                                                                       '?' /* Unknown */
      END duplicate                                                     /* Flag duplicates */
  FROM simplification_points_b e, d
 WHERE e.polygon_number = d.polygon_number
 ORDER BY coord_id, polygon_number /* Sort order in next statement */;

CREATE TEMPORARY TABLE simplification_points_d
AS
WITH f AS (
        SELECT coord_id,
               COUNT(DISTINCT(polygon_number)) AS num_polygon_number    /* Count up number of distinct polygons using the same co-ordinate */
         FROM simplification_points_c
         GROUP BY coord_id
) 
SELECT area_id, polygon_number, pointflow, e.coord_id, coordinate, tot_dup_coords, dup_coord_order, prev_pointflow, duplicate,
       f.num_polygon_number
  FROM  simplification_points_c e
                LEFT OUTER JOIN f ON (e.coord_id = f.coord_id)
 ORDER BY polygon_number, pointflow;

UPDATE simplification_points_d g1
   SET joined_polygon_number = (
        SELECT DISTINCT g2.polygon_number AS joined_polygon_number
          FROM simplification_points_d g2
         WHERE g1.num_polygon_number = g2.num_polygon_number                    /* Join type matches */
            AND g1.coord_id           = g2.coord_id                             /* Co-ordinates are the same */
            AND g1.polygon_number    != g2.polygon_number                       /* Polygons are NOT the same */
            AND (
                 (g1.duplicate        = g2.duplicate) OR                        /* Duplicate flags match */
                 (g1.duplicate        = 'N' AND g2.duplicate = 'O') OR      /* Handle different origins */
                 (g1.duplicate        = 'O' AND g2.duplicate = 'N')
               )
        )
 WHERE g1.num_polygon_number = 2        /* Join points shared between two polygons only - i.e. shares linestrings */
   AND g1.duplicate IN ('N' /* Not a duplicate */, 'O' /* Origin */, 'L' /* Loop */);

CREATE TEMPORARY TABLE simplification_points_e
AS
WITH a AS (
        SELECT area_id, polygon_number, pointflow, coord_id, coordinate, duplicate, num_polygon_number, joined_polygon_number,
               LAG(polygon_number) OVER w               AS prev_polygon_number,
               LAG(num_polygon_number) OVER w           AS prev_num_polygon_number,
               LAG(pointflow) OVER w                    AS prev_pointflow,
               LAG(joined_polygon_number) OVER w        AS prev_joined_polygon_number,
               LEAD(pointflow) OVER w                   AS next_pointflow,
               LEAD(joined_polygon_number) OVER w       AS next_joined_polygon_number,
               LEAD(polygon_number) OVER w              AS next_polygon_number,
               LEAD(num_polygon_number) OVER w          AS next_num_polygon_number
          FROM simplification_points_d
         WHERE duplicate NOT IN('E', 'Y')               /* Exclude end point and duplicates */
        WINDOW w AS (PARTITION BY polygon_number ORDER BY pointflow)
)
SELECT area_id, polygon_number::bigint, pointflow::bigint, duplicate, coord_id::bigint, coordinate, num_polygon_number::bigint, joined_polygon_number::bigint,
       next_polygon_number::bigint, next_pointflow::bigint, next_joined_polygon_number::bigint,
       prev_polygon_number::bigint, prev_pointflow::bigint, prev_joined_polygon_number::bigint,
       CASE
                WHEN pointflow = 1                                              THEN 'A' /* nextval: start */
                WHEN num_polygon_number > 2                                     THEN 'B' /* nextval: junction */
                WHEN prev_num_polygon_number > 2                                THEN 'C' /* nextval: junction */
                WHEN duplicate = 'L' AND next_joined_polygon_number IS NULL   THEN 'D' /* nextval: duplicate and change in polygon_number */
                WHEN num_polygon_number = 1 AND next_num_polygon_number = 1     THEN 'E' /* currval: outside edge */
                WHEN pointflow != 1 AND duplicate = 'O'                       THEN 'V' /* currval: end */
                WHEN polygon_number  = next_polygon_number AND joined_polygon_number = next_joined_polygon_number
                        AND joined_polygon_number != prev_joined_polygon_number THEN 'W' /* nextval: next == current, but previous != current */
                        /* Normally there is a three cornered point and this does not occur as there is a NULL in the next/prev polygon_number */
                WHEN polygon_number  = next_polygon_number AND
                        joined_polygon_number = next_joined_polygon_number      THEN 'X' /* currval: next == current */
                WHEN polygon_number  = prev_polygon_number AND
                        joined_polygon_number = prev_joined_polygon_number      THEN 'Y' /* currval: previous == current */
                ELSE 'Z' /* nextval */
       END join_code,
       CASE
                WHEN pointflow = 1                                              THEN nextval('simplification_points_seq') /* nextval: start */
                WHEN num_polygon_number > 2                                     THEN nextval('simplification_points_seq') /* nextval: junction */
                WHEN prev_num_polygon_number > 2                                THEN nextval('simplification_points_seq') /* nextval: junction */
                WHEN duplicate = 'L' AND next_joined_polygon_number IS NULL   THEN nextval('simplification_points_seq') /* nextval: duplicate and change in polygon_number */
                WHEN num_polygon_number = 1 AND next_num_polygon_number = 1     THEN currval('simplification_points_seq') /* currval: outside edge */
                WHEN pointflow != 1 AND duplicate = 'O'                       THEN currval('simplification_points_seq') /* currval: end */
                WHEN polygon_number  = next_polygon_number AND joined_polygon_number = next_joined_polygon_number
                        AND joined_polygon_number != prev_joined_polygon_number THEN nextval('simplification_points_seq') /* nextval: next == current, but previous != current */
                        /* Normally there is a three cornered point and this does not occur as there is a NULL in the next/prev polygon_number */
                WHEN polygon_number  = next_polygon_number AND
                        joined_polygon_number = next_joined_polygon_number      THEN currval('simplification_points_seq') /* currval: next == current */
                WHEN polygon_number  = prev_polygon_number AND
                        joined_polygon_number = prev_joined_polygon_number      THEN currval('simplification_points_seq') /* currval: previous == current */
                ELSE nextval('simplification_points_seq')
       END join_seq
  FROM a
 ORDER BY polygon_number, pointflow;

CREATE TABLE simplification_points
AS
WITH b AS /* Joinable polygons */ (
        SELECT joined_polygon_number, coord_id, duplicate, COUNT(DISTINCT(join_seq)) AS num_join_seq
          FROM simplification_points_e c
         WHERE num_polygon_number = 2
           AND joined_polygon_number IS NOT NULL
         GROUP BY joined_polygon_number, coord_id, duplicate
        HAVING COUNT(DISTINCT(join_seq)) = 1
)
SELECT c.area_id, polygon_number, pointflow, c.coord_id, coordinate, c.duplicate,
       c.num_polygon_number, c.joined_polygon_number,
       next_polygon_number, next_pointflow, next_joined_polygon_number,
       prev_polygon_number, prev_pointflow, prev_joined_polygon_number,
       join_seq, join_code, b.num_join_seq
  FROM simplification_points_e c
        LEFT OUTER JOIN b /* For joined_polygon_number */ ON (
               b.joined_polygon_number = c.polygon_number
           AND b.coord_id              = c.coord_id
           AND (
                (b.duplicate           = c.duplicate) /* Same flag */ OR
                (b.duplicate           = 'N' AND c.duplicate = 'O') OR /* Handle different origins */
                (b.duplicate           = 'O' AND c.duplicate = 'N')
               )
           AND c.num_polygon_number    = 2 /* Shared boundary between two polygons only */)
 ORDER BY polygon_number, pointflow;

CREATE TEMPORARY TABLE simplification_points_f
AS
WITH a AS (
        SELECT polygon_number AS joined_polygon_number, coord_id, duplicate, join_seq, COUNT(join_seq) AS total_join_seq
          FROM simplification_points
         WHERE num_join_seq  = 1
         GROUP BY polygon_number, coord_id, duplicate, join_seq
), b /* Exclude a small number of loop duplicates that would break the primary key */ AS (
        SELECT joined_polygon_number, coord_id, duplicate, COUNT(join_seq) AS total
          FROM a
         GROUP BY joined_polygon_number, coord_id, duplicate
        HAVING COUNT(join_seq) > 1
)
SELECT a.joined_polygon_number, a.coord_id, a.duplicate, a.join_seq, a.total_join_seq
  FROM a
        LEFT OUTER JOIN b ON (a.joined_polygon_number = b.joined_polygon_number AND a.coord_id = b.coord_id AND a.duplicate = b.duplicate)
 WHERE b.total IS NULL
 ORDER BY a.joined_polygon_number, a.coord_id, a.duplicate, a.join_seq;

UPDATE simplification_points a
   SET joined_join_seq = (
        SELECT join_seq
          FROM simplification_points_f b1
         WHERE a.joined_polygon_number = b1.joined_polygon_number
           AND a.coord_id       = b1.coord_id
           AND a.duplicate      = b1.duplicate);]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="l_geography" in="true" default-value="NULL::character varying">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_geolevel" in="true" default-value="1">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_filter" in="true" default-value="NULL::numeric">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_min_point_resolution" in="true">
		<type name="numeric"/>
	</parameter>
	<parameter name="l_st_simplify_tolerance" in="true">
		<type name="numeric"/>
	</parameter>
	<definition><![CDATA[
DECLARE
/*

Function: 	_simplify_geometry_phase_I()
Parameters:	Geography, geolevel, 
                geolevel; filter (for testing, no default), 
                minimum point resolution (default 1 - assumed metre, but depends on the geometry), 
                override for rif40_geoelvels.st_simplify_tolerance
Returns:	Nothing
Description:	Simplify geography geolevel - Phase I: Create the points table

Phase I: Create the points table

Test 0 for valid geometry
Create a sequence so that points are in the original order specified by ST_DumpPoints()
Create table simplification_points_a and convert geometry to points, reduce precision to <l_min_point_resolution>m
from the relevent geolevel geometry table. Give each polygon a separate polygon number

Test 11: Check there are 1 or more distinct areas in simplification_points_a (i.e. filter is not broken)
Print out polygon/points reports [limited to first 20 rows]

a) Print points per first two dimensions (i.e. [1] and [2])
b) Polygons per area
c) Multiple polygons

Test 1 - check last_pointflow = one per area (should be zero)

Create table simplification_points_b from simplification_points_a to:

a) Round first and last points in area (were not rounded in the previous step); convert to points
b) Create the variables needed to detect duplcates within co-ordinates (a side effect of the round in the previous statement)

Note that a duplicate co-ordinate is defined as being within an area_id and coordinate pair; polygons are ignored 
as self intersections were removed by ST_Buffer(geom, 0.0) during shapefile geometry load into the geography geometry table

The geometry is not checked for validity at this time; hence test 0 above. This is to allow the initial load
to complete even if there are uncorrectable errors in the geometry.

Create table simplification_points_c to detect and classify duplcates within co-ordinates (a side effect of the 
round) from simplification_points_b:

O: original - first or last point in area
N: Not a dupicate
Y: A dupicate (two or more consecutive points sharing the same co-ordinate); removed later
L: Loop duplicate (two or more NON consecutive points sharing the same co-ordinate)

Print duplicate flags
Print numbers of multiple loop and origin flags per area. There will only be one origin; but a small number  of multiple loops. 
Display first two "L" (loop) duplicates and the three rows either side
Test 2.1 for invalid duplicate flag: "?"
Create table simplification_points_d to count up number of distinct polygon_number using the same
co-ordinate from simplification_points_c

List by number of distinct polygon_number using the same co-ordinate

num_polygon_number (join type if >1)
------------------ -----------------

1            Outer edge (no join)
2            Join between two polygons
3            Triple point - junction of three polygons
...
N            Nth point - junction of N polygons

Test 2 for un-detected duplicates

Join up adjacent edges by update of simplification_points_d
List joins by number of distinct polygon_number using the same co-ordinate
List of joinable co-ordinates by duplicate type
Create table simplification_points_e to categorise join types from simplification_points_d:

 Join code	Description						Increment join sequence
 ---------	-----------						-----------------------
 A		Start of polygon					YES
 B		Junction						YES
 C		Junction (previous area_id)				YES
 D		Duplicate and change in area_id				YES
 V		End of polygon						NO
 W		next area_id == current, but previous != current	YES
		(Normally there is a three cornered point and this does not occur as there is a NULL in the next/prev area_id)
 X		next == current						NO
 Y		Previous area_id == current				NO
 Z		ELSE							YES

Create the points table: simplification_points from simplification_points_e adding in joinable points

Note that a duplicate co-ordinate is defined as being within an area_id and coordinate pair; polygons are ignored 
as self intersections were removed by ST_Buffer(geom, 0.0) during shapefile geometry load into the geography geometry table

The geometry is not checked for validity at this time; hence test 0 above. This is to allow the initial load
to complete even if there are uncorrectable errors in the geometry.

Test 3 and 4 - Checks - MUST BE 0
	
a) Areas with no join sequence
b) Areas with mis-joined sequences

Create a list of joined_polygon_numbers as temporary table simplification_points_f (i.e. the num_join_seq is 1)

Test 5: For join sequence(s) used by more than one polygon_number
Test 6: For polygon_number, coord_id, duplicate(s) used by more than one join sequence

Update simplification_points.joined_join_seq using joined_polygon_numbers in simplification_points_f (i.e. the num_join_seq is 1) 
joining on joined_polygon_number, coord_id and the duplicate flag

Display number of polygons and duplicate flag
Display number of polygons joined at a point (1=edge; 2=shared polygon boundary between 2 polygons; 3+: triple or more point)
List duplicates
Test 7: areas(s) with non unique join sequences.
 */
	c1_sI	CURSOR(l_geography VARCHAR) FOR
		SELECT *
		  FROM rif40_geographies
		 WHERE geography = l_geography;
	c2_sI CURSOR(l_geography VARCHAR, l_geolevel_name VARCHAR) FOR
		SELECT * 
		  FROM t_rif40_geolevels
		 WHERE geography = l_geography
		   AND geolevel_name = l_geolevel_name;
--
	c1_rec rif40_geographies%ROWTYPE;
	c2_rec t_rif40_geolevels%ROWTYPE;
--
	sql_stmt	VARCHAR[];
	l_sql_stmt	VARCHAR;
--
	stp TIMESTAMP WITH TIME ZONE;
	etp TIMESTAMP WITH TIME ZONE;
	took INTERVAL;
--
	rel_size BIGINT=0;
--
	st_simplify_tolerance	INTEGER;
BEGIN
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, '_simplify_geometry_phase_I', 'User % must be rif40 or have rif_manager role', 
			USER::VARCHAR	/* Username */);
	END IF;
--
	stp:=clock_timestamp();
--
	OPEN c1_sI(l_geography);
	FETCH c1_sI INTO c1_rec;
	CLOSE c1_sI;
	IF c1_rec.geography IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10091, '_simplify_geometry_phase_I', 'No geography specified');
	END IF;
	OPEN c2_sI(l_geography, l_geolevel);
	FETCH c2_sI INTO c2_rec;
	CLOSE c2_sI;
	IF c2_rec.geolevel_name IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10092, '_simplify_geometry_phase_I', 'No geolevel name specified for geography: %',
			l_geography::VARCHAR);
	ELSIF c1_rec.srid IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10094, '_simplify_geometry_phase_I', 'No srid specified for geography: % geolevel: %',
			l_geography::VARCHAR);
	ELSE
--
-- Set st_simplify_tolerance from param or rif40_geolevels table
--
		IF l_st_simplify_tolerance IS NULL THEN
			st_simplify_tolerance:=c2_rec.st_simplify_tolerance;
			PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_phase_I', 'Geography: % geolevel: %. Parameters - st_simplify_tolerance: % [default for geolevel]; units: %',
				l_geography::VARCHAR,
				l_geolevel::VARCHAR,
				c2_rec.st_simplify_tolerance::VARCHAR,
				rif40_geo_pkg.get_srid_projection_parameters(l_geography, '+units')::VARCHAR);
		ELSE
			st_simplify_tolerance:=l_st_simplify_tolerance;
			PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_phase_I', 'Geography: % geolevel: %. Parameters - st_simplify_tolerance: %  overides default for geolevel: %; units: %',
				l_geography::VARCHAR,
				l_geolevel::VARCHAR,
				l_st_simplify_tolerance::VARCHAR,
				c2_rec.st_simplify_tolerance::VARCHAR,
				rif40_geo_pkg.get_srid_projection_parameters(l_geography, '+units')::VARCHAR);
		END IF;
		IF st_simplify_tolerance IS NULL THEN
			PERFORM rif40_log_pkg.rif40_error(-10093, '_simplify_geometry_phase_I', 'No st_simplify_tolerance specified for geography: % geolevel: %',
				l_geography::VARCHAR,
				l_geolevel::VARCHAR);
		ELSIF st_simplify_tolerance < l_min_point_resolution THEN
			PERFORM rif40_log_pkg.rif40_error(-10097, '_simplify_geometry_phase_I', 'st_simplify_tolerance (%) specified for geography: % geolevel: % < l_min_point_resolution (%); units: %',
				st_simplify_tolerance::VARCHAR,
				l_geography::VARCHAR,
				l_geolevel::VARCHAR,
				l_min_point_resolution::VARCHAR,
				rif40_geo_pkg.get_srid_projection_parameters(l_geography, '+units')::VARCHAR);
		END IF;
	END IF;
--
	PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_phase_I', 'Phase I (points creation) for geography: % geolevel: %. Parameters - st_simplify_tolerance: %; l_min_point_resolution: %; units: %',
		l_geography::VARCHAR,
		l_geolevel::VARCHAR,
		st_simplify_tolerance::VARCHAR,
		l_min_point_resolution::VARCHAR,
		rif40_geo_pkg.get_srid_projection_parameters(l_geography, '+units')::VARCHAR);
--
-- Test 0 for valid geometry
--
	PERFORM rif40_geo_pkg._simplify_geometry_checks(l_geography, l_geolevel, 0);
--
-- Create a sequence so that points are in the original order specified by ST_DumpPoints()
--
	sql_stmt[1]:='DROP SEQUENCE IF EXISTS simplification_points_seq';
	sql_stmt[array_length(sql_stmt, 1)+1]:='DROP SEQUENCE IF EXISTS simplification_points_poly_seq';
	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE SEQUENCE simplification_points_seq';
	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE SEQUENCE simplification_points_poly_seq';
--
-- Create table simplification_points_a and convert geometry to points, reduce precision to <l_min_point_resolution>m
-- from the relevent geolevel geometry table
--
	sql_stmt[array_length(sql_stmt, 1)+1]:='DROP TABLE IF EXISTS simplification_points_a';
	l_sql_stmt:='EXPLAIN ANALYZE VERBOSE CREATE TEMPORARY TABLE simplification_points_a'||E'\n'||
'AS'||E'\n'||
'WITH a AS ('||E'\n'||
'        SELECT area_id,'||E'\n'||
'               ST_DumpPoints(shapefile_geometry) AS geometry_data,     /* Convert geometry to points */'||E'\n'||
'               nextval(''simplification_points_seq'') AS point_order_seq'||E'\n'||
'          FROM '||quote_ident('t_rif40_geolevels_geometry_'||LOWER(l_geography)||'_'||LOWER(l_geolevel))||E'\n'||
'         WHERE geolevel_name = '''||UPPER(l_geolevel)||''''||E'\n';
	IF l_filter IS NOT NULL THEN
		l_sql_stmt:=l_sql_stmt||E'\t'||'   AND '||l_filter||E'\n';
	END IF;
	sql_stmt[array_length(sql_stmt, 1)+1]:=l_sql_stmt||'), b /* Extract points and point order within a polygon */ AS ('||E'\n'||
'	SELECT area_id, point_order_seq /* Point order in shapefile */,'||E'\n'||
'	       (geometry_data).geom AS points,				/* Points component */'||E'\n'||
'	       (geometry_data).path AS path,				/* Path component */'||E'\n'||
'	       CASE'||E'\n'||
'			WHEN (geometry_data).path[3] = 1 /* OR */       /* New polygon */ '||E'\n'||
'		/*	     LAG((geometry_data).path[1]) OVER x < (geometry_data).path[1] OR'||E'\n'||
'			     LAG((geometry_data).path[2]) OVER x < (geometry_data).path[2] */ THEN nextval(''simplification_points_poly_seq'')'||E'\n'||
'			ELSE                                            /* Current polygon */      currval(''simplification_points_poly_seq'')'||E'\n'||
'	       END AS polygon_number'||E'\n'||
'	  FROM a'||E'\n'||
'	/* WINDOW x AS (ORDER BY point_order_seq) */'||E'\n'||
')'||E'\n'||
'SELECT area_id, polygon_number, path, '||E'\n'||
'       ST_MakePoint(ROUND(CAST(st_X(points) AS numeric), '||l_min_point_resolution||'),'||E'\n'||
'               ROUND(CAST(st_Y(points) AS numeric), '||l_min_point_resolution||')) /* Reduce precision to <l_min_point_resolution> m */ AS coordinate, '||E'\n'||
'       ROW_NUMBER() OVER w AS pointflow, '||E'\n'||
'       COUNT(point_order_seq) OVER w AS last_pointflow,'||E'\n'|| 
'       LAST_VALUE(points) OVER w AS lastpoint,                         /* Lastpoint should be the same as the first */'||E'\n'||
'       FIRST_VALUE(points) OVER w AS firstpoint                        /* firstpoint should be the same as the first */'||E'\n'||
'  FROM b'||E'\n'||
'	WINDOW w AS (PARTITION BY polygon_number ORDER BY point_order_seq RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)'||E'\n'||
'                    /* Disable window sliding (i.e. COUNT/LAST_VALUE works over the whole partition) */';
--
-- Total runtime: 108228.675 ms => 149895.648 ms (with ORDER BY)
-- Indexes are not efficient - PK implmented in the third step
--
-- Not used in tune
--
--	sql_stmt[array_length(sql_stmt, 1)+1]:='ALTER TABLE simplification_points_a ADD PRIMARY KEY(polygon_number, pointflow)';
-- 	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_a_coordinate ON simplification_points_a(coordinate)';
-- 	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_a_lastpoint ON simplification_points_a(last_pointflow)';
--
	sql_stmt[array_length(sql_stmt, 1)+1]:='ANALYZE simplification_points_a';
--
	sql_stmt[array_length(sql_stmt, 1)+1]:='DROP SEQUENCE simplification_points_seq';
	sql_stmt[array_length(sql_stmt, 1)+1]:='DROP SEQUENCE simplification_points_poly_seq';
--
-- Execute first block of SQL statements
--
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	rel_size:=rel_size+rif40_sql_pkg._print_table_size('simplification_points_a');
--
-- Test 11: Check there are 1 or more distinct areas in simplification_points_a (i.e. filter is not broken)
--
	PERFORM rif40_geo_pkg._simplify_geometry_checks(l_geography, l_geolevel, 11);
--
-- Check array dimensions are [1:3] as expected (Test 22)
--
PERFORM rif40_geo_pkg._simplify_geometry_checks(l_geography, l_geolevel, 22);
--
-- Print out polygon/points reports [limited to first 20 rows]
--
-- a) Print points per first two dimensions (i.e. [1] and [2])
--
	PERFORM rif40_sql_pkg.rif40_method4('SELECT path[1] AS path_1, path[2] AS path_2, COUNT(*)  AS total '||E'\n'|| 
'         FROM simplification_points_a GROUP BY path[1], path[2] LIMIT 10', 'Check array dimensions are [1:3] as expected');
/*
path_1     | path_2     | total               
-------------------------------------------------
8          | 1          | 23693               
1          | 1          | 487364              
4          | 1          | 307                 
7          | 1          | 123                 
3          | 1          | 29486               
5          | 1          | 344                 
2          | 1          | 107159              
6          | 1          | 44093               
(8 rows)
 */
--
-- b) Polygons per area
--
	PERFORM rif40_sql_pkg.rif40_method4('SELECT area_id, '||E'\n'|| 
'       MAX(pointflow) AS max_points, '||E'\n'||
'       MIN(polygon_number) AS min_polynum, MAX(polygon_number) AS max_polynum, COUNT(DISTINCT(polygon_number)) AS tot_polys'||E'\n'||
'  FROM simplification_points_a'||E'\n'||
' GROUP BY area_id'||E'\n'||
' ORDER BY MIN(polygon_number) LIMIT 20', 'Polygons per area');
/*
area_id                                  | max_points           | min_polynum          | max_polynum          | tot_polys           
---------------------------------------------------------------------------------------------------------------------------------------
00HG                                     | 5679                 | 1                    | 3                    | 3                   
00HH                                     | 2756                 | 4                    | 4                    | 1                   
00HA                                     | 13801                | 5                    | 5                    | 1                   
00HB                                     | 13541                | 6                    | 6                    | 1                   
00HN                                     | 4185                 | 7                    | 7                    | 1                   
00HC                                     | 10540                | 8                    | 9                    | 2                   
00HP                                     | 3774                 | 10                   | 10                   | 1                   
00HD                                     | 13719                | 11                   | 11                   | 1                   
00HX                                     | 8448                 | 12                   | 12                   | 1                   
15UH                                     | 44                   | 13                   | 13                   | 1                   
18UC                                     | 3009                 | 14                   | 14                   | 1                   
18UD                                     | 22904                | 15                   | 15                   | 1                   
18UE                                     | 24122                | 16                   | 16                   | 1                   
18UG                                     | 40614                | 17                   | 18                   | 2                   
15UB                                     | 22907                | 19                   | 20                   | 2                   
15UC                                     | 23040                | 21                   | 23                   | 3                   
15UD                                     | 25569                | 24                   | 25                   | 2                   
15UE                                     | 43967                | 26                   | 31                   | 6                   
15UF                                     | 23693                | 32                   | 39                   | 8                   
15UG                                     | 21136                | 40                   | 40                   | 1                   
(20 rows)
 */
--
-- c) Multiple polygons
--
	PERFORM rif40_sql_pkg.rif40_method4('WITH a AS /* Multiple polygons */ ('||E'\n'||
'	SELECT area_id, COUNT(DISTINCT(polygon_number)) AS tot_poly'||E'\n'||
'	  FROM simplification_points_a'||E'\n'||
'	 GROUP BY area_id'||E'\n'||
'	HAVING COUNT(DISTINCT(polygon_number)) > 1'||E'\n'||
')'||E'\n'||
'SELECT b.area_id, polygon_number, MIN(pointflow) AS min_points, MAX(pointflow) AS max_points, COUNT(pointflow) AS tot_points'||E'\n'||
'  FROM simplification_points_a b, a'||E'\n'||
' WHERE a.area_id = b.area_id'||E'\n'||
' GROUP BY b.area_id, polygon_number'||E'\n'||
' ORDER BY b.area_id, polygon_number LIMIT 20', 'Multiple polygons');
/*
area_id                                  | polygon_number       | min_points           | max_points           | tot_points          
---------------------------------------------------------------------------------------------------------------------------------------
00HC                                     | 8                    | 1                    | 305                  | 305                 
00HC                                     | 9                    | 1                    | 10540                | 10540               
00HG                                     | 1                    | 1                    | 182                  | 182                 
00HG                                     | 2                    | 1                    | 385                  | 385                 
00HG                                     | 3                    | 1                    | 5679                 | 5679                
15UB                                     | 19                   | 1                    | 427                  | 427                 
15UB                                     | 20                   | 1                    | 22907                | 22907               
15UC                                     | 21                   | 1                    | 47                   | 47                  
15UC                                     | 22                   | 1                    | 151                  | 151                 
15UC                                     | 23                   | 1                    | 23040                | 23040               
15UD                                     | 24                   | 1                    | 228                  | 228                 
15UD                                     | 25                   | 1                    | 25569                | 25569               
15UE                                     | 26                   | 1                    | 79                   | 79                  
15UE                                     | 27                   | 1                    | 95                   | 95                  
15UE                                     | 28                   | 1                    | 717                  | 717                 
15UE                                     | 29                   | 1                    | 104                  | 104                 
15UE                                     | 30                   | 1                    | 214                  | 214                 
15UE                                     | 31                   | 1                    | 43967                | 43967               
15UF                                     | 32                   | 1                    | 82                   | 82                  
15UF                                     | 33                   | 1                    | 112                  | 112                 
(20 rows)
 */
--
-- Test 1 - check last_pointflow = one per area (should be zero)
--
	PERFORM rif40_geo_pkg._simplify_geometry_checks(l_geography, l_geolevel, 1);
--
-- Second block of SQL statements
--
	sql_stmt:=NULL;	/* Empty statement array */
-- 
-- Create table simplification_points_b from simplification_points_a to:
-- a) Round first and last points in area (were not rounded in the previous step); convert to points
-- b) Create the variables needed to detect duplcates within co-ordinates (a side effect of the round in the previous statement)
--
	sql_stmt[1]:='DROP TABLE IF EXISTS simplification_points_b';
	sql_stmt[array_length(sql_stmt, 1)+1]:='EXPLAIN ANALYZE VERBOSE CREATE TEMPORARY TABLE simplification_points_b'||E'\n'||
'AS'||E'\n'||
'SELECT area_id, pointflow, polygon_number, last_pointflow,'||E'\n'||
'       ST_MakePoint(ROUND(CAST(st_X(firstpoint) AS numeric), '||l_min_point_resolution||'),
		ROUND(CAST(st_Y(firstpoint) AS numeric), '||l_min_point_resolution||')) AS firstpoint,	/* Convert firstpoint to POINT() datatype */'||E'\n'||
'       ST_MakePoint(ROUND(CAST(st_X(lastpoint) AS numeric), '||l_min_point_resolution||'),
		ROUND(CAST(st_Y(lastpoint) AS numeric), '||l_min_point_resolution||')) AS lastpoint,	/* Convert lastpoint to POINT() datatype */'||E'\n'||
'       coordinate,'||E'\n'||
'       COUNT(pointflow) OVER w AS tot_dup_coords, 		/* Total duplicate co-ordinates within an area_id and coordinate pair */'||E'\n'||
'       LAG(pointflow) OVER w AS prev_pointflow, 		/* Previous pointflow within a duplicate */'||E'\n'||
'       LEAD(polygon_number) OVER w AS next_polygon_number, 	/* Next polygon_number */'||E'\n'||
'       LAG(polygon_number) OVER w AS prev_polygon_number, 	/* Previous polygon_number */'||E'\n'||
'       ROW_NUMBER() OVER w AS dup_coord_order 			/* Find pointflows with the same coordinate [i.e. side effect of the ROUND()] */'||E'\n'||
'  FROM simplification_points_a'||E'\n'||
'WINDOW w AS (PARTITION BY polygon_number, coordinate ORDER BY pointflow)'||E'\n'||
' ORDER BY coordinate, polygon_number /* Optimise index: simplification_points_b_coordinate; not the primary key */';
--
-- Note that a duplicate co-ordinate is defined as being within an area_id and coordinate pair; polygons are ignored 
-- as self intersections were removed by ST_Buffer(geom, 0.0) during shapefile geometry load into the geography geometry table
--
-- The geometry is not checked for validity at this time; hence test 0 above. This is to allow the initial load
-- to complete even if there are uncorrectable errors in the geometry.
--
--
-- PK(simplification_points_b_pkey) was used, simplification_points_b_pointflow_last_pointflow in preference
-- 
--	sql_stmt[array_length(sql_stmt, 1)+1]:='ALTER TABLE simplification_points_b ADD PRIMARY KEY(polygon_number, pointflow)';
--
-- Added for tune
--
	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_b_area_id ON simplification_points_b(area_id)';
	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_b_pointflow_last_pointflow ON simplification_points_b(pointflow, last_pointflow)';
-- None of these improved matters
--	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_b_coordinate ON simplification_points_b(coordinate)';
--	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_b_lastpoint_coordinate ON simplification_points_b(lastpoint, coordinate)';
--	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_b_coord_last_pointflow ON simplification_points_b(coordinate, last_pointflow)';
--	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_b_last_pointflow ON simplification_points_b(last_pointflow)';
--	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_b_pointflow ON simplification_points_b(pointflow)';
--	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_b_lastpoint ON simplification_points_b(lastpoint)';
--	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_b_firstpoint ON simplification_points_b(firstpoint)';
--
-- Unable to fix CTE b full table scan - need to find out why the optimiser ignored the indexes (i.e. 10054 type trace). An Oracle trace would have:
--
-- HASH(join)
--   HASH(join)
--     INDEX RANGE SCAN(last_pointflow)
--     INDEX RANGE SCAN(pointflow)
--   HASH(join)
--     INDEX RANGE SCAN(coordinate)
--     INDEX RANGE SCAN(lastpoint)
--
-- Or with composite indexes:
--
--   HASH(join)
--     INDEX FAST FULL SCAN(last_pointflow, pointflow)
--     INDEX FAST FULL SCAN(coordinate, lastpoint)
--
/*
[WITH] b AS (
	SELECT area_id, coordinate AS lastpoint, pointflow AS last_pointflow
	  FROM simplification_points_b
	 WHERE last_pointflow = pointflow AND coordinate = lastpoint
)

  CTE b
    ->  Seq Scan on pg_temp_2.simplification_points_b  (cost=0.00..182218.22 rows=26 width=151) (actual time=1.945..1637.435 rows=3380 loops=1)
          Output: pg_temp_2.simplification_points_b.area_id, pg_temp_2.simplification_points_b.coordinate, pg_temp_2.simplification_points_b.pointflow
          Filter: ((pg_temp_2.simplification_points_b.coordinate = pg_temp_2.simplification_points_b.lastpoint) AND (pg_temp_2.simplification_points_b.last_pointflow = pg_temp_2.simplification_points_b.pointflow))
 */
 	sql_stmt[array_length(sql_stmt, 1)+1]:='DROP TABLE simplification_points_a';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ANALYZE simplification_points_b';
-- 164s for WARD in London
--
-- Create table simplification_points_c to detect and classify duplcates within co-ordinates (a side effect of the 
-- round) from simplification_points_b:
--
-- O: original - first or last point in area
-- N: Not a duplicate
-- Y: A duplicate (two or more consecutive points sharing the same co-ordinate); removed later
-- L: Loop duplicate (two or more NON consecutive points sharing the same co-ordinate)
--
	sql_stmt[array_length(sql_stmt, 1)+1]:='DROP TABLE IF EXISTS simplification_points_c';
	sql_stmt[array_length(sql_stmt, 1)+1]:='EXPLAIN ANALYZE VERBOSE CREATE TEMPORARY TABLE simplification_points_c'||E'\n'||
'AS'||E'\n'||
'WITH a /* First point in polygon_number */ AS ('||E'\n'||
'	SELECT polygon_number, coordinate AS firstpoint, pointflow AS first_pointflow'||E'\n'||
'	  FROM simplification_points_b'||E'\n'||
'	 WHERE pointflow = 1 AND coordinate = firstpoint'||E'\n'||
'), b /* Last point in polygon */ AS ('||E'\n'||
'	SELECT polygon_number, coordinate AS lastpoint, pointflow AS last_pointflow'||E'\n'||
'	  FROM simplification_points_b'||E'\n'||
'	 WHERE last_pointflow = pointflow AND coordinate = lastpoint'||E'\n'||
'), c /* Total polygons */ AS ('||E'\n'||
'	SELECT DISTINCT polygon_number'||E'\n'||
'	  FROM simplification_points_b'||E'\n'||
'), d AS ('||E'\n'||
'	SELECT c.polygon_number,'||E'\n'||
'       	       CASE WHEN a.firstpoint = b.lastpoint THEN 1 ELSE 0 END origin_verified'||E'\n'||
'	  FROM c'||E'\n'||
'	 	LEFT OUTER JOIN a ON (c.polygon_number = a.polygon_number)'||E'\n'||
' 		LEFT OUTER JOIN b ON (c.polygon_number = b.polygon_number)'||E'\n'||
')'||E'\n'||
'SELECT area_id, e.polygon_number, prev_polygon_number, pointflow, last_pointflow, tot_dup_coords, dup_coord_order, prev_pointflow, origin_verified,'||E'\n'||
'      DENSE_RANK() OVER (ORDER BY coordinate) AS coord_id,		/* Add coordinate index number per geolevel */'||E'\n'||
'      coordinate,'||E'\n'||
'      CASE 								/* Is co-ordinate a duplicate within a polygon? */'||E'\n'||
'		WHEN pointflow = 1 AND coordinate = firstpoint  THEN                                       ''O'' /* Origin */'||E'\n'||
'		WHEN last_pointflow = pointflow AND coordinate = lastpoint AND d.origin_verified = 1 THEN  ''E'' /* End (same as Origin) */ '||E'\n'||
'		WHEN tot_dup_coords = 1 OR (tot_dup_coords > 1  AND dup_coord_order = 1) THEN              ''N'' /* No */'||E'\n'||
'		WHEN tot_dup_coords > 1 AND dup_coord_order > 1 AND'||E'\n'||
'		        prev_pointflow + 1 = pointflow THEN                                                ''Y'' /* Yes */'||E'\n'||
'		WHEN tot_dup_coords > 1 AND dup_coord_order > 1 AND '||E'\n'||
'			prev_pointflow IS NOT NULL AND prev_pointflow + 1 != pointflow THEN                ''L'' /* Loop */'||E'\n'||
'		ELSE                                                                                       ''?'' /* Unknown */'||E'\n'||
'      END duplicate							/* Flag duplicates */'||E'\n'||
'  FROM simplification_points_b e, d'||E'\n'||
' WHERE e.polygon_number = d.polygon_number'||E'\n'||
' ORDER BY coord_id, polygon_number /* Sort order in next statement */';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ALTER TABLE simplification_points_c ADD PRIMARY KEY(polygon_number, pointflow)';
--
-- Added for tune
--
	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_c_coord_id ON simplification_points_c(coord_id)';
--
-- Not needed - OK to remove - try again with multi polygon mode
--	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_c_polygon_number ON simplification_points_c(polygon_number)';
-- 
	sql_stmt[array_length(sql_stmt, 1)+1]:='ANALYZE simplification_points_c';
--
-- Execute second block of SQL statements
--
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	rel_size:=rel_size+rif40_sql_pkg._print_table_size('simplification_points_b');
	rel_size:=rel_size+rif40_sql_pkg._print_table_size('simplification_points_c');
--
-- Print duplicate flags
--
	PERFORM rif40_sql_pkg.rif40_method4('SELECT duplicate, COUNT(DISTINCT(polygon_number)) AS t_polys, COUNT(polygon_number) AS t_points'||E'\n'||
'  FROM simplification_points_c'||E'\n'||
' GROUP BY duplicate', 'Print duplicate flags');
/*
duplicate | t_polys              | t_points            
----------------------------------------------------------
E         | 66                   | 66                  
L         | 14                   | 23                  
N         | 66                   | 679904              
O         | 66                   | 66                  
Y         | 60                   | 12510               
(5 rows)              
 */
--
-- Print numbers of multiple loop and origin flags per area
-- There will only be one origin; but a small number  of multiple loops. 
--
	PERFORM rif40_sql_pkg.rif40_method4('WITH a AS ('||E'\n'||
'	SELECT duplicate, polygon_number, COUNT(duplicate) AS t_duplicate'||E'\n'||
'	  FROM simplification_points_c'||E'\n'||
'	 WHERE duplicate IN (''O'' /* Origin */, ''L'' /* Loop */)'||E'\n'||
'	 GROUP BY duplicate, polygon_number'||E'\n'||
')'||E'\n'||
'SELECT duplicate, t_duplicate, COUNT(DISTINCT(polygon_number)) AS t_polys, COUNT(polygon_number) AS t_points'||E'\n'||
'  FROM a'||E'\n'||
' GROUP BY duplicate, t_duplicate', 'Print numbers of multiple loop and origin flags per area');
/*
duplicate | t_duplicate          | t_polys              | t_points            
---------------------------------------------------------------------------------
L         | 1                    | 7                    | 7                   
L         | 2                    | 5                    | 5                   
L         | 3                    | 2                    | 2                   
O         | 1                    | 66                   | 66                  
(4 rows)
 */
--
-- Display first two 'L' (loop) duplicates and the three rows either side
--
	PERFORM rif40_sql_pkg.rif40_method4('WITH a AS ('||E'\n'||
'	SELECT polygon_number, pointflow'||E'\n'||
' 	  FROM simplification_points_c'||E'\n'||
'	 WHERE duplicate = ''L'' LIMIT 2'||E'\n'||
'), b AS ('||E'\n'||
'	SELECT polygon_number, pointflow-3 AS pointflow'||E'\n'||
'	  FROM a'||E'\n'||
'	UNION'||E'\n'||
'	SELECT polygon_number, pointflow-2'||E'\n'||
'	  FROM a'||E'\n'||
'	UNION'||E'\n'||
'	SELECT polygon_number, pointflow-1'||E'\n'||
'	  FROM a'||E'\n'||
'	UNION'||E'\n'||
'	SELECT polygon_number, pointflow'||E'\n'||
'	  FROM a'||E'\n'||
'	UNION'||E'\n'||
'	SELECT polygon_number, pointflow+1'||E'\n'||
'	  FROM a'||E'\n'||
'	UNION'||E'\n'||
'	SELECT polygon_number, pointflow+2'||E'\n'||
'	  FROM a'||E'\n'||
'	UNION'||E'\n'||
'	SELECT polygon_number, pointflow+3'||E'\n'||
'	  FROM a'||E'\n'||
')'||E'\n'||
'SELECT area_id, c.polygon_number AS poly_no, c.pointflow,'||E'\n'||
'       last_pointflow AS last_pf, tot_dup_coords, dup_coord_order AS dup_co, prev_pointflow AS prev_pf, origin_verified AS orig_ver,'||E'\n'||
'       duplicate, coord_id'||E'\n'||
'  FROM simplification_points_c c, b'||E'\n'||
' WHERE b.pointflow      = c.pointflow'||E'\n'||
'   AND b.polygon_number = c.polygon_number'||E'\n'||
' ORDER BY area_id, c.polygon_number, c.pointflow', 'Display first two ''L'' (loop) duplicates and the three rows either side');

/*
 area_id | poly_no | pointflow | last_pf | tot_dup_coords | dup_co | prev_pf | orig_ver | duplicate | coord_id 
---------+---------+-----------+---------+----------------+--------+---------+----------+-----------+----------
 15UE    |      31 |     20751 |   43967 |              1 |      1 |         |        1 | N         |    62605
 15UE    |      31 |     20752 |   43967 |              1 |      1 |         |        1 | N         |    62625
 15UE    |      31 |     20753 |   43967 |              1 |      1 |         |        1 | N         |    62626
 15UE    |      31 |     20754 |   43967 |              2 |      2 |   20752 |        1 | L         |    62625
 15UE    |      31 |     20755 |   43967 |              1 |      1 |         |        1 | N         |    62612
 15UE    |      31 |     20756 |   43967 |              1 |      1 |         |        1 | N         |    62611
 15UE    |      31 |     20757 |   43967 |              1 |      1 |         |        1 | N         |    62583
 15UF    |      39 |      9615 |   23693 |              1 |      1 |         |        1 | N         |     6915
 15UF    |      39 |      9616 |   23693 |              1 |      1 |         |        1 | N         |     6902
 15UF    |      39 |      9617 |   23693 |              1 |      1 |         |        1 | N         |     6903
 15UF    |      39 |      9618 |   23693 |              2 |      2 |    9616 |        1 | L         |     6902
 15UF    |      39 |      9619 |   23693 |              1 |      1 |         |        1 | N         |     6904
 15UF    |      39 |      9620 |   23693 |              1 |      1 |         |        1 | N         |     6898
 15UF    |      39 |      9621 |   23693 |              1 |      1 |         |        1 | N         |     6929
(14 rows)
 */
--
-- Test 2.1 for invalid duplicate flag: '?'
--
	PERFORM rif40_geo_pkg._simplify_geometry_checks(l_geography, l_geolevel, 21);
--
-- Third block of SQL statements
--
	sql_stmt:=NULL;	/* Empty statement array */
--
-- Create table simplification_points_d to count up number of distinct polygon_number using the same co-ordinate from simplification_points_c
--
	sql_stmt[1]:='DROP TABLE IF EXISTS simplification_points_d';
	sql_stmt[array_length(sql_stmt, 1)+1]:='DROP TABLE simplification_points_b';
	sql_stmt[array_length(sql_stmt, 1)+1]:='EXPLAIN ANALYZE VERBOSE CREATE TEMPORARY TABLE simplification_points_d'||E'\n'||
'AS'||E'\n'||
'WITH f AS ('||E'\n'||
'	SELECT coord_id,'||E'\n'||
'	       COUNT(DISTINCT(polygon_number)) AS num_polygon_number	/* Count up number of distinct polygons using the same co-ordinate */'||E'\n'||	
'	 FROM simplification_points_c'||E'\n'||
'	 GROUP BY coord_id'||E'\n'||
') '||E'\n'||
'SELECT area_id, polygon_number, pointflow, e.coord_id, coordinate, tot_dup_coords, dup_coord_order, prev_pointflow, duplicate,'||E'\n'||
'       f.num_polygon_number'||E'\n'||
'  FROM  simplification_points_c e'||E'\n'||
'		LEFT OUTER JOIN f ON (e.coord_id = f.coord_id)'||E'\n'||
' ORDER BY polygon_number, pointflow';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ALTER TABLE simplification_points_d ADD PRIMARY KEY(polygon_number, pointflow)';
	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_d_coord_id ON simplification_points_d(coord_id)';
--
-- Added for tune
--
	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_d_polygon_number ON simplification_points_d(polygon_number)';
--
-- None of these improved matters
--
--	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_d_num_polygon_number ON simplification_points_d(num_polygon_number)';
--	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_d_duplicate ON simplification_points_d(duplicate)';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ALTER TABLE simplification_points_d ADD joined_polygon_number VARCHAR(300)';
	sql_stmt[array_length(sql_stmt, 1)+1]:='DROP TABLE simplification_points_c';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ANALYZE simplification_points_d';
--
-- Execute third block of SQL statements
--
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- List by number of distinct polygon_number using the same co-ordinate
--
	PERFORM rif40_sql_pkg.rif40_method4('WITH a AS ('||E'\n'||
'	SELECT COUNT(coord_id) AS total_coords'||E'\n'||
' 	  FROM simplification_points_d'||E'\n'||
')'||E'\n'||
'SELECT num_polygon_number	/* Count of distinct polygons using the same co-ordinate */,'||E'\n'||
'       COUNT(num_polygon_number) AS num_coords,'||E'\n'||
'       ROUND((CAST(COUNT(num_polygon_number) AS numeric)/a.total_coords)*100.0, 4) AS pct'||E'\n'||
'  FROM simplification_points_d, a'||E'\n'||
' GROUP BY num_polygon_number, a.total_coords'||E'\n'||
' ORDER BY num_polygon_number', 'List by number of distinct polygon_number using the same co-ordinate');
/*
num_polygon_number   | num_coords           | pct
----------------------------------------------------
1                    | 245339               | 35.
2                    | 447043               | 64.
3                    | 187                  | 0.0
 */
--
-- num_polygon_number (join type if >1)
-- ------------------ -----------------
--
-- 1                  Outer edge (no join)
-- 2                  Join between two polygons
-- 3                  Triple point - junction of three polygons
-- ...
-- N            Nth point - junction of N polygons
--
-- Test 2 for un-detected duplicates
--
	PERFORM rif40_geo_pkg._simplify_geometry_checks(l_geography, l_geolevel, 2);
--
-- Fourth block of SQL statements
--
	sql_stmt:=NULL;	/* Empty statement array */
--
-- Join up adjacent edges by update of simplification_points_d
--
/*
Update on pg_temp_2.simplification_points_d g1  (cost=0.00..16936.95 rows=1438 width=197) (actual time=9.395..9.395 rows=0 loops=1)
  ->  Index Scan using simplification_points_d_polygon_number on pg_temp_2.simplification_points_d g1  (cost=0.00..16936.95 rows=1438 width=197) (actual time=0.075..2.242 rows=380 loops=1)
        Output: g1.area_id, g1.polygon_number, g1.pointflow, g1.coord_id, g1.coordinate, g1.tot_dup_coords, g1.dup_coord_order, g1.prev_pointflow, g1.duplicate, g1.num_polygon_number, (SubPlan 1), g1.ctid
        Index Cond: (g1.polygon_number = 2)
        Filter: (g1.duplicate = ANY ('{N,O,L}'::text[]))
        SubPlan 1
          ->  Unique  (cost=0.00..11.72 rows=1 width=8) (actual time=0.003..0.004 rows=1 loops=380)
                Output: g2.polygon_number
                ->  Index Scan using simplification_points_d_coord_id on pg_temp_2.simplification_points_d g2  (cost=0.00..11.71 rows=1 width=8) (actual time=0.003..0.003 rows=1 loops=380)
                      Output: g2.polygon_number
                      Index Cond: (g1.coord_id = g2.coord_id)
                      Filter: ((g1.polygon_number = g2.polygon_number) AND ((g1.duplicate = g2.duplicate) OR ((g1.duplicate = 'N'::text) AND (g2.duplicate = 'O'::text)) OR ((g1.duplicate = 'O'::text) AND (g2.duplicate = 'N'::text))))
Total runtime: 9.433 ms
 */
-- 
-- This code does NOT handle polygon outside edges (i.e. where num_polygon_number = 1)
--
	sql_stmt[1]:='EXPLAIN ANALYZE VERBOSE UPDATE simplification_points_d g1'||E'\n'||
'   SET joined_polygon_number = ('||E'\n'||
'	SELECT DISTINCT g2.polygon_number AS joined_polygon_number'||E'\n'||
'	  FROM simplification_points_d g2'||E'\n'||
'         WHERE g1.num_polygon_number = g2.num_polygon_number			/* Join type matches */'||E'\n'||
'	    AND g1.coord_id           = g2.coord_id 				/* Co-ordinates are the same */'||E'\n'||
'	    AND g1.polygon_number    != g2.polygon_number         		/* Polygons are NOT the same */'||E'\n'||
'	    AND ('||E'\n'||
'		 (g1.duplicate        = g2.duplicate) OR 			/* Duplicate flags match */'||E'\n'||
'		 (g1.duplicate        = ''N'' AND g2.duplicate = ''O'') OR 	/* Handle different origins */'||E'\n'||
'		 (g1.duplicate        = ''O'' AND g2.duplicate = ''N'')'||E'\n'||
'               )'||E'\n'||
'	)'||E'\n'||
' WHERE g1.num_polygon_number = 2	/* Join points shared between two polygons only - i.e. shares linestrings */'||E'\n'||
'   AND g1.duplicate IN (''N'' /* Not a duplicate */, ''O'' /* Origin */, ''L'' /* Loop */)';
--
	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_d_joined_polygon_number ON simplification_points_d(joined_polygon_number)';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ANALYZE simplification_points_d';
--
-- Execute fourth block of SQL statements
--
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- List joins by number of distinct polygon_number using the same co-ordinate
--
	PERFORM rif40_sql_pkg.rif40_method4('WITH a AS ('||E'\n'||
'	SELECT COUNT(coord_id) AS total_coords'||E'\n'||
' 	  FROM simplification_points_d'||E'\n'||
')'||E'\n'||
'SELECT num_polygon_number	/* Count of distinct polygons using the same co-ordinate */,'||E'\n'||
'       COUNT(num_polygon_number) AS num_coords,'||E'\n'||
'       COUNT(joined_polygon_number) AS num_joined_coords,'||E'\n'||
'       ROUND((CAST(COUNT(joined_polygon_number) AS numeric)/a.total_coords)*100.0, 4) AS pct_joined'||E'\n'||
'  FROM simplification_points_d, a'||E'\n'||
' GROUP BY num_polygon_number, a.total_coords'||E'\n'||
' ORDER BY num_polygon_number', 'List joins by number of distinct polygon_number using the same co-ordinate');
/*
num_polygon_number   | num_coords           | num_joined_coords    | pct_joined
----------------------------------------------------------------------------------
1                    | 245339               | 0                    | 0.0000    
2                    | 447043               | 439422               | 63.4481   
3                    | 187                  | 0                    | 0.0000  
 */
--
-- List of joinable co-ordinates by duplicate type
--
	PERFORM rif40_sql_pkg.rif40_method4('WITH b AS ('||E'\n'||
'	SELECT COUNT(duplicate) AS gtotal'||E'\n'||
'	  FROM simplification_points_d'||E'\n'||
')'||E'\n'||
'SELECT duplicate,'||E'\n'||
'       CASE'||E'\n'||
'		WHEN duplicate IN (''N'' /* Not a duplicate */, ''O'' /* Origin */, ''L'' /* Loop */) AND'||E'\n'||
'		     polygon_number IN (1, 2) THEN ''Joinable: ''||tot_dup_coords::Text'||E'\n'||
'		ELSE                               ''Not Joinable: ''||tot_dup_coords::Text'||E'\n'||
'       END join_type,'||E'\n'||
'       COUNT(pointflow) AS points,'||E'\n'||
'       COUNT(DISTINCT(polygon_number)) AS polygons,'||E'\n'||
'       ROUND((CAST(COUNT(pointflow) AS numeric)/b.gtotal)*100.0, 4) AS pct_points,'||E'\n'||
'       SUM(CASE WHEN duplicate = ''Y'' THEN 1 ELSE 0 END) AS tot_dups,'||E'\n'||
'       ROUND((CAST(SUM(CASE WHEN duplicate = ''Y'' THEN 1 ELSE 0 END) AS numeric)/b.gtotal)*100.0, 4) AS pct_dup,'||E'\n'||
'       COUNT(joined_polygon_number) AS tot_joined, ROUND((CAST(COUNT(joined_polygon_number) AS numeric)/b.gtotal)*100.0, 4) AS pct_joined,'||E'\n'||
'       COUNT(pointflow)- COUNT(joined_polygon_number) AS tot_unjoined,'||E'\n'|| 
'       ROUND((CAST(COUNT(pointflow)- COUNT(joined_polygon_number) AS numeric)/b.gtotal)*100.0, 4) AS pct_unjoined'||E'\n'||
'  FROM simplification_points_d, b'||E'\n'||
' GROUP BY duplicate,'||E'\n'|| 
'       CASE'||E'\n'|| 
'		WHEN duplicate IN (''N'' /* Not a duplicate */, ''O'' /* Origin */, ''L'' /* Loop */) AND'||E'\n'||
'		     polygon_number IN (1, 2) THEN ''Joinable: ''||tot_dup_coords::Text'||E'\n'||
'		ELSE                               ''Not Joinable: ''||tot_dup_coords::Text'||E'\n'|| 
'       END,'||E'\n'||
'       b.gtotal'||E'\n'||
' ORDER BY 1, 2', 'List of joinable co-ordinates by duplicate type');
/*
duplicate | join_type | points               | polygons             | pct_points | tot_dups             | pct_dup | tot_joined           | pct_joined | tot_unjoined         | pct_unjoined
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
E         | "Not Join | 60                   | 60                   | 0.0087     | 0                    | 0.0000  | 0                    | 0.0000     | 60                   | 0.0087      
E         | "Not Join | 6                    | 6                    | 0.0009     | 0                    | 0.0000  | 0                    | 0.0000     | 6                    | 0.0009      
L         | "Not Join | 23                   | 14                   | 0.0033     | 0                    | 0.0000  | 6                    | 0.0009     | 17                   | 0.0025      
N         | "Joinable | 379                  | 1                    | 0.0547     | 0                    | 0.0000  | 0                    | 0.0000     | 379                  | 0.0547      
N         | "Not Join | 679525               | 65                   | 98.1166    | 0                    | 0.0000  | 439383               | 63.4425    | 240142               | 34.6741     
O         | "Joinable | 1                    | 1                    | 0.0001     | 0                    | 0.0000  | 0                    | 0.0000     | 1                    | 0.0001      
O         | "Not Join | 65                   | 65                   | 0.0094     | 0                    | 0.0000  | 33                   | 0.0048     | 32                   | 0.0046      
Y         | "Not Join | 12060                | 60                   | 1.7413     | 12060                | 1.7413  | 0                    | 0.0000     | 12060                | 1.7413      
Y         | "Not Join | 447                  | 41                   | 0.0645     | 447                  | 0.0645  | 0                    | 0.0000     | 447                  | 0.0645      
Y         | "Not Join | 3                    | 3                    | 0.0004     | 3                    | 0.0004  | 0                    | 0.0000     | 3                    | 0.0004      
(10 rows)
 */

--
-- Fifth block of SQL statements
--
	sql_stmt:=NULL;	/* Empty statement array */
--
-- Create table simplification_points_e to categorise join types from simplification_points_d:
--
-- Join code	Description						Increment join sequence
-- ---------	-----------						-----------------------
-- A		Start of polygon					YES
-- B		Junction						YES
-- C		Junction (previous polygon_number)			YES
-- D		Loop duplicate and change in polygon_number		YES
-- V		End of polygon						NO
-- W		next polygon_number == current, but previous != current	YES
--		(Normally there is a three cornered point and this does not occur as there is a NULL in the next/prev polygon_number)
-- X		next == current						NO
-- Y		Previous polygon_number == current			NO
-- Z		ELSE							YES
--

	sql_stmt[1]:='DROP TABLE IF EXISTS simplification_points_e';
	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE SEQUENCE simplification_points_seq';
	sql_stmt[array_length(sql_stmt, 1)+1]:='EXPLAIN ANALYZE VERBOSE CREATE TEMPORARY TABLE simplification_points_e'||E'\n'||
'AS'||E'\n'||
'WITH a AS ('||E'\n'||
'	SELECT area_id, polygon_number, pointflow, coord_id, coordinate, duplicate, num_polygon_number, joined_polygon_number,'||E'\n'||
'	       LAG(polygon_number) OVER w 		AS prev_polygon_number,'||E'\n'||
'	       LAG(num_polygon_number) OVER w 		AS prev_num_polygon_number,'||E'\n'||
'	       LAG(pointflow) OVER w 			AS prev_pointflow,'||E'\n'||
'	       LAG(joined_polygon_number) OVER w 	AS prev_joined_polygon_number,'||E'\n'||
'	       LEAD(pointflow) OVER w 			AS next_pointflow,'||E'\n'||
'	       LEAD(joined_polygon_number) OVER w 	AS next_joined_polygon_number,'||E'\n'||
'	       LEAD(polygon_number) OVER w 		AS next_polygon_number,'||E'\n'||
'	       LEAD(num_polygon_number) OVER w 		AS next_num_polygon_number'||E'\n'||
'	  FROM simplification_points_d'||E'\n'||
'	 WHERE duplicate NOT IN(''E'', ''Y'')		/* Exclude end point and duplicates */'||E'\n'||
'	WINDOW w AS (PARTITION BY polygon_number ORDER BY pointflow)'||E'\n'||
')'||E'\n'||
'SELECT area_id, polygon_number::bigint, pointflow::bigint, duplicate, coord_id::bigint, coordinate, num_polygon_number::bigint, joined_polygon_number::bigint,'||E'\n'||
'       next_polygon_number::bigint, next_pointflow::bigint, next_joined_polygon_number::bigint,'||E'\n'||
'       prev_polygon_number::bigint, prev_pointflow::bigint, prev_joined_polygon_number::bigint,'||E'\n'||
'       CASE'||E'\n'|| 
'		WHEN pointflow = 1                                              THEN ''A'' /* nextval: start */'||E'\n'||
'		WHEN num_polygon_number > 2                                     THEN ''B'' /* nextval: junction */'||E'\n'||
'		WHEN prev_num_polygon_number > 2                                THEN ''C'' /* nextval: junction */'||E'\n'||
'		WHEN duplicate = ''L'' AND next_joined_polygon_number IS NULL   THEN ''D'' /* nextval: duplicate and change in polygon_number */'||E'\n'||
'		WHEN num_polygon_number = 1 AND next_num_polygon_number = 1     THEN ''E'' /* currval: outside edge */'||E'\n'||
'		WHEN pointflow != 1 AND duplicate = ''O''                       THEN ''V'' /* currval: end */'||E'\n'||
'		WHEN polygon_number  = next_polygon_number AND joined_polygon_number = next_joined_polygon_number'||E'\n'|| 
'			AND joined_polygon_number != prev_joined_polygon_number THEN ''W'' /* nextval: next == current, but previous != current */'||E'\n'||
'			/* Normally there is a three cornered point and this does not occur as there is a NULL in the next/prev polygon_number */'||E'\n'||
'		WHEN polygon_number  = next_polygon_number AND'||E'\n'|| 
'			joined_polygon_number = next_joined_polygon_number      THEN ''X'' /* currval: next == current */'||E'\n'||
'		WHEN polygon_number  = prev_polygon_number AND'||E'\n'|| 
'			joined_polygon_number = prev_joined_polygon_number      THEN ''Y'' /* currval: previous == current */'||E'\n'||
'		ELSE ''Z'' /* nextval */'||E'\n'||
'       END join_code,'||E'\n'||
'       CASE'||E'\n'|| 
'		WHEN pointflow = 1                                              THEN nextval(''simplification_points_seq'') /* nextval: start */'||E'\n'||
'		WHEN num_polygon_number > 2                                     THEN nextval(''simplification_points_seq'') /* nextval: junction */'||E'\n'||
'		WHEN prev_num_polygon_number > 2                                THEN nextval(''simplification_points_seq'') /* nextval: junction */'||E'\n'||
'		WHEN duplicate = ''L'' AND next_joined_polygon_number IS NULL   THEN nextval(''simplification_points_seq'') /* nextval: duplicate and change in polygon_number */'||E'\n'||
'		WHEN num_polygon_number = 1 AND next_num_polygon_number = 1     THEN currval(''simplification_points_seq'') /* currval: outside edge */'||E'\n'||
'		WHEN pointflow != 1 AND duplicate = ''O''                       THEN currval(''simplification_points_seq'') /* currval: end */'||E'\n'||
'		WHEN polygon_number  = next_polygon_number AND joined_polygon_number = next_joined_polygon_number'||E'\n'|| 
'			AND joined_polygon_number != prev_joined_polygon_number THEN nextval(''simplification_points_seq'') /* nextval: next == current, but previous != current */'||E'\n'||
'			/* Normally there is a three cornered point and this does not occur as there is a NULL in the next/prev polygon_number */'||E'\n'||
'		WHEN polygon_number  = next_polygon_number AND'||E'\n'|| 
'			joined_polygon_number = next_joined_polygon_number      THEN currval(''simplification_points_seq'') /* currval: next == current */'||E'\n'||
'		WHEN polygon_number  = prev_polygon_number AND'||E'\n'|| 
'			joined_polygon_number = prev_joined_polygon_number      THEN currval(''simplification_points_seq'') /* currval: previous == current */'||E'\n'||
'		ELSE nextval(''simplification_points_seq'')'||E'\n'||
'       END join_seq'||E'\n'||
'  FROM a'||E'\n'||
' ORDER BY polygon_number, pointflow';
-- Statement took: 00:01:44.925395 (104.925395)
-- 
	sql_stmt[array_length(sql_stmt, 1)+1]:='DROP SEQUENCE IF EXISTS simplification_points_seq';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ALTER TABLE simplification_points_e ADD PRIMARY KEY(polygon_number, pointflow)';
	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_e_coord_id ON simplification_points_e(coord_id)';
--
--	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_e_polygon_number ON simplification_points_e(polygon_number)';
--	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_e_num_polygon_number ON simplification_points_e(num_polygon_number)';
--	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_e_duplicate ON simplification_points_e(duplicate)';
-- 
	sql_stmt[array_length(sql_stmt, 1)+1]:='ANALYZE simplification_points_e';
--
-- Execute fifth block of SQL statements
--
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	rel_size:=rel_size+rif40_sql_pkg._print_table_size('simplification_points_d');
	rel_size:=rel_size+rif40_sql_pkg._print_table_size('simplification_points_e');
--
-- Sixth block of SQL statements
--
	sql_stmt:=NULL;	/* Empty statement array */
--
-- Create the points table: simplification_points from simplification_points_e adding in joinable points
--
	sql_stmt[1]:='DROP TABLE IF EXISTS simplification_points';
	sql_stmt[array_length(sql_stmt, 1)+1]:='DROP TABLE simplification_points_d';
	IF l_filter IS NULL THEN /* Non test mode */
		l_sql_stmt:='EXPLAIN ANALYZE VERBOSE CREATE TEMPORARY TABLE simplification_points'||E'\n';
	ELSE
		l_sql_stmt:='EXPLAIN ANALYZE VERBOSE CREATE TABLE simplification_points'||E'\n';
	END IF;
	sql_stmt[array_length(sql_stmt, 1)+1]:=l_sql_stmt||
'AS'||E'\n'||
'WITH b AS /* Joinable polygons */ ('||E'\n'||
'	SELECT joined_polygon_number, coord_id, duplicate, COUNT(DISTINCT(join_seq)) AS num_join_seq'||E'\n'||
'	  FROM simplification_points_e c'||E'\n'||
'	 WHERE num_polygon_number = 2'||E'\n'||
'	   AND joined_polygon_number IS NOT NULL'||E'\n'||
'	 GROUP BY joined_polygon_number, coord_id, duplicate'||E'\n'||
'	HAVING COUNT(DISTINCT(join_seq)) = 1'||E'\n'||
')'||E'\n'||
'SELECT c.area_id, polygon_number, pointflow, c.coord_id, coordinate, c.duplicate,'||E'\n'|| 
'       c.num_polygon_number, c.joined_polygon_number,'||E'\n'|| 
'       next_polygon_number, next_pointflow, next_joined_polygon_number,'||E'\n'||
'       prev_polygon_number, prev_pointflow, prev_joined_polygon_number,'||E'\n'||
'       join_seq, join_code, b.num_join_seq'||E'\n'||
'  FROM simplification_points_e c'||E'\n'||
'	LEFT OUTER JOIN b /* For joined_polygon_number */ ON ('||E'\n'||
' 	       b.joined_polygon_number = c.polygon_number'||E'\n'|| 
'	   AND b.coord_id              = c.coord_id'||E'\n'||
'           AND ('||E'\n'||
'		(b.duplicate           = c.duplicate) /* Same flag */ OR'||E'\n'||
'		(b.duplicate           = ''N'' AND c.duplicate = ''O'') OR /* Handle different origins */'||E'\n'||
'		(b.duplicate           = ''O'' AND c.duplicate = ''N'')'||E'\n'||
'               )'||E'\n'||
'	   AND c.num_polygon_number    = 2 /* Shared boundary between two polygons only */)'||E'\n'||
' ORDER BY polygon_number, pointflow';
--
	sql_stmt[array_length(sql_stmt, 1)+1]:='ALTER TABLE simplification_points ADD PRIMARY KEY(polygon_number, pointflow)';
	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_num_join_seq ON simplification_points(num_join_seq)';
	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_num_polygon_number ON simplification_points(num_polygon_number)';
	sql_stmt[array_length(sql_stmt, 1)+1]:='DROP TABLE simplification_points_e';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ANALYZE simplification_points';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ALTER TABLE simplification_points ADD joined_join_seq BIGINT';
--
-- Execute sixth block of SQL statements
--
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Checks - MUST BE 0
--
-- a) Areas with no join sequence
--
	PERFORM rif40_geo_pkg._simplify_geometry_checks(l_geography, l_geolevel, 3);
--
-- b) Areas with mis-joined sequences
--
	PERFORM rif40_geo_pkg._simplify_geometry_checks(l_geography, l_geolevel, 4);

--
-- Seventh block of SQL statements
--
	sql_stmt:=NULL;	/* Empty statement array */
--
-- Create a list of joined_polygon_numbers as temporary table simplification_points_f (i.e. the num_join_seq is 1)
--
	sql_stmt[1]:='DROP TABLE IF EXISTS simplification_points_f';
	sql_stmt[array_length(sql_stmt, 1)+1]:='EXPLAIN ANALYZE VERBOSE CREATE TEMPORARY TABLE simplification_points_f'||E'\n'||
'AS'||E'\n'||
'WITH a AS ('||E'\n'||
'	SELECT polygon_number AS joined_polygon_number, coord_id, duplicate, join_seq, COUNT(join_seq) AS total_join_seq'||E'\n'||
'	  FROM simplification_points'||E'\n'||
'	 WHERE num_join_seq  = 1'||E'\n'||
'	 GROUP BY polygon_number, coord_id, duplicate, join_seq'||E'\n'||
'), b /* Exclude a small number of loop duplicates that would break the primary key */ AS ('||E'\n'||
'	SELECT joined_polygon_number, coord_id, duplicate, COUNT(join_seq) AS total'||E'\n'||
'	  FROM a'||E'\n'||
'	 GROUP BY joined_polygon_number, coord_id, duplicate'||E'\n'||
'	HAVING COUNT(join_seq) > 1'||E'\n'||
')'||E'\n'||
'SELECT a.joined_polygon_number, a.coord_id, a.duplicate, a.join_seq, a.total_join_seq'||E'\n'||
'  FROM a'||E'\n'||
'	LEFT OUTER JOIN b ON (a.joined_polygon_number = b.joined_polygon_number AND a.coord_id = b.coord_id AND a.duplicate = b.duplicate)'||E'\n'||
' WHERE b.total IS NULL'||E'\n'||
' ORDER BY a.joined_polygon_number, a.coord_id, a.duplicate, a.join_seq';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ALTER TABLE simplification_points_f ADD PRIMARY KEY(joined_polygon_number, coord_id, duplicate)';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ANALYZE simplification_points_f';
--
-- Execute seventh block of SQL statements
--
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Test 5: For join sequence(s) used by more than one polygon_number
--
	PERFORM rif40_geo_pkg._simplify_geometry_checks(l_geography, l_geolevel, 5);
--
-- Test 6: For polygon_number, coord_id, duplicate(s) used by more than one join sequence
--
	PERFORM rif40_geo_pkg._simplify_geometry_checks(l_geography, l_geolevel, 6);
--
-- Seventh block of SQL statements
--
	sql_stmt:=NULL;	/* Empty statement array */
--
-- Update simplification_points.joined_join_seq using joined_polygon_numbers in simplification_points_f (i.e. the num_join_seq is 1) 
-- joining on joined_polygon_number, coord_id and the duplicate flag
--
	sql_stmt[1]:='EXPLAIN ANALYZE VERBOSE UPDATE simplification_points a'||E'\n'||
'   SET joined_join_seq = ('||E'\n'||
'	SELECT join_seq'||E'\n'||
'	  FROM simplification_points_f b1'||E'\n'||
' 	 WHERE a.joined_polygon_number = b1.joined_polygon_number'||E'\n'||
'	   AND a.coord_id       = b1.coord_id'||E'\n'||
'	   AND a.duplicate      = b1.duplicate)';
-- UPDATE 13795468 Time: 549892.370 ms (9 mins)
	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE INDEX simplification_points_joined_join_seq ON simplification_points(joined_join_seq)';
	sql_stmt[array_length(sql_stmt, 1)+1]:='DROP TABLE simplification_points_f';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ANALYZE simplification_points';
--
-- Execute seventh block of SQL statements
--
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	rel_size:=rel_size+rif40_sql_pkg._print_table_size('simplification_points');
--
-- Display number of polygons and duplicate flag
--
	PERFORM rif40_sql_pkg.rif40_method4('SELECT num_polygon_number, duplicate, num_join_seq,'||E'\n'|| 
'       COUNT(joined_polygon_number) AS t_joined_polygon_number,'||E'\n'|| 
'       COUNT(join_seq) AS t_join_seq,'||E'\n'|| 
'       COUNT(joined_join_seq) AS t_joined_join_seq'||E'\n'||
'  FROM simplification_points'||E'\n'||
' GROUP BY num_polygon_number, duplicate, num_join_seq'||E'\n'||
' ORDER BY num_polygon_number, duplicate, num_join_seq', 'Nnumber of polygons and duplicate flag');
/*
num_polygon_number   | duplicate | num_join_seq         | t_joined_polygon_number | t_join_seq           | t_joined_join_seq   
----------------------------------------------------------------------------------------------------------------------------------
1                    | L         |                      | 0                       | 13                   | 0                   
1                    | N         |                      | 0                       | 240375               | 0                   
1                    | O         |                      | 0                       | 23                   | 0                   
2                    | L         | 1                    | 6                       | 6                    | 6                   
2                    | L         |                      | 0                       | 3                    | 0                   
2                    | N         | 1                    | 439383                  | 439383               | 439354              
2                    | O         | 1                    | 33                      | 33                   | 4                   
3                    | L         |                      | 0                       | 1                    | 0                   
3                    | N         |                      | 0                       | 146                  | 0                   
3                    | O         |                      | 0                       | 10                   | 0                   
(10 rows)
 */
--
-- Display number of polygons joined at a point (1=edge; 2=shared polygon boundary between 2 polygons; 3+: triple or more point)
--
	PERFORM rif40_sql_pkg.rif40_method4('WITH b AS ('||E'\n'||
'	SELECT COUNT(coord_id) AS total_coords'||E'\n'||
' 	  FROM simplification_points'||E'\n'||
')'||E'\n'||
'SELECT num_polygon_number, SUM(num_polygon_number) AS num_coords, ROUND((CAST(SUM(num_polygon_number) AS numeric)/b.total_coords)*100.0, 4) AS pct'||E'\n'||
'  FROM ('||E'\n'||
'	SELECT coord_id, COUNT(polygon_number) AS num_polygon_number'||E'\n'||
' 	 FROM simplification_points'||E'\n'||
'	 GROUP BY coord_id) a, b'||E'\n'||
' GROUP BY num_polygon_number, b.total_coords'||E'\n'||
' ORDER BY num_polygon_number', 'Number of polygons joined at a point (1=edge; 2=shared polygon boundary between 2 polygons; 3+: triple or more point)');
/*
num_polygon_number   | num_coords | pct
------------------------------------------
1                    | 240385     | 35.
2                    | 439430     | 64.
3                    | 162        | 0.0
4                    | 16         | 0.0
 */
--
-- List duplicates
--
	PERFORM rif40_sql_pkg.rif40_method4('WITH b AS ('||E'\n'||
'	SELECT COUNT(duplicate) AS gtotal'||E'\n'||
'	  FROM simplification_points'||E'\n'||
')'||E'\n'||
'SELECT duplicate,'||E'\n'||
'       COUNT(join_seq) AS tot_seqs, ROUND((CAST(COUNT(join_seq) AS numeric)/b.gtotal)*100.0, 4) AS pct_seq,'||E'\n'||
'       COUNT(joined_polygon_number) AS tot_joined, ROUND((CAST(COUNT(joined_polygon_number) AS numeric)/b.gtotal)*100.0, 4) AS pct_joined'||E'\n'||
'  FROM simplification_points, b'||E'\n'||
' GROUP BY duplicate, b.gtotal'||E'\n'||
' ORDER BY 1, 2', 'List duplicates');
/*
duplicate | tot_seqs             | pct_seq | tot_joined           | pct_joined
---------------------------------------------------------------------------------
L         | 23                   | 0.0034  | 6                    | 0.0009    
N         | 679904               | 99.9869 | 439383               | 64.6158   
O         | 66                   | 0.0097  | 33                   | 0.0049   
 */

--
-- Test 7: areas(s) with non unique join sequences
--
	PERFORM rif40_geo_pkg._simplify_geometry_checks(l_geography, l_geolevel, 7);
--
	etp:=clock_timestamp();
	took:=age(etp, stp);
	PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_phase_I', 'Simplify % geography geolevel %: Phase I (Create the points table) took %s, total space used: %', 
		l_geography::VARCHAR			/* Geography */, 
		l_geolevel::VARCHAR			/* Geolevel */, 
		took::VARCHAR				/* Took */,
		pg_size_pretty(rel_size)::VARCHAR	/* Total size of table and indexes */);
--
END;
]]></definition>
</function>

<function name="_simplify_geometry_phase_ii"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	_simplify_geometry_phase_II()
Parameters:	Geography, geolevel, 
                geolevel; filter (for testing, no default), 
                minimum point resolution (default 1 - assumed metre, but depends on the geometry), 
                override for rif40_geoelvels.st_simplify_tolerance
Returns:	Nothing
Description:	Simplify geography geolevel - Phase II: Create the lines table

Phase II: Create the lines table

Set st_simplify_tolerance from command line parameter or rif40_geolevels table
Check st_simplify_tolerance >= l_min_point_resolution

Create and populate simplification_lines table. Processed in two sections:

a) Good joins - where there is a 1:1 mapping between join_seq, polygon_number and joined_join_seq
b) Add in the duplicate joins - where there is no 1:1 mapping between join_seq, polygon_number and joined_join_seq

Display the duplicate joins to be removed (duplicate_join_to_be_removed=Y). 

Note:

a) Duplicate joins to be removed are all one or two polygon joins
b) OK joins are either 1, 2 or 3 polygons joins (1 is an outside edge) and MIN == MAX

Report on join duplicates. This is the polygon_number/join_seq/joined_join_seq where there is not a 1:1 mapping between join_seq, 
polygon_number and joined_join_seq cannot used shared simplification and are therefore a potential source of slivers

The table simplification_lines_join_duplicates table allows the join duplicates to be explored offline within the same session

Report on 1:1 mapping between join_seq and joined_join_seq test

Flag lines for reversal. Where shared simplification is in use the lines may need to be reversed if:

a) Start point line A == end point line b
b) End point line A == start point line b
c) duplicate_join_to_be_removed = N is both
d) Number of poibnts in both lines are the same
e) If line A join sequence is bigger line A stays the same
   If line B join sequence is bigger line B is reversed
f) Line of the line (as an INT) is the same [originally assumed metre type units; has been changed to a % test]

Carry out line reversal

Display joins and reversals

The duplicate_join_to_be_removed flag is where there is no 1:1 mapping between join_seq, polygon_number and joined_join_seq
duplicate_join_to_be_removed applies to both side of a joined line so:

  N/Y means the line cannot be reversed or replaced as the duplicate status varies
  Y/ duplicates, but only a single point  
  N/ no duplicates, but only a single point
  N/N No duplicates; 1, 2 or 3 polygon join; Can reverse:Y, stays same: S or N [default no matching criteria; should not be any]

Test 9: join sequence(s) causing invalid joins and reversals
Update spatial linestrings table, e.g. t_rif40_linestrings_ew01_ward2001 if there is no filter [NOT CURRENTLY IMPLEMENTED]

Example SQL>

CREATE TABLE simplification_lines(
 geolevel_name                  VARCHAR(30),
 polygon_number                 bigint,
 area_id                        VARCHAR(300),
 join_seq                       bigint,
 joined_join_seq        bigint,
 line_length                    NUMERIC,
 simplified_line_length         NUMERIC,
 min_num_polygon_number         bigint,
 max_num_polygon_number         bigint,
 min_pointflow                  bigint,
 max_pointflow                  bigint,
 num_points                     bigint,
 duplicate_join_to_be_removed   VARCHAR(1));

INSERT INTO simplification_lines
      (geolevel_name, area_id, polygon_number, join_seq, joined_join_seq, line_length, simplified_line_length,
        min_num_polygon_number, max_num_polygon_number, min_pointflow, max_pointflow, num_points, line, simplified_line, duplicate_join_to_be_removed)
WITH a AS /* Convert co-ordinate points to LINESTRINGs */ (
        SELECT area_id, polygon_number, join_seq, joined_join_seq,
               MIN(num_polygon_number) AS min_num_polygon_number,
               MAX(num_polygon_number) AS max_num_polygon_number,
               MIN(pointflow) AS min_pointflow,
               MAX(pointflow) AS max_pointflow,
               COUNT(pointflow) AS num_points,
               ST_RemoveRepeatedPoints(                         /* Remove repeated points */
                 ST_Makeline(array_agg(                         /* Convert to line */
                   ST_SetSRID(coordinate, 27700 /* Convert coordinates to Geogrpahy SRID */) ORDER BY pointflow))) AS line,
               ST_SimplifyPreserveTopology(                     /* Run Douglas-Peuker on line to simplify */
                 ST_RemoveRepeatedPoints(                       /* Remove repeated points */
                   ST_Makeline(array_agg(                       /* Convert to line */
                     ST_SetSRID(coordinate, 27700       /* Convert coordinates to Geogrpahy SRID */) ORDER BY pointflow))), 
                   50                   /* Simplify tolerance */) AS simplified_line
          FROM simplification_points
         GROUP BY area_id, polygon_number, join_seq, joined_join_seq
), b AS /* 1:1 mapping between join_seq, polygon_number and joined_join_seq - can use shared implification */ (
        SELECT polygon_number, join_seq, COUNT(polygon_number) AS total
          FROM a
         GROUP BY polygon_number, join_seq
         HAVING COUNT(polygon_number) = 1
), c AS /* No 1:1 mapping between join_seq, polygon_number and joined_join_seq */ (
        SELECT DISTINCT join_seq
          FROM (
                SELECT polygon_number, join_seq, COUNT(polygon_number) AS total
                  FROM a
                 GROUP BY polygon_number, join_seq
                 HAVING COUNT(polygon_number) > 1
        ) c1
), d AS /* Simplify separately - as there is no 1:1 mapping between join_seq, polygon_number and joined_join_seq */ (
        SELECT d1.area_id, d1.polygon_number, d1.join_seq, NULL::bigint joined_join_seq,
               MIN(num_polygon_number) AS min_num_polygon_number,
               MAX(num_polygon_number) AS max_num_polygon_number,
               MIN(pointflow) AS min_pointflow,
               MAX(pointflow) AS max_pointflow,
               COUNT(pointflow) AS num_points,
               ST_RemoveRepeatedPoints(                         /* Remove repeated points */
                 ST_Makeline(array_agg(                         /* Convert to line */
                   ST_SetSRID(coordinate, 27700 /* Convert coordinates to Geogrpahy SRID */) ORDER BY pointflow))) AS line,
               ST_SimplifyPreserveTopology(                     /* Run Douglas-Peuker on line to simplify */
                 ST_RemoveRepeatedPoints(                       /* Remove repeated points */
                   ST_Makeline(array_agg(                       /* Convert to line */
                     ST_SetSRID(coordinate, 27700       /* Convert coordinates to Geogrpahy SRID */) ORDER BY pointflow))),
                   50                       /* Simplify tolerance */) AS simplified_line
          FROM simplification_points d1, c
         WHERE d1.join_seq = c.join_seq
         GROUP BY d1.area_id, d1.polygon_number, d1.join_seq
)
SELECT /* Good joins - where there is a 1:1 mapping between join_seq, polygon_number and joined_join_seq */ 'LADUA2001' AS geolevel_name,
       area_id, a.polygon_number, a.join_seq, joined_join_seq,
       ROUND(CAST(ST_Length(line) AS numeric), 0) AS line_length,
       ROUND(CAST(ST_Length(simplified_line) AS numeric), 0) AS simplified_line_length, 
       min_num_polygon_number, max_num_polygon_number, min_pointflow, max_pointflow, num_points, line, simplified_line, 'N' AS duplicate_join_to_be_removed
  FROM a, b
 WHERE a.polygon_number  = b.polygon_number
   AND a.join_seq        = b.join_seq
UNION
SELECT /* Add in the duplicate joins - where there is no 1:1 mapping between join_seq, polygon_number and joined_join_seq */ 'LADUA2001' AS geolevel_name,
       area_id, polygon_number, join_seq, joined_join_seq /* This is NULL */,
       ROUND(CAST(ST_Length(line) AS numeric), 0) AS line_length,
       ROUND(CAST(ST_Length(simplified_line) AS numeric), 0) AS simplified_line_length,
       min_num_polygon_number, max_num_polygon_number, min_pointflow, max_pointflow, num_points, line, simplified_line,
       CASE
                WHEN max_num_polygon_number > 2  THEN 'M' /* Mutli (>2) polygon join, e.g. triple point between 3 polygons */
                WHEN max_num_polygon_number = 2  THEN 'Y' /* Two polygon join */
                WHEN max_num_polygon_number = 1  THEN 'E' /* Outer edge */
                ELSE                                  '?' /* Unknown */
       END AS duplicate_join_to_be_removed
  FROM d
 ORDER BY 1, 2, 3, 4;

CREATE TEMPORARY TABLE simplification_lines_join_duplicates
AS
WITH a AS (
        SELECT polygon_number, join_seq, joined_join_seq,
               MIN(num_polygon_number) AS min_num_polygon_number,
               MAX(num_polygon_number) AS max_num_polygon_number,
               MIN(pointflow) AS min_pointflow,
               MAX(pointflow) AS max_pointflow,
               COUNT(pointflow) AS num_points,
               ST_Makeline(array_agg(ST_SetSRID(coordinate, 27700) ORDER BY pointflow)) AS line,
               ST_SimplifyPreserveTopology(ST_Makeline(array_agg(ST_SetSRID(coordinate, 27700) ORDER BY pointflow)), 50) AS simplified_line
          FROM simplification_points
         GROUP BY polygon_number, join_seq, joined_join_seq
), b AS (
        SELECT polygon_number, join_seq, COUNT(polygon_number) AS total
          FROM a
         GROUP BY polygon_number, join_seq
         HAVING COUNT(polygon_number) > 1
)
SELECT a.polygon_number, a.join_seq, COALESCE(joined_join_seq, 0) AS joined_join_seq,
       ROUND(CAST(ST_Length(line) AS numeric), 0) AS line_length,
       ROUND(CAST(ST_Length(simplified_line) AS numeric), 0) AS simplified_line_length,
       min_num_polygon_number, max_num_polygon_number, min_pointflow, max_pointflow, num_points, line, simplified_line, 'Y'::Text duplicate_join_to_be_removed
  FROM a, b
 WHERE a.polygon_number  = b.polygon_number
   AND a.join_seq = b.join_seq
 ORDER BY polygon_number, join_seq, joined_join_seq;

CREATE TEMPORARY TABLE simplification_lines_temp
AS
SELECT a.polygon_number, a.join_seq, a.joined_join_seq, b.polygon_number AS joined_polygon_number,
       a.duplicate_join_to_be_removed||'/'||COALESCE(b.duplicate_join_to_be_removed, ') AS duplicate_join_to_be_removed,
      CASE
                WHEN ST_Startpoint(a.line)                        = ST_Endpoint(b.line)   AND
                     ST_Endpoint(a.line)                          = ST_Startpoint(b.line) AND
                     a.duplicate_join_to_be_removed               = 'N'                   AND
                     b.duplicate_join_to_be_removed               = 'N'                   AND
                     a.num_points                                 = b.num_points          AND
                     a.join_seq                                   > b.join_seq            AND
                     (a.num_points = 1 OR ROUND(ABS(1-(CAST(ST_Length(a.line) AS numeric)/(CAST(ST_Length(b.line) AS numeric)+0.00000001))), 3) <= 0.001)
                         /* Avooid assuming decical range units, e.g. metres when rounding */ THEN 'Y' /* Reverse */
                WHEN ST_Startpoint(a.line)                        = ST_Endpoint(b.line)   AND
                     ST_Endpoint(a.line)                          = ST_Startpoint(b.line) AND
                     a.duplicate_join_to_be_removed               = 'N'                   AND
                     b.duplicate_join_to_be_removed               = 'N'                   AND
                     a.num_points                                 = b.num_points          AND
                     a.join_seq                                   < b.join_seq            AND
                     (a.num_points = 1 OR ROUND(ABS(1-(CAST(ST_Length(a.line) AS numeric)/(CAST(ST_Length(b.line) AS numeric)+0.00000001))), 3) <= 0.001)
                         /* Avoid assuming decical range units, e.g. metres when rounding */ THEN 'S' /* Stays the same */
                ELSE 'N'
       END AS reverse_line,
      CASE
                WHEN ST_Startpoint(a.simplified_line)                        = ST_Endpoint(b.simplified_line)   AND
                     ST_Endpoint(a.simplified_line)                          = ST_Startpoint(b.simplified_line) AND
                     a.duplicate_join_to_be_removed                          = 'N'                              AND
                     b.duplicate_join_to_be_removed                          = 'N'                              AND
                     a.num_points                                            = b.num_points                     AND
                     a.join_seq                                              > b.join_seq                       AND
                     (a.num_points = 1 OR ROUND(ABS(1-(CAST(ST_Length(a.simplified_line) AS numeric)/(CAST(ST_Length(b.simplified_line) AS numeric)+0.00000001))), 3) <= 0.001)
                         /* Avoid assuming decical range units, e.g. metres when rounding */ THEN 'Y' /* Reverse */
                WHEN ST_Startpoint(a.simplified_line)                        = ST_Endpoint(b.simplified_line)   AND
                     ST_Endpoint(a.simplified_line)                          = ST_Startpoint(b.simplified_line) AND
                     a.duplicate_join_to_be_removed                          = 'N'                              AND
                     b.duplicate_join_to_be_removed                          = 'N'                              AND
                     a.num_points                                            = b.num_points                     AND
                     a.join_seq                                              < b.join_seq                       AND
                     (a.num_points = 1 OR ROUND(ABS(1-(CAST(ST_Length(a.simplified_line) AS numeric)/(CAST(ST_Length(b.simplified_line) AS numeric)+0.00000001))), 3) <= 0.001)
                         /* Avoid assuming decical range units, e.g. metres when rounding */ THEN 'S' /* Stays the same */
                ELSE 'N'
       END AS reverse_simplified_line,
       a.num_points,
       ROUND(ABS(1-(CAST(ST_Length(a.simplified_line) AS numeric)/(CAST(ST_Length(b.simplified_line) AS numeric)+0.00000001))), 3) AS simplified_line_test,
       ROUND(ABS(1-(CAST(ST_Length(a.line) AS numeric)/(CAST(ST_Length(b.line) AS numeric)+0.00000001))), 3) AS line_test,
       ST_Length(a.simplified_line) AS simplified_line_length,
       ST_Length(a.line) AS line_length,
       ST_Reverse(b.line) AS revered_line, ST_Reverse(b.simplified_line) AS reversed_simplified_line
  FROM simplification_lines a
        LEFT OUTER JOIN simplification_lines b ON (a.joined_join_seq = b.join_seq)
 ORDER BY a.polygon_number, a.join_seq;]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="l_geography" in="true" default-value="NULL::character varying">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_geolevel" in="true" default-value="1">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_filter" in="true" default-value="NULL::numeric">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_min_point_resolution" in="true">
		<type name="numeric"/>
	</parameter>
	<parameter name="l_st_simplify_tolerance" in="true">
		<type name="numeric"/>
	</parameter>
	<definition><![CDATA[
DECLARE
/*
Function: 	_simplify_geometry_phase_II()
Parameters:	Geography, geolevel, 
                geolevel; filter (for testing, no default), 
                minimum point resolution (default 1 - assumed metre, but depends on the geometry), 
                override for rif40_geoelvels.st_simplify_tolerance
Returns:	Nothing
Description:	Simplify geography geolevel - Phase II: Create the lines table

Phase II: Create the lines table

Set st_simplify_tolerance from command line parameter or rif40_geolevels table
Check st_simplify_tolerance >= l_min_point_resolution

Create and populate simplification_lines table. Processed in two sections:

a) Good joins - where there is a 1:1 mapping between join_seq, polygon_number and joined_join_seq
b) Add in the duplicate joins - where there is no 1:1 mapping between join_seq, polygon_number and joined_join_seq

Display the duplicate joins to be removed (duplicate_join_to_be_removed=Y). 

Note:

a) Duplicate joins to be removed are all one or two polygon joins
b) OK joins are either 1, 2 or 3 polygons joins (1 is an outside edge) and MIN == MAX

Report on join duplicates. This is the polygon_number/join_seq/joined_join_seq where there is not a 1:1 mapping between join_seq, 
polygon_number and joined_join_seq cannot used shared simplification and are therefore a potential source of slivers

The table simplification_lines_join_duplicates table allows the join duplicates to be explored offline within the same session

Report on 1:1 mapping between join_seq and joined_join_seq test

Flag lines for reversal. Where shared simplification is in use the lines may need to be reversed if:

a) Start point line A == end point line b
b) End point line A == start point line b
c) duplicate_join_to_be_removed = N is both
d) Number of poibnts in both lines are the same
e) If line A join sequence is bigger line A stays the same
   If line B join sequence is bigger line B is reversed
f) Line of the line (as an INT) is the same [originally assumed metre type units; has been changed to a % test]

Carry out line reversal

Display joins and reversals

The duplicate_join_to_be_removed flag is where there is no 1:1 mapping between join_seq, polygon_number and joined_join_seq
duplicate_join_to_be_removed applies to both side of a joined line so:

  N/Y means the line cannot be reversed or replaced as the duplicate status varies
  Y/ duplicates, but only a single point  
  N/ no duplicates, but only a single point
  N/N No duplicates; 1, 2 or 3 polygon join; Can reverse:Y, stays same: S or N [default no matching criteria; should not be any]

Test 9: join sequence(s) causing invalid joins and reversals
Update spatial linestrings table, e.g. t_rif40_linestrings_ew01_ward2001 if there is no filter [NOT CURRENTLY IMPLEMENTED]

 */
	c1_sII	CURSOR(l_geography VARCHAR) FOR
		SELECT *
		  FROM rif40_geographies
		 WHERE geography = l_geography;
	c2_sII CURSOR(l_geography VARCHAR, l_geolevel_name VARCHAR) FOR
		SELECT * 
		  FROM t_rif40_geolevels
		 WHERE geography = l_geography
		   AND geolevel_name = l_geolevel_name;
--
	c1_rec rif40_geographies%ROWTYPE;
	c2_rec t_rif40_geolevels%ROWTYPE;
--
	sql_stmt	VARCHAR[];
	l_sql_stmt	VARCHAR;
--
	l_spatial_linestrings_table	VARCHAR;
	st_simplify_tolerance NUMERIC;
--
	stp TIMESTAMP WITH TIME ZONE;
	etp TIMESTAMP WITH TIME ZONE;
	took INTERVAL;
--
	rel_size BIGINT=0;
BEGIN
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, '_simplify_geometry_phase_II', 'User % must be rif40 or have rif_manager role', 
			USER::VARCHAR	/* Username */);
	END IF;
--
	stp:=clock_timestamp();
--
	OPEN c1_sII(l_geography);
	FETCH c1_sII INTO c1_rec;
	CLOSE c1_sII;
	IF c1_rec.geography IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10091, '_simplify_geometry_phase_II', 'No geography specified');
	END IF;
	OPEN c2_sII(l_geography, l_geolevel);
	FETCH c2_sII INTO c2_rec;
	CLOSE c2_sII;
	IF c2_rec.geolevel_name IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10092, '_simplify_geometry_phase_II', 'No geolevel name specified for geography: %',
			l_geography::VARCHAR);
	ELSIF c1_rec.srid IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10094, '_simplify_geometry_phase_II', 'No srid specified for geography: % geolevel: %',
			l_geography::VARCHAR);
	ELSE
--
-- Set st_simplify_tolerance from command line parameter or rif40_geolevels table
-- Check st_simplify_tolerance >= l_min_point_resolution
--
		IF l_st_simplify_tolerance IS NULL THEN
			st_simplify_tolerance:=c2_rec.st_simplify_tolerance;
		ELSE
			st_simplify_tolerance:=l_st_simplify_tolerance;
		END IF;
		IF st_simplify_tolerance IS NULL THEN
			PERFORM rif40_log_pkg.rif40_error(-10093, '_simplify_geometry_phase_II', 'No st_simplify_tolerance specified for geography: % geolevel: %',
				l_geography::VARCHAR,
				l_geolevel::VARCHAR);
		ELSIF st_simplify_tolerance < l_min_point_resolution THEN
			PERFORM rif40_log_pkg.rif40_error(-10097, '_simplify_geometry_phase_II', 'st_simplify_tolerance (%) specified for geography: % geolevel: % < l_min_point_resolution (%); units: %',
				st_simplify_tolerance::VARCHAR,
				l_geography::VARCHAR,
				l_geolevel::VARCHAR,
				l_min_point_resolution::VARCHAR,
				rif40_geo_pkg.get_srid_projection_parameters(l_geography, '+units')::VARCHAR);
		END IF;
	END IF;
--
	PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_phase_II', 'Phase II (lines creation) for geography: % geolevel: %. Parameters - st_simplify_tolerance: %; l_min_point_resolution: %; units: %',
		l_geography::VARCHAR,
		l_geolevel::VARCHAR,
		st_simplify_tolerance::VARCHAR,
		l_min_point_resolution::VARCHAR,
		rif40_geo_pkg.get_srid_projection_parameters(l_geography, '+units')::VARCHAR);
--
-- First block of SQL statements
--
-- Create lines table
--
	sql_stmt[1]:='DROP TABLE IF EXISTS simplification_lines';
	IF l_filter IS NULL THEN /* Non test mode */
		l_sql_stmt:='CREATE TEMPORARY TABLE simplification_lines('||E'\n';
	ELSE
		l_sql_stmt:='CREATE TABLE simplification_lines('||E'\n';
	END IF;
	sql_stmt[array_length(sql_stmt, 1)+1]:=l_sql_stmt||
' geolevel_name			VARCHAR(30),'||E'\n'||
' polygon_number    	   	bigint,'||E'\n'||   
' area_id      	  		VARCHAR(300),'||E'\n'||
' join_seq       		bigint,'||E'\n'||   
' joined_join_seq       	bigint,'||E'\n'||   
' line_length	 		NUMERIC,'||E'\n'||  
' simplified_line_length 	NUMERIC,'||E'\n'||  
' min_num_polygon_number    	bigint,'||E'\n'||  
' max_num_polygon_number    	bigint,'||E'\n'||  
' min_pointflow  		bigint,'||E'\n'||
' max_pointflow  		bigint,'||E'\n'||
' num_points     		bigint,'||E'\n'||
' duplicate_join_to_be_removed 	VARCHAR(1))';

--
-- Execute first block of SQL statements
--
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Add geometry
--
	PERFORM AddGeometryColumn('simplification_lines', 'line', c1_rec.srid, 'LINESTRING', 2);
      	PERFORM AddGeometryColumn('simplification_lines', 'simplified_line', c1_rec.srid, 'LINESTRING', 2);
--
-- Second block of SQL statements
--
	sql_stmt:=NULL;	/* Empty statement array */
--
-- Populate simplification_lines table. Processed in two sections:
--
-- a) Good joins - where there is a 1:1 mapping between join_seq, polygon_number and joined_join_seq
-- b) Add in the duplicate joins - where there is no 1:1 mapping between join_seq, polygon_number and joined_join_seq
--
-- ST_Makeline() is assumed to be valid at the moment, attempting ST_MakeValid() causes: 
-- Geometry type (Point) does not match column type (LineString)
--
-- Note that the SQL has not been split and indexed as the process is linear apart from the 1:1 mapping check and does not consume huge amounts of sort
-- Could be improved
--
	sql_stmt[1]:='EXPLAIN ANALYZE VERBOSE INSERT INTO simplification_lines'||E'\n'|| 
'      (geolevel_name, area_id, polygon_number, join_seq, joined_join_seq, line_length, simplified_line_length,'||E'\n'||  
'	min_num_polygon_number, max_num_polygon_number, min_pointflow, max_pointflow, num_points, line, simplified_line, duplicate_join_to_be_removed)'||E'\n'|| 
'WITH a AS /* Convert co-ordinate points to LINESTRINGs */ ('||E'\n'|| 
'	SELECT area_id, polygon_number, join_seq, joined_join_seq,'||E'\n'||  
'	       MIN(num_polygon_number) AS min_num_polygon_number,'||E'\n'|| 
'	       MAX(num_polygon_number) AS max_num_polygon_number,'||E'\n'|| 
'	       MIN(pointflow) AS min_pointflow,'||E'\n'|| 
'	       MAX(pointflow) AS max_pointflow,'||E'\n'|| 
'	       COUNT(pointflow) AS num_points,'||E'\n'|| 
'	       ST_RemoveRepeatedPoints( 			/* Remove repeated points */'||E'\n'|| 
'	         ST_Makeline(array_agg(				/* Convert to line */'||E'\n'|| 
'	           ST_SetSRID(coordinate, '||c1_rec.srid||'	/* Convert coordinates to Geogrpahy SRID */) ORDER BY pointflow))) AS line,'||E'\n'|| 
'	       ST_SimplifyPreserveTopology(			/* Run Douglas-Peuker on line to simplify */'||E'\n'|| 
'	         ST_RemoveRepeatedPoints(  			/* Remove repeated points */'||E'\n'|| 
'	           ST_Makeline(array_agg(			/* Convert to line */'||E'\n'|| 
'	             ST_SetSRID(coordinate, '||c1_rec.srid||'	/* Convert coordinates to Geogrpahy SRID */) ORDER BY pointflow))), '||E'\n'|| 
'	           '||st_simplify_tolerance||'			/* Simplify tolerance */) AS simplified_line'||E'\n'|| 
'	  FROM simplification_points'||E'\n'|| 
'	 GROUP BY area_id, polygon_number, join_seq, joined_join_seq'||E'\n'|| 
'), b AS /* 1:1 mapping between join_seq, polygon_number and joined_join_seq - can use shared implification */ ('||E'\n'|| 
'	SELECT polygon_number, join_seq, COUNT(polygon_number) AS total'||E'\n'|| 
'	  FROM a'||E'\n'|| 
'	 GROUP BY polygon_number, join_seq'||E'\n'|| 
'	 HAVING COUNT(polygon_number) = 1'||E'\n'|| 	
'), c AS /* No 1:1 mapping between join_seq, polygon_number and joined_join_seq */ ('||E'\n'|| 
'	SELECT DISTINCT join_seq'||E'\n'||  
'	  FROM ('||E'\n'|| 
'		SELECT polygon_number, join_seq, COUNT(polygon_number) AS total'||E'\n'|| 
'		  FROM a'||E'\n'|| 
'		 GROUP BY polygon_number, join_seq'||E'\n'|| 
'		 HAVING COUNT(polygon_number) > 1'||E'\n'|| 
'	) c1'||E'\n'|| 
'), d AS /* Simplify separately - as there is no 1:1 mapping between join_seq, polygon_number and joined_join_seq */ ('||E'\n'|| 
'	SELECT d1.area_id, d1.polygon_number, d1.join_seq, NULL::bigint joined_join_seq,'||E'\n'||  
'	       MIN(num_polygon_number) AS min_num_polygon_number,'||E'\n'|| 
'	       MAX(num_polygon_number) AS max_num_polygon_number,'||E'\n'|| 
'	       MIN(pointflow) AS min_pointflow,'||E'\n'|| 
'	       MAX(pointflow) AS max_pointflow,'||E'\n'|| 
'	       COUNT(pointflow) AS num_points,'||E'\n'|| 
'	       ST_RemoveRepeatedPoints(				/* Remove repeated points */'||E'\n'|| 
'	         ST_Makeline(array_agg(				/* Convert to line */'||E'\n'|| 
'	           ST_SetSRID(coordinate, '||c1_rec.srid||'	/* Convert coordinates to Geogrpahy SRID */) ORDER BY pointflow))) AS line,'||E'\n'|| 
'	       ST_SimplifyPreserveTopology(			/* Run Douglas-Peuker on line to simplify */'||E'\n'|| 
'	         ST_RemoveRepeatedPoints( 			/* Remove repeated points */'||E'\n'|| 
'	           ST_Makeline(array_agg(			/* Convert to line */'||E'\n'|| 
'	             ST_SetSRID(coordinate, '||c1_rec.srid||'	/* Convert coordinates to Geogrpahy SRID */) ORDER BY pointflow))), '||
'                  '||st_simplify_tolerance||'			/* Simplify tolerance */) AS simplified_line'||E'\n'|| 
'	  FROM simplification_points d1, c'||E'\n'|| 
'	 WHERE d1.join_seq = c.join_seq'||E'\n'|| 
'	 GROUP BY d1.area_id, d1.polygon_number, d1.join_seq'||E'\n'|| 
')'||E'\n'|| 
'SELECT /* Good joins - where there is a 1:1 mapping between join_seq, polygon_number and joined_join_seq */ '''||c2_rec.geolevel_name||''' AS geolevel_name,'||E'\n'||  
'       area_id, a.polygon_number, a.join_seq, joined_join_seq,'||E'\n'||  
'       ROUND(CAST(ST_Length(line) AS numeric), 0) AS line_length,'||E'\n'||  
'       ROUND(CAST(ST_Length(simplified_line) AS numeric), 0) AS simplified_line_length, '||E'\n'|| 
'       min_num_polygon_number, max_num_polygon_number, min_pointflow, max_pointflow, num_points, line, simplified_line, ''N'' AS duplicate_join_to_be_removed'||E'\n'|| 
'  FROM a, b'||E'\n'|| 
' WHERE a.polygon_number  = b.polygon_number'||E'\n'|| 
'   AND a.join_seq        = b.join_seq'||E'\n'|| 
'UNION'||E'\n'|| 
'SELECT /* Add in the duplicate joins - where there is no 1:1 mapping between join_seq, polygon_number and joined_join_seq */ '''||c2_rec.geolevel_name||''' AS geolevel_name,'||E'\n'||  
'       area_id, polygon_number, join_seq, joined_join_seq /* This is NULL */,'||E'\n'||  
'       ROUND(CAST(ST_Length(line) AS numeric), 0) AS line_length,'||E'\n'||  
'       ROUND(CAST(ST_Length(simplified_line) AS numeric), 0) AS simplified_line_length,'||E'\n'||  
'       min_num_polygon_number, max_num_polygon_number, min_pointflow, max_pointflow, num_points, line, simplified_line,'||E'\n'||  
'       CASE'||E'\n'||  
'          	WHEN max_num_polygon_number > 2  THEN ''M'' /* Mutli (>2) polygon join, e.g. triple point between 3 polygons */'||E'\n'||  
'          	WHEN max_num_polygon_number = 2  THEN ''Y'' /* Two polygon join */'||E'\n'||  
'          	WHEN max_num_polygon_number = 1  THEN ''E'' /* Outer edge */'||E'\n'||  
E'          	ELSE                                  ''?'' /* Unknown */'||E'\n'||  
'       END AS duplicate_join_to_be_removed'||E'\n'|| 
'  FROM d'||E'\n'|| 
' ORDER BY 1, 2, 3, 4';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ALTER TABLE simplification_lines ADD PRIMARY KEY(polygon_number, join_seq)';
	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE UNIQUE INDEX simplification_lines_uk ON simplification_lines(join_seq)';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ANALYZE simplification_lines';
--
-- Report on invalid LINESTRINGs [Removed - separate test at the polygon level - ST_MakeValid(linestrings) causes errors]
--
/*
SELECT COUNT(join_seq) AS total_single_point_lines, SUM(ST_Length(line)) AS total_line_length
  FROM simplification_lines
 WHERE ST_NPoints(line) = 1;

SELECT ST_IsValid(line) AS line_ok, ST_IsValid(simplified_line) AS simplified_line, COUNT(join_seq) AS total_lines,
       SUM(ST_Length(line)) AS total_line_length, SUM(ST_Length(simplified_line)) AS total_simplified_line_line_length,
       SUM(ST_NPoints(line)) AS total_line_points, SUM(ST_NPoints(simplified_line)) AS total_simplified_line_points
  FROM simplification_lines
 WHERE ST_NPoints(line) > 1 
 GROUP BY ST_IsValid(line), ST_IsValid(simplified_line);
 
SELECT ST_IsValidReason(line), join_seq, ST_Dump(line), ST_NPoints(line)
  FROM simplification_lines 
 WHERE ST_NPoints(line) > 1 AND NOT ST_IsValid(line)
 LIMIT 10; 
 */
--
-- Execute second block of SQL statements
--
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Display the duplicate joins to be removed (duplicate_join_to_be_removed=Y). 
--
-- Note:
--
-- a) Duplicate joins to be removed are all one or two polygon joins
-- b) OK joins are either 1, 2 or 3 polygons joins (1 is an outside edge) and MIN == MAX
--
	PERFORM rif40_sql_pkg.rif40_method4('WITH b AS ('||E'\n'||
'	SELECT COUNT(DISTINCT(join_seq)) AS total, SUM(num_points) AS total_points, SUM(simplified_line_length) AS total_simplified_line_length'||E'\n'||
'	  FROM simplification_lines'||E'\n'||
')'||E'\n'||
'SELECT duplicate_join_to_be_removed, min_num_polygon_number, max_num_polygon_number, '||E'\n'|| 
'       COUNT(DISTINCT(join_seq)) AS t_join_seq, ROUND((CAST(COUNT(DISTINCT(join_seq)) AS numeric)/b.total)*100.0, 4) AS pct_join_seq,'||E'\n'||
'       SUM(num_points) AS points,'||E'\n'||
'       CASE'||E'\n'|| 
'       	WHEN b.total_points > 0 THEN'||E'\n'|| 
'       		ROUND((CAST( SUM(num_points) AS numeric)/b.total_points)*100.0, 4)'||E'\n'||
'		ELSE 0 END AS pct_points,'||E'\n'||
'       SUM(simplified_line_length) AS t_simp_line_length,'||E'\n'|| 
'       CASE'||E'\n'|| 
'       	WHEN b.total_simplified_line_length > 0 THEN'||E'\n'|| 
'       		ROUND((CAST( SUM(simplified_line_length) AS numeric)/b.total_simplified_line_length)*100.0, 4)'||E'\n'||
'		ELSE 0 END AS pct_simp_line_length,'||E'\n'||
'       COUNT(DISTINCT(polygon_number)) AS t_polygon_number'||E'\n'||
'  FROM simplification_lines a, b'||E'\n'||
' GROUP BY duplicate_join_to_be_removed, min_num_polygon_number, max_num_polygon_number, total, total_points, total_simplified_line_length', 
	'Display the duplicate joins to be removed (duplicate_join_to_be_removed=Y)');

/*
duplicate_join_to_be_removed | min_num_polygon_number | max_num_polygon_number | t_join_seq           | pct_join_seq | points | pct_points | t_simp_line_length | pct_simp_line_length | t_polygon_number    
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
N                            | 1                      | 1                      | 63                   | 14.2212      | 82158  | 12.0822    | 502980             | 7.1737               | 33                  
N                            | 2                      | 2                      | 120                  | 27.0880      | 219028 | 32.2103    | 2590187            | 36.9425              | 38                  
N                            | 3                      | 3                      | 157                  | 35.4402      | 157    | 0.0231     | 0                  | 0.0000               | 40                  
Y                            | 1                      | 2                      | 62                   | 13.9955      | 266455 | 39.1850    | 2680832            | 38.2353              | 31                  
Y                            | 2                      | 2                      | 41                   | 9.2551       | 112195 | 16.4994    | 1237402            | 17.6484              | 31                  
(5 rows)

 */
--
-- Report on join duplicates. This is the polygon_number/join_seq/joined_join_seq where there is not a 1:1 mapping between join_seq, 
-- polygon_number and joined_join_seq cannot used shared simplification and are therefore a potential source of slivers
--
-- Third block of SQL statements
--
-- The table simplification_lines_join_duplicates table allows the join duplicates to be explored offline within the same session
--
/*
XXXX
PH Notes
It is strongly suspected that these are mainly caused by the joined_join_seq=0, line_length=0 pairs
 
SELECT COUNT(polygon_number)
  FROM simplification_lines_join_duplicates;

 count 
-------
   281
(1 row)

SELECT total, COUNT(total) 
  FROM (
	SELECT polygon_number, join_seq, COUNT(joined_join_seq) AS total
	  FROM simplification_lines_join_duplicates
	 GROUP BY polygon_number, join_seq) t
 GROUP BY total;

 total | count 
-------+-------
     3 |     7
     2 |   130
(2 rows)

WITH a AS (
	SELECT polygon_number, join_seq, COUNT(joined_join_seq) AS total
	  FROM simplification_lines_join_duplicates
	 GROUP BY polygon_number, join_seq
	 HAVING COUNT(joined_join_seq) = 2
)
SELECT polygon_number, join_seq, COUNT(joined_join_seq) AS total, MIN(joined_join_seq) AS min, MAX(joined_join_seq) AS max
  FROM simplification_lines_join_duplicates
 GROUP BY polygon_number, join_seq LIMIT 20;

 polygon_number | join_seq | total | min | max  
----------------+----------+-------+-----+------
             26 |      298 |     2 |   0 |  400
             31 |      362 |     2 |   0 |  421
             34 |      400 |     3 |   0 |  312
             35 |      411 |     2 |   0 |  496
             38 |      443 |     2 |   0 | 1998
             38 |      449 |     2 |   0 |  497
             41 |      478 |     2 |   0 |  494
             42 |      494 |     3 |   0 |  490
             42 |      496 |     2 |   0 |  411
             42 |      497 |     2 |   0 |  449
             54 |      626 |     2 |   0 |  725
             54 |      627 |     2 |   0 |  745
             56 |      641 |     2 |   0 |  746
             56 |      642 |     2 |   0 | 1090
             63 |      724 |     2 |   0 | 3391
             63 |      725 |     2 |   0 |  626
             65 |      745 |     2 |   0 |  627
             65 |      746 |     2 |   0 |  641
             87 |     1006 |     2 |   0 | 1129
             87 |     1007 |     2 |   0 | 1545
(20 rows)

WITH a AS (
	SELECT polygon_number, join_seq, COUNT(joined_join_seq) AS total
	  FROM simplification_lines_join_duplicates
	 GROUP BY polygon_number, join_seq
	 HAVING COUNT(joined_join_seq) = 3
)
SELECT a.polygon_number, a.join_seq, joined_join_seq, line_length, min_pointflow, max_pointflow, num_points
  FROM a, simplification_lines_join_duplicates b
 WHERE a.polygon_number = b.polygon_number
   AND a.join_seq       = b.join_seq ORDER BY 1, 2, 3 LIMIT 20;

 polygon_number | join_seq | joined_join_seq | line_length | min_pointflow | max_pointflow | num_points 
----------------+----------+-----------------+-------------+---------------+---------------+------------
             34 |      400 |               0 |           0 |           751 |           751 |          1
             34 |      400 |             298 |        2675 |           267 |           750 |        477
             34 |      400 |             312 |         606 |           752 |           792 |         41
             42 |      494 |               0 |           0 |           840 |           840 |          1
             42 |      494 |             478 |        3122 |           153 |           839 |        652
             42 |      494 |             490 |        1601 |           841 |          1147 |        290
            257 |     2938 |               0 |           0 |           787 |           787 |          1
            257 |     2938 |            2535 |        1905 |           327 |           786 |        440
            257 |     2938 |            2547 |         511 |           788 |           951 |        163
            289 |     3297 |               0 |           0 |          1009 |          1009 |          1
            289 |     3297 |            3270 |        2542 |           542 |          1008 |        426
            289 |     3297 |            3277 |        1101 |          1010 |          1146 |        137
            290 |     3307 |               0 |           0 |           806 |           806 |          1
            290 |     3307 |            3341 |         830 |           640 |           805 |        166
            290 |     3307 |            3349 |        3751 |           807 |          1332 |        508
            433 |     4886 |               0 |           0 |           592 |           592 |          1
            433 |     4886 |            4754 |        2035 |           117 |           591 |        471
            433 |     4886 |            4764 |        1278 |           593 |           832 |        237
            447 |     5047 |               0 |           0 |           371 |           371 |          1
            447 |     5047 |            5064 |         409 |           277 |           370 |         94
(20 rows)
  */
	sql_stmt:=NULL;	/* Empty statement array */
	sql_stmt[1]:='DROP TABLE IF EXISTS simplification_lines_join_duplicates';
	IF l_filter IS NULL THEN /* Non test mode */
		l_sql_stmt:='CREATE TEMPORARY TABLE simplification_lines_join_duplicates'||E'\n';
	ELSE
		l_sql_stmt:='CREATE TABLE simplification_lines_join_duplicates'||E'\n';
	END IF;
	sql_stmt[array_length(sql_stmt, 1)+1]:='EXPLAIN ANALYZE VERBOSE '||l_sql_stmt||E'\n'||
'AS'||E'\n'||
'WITH a AS ('||E'\n'||
'	SELECT polygon_number, join_seq, joined_join_seq,'||E'\n'|| 
'	       MIN(num_polygon_number) AS min_num_polygon_number,'||E'\n'||
'	       MAX(num_polygon_number) AS max_num_polygon_number,'||E'\n'||
'	       MIN(pointflow) AS min_pointflow,'||E'\n'||
'	       MAX(pointflow) AS max_pointflow,'||E'\n'||
'	       COUNT(pointflow) AS num_points,'||E'\n'||
'	       ST_Makeline(array_agg(ST_SetSRID(coordinate, '||c1_rec.srid||') ORDER BY pointflow)) AS line,'||E'\n'||
'	       ST_SimplifyPreserveTopology(ST_Makeline(array_agg(ST_SetSRID(coordinate, '||c1_rec.srid||') ORDER BY pointflow)), '||st_simplify_tolerance||') AS simplified_line'||E'\n'||
'	  FROM simplification_points'||E'\n'||
'	 GROUP BY polygon_number, join_seq, joined_join_seq'||E'\n'||
'), b AS ('||E'\n'||
'	SELECT polygon_number, join_seq, COUNT(polygon_number) AS total'||E'\n'||
'	  FROM a'||E'\n'||
'	 GROUP BY polygon_number, join_seq'||E'\n'||
'	 HAVING COUNT(polygon_number) > 1'||E'\n'||	
')'||E'\n'||
'SELECT a.polygon_number, a.join_seq, COALESCE(joined_join_seq, 0) AS joined_join_seq,'||E'\n'||
'       ROUND(CAST(ST_Length(line) AS numeric), 0) AS line_length,'||E'\n'||
'       ROUND(CAST(ST_Length(simplified_line) AS numeric), 0) AS simplified_line_length,'||E'\n'||
'       min_num_polygon_number, max_num_polygon_number, min_pointflow, max_pointflow, num_points, line, simplified_line, ''Y''::Text duplicate_join_to_be_removed'||E'\n'||
'  FROM a, b'||E'\n'||
' WHERE a.polygon_number  = b.polygon_number'||E'\n'||
'   AND a.join_seq = b.join_seq'||E'\n'||
' ORDER BY polygon_number, join_seq, joined_join_seq';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ALTER TABLE simplification_lines_join_duplicates ADD PRIMARY KEY(polygon_number, join_seq, joined_join_seq)';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ANALYZE simplification_lines_join_duplicates';
--
-- Execute third block of SQL statements
--
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	rel_size:=rel_size+rif40_sql_pkg._print_table_size('simplification_lines_join_duplicates');
--
-- Report on 1:1 mapping between join_seq and joined_join_seq test
--
	PERFORM rif40_sql_pkg.rif40_method4('WITH b AS ('||E'\n'||
'	SELECT COUNT(DISTINCT(join_seq)) AS total, SUM(num_points) AS total_points, SUM(simplified_line_length) AS total_simplified_line_length'||E'\n'||
'	  FROM simplification_lines_join_duplicates'||E'\n'||
')'||E'\n'||
'SELECT duplicate_join_to_be_removed AS dup_join_removed,'||E'\n'|| 
'       COUNT(DISTINCT(join_seq)) AS t_join_seq, ROUND((CAST(COUNT(DISTINCT(join_seq)) AS numeric)/b.total)*100.0, 4) AS pct_join_seq,'||E'\n'||
'       SUM(num_points) AS points, ROUND((CAST( SUM(num_points) AS numeric)/b.total_points)*100.0, 4) AS pct_points,'||E'\n'||
'       SUM(simplified_line_length) AS t_simp_line_length,'||E'\n'|| 
'       ROUND((CAST( SUM(simplified_line_length) AS numeric)/b.total_simplified_line_length)*100.0, 4) AS pct_simp_line_length,'||E'\n'||
'       COUNT(DISTINCT(polygon_number)) AS t_polygon_number'||E'\n'||
'  FROM simplification_lines_join_duplicates a, b'||E'\n'||
' GROUP BY duplicate_join_to_be_removed, total, total_points, total_simplified_line_length', 'Report on 1:1 mapping between join_seq and joined_join_seq test');
/*
 dup_join_removed | t_join_seq | pct_join_seq | points  | pct_points | t_simp_line_length | pct_simp_line_length | t_area_id 
------------------+------------+--------------+---------+------------+--------------------+----------------------+-----------
 Y                |       2404 |     100.0000 | 1278172 |   100.0000 |           14023163 |             100.0000 |      1976
 */
--
-- Fourth block of SQL statements
--
-- Flag lines for reversal. Where shared simplification is in use the lines may need to be reversed if:
--
-- a) Start point line A == end point line b
-- b) End point line A == start point line b
-- c) duplicate_join_to_be_removed = N is both
-- d) Number of poibnts in both lines are the same
-- e) If line A join sequence is bigger line A stays the same
--    If line B join sequence is bigger line B is reversed
-- f) Line of the line (as an INT) is the same [originally assumed metre type units; has been changed to a % test]
--
	sql_stmt:=NULL;	/* Empty statement array */
	sql_stmt[1]:='DROP TABLE IF EXISTS simplification_lines_temp';
	sql_stmt[array_length(sql_stmt, 1)+1]:='EXPLAIN ANALYZE VERBOSE CREATE TEMPORARY TABLE simplification_lines_temp'||E'\n'||
'AS'||E'\n'||
'SELECT a.polygon_number, a.join_seq, a.joined_join_seq, b.polygon_number AS joined_polygon_number,'||E'\n'||
'       a.duplicate_join_to_be_removed||''/''||COALESCE(b.duplicate_join_to_be_removed, '''') AS duplicate_join_to_be_removed,'||E'\n'||
'      CASE'||E'\n'|| 
'		WHEN ST_Startpoint(a.line)		 	  = ST_Endpoint(b.line)   AND'||E'\n'||  
'		     ST_Endpoint(a.line)   		  	  = ST_Startpoint(b.line) AND'||E'\n'|| 
'		     a.duplicate_join_to_be_removed               = ''N''                   AND'||E'\n'||
'		     b.duplicate_join_to_be_removed               = ''N''                   AND'||E'\n'||
'		     a.num_points                                 = b.num_points          AND'||E'\n'||
'		     a.join_seq                                   > b.join_seq            AND'||E'\n'||
--'		     ROUND(CAST(ST_Length(a.line) AS numeric), 0) = ROUND(CAST(ST_Length(b.line) AS numeric), 0) THEN ''Y'' /* Reverse */'||E'\n'||
'		     (a.num_points = 1 OR ROUND(ABS(1-(CAST(ST_Length(a.line) AS numeric)/(CAST(ST_Length(b.line) AS numeric)+0.00000001))), 3) <= 0.002)'||E'\n'|| 
'                 	 /* Avooid assuming decical range units, e.g. metres when rounding */ THEN ''Y'' /* Reverse */'||E'\n'|| 
'		WHEN ST_Startpoint(a.line)		 	  = ST_Endpoint(b.line)   AND'||E'\n'||  
'		     ST_Endpoint(a.line)   		  	  = ST_Startpoint(b.line) AND'||E'\n'|| 
'		     a.duplicate_join_to_be_removed               = ''N''                   AND'||E'\n'||
'		     b.duplicate_join_to_be_removed               = ''N''                   AND'||E'\n'||
'		     a.num_points                                 = b.num_points          AND'||E'\n'||
'		     a.join_seq                                   < b.join_seq            AND'||E'\n'||
--'		     ROUND(CAST(ST_Length(a.line) AS numeric), 0) = ROUND(CAST(ST_Length(b.line) AS numeric), 0) THEN ''S'' /* Stays the same */'||E'\n'|| 
'		     (a.num_points = 1 OR ROUND(ABS(1-(CAST(ST_Length(a.line) AS numeric)/(CAST(ST_Length(b.line) AS numeric)+0.00000001))), 3) <= 0.002)'||E'\n'|| 
'                 	 /* Avoid assuming decical range units, e.g. metres when rounding */ THEN ''S'' /* Stays the same */'||E'\n'|| 
'		ELSE ''N'''||E'\n'|| 
'       END AS reverse_line,'||E'\n'||
'      CASE'||E'\n'|| 
'		WHEN ST_Startpoint(a.simplified_line)			     = ST_Endpoint(b.simplified_line)   AND'||E'\n'|| 
'		     ST_Endpoint(a.simplified_line)   			     = ST_Startpoint(b.simplified_line) AND'||E'\n'||
'		     a.duplicate_join_to_be_removed              	     = ''N''                              AND'||E'\n'||
'		     b.duplicate_join_to_be_removed                  	     = ''N''                              AND'||E'\n'||
'		     a.num_points                                            = b.num_points                     AND'||E'\n'||
'		     a.join_seq                                              > b.join_seq                       AND'||E'\n'||
--'		     ROUND(CAST(ST_Length(a.simplified_line) AS numeric), 0) = ROUND(CAST(ST_Length(b.simplified_line) AS numeric), 0) THEN ''Y'' /* Reverse */'||E'\n'|| 
'		     (a.num_points = 1 OR ROUND(ABS(1-(CAST(ST_Length(a.simplified_line) AS numeric)/(CAST(ST_Length(b.simplified_line) AS numeric)+0.00000001))), 3) <= 0.002)'||E'\n'|| 
'                 	 /* Avoid assuming decical range units, e.g. metres when rounding */ THEN ''Y'' /* Reverse */'||E'\n'|| 
'		WHEN ST_Startpoint(a.simplified_line)			     = ST_Endpoint(b.simplified_line)   AND'||E'\n'|| 
'		     ST_Endpoint(a.simplified_line)   			     = ST_Startpoint(b.simplified_line) AND'||E'\n'||
'		     a.duplicate_join_to_be_removed                  	     = ''N''                              AND'||E'\n'||
'		     b.duplicate_join_to_be_removed                  	     = ''N''                              AND'||E'\n'||
'		     a.num_points                                            = b.num_points                     AND'||E'\n'||
'		     a.join_seq                                              < b.join_seq                       AND'||E'\n'||
--'		     ROUND(CAST(ST_Length(a.simplified_line) AS numeric), 0) = ROUND(CAST(ST_Length(b.simplified_line) AS numeric), 0) THEN ''S'' /* Stays the same */'||E'\n'||
'		     (a.num_points = 1 OR ROUND(ABS(1-(CAST(ST_Length(a.simplified_line) AS numeric)/(CAST(ST_Length(b.simplified_line) AS numeric)+0.00000001))), 3) <= 0.002)'||E'\n'|| 
'                 	 /* Avoid assuming decical range units, e.g. metres when rounding */ THEN ''S'' /* Stays the same */'||E'\n'|| 
'		ELSE ''N'''||E'\n'|| 
'       END AS reverse_simplified_line,'||E'\n'||
'       a.num_points AS num_points_a,'||E'\n'||
'       b.num_points AS num_points_b,'||E'\n'||
'       CASE'||E'\n'||
'		WHEN ST_Startpoint(a.line)		 	  = ST_Endpoint(b.line)   AND'||E'\n'||  
'		     ST_Endpoint(a.line)   		  	  = ST_Startpoint(b.line) THEN 1'||E'\n'||
'		ELSE 0'||E'\n'||
'       END AS line_start_endpoints_match,'||E'\n'||
'       CASE'||E'\n'||
'		WHEN ST_Startpoint(a.simplified_line)		 	  = ST_Endpoint(b.simplified_line)   AND'||E'\n'||  
'		     ST_Endpoint(a.simplified_line)   		  	  = ST_Startpoint(b.simplified_line) THEN 1'||E'\n'||
'		ELSE 0'||E'\n'||
'       END AS simplified_line_start_endpoints_match,'||E'\n'||
'       ROUND(ABS(1-(CAST(ST_Length(a.simplified_line) AS numeric)/(CAST(ST_Length(b.simplified_line) AS numeric)+0.00000001))), 3) AS simplified_line_test,'||E'\n'||
'       ROUND(ABS(1-(CAST(ST_Length(a.line) AS numeric)/(CAST(ST_Length(b.line) AS numeric)+0.00000001))), 3) AS line_test,'||E'\n'||
'       ST_Length(a.simplified_line) AS simplified_line_length,'||E'\n'||
'       ST_Length(a.line) AS line_length,'||E'\n'||
'       ST_Reverse(b.line) AS revered_line, ST_Reverse(b.simplified_line) AS reversed_simplified_line'||E'\n'||
'  FROM simplification_lines a'||E'\n'||
'	LEFT OUTER JOIN simplification_lines b ON (a.joined_join_seq = b.join_seq)'||E'\n'||
' ORDER BY a.polygon_number, a.join_seq';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ALTER TABLE simplification_lines_temp ADD PRIMARY KEY(polygon_number, join_seq)';
	sql_stmt[array_length(sql_stmt, 1)+1]:='CREATE UNIQUE INDEX simplification_lines_temp_uk ON simplification_lines_temp(join_seq)';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ANALYZE simplification_lines_temp';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ALTER TABLE simplification_lines ADD reverse_simplified_line VARCHAR(1)';
--
-- Carry out line reversal
--
	sql_stmt[array_length(sql_stmt, 1)+1]:='EXPLAIN ANALYZE VERBOSE UPDATE simplification_lines a'||E'\n'||
'   SET simplified_line = ('||E'\n'||
'	SELECT reversed_simplified_line'||E'\n'|| 
'	  FROM simplification_lines_temp b'||E'\n'||
'	 WHERE a.join_seq = b.join_seq), reverse_simplified_line = ''Y'''||E'\n'||
' WHERE a.join_seq IN ('||E'\n'||
'	SELECT join_seq'||E'\n'||
'	  FROM simplification_lines_temp'||E'\n'||
'	 WHERE reverse_simplified_line = ''Y'')';
--
	sql_stmt[array_length(sql_stmt, 1)+1]:='EXPLAIN ANALYZE VERBOSE UPDATE simplification_lines'||E'\n'||
'  SET reverse_simplified_line = ''N'''||E'\n'||
' WHERE reverse_simplified_line IS NULL';
--
-- Execute fourth block of SQL statements
--
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	rel_size:=rel_size+rif40_sql_pkg._print_table_size('simplification_lines_temp');
	rel_size:=rel_size+rif40_sql_pkg._print_table_size('simplification_lines');
--
-- Display joins and reversals
--
-- The duplicate_join_to_be_removed flag is where there is no 1:1 mapping between join_seq, polygon_number and joined_join_seq
-- duplicate_join_to_be_removed applies to both side of a joined line so:
--
-- N/Y means the line cannot be reversed or replaced as the duplicate status varies
-- Y/ duplicates, but only a single point
-- N/ no duplicates, but only a single point
-- N/N No duplicates; 1, 2 or 3 polygon join; Can reverse:Y, stays same: S or N [default no matching criteria; should not be any]
--
	PERFORM rif40_sql_pkg.rif40_method4('SELECT duplicate_join_to_be_removed, reverse_line, reverse_simplified_line,'||E'\n'||
'       COUNT(join_seq) AS t_join_seq,'||E'\n'||
'       SUM(num_points_a) AS num_points_a,'||E'\n'||
'       SUM(COALESCE(num_points_b, 0)) AS num_points_b'||E'\n'||
'  FROM simplification_lines_temp'||E'\n'||
' GROUP BY duplicate_join_to_be_removed, reverse_line, reverse_simplified_line'||E'\n'||
' ORDER BY 2, 3', 'Joins and reversals');
/*
duplicate_join_to_be_removed | reverse_line | reverse_simplified_line | t_join_seq           | num_points
------------------------------------------------------------------------------------------------------------
N/Y                          | N            | N                       | 23                   | 42055     
N/                           | N            | N                       | 223                  | 82318     
Y/                           | N            | N                       | 103                  | 378650    
N/N                          | S            | S                       | 47                   | 88485     
N/N                          | Y            | Y                       | 47                   | 88485     
(5 rows)
 */
--
-- Test 9: join sequence(s) causing invalid joins and reversals
--
	PERFORM rif40_geo_pkg._simplify_geometry_checks(l_geography, l_geolevel, 9);
--
-- Execute final block of SQL statements
--
	sql_stmt=NULL;
	sql_stmt[1]:='DROP TABLE simplification_lines_temp';
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);

--
-- Update spatial linestrings table, e.g. t_rif40_linestrings_ew01_ward2001 if there is no filter
--
	l_spatial_linestrings_table:='t_rif40_linestrings_'||LOWER(l_geography)||'_'||LOWER(l_geolevel);
	IF l_filter IS NULL THEN
		PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_phase_II', 'Simplify % geography geolevel %: Phase II (Create the lines table) Update spatial geolevel table: %', 
			l_geography::VARCHAR, 
			l_geolevel::VARCHAR,
			l_spatial_linestrings_table::VARCHAR); 
--
-- Do update
--
-- ADD
	ELSE
		PERFORM rif40_log_pkg.rif40_log('WARNING', '_simplify_geometry_phase_II', 'Simplify % geography geolevel %: Phase II (Create the lines table) No update of spatial geolevel table: %, test filter present', 
			l_geography::VARCHAR, 
			l_geolevel::VARCHAR,
			l_spatial_linestrings_table::VARCHAR); 
	END IF;

--
	etp:=clock_timestamp();
	took:=age(etp, stp);
	PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_phase_II', 'Simplify % geography geolevel %: Phase II (Create the lines table) took: %, total space used: %', 
		l_geography::VARCHAR			/* Geography */, 
		l_geolevel::VARCHAR			/* Geolevel */, 
		took::VARCHAR				/* Took */,
		pg_size_pretty(rel_size)::VARCHAR	/* Total size of table and indexes */);
--
END;
]]></definition>
</function>

<function name="_simplify_geometry_phase_iii"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	_simplify_geometry_phase_II()
Parameters:	Geography, geolevel, 
                geolevel; filter (for testing, no default), 
                minimum point resolution (default 1 - assumed metre, but depends on the geometry), 
                override for rif40_geoelvels.st_simplify_tolerance
Returns:	Nothing
Description:	Simplify geography geolevel - Phase III: Create the polygons table, Update spatial geolevel table

Phase III: Create the polygons table, Update spatial geolevel table

Create temporary polygon table: simplification_polygons
Add geometry columns: geometry, topo_optimised_geometry 
INSERT valid multipolygons INTO simplification_polygons
Display the increase in geoJSON length between the old simplification algorithm and the new
Test 8: areas(s) with invalid geometry in simplification_polygons
Update spatial geolevel table, e.g. t_rif40_geolevels_ward2001 if there is no filter

Example INSERT statements:

INSERT INTO simplification_polygons
        (area_id, name, geometry, topo_optimised_geometry, topo_optimised_geojson, num_lines, num_points, topo_optimised_num_points)
WITH a /* Join all lines in a polygon */ AS (
        SELECT area_id, polygon_number,
               ST_Makeline(array_agg(line ORDER BY join_seq)) AS line,
               ST_Makeline(array_agg(simplified_line ORDER BY join_seq)) AS simplified_line,
               COUNT(num_points) AS num_lines,
               SUM(num_points) AS num_points
          FROM simplification_lines
         GROUP BY area_id, polygon_number
), b /* Close linestrings to create POLYGONs */ AS (
        SELECT area_id, polygon_number,
               CASE      /* Close polygon if needed */
                         WHEN ST_IsClosed(line) THEN ST_Polygon(line, 27700)
                         ELSE /* Close LINESTRING */ ST_Polygon(ST_AddPoint(line, ST_Startpoint(line)), 27700)
               END line_polygon,
               CASE      /* Close polygon if needed */
                         WHEN ST_IsClosed(simplified_line) THEN ST_Polygon(line, 27700)
                         ELSE /* Close LINESTRING */ ST_Polygon(ST_AddPoint(simplified_line, ST_Startpoint(line)), 27700)
               END simplified_line_polygon,
               num_lines, num_points
          FROM a
), c /* Create valid MULITPOLYGONs by aggregation to area_id */ AS (
        SELECT area_id, SUM(num_lines) AS num_lines, SUM(num_points) AS num_points,
               ST_ForceRHR(               /* Orientate all polygons clockwise */
                 ST_CollectionExtract(    /* Remove orphaned LINESTRINGs and POINTs */
                   ST_Multi(              /* Convert to MULTIPOLYGON */
                     ST_Union(            /* Polygons */
                             CASE         /* Remove self intersections */
                                WHEN ST_IsValid(line_polygon) THEN line_polygon
                                ELSE                               ST_MakeValid(line_polygon)
                              END)), 3 /* MULTIPOLYGON */)) AS geometry,
              ST_transform(               /* Convert to WGS 84 */
                 ST_ForceRHR(             /* Orientate all polygons clockwise */
                  ST_CollectionExtract(   /* Remove orphaned LINESTRINGs and POINTs */
                     ST_Multi(            /* Convert to MULTIPOLYGON */
                       ST_Union(          /* Polygons */
                               CASE       /* Remove self intersections */
                                        WHEN ST_IsValid(simplified_line_polygon) THEN simplified_line_polygon
                                        ELSE                                          ST_MakeValid(simplified_line_polygon)
                               END)), 3 /* MULTIPOLYGON */)), 4326 /* WGS 84 */) AS topo_optimised_geometry
          FROM b
         GROUP BY area_id
), d AS /* Forcbily make valid if still not valid */ (
        SELECT area_id, num_lines, num_points,
              CASE WHEN ST_IsValid(geometry) THEN geometry ELSE ST_MakeValid(geometry) END geometry,
              CASE WHEN ST_IsValid(topo_optimised_geometry) THEN topo_optimised_geometry ELSE ST_MakeValid(topo_optimised_geometry) END topo_optimised_geometry
          FROM c
)
SELECT d.area_id, e.name, geometry, topo_optimised_geometry,
       ST_AsGeoJson(topo_optimised_geometry, 8 /* max_geojson_digits */,
                0 /* no options */) AS topo_optimised_geojson,
       num_lines, num_points, ST_NPoints(topo_optimised_geometry) AS topo_optimised_num_points
  FROM d
        LEFT OUTER JOIN sahsuland_level4 e ON (e.level4 = d.area_id)
 ORDER BY d.area_id;

UPDATE t_rif40_geolevels_geometry_sahsu_level4 a
   SET optimised_geojson = (
        SELECT topo_optimised_geojson
          FROM simplification_polygons b
         WHERE a.area_id = b.area_id);

]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="l_geography" in="true" default-value="NULL::character varying">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_geolevel" in="true" default-value="1">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_filter" in="true" default-value="NULL::numeric">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_min_point_resolution" in="true">
		<type name="numeric"/>
	</parameter>
	<parameter name="l_st_simplify_tolerance" in="true">
		<type name="numeric"/>
	</parameter>
	<definition><![CDATA[
DECLARE
/*
Function: 	_simplify_geometry_phase_II()
Parameters:	Geography, geolevel, 
                geolevel; filter (for testing, no default), 
                minimum point resolution (default 1 - assumed metre, but depends on the geometry), 
                override for rif40_geoelvels.st_simplify_tolerance
Returns:	Nothing
Description:	Simplify geography geolevel - Phase III: Create the polygons table, Update spatial geolevel table

Phase III: Create the polygons table, Update spatial geolevel table

Create temporary polygon table: simplification_polygons
Add geometry columns: geometry, topo_optimised_geometry 
INSERT valid multipolygons INTO simplification_polygons
Display the increase in geoJSON length between the old simplification algorithm and the new
Test 8: areas(s) with invalid geometry in simplification_polygons
Update spatial geolevel table, e.g. t_rif40_geolevels_ward2001 if there is no filter

 */
	c1_sIII	CURSOR(l_geography VARCHAR) FOR
		SELECT *
		  FROM rif40_geographies
		 WHERE geography = l_geography;
	c2_sIII CURSOR(l_geography VARCHAR, l_geolevel_name VARCHAR) FOR
		SELECT * 
		  FROM t_rif40_geolevels
		 WHERE geography = l_geography
		   AND geolevel_name = l_geolevel_name;
--
	c1_rec rif40_geographies%ROWTYPE;
	c2_rec t_rif40_geolevels%ROWTYPE;
--
	sql_stmt	VARCHAR[];
	l_sql_stmt	VARCHAR;
--
	l_spatial_geolevel_table	VARCHAR;
--
	stp TIMESTAMP WITH TIME ZONE;
	etp TIMESTAMP WITH TIME ZONE;
	took INTERVAL;
--
	rel_size BIGINT=0;
BEGIN
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, '_simplify_geometry_phase_III', 'User % must be rif40 or have rif_manager role', 
			USER::VARCHAR	/* Username */);
	END IF;
--
	stp:=clock_timestamp();
--
	OPEN c1_sIII(l_geography);
	FETCH c1_sIII INTO c1_rec;
	CLOSE c1_sIII;
	IF c1_rec.geography IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10091, '_simplify_geometry_phase_III', 'No geography specified');
	END IF;
	OPEN c2_sIII(l_geography, l_geolevel);
	FETCH c2_sIII INTO c2_rec;
	CLOSE c2_sIII;
	IF c2_rec.geolevel_name IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10092, '_simplify_geometry_phase_III', 'No geolevel name specified for geography: %',
			l_geography::VARCHAR);
	END IF;
--
	PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_phase_III', 'Phase III (polygons creation) for geography: % geolevel: %',
		l_geography::VARCHAR,
		l_geolevel::VARCHAR);
--
-- First block of SQL statements
--

--
-- Create temporary polygon table: simplification_polygons
--
	sql_stmt[1]:='DROP TABLE IF EXISTS simplification_polygons CASCADE';
	IF l_filter IS NULL THEN /* Non test mode */
		l_sql_stmt:='CREATE TEMPORARY TABLE simplification_polygons('||E'\n';
	ELSE
		l_sql_stmt:='CREATE TABLE simplification_polygons('||E'\n';
	END IF;
	sql_stmt[array_length(sql_stmt, 1)+1]:=l_sql_stmt||
' area_id        		VARCHAR(300)  	    	NOT NULL,'||E'\n'||
' name	 			VARCHAR(300),'||E'\n'||
' topo_optimised_geojson 	CHARACTER VARYING       NOT NULL,'||E'\n'||
' num_lines     		bigint,'||E'\n'||
' num_points     		bigint,'||E'\n'||
' topo_optimised_num_points    	bigint)';

--
-- Execute first block of SQL statements
--
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Add geometry columns: geometry, topo_optimised_geometry 
--
	PERFORM AddGeometryColumn('simplification_polygons', 'geometry', c1_rec.srid, 'MULTIPOLYGON', 2);
       	PERFORM AddGeometryColumn('simplification_polygons', 'topo_optimised_geometry', 4326  /* WGS 84 */, 'MULTIPOLYGON', 2);
--
-- Second block of SQL statements
--
	sql_stmt:=NULL;	/* Empty statement array */
--
-- INSERT valid multipolygons INTO simplification_polygons
--
-- Note that the SQL has not been split and indexed as the process is linear and does not consume huge amounts of sort
--
	sql_stmt[1]:='EXPLAIN ANALYZE VERBOSE INSERT INTO simplification_polygons'||E'\n'||
' 	(area_id, name, geometry, topo_optimised_geometry, topo_optimised_geojson, num_lines, num_points, topo_optimised_num_points)'||E'\n'||
'WITH a /* Join all lines in a polygon */ AS ('||E'\n'||
'	SELECT area_id, polygon_number,'||E'\n'||
'	       ST_Makeline(array_agg(line ORDER BY join_seq)) AS line,'||E'\n'||
'	       ST_Makeline(array_agg(simplified_line ORDER BY join_seq)) AS simplified_line,'||E'\n'||
'	       COUNT(num_points) AS num_lines,'||E'\n'||
'	       SUM(num_points) AS num_points'||E'\n'||
'	  FROM simplification_lines'||E'\n'||
'	 GROUP BY area_id, polygon_number'||E'\n'||
'), b /* Close linestrings to create POLYGONs */ AS ('||E'\n'||
'        SELECT area_id, polygon_number,'||E'\n'|| 
'               CASE      /* Close polygon if needed */'||E'\n'|| 
'                         WHEN ST_IsClosed(line) THEN ST_Polygon(line, '||c1_rec.srid||')'||E'\n'|| 
'                         ELSE /* Close LINESTRING */ ST_Polygon(ST_AddPoint(line, ST_Startpoint(line)), '||c1_rec.srid||')'||E'\n'|| 
'               END line_polygon,'||E'\n'|| 
'               CASE      /* Close polygon if needed */'||E'\n'|| 
'                         WHEN ST_IsClosed(simplified_line) THEN ST_Polygon(line, '||c1_rec.srid||')'||E'\n'|| 
'                         ELSE /* Close LINESTRING */ ST_Polygon(ST_AddPoint(simplified_line, ST_Startpoint(line)), '||c1_rec.srid||')'||E'\n'|| 
'               END simplified_line_polygon,'||E'\n'|| 
'               num_lines, num_points'||E'\n'|| 
'	  FROM a'||E'\n'|| 
'), c /* Create valid MULITPOLYGONs by aggregation to area_id */ AS ('||E'\n'|| 
'	SELECT area_id, SUM(num_lines) AS num_lines, SUM(num_points) AS num_points,'||E'\n'|| 
'              ST_ForceRHR(    	   	  /* Orientate all polygons clockwise */'||E'\n'|| 
'                ST_CollectionExtract(    /* Remove orphaned LINESTRINGs and POINTs */'||E'\n'|| 
'                  ST_Multi(              /* Convert to MULTIPOLYGON */'||E'\n'|| 
'                    ST_Union(            /* Polygons */'||E'\n'|| 
'			     CASE         /* Remove self intersections */'||E'\n'||  
'				WHEN ST_IsValid(line_polygon) THEN line_polygon'||E'\n'|| 
'				ELSE                               ST_MakeValid(line_polygon)'||E'\n'|| 
'				 				   /* ST_Buffer(geom, 0.0) removed as was occaisonially causing corruption */'||E'\n'|| 
'			      END)), 3 /* MULTIPOLYGON */)) AS geometry,'||E'\n'|| 
'              ST_transform(              /* Convert to WGS 84 */'||E'\n'|| 
'                ST_ForceRHR(    	  /* Orientate all polygons clockwise */'||E'\n'|| 
'                  ST_CollectionExtract(  /* Remove orphaned LINESTRINGs and POINTs */'||E'\n'|| 
'                    ST_Multi(            /* Convert to MULTIPOLYGON */'||E'\n'|| 
'                      ST_Union(          /* Polygons */'||E'\n'|| 
'			     CASE         /* Remove self intersections */'||E'\n'||  
'				WHEN ST_IsValid(simplified_line_polygon) THEN simplified_line_polygon'||E'\n'|| 
'				ELSE                                          ST_MakeValid(simplified_line_polygon)'||E'\n'|| 
'				 					      /* ST_Buffer(geom, 0.0) removed as was occaisonially causing corruption */'||E'\n'|| 
'			      END)), 3 /* MULTIPOLYGON */)),'||E'\n'|| 
'                      	       4326 /* WGS 84 */) AS topo_optimised_geometry'||E'\n'|| 
'          FROM b'||E'\n'|| 
'         GROUP BY area_id'||E'\n'|| 
'), d AS /* Forcbily make valid if still not valid */ ('||E'\n'|| 
'	SELECT area_id, num_lines, num_points,'||E'\n'|| 
'   	      CASE WHEN ST_IsValid(geometry) THEN geometry ELSE ST_MakeValid(geometry) END geometry,'||E'\n'|| 
'	      CASE WHEN ST_IsValid(topo_optimised_geometry) THEN topo_optimised_geometry ELSE ST_MakeValid(topo_optimised_geometry) END topo_optimised_geometry'||E'\n'|| 
'          FROM c'||E'\n'|| 
')'||E'\n'|| 
'SELECT d.area_id, e.name, geometry, topo_optimised_geometry,'||E'\n'||
'       ST_AsGeoJson(topo_optimised_geometry, '||c1_rec.max_geojson_digits||' /* max_geojson_digits */,'||E'\n'|| 
'		0 /* no options */) AS topo_optimised_geojson,'||E'\n'||
'       num_lines, num_points, ST_NPoints(topo_optimised_geometry) AS topo_optimised_num_points'||E'\n'||
'  FROM d'||E'\n'||
'	LEFT OUTER JOIN '||quote_ident(LOWER(c2_rec.lookup_table))||' e ON (e.'||quote_ident(LOWER(l_geolevel))||' = d.area_id)'||E'\n'||
' ORDER BY d.area_id';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ALTER TABLE simplification_polygons ADD PRIMARY KEY(area_id)';
	sql_stmt[array_length(sql_stmt, 1)+1]:='ANALYZE simplification_polygons';
--
-- Execute second block of SQL statements
--
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	rel_size:=rel_size+rif40_sql_pkg._print_table_size('simplification_polygons');

--
-- Display the increase in geoJSON length between the old simplification algorithm and the new
--
	PERFORM rif40_sql_pkg.rif40_method4('WITH a AS ('||E'\n'||
'	SELECT SUM(LENGTH(topo_optimised_geojson)) AS new_geojson_len'||E'\n'||
'	  FROM simplification_polygons'||E'\n'||
'), b AS ('||E'\n'||
'	SELECT file_geojson_len AS old_geojson_len'||E'\n'||
'	  FROM t_rif40_geolevels'||E'\n'||
'	 WHERE geography = '''||l_geography||''' AND geolevel_name = '''||l_geolevel||''''||E'\n'||
')'||E'\n'||
'SELECT old_geojson_len, new_geojson_len, ROUND((CAST((new_geojson_len-old_geojson_len) AS numeric)/old_geojson_len)*100, 2) AS pct_increase'||E'\n'||
'  FROM a, b', 'Display the increase in geoJSON length between the old simplification algorithm and the new');
/*
old_geojson_len      | new_geojson_len      | pct_increase
-------------------------------------------------------------
16812544             | 30503245             | 81.43       
 */
--
-- Test 8: areas(s) with invalid geometry in simplification_polygons
--
	PERFORM rif40_geo_pkg._simplify_geometry_checks(l_geography, l_geolevel, 8);

--
-- Update spatial geolevel table, e.g. t_rif40_geolevels_geometry_ew01_ward2001 if there is no filter
--
	l_spatial_geolevel_table:='t_rif40_geolevels_geometry_'||LOWER(l_geography)||'_'||LOWER(l_geolevel);
	IF l_filter IS NULL THEN /* Non test mode */
		PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_phase_III', 'Simplify % geography geolevel %: Phase III (Create the polygons table) Update spatial geolevel table: %', 
			l_geography::VARCHAR, 
			l_geolevel::VARCHAR,
			l_spatial_geolevel_table::VARCHAR); 
--
-- Do update
--

--
-- Third block of SQL statements
--
		sql_stmt:=NULL;	/* Empty statement array */
		sql_stmt[1]:='EXPLAIN ANALYZE VERBOSE UPDATE '||quote_ident(LOWER(l_spatial_geolevel_table))||' a'||E'\n'||
'   SET optimised_geometry = ('||E'\n'||
'	SELECT topo_optimised_geometry'||E'\n'||
'	  FROM simplification_polygons b'||E'\n'||
'	 WHERE a.area_id = b.area_id)';
		sql_stmt[1]:='EXPLAIN ANALYZE VERBOSE UPDATE '||quote_ident(LOWER(l_spatial_geolevel_table))||' a'||E'\n'||
'   SET optimised_geojson = ('||E'\n'||
'	SELECT topo_optimised_geojson'||E'\n'||
'	  FROM simplification_polygons b'||E'\n'||
'	 WHERE a.area_id = b.area_id)';
		sql_stmt[array_length(sql_stmt, 1)+1]:='ANALYZE '||quote_ident(LOWER(l_spatial_geolevel_table));
--
-- Execute third block of SQL statements
--
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('WARNING', '_simplify_geometry_phase_III', 'Simplify % geography geolevel %: Phase III (Create the polygons table) No update of spatial geolevel table: %, test filter present', 
			l_geography::VARCHAR, 
			l_geolevel::VARCHAR,
			l_spatial_geolevel_table::VARCHAR); 
	END IF;

--
	etp:=clock_timestamp();
	took:=age(etp, stp);
	PERFORM rif40_log_pkg.rif40_log('INFO', '_simplify_geometry_phase_III', 'Simplify % geography geolevel %: Phase III (Create the polygons table) took %s, total space used: %', 
		l_geography::VARCHAR			/* Geography */, 
		l_geolevel::VARCHAR			/* Geolevel */, 
		took::VARCHAR				/* Took */,
		pg_size_pretty(rel_size)::VARCHAR	/* Total size of table and indexes */);
--
END;
]]></definition>
</function>

<function name="add_population_to_rif40_geolevels_geometry"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	add_population_to_rif40_geolevels_geometry()
Parameters:	None
Returns:	Nothing
Description:	Add denominator population table to geography geolevel geometry data, re-analyze]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<definition><![CDATA[
/*

Function: 	add_population_to_rif40_geolevels_geometry()
Parameters:	None
Returns:	Nothing
Description:	Add denominator population table to geography geolevel geometry data, re-analyze
 */
DECLARE
	c1_adpop2 CURSOR(l_geography VARCHAR) FOR
		SELECT denominator_table, COUNT(*) total_numerators 
		  FROM rif40_num_denom
		 WHERE geography = l_geography
		   AND automatic =1
		 GROUP BY denominator_table;
	c2_adpop2 CURSOR FOR
		SELECT *
		  FROM rif40_geographies;
--
	c2_rec rif40_geographies%ROWTYPE;
	c1_rec RECORD;
--
	i INTEGER:=0;
BEGIN
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'add_population_to_rif40_geolevels_geometry', 'User % must be rif40 or have rif_manager role', 
			USER::VARCHAR	/* Username */);
	END IF;
--
-- Create lookup and Hierarchy tables
--
	FOR c2_rec IN c2_adpop2 LOOP
		i:=0;
		FOR c1_rec IN c1_adpop2(c2_rec.geography) LOOP
			i:=i+1;
			IF i = 1 THEN
				PERFORM rif40_geo_pkg.add_population_to_rif40_geolevels_geometry(c2_rec.geography, c1_rec.denominator_table);
			END IF;
		END LOOP;
--
		IF i = 0 THEN
--
-- Demoted to a warning for EW01 geography testing
--
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'add_population_to_rif40_geolevels_geometry', 'No automatic denominators for geography: %', 
				c2_rec.geography::VARCHAR	/* Geography */);
--			PERFORM rif40_log_pkg.rif40_error(-10052, 'add_population_to_rif40_geolevels_geometry', 'No automatic denominators for geography: %', 
--				c2_rec.geography::VARCHAR	/* Geography */);
		ELSIF i > 1 THEN
			PERFORM rif40_log_pkg.rif40_error(-10051, 'add_population_to_rif40_geolevels_geometry', '>1 (%) automatic denominators for geography: %', 
				c2_rec.geography::VARCHAR	/* Geography */,
				i::VARCHAR			/* Number of automatic denominators */);
		END IF;
	END LOOP;
--
	IF i = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-10053, 'add_population_to_rif40_geolevels_geometry', 'No geographies found');
	END IF;
--
	RETURN;
END;
]]></definition>
</function>

<function name="add_population_to_rif40_geolevels_geometry"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	add_population_to_rif40_geolevels_geometry()
Parameters:	geography, denominator population table
Returns:	Nothing
Description:	Add denominator population table to geography geolevel geometry data, re-analyze

Example update statement:

WITH a AS (
	SELECT MAX(year) AS max_year 
	  FROM sahsuland_pop
), b AS (
	SELECT level2, TRUNC(age_sex_group/100) AS sex, year AS population_year, SUM(total) AS total
	  FROM sahsuland_pop b, a
	 WHERE b.year = a.max_year
	 GROUP BY level2, TRUNC(age_sex_group/100), year
), c AS (
	SELECT b1.level2, b1.total AS total_males, b2.total AS total_females, b1.population_year
	  FROM b b1, b b2
	 WHERE b1.level2 = b2.level2
	   AND b1.sex    = 1
	   AND b2.sex    = 2
)
UPDATE t_rif40_sahsu_geometry d
   SET total_males = (
	SELECT total_males
	  FROM c
	 WHERE c.level2 = d.area_id),
       total_females = (
	SELECT total_females
	  FROM c
	 WHERE c.level2 = d.area_id),
       population_year = (
	SELECT population_year
	  FROM c
	 WHERE c.level2 = d.area_id)
 WHERE d.geolevel_name = 'LEVEL2';]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="l_geography" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_population_table" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	add_population_to_rif40_geolevels_geometry()
Parameters:	geography, denominator population table
Returns:	Nothing
Description:	Add denominator population table to geography geolevel geometry data, re-analyze

Example update statement:

WITH a AS (
	SELECT MAX(year) AS max_year 
	  FROM sahsuland_pop
), b AS (
	SELECT level2, TRUNC(age_sex_group/100) AS sex, year AS population_year, SUM(total) AS total
	  FROM sahsuland_pop b, a
	 WHERE b.year = a.max_year
	 GROUP BY level2, TRUNC(age_sex_group/100), year
), c AS (
	SELECT b1.level2, b1.total AS total_males, b2.total AS total_females, b1.population_year
	  FROM b b1, b b2
	 WHERE b1.level2 = b2.level2
	   AND b1.sex    = 1
	   AND b2.sex    = 2
)
UPDATE t_rif40_sahsu_geometry d
   SET total_males = (
	SELECT total_males
	  FROM c
	 WHERE c.level2 = d.area_id),
       total_females = (
	SELECT total_females
	  FROM c
	 WHERE c.level2 = d.area_id),
       population_year = (
	SELECT population_year
	  FROM c
	 WHERE c.level2 = d.area_id)
 WHERE d.geolevel_name = 'LEVEL2';

To test:

SELECT area_id, name, area, total_males, total_females, population_year
  FROM t_rif40_sahsu_geometry
 WHERE geolevel_name = 'LEVEL2';

EW01 test SELECT

WITH a AS (
	SELECT MAX(year) AS max_year 
	  FROM v_ew01_rif_pop_asg_1_oa2001
), b AS (
	SELECT ladua2001, TRUNC(age_sex_group/100) AS sex, year AS population_year, SUM(total) AS total
	  FROM v_ew01_rif_pop_asg_1_oa2001 b, a
	 WHERE b.year = a.max_year
	 GROUP BY ladua2001, TRUNC(age_sex_group/100), year
), c AS (
	SELECT b1.ladua2001, b1.total AS total_males, b2.total AS total_females, b1.population_year
	  FROM b b1, b b2
	 WHERE b1.ladua2001 = b2.ladua2001
	   AND b1.sex    = 1
	   AND b2.sex    = 2
)
SELECT * 
  FROM c;

 */
DECLARE
	c1_adpop CURSOR(l_geography VARCHAR) FOR
		SELECT * 
		  FROM t_rif40_geolevels
		 WHERE geography = l_geography
		 ORDER BY geography, geolevel_id;
	c2_adpop CURSOR(l_population_table VARCHAR) FOR
		SELECT *
		  FROM rif40_tables
		 WHERE table_name = l_population_table;
	c3_adpop CURSOR(l_population_table VARCHAR, l_schema VARCHAR, l_column VARCHAR) FOR
		SELECT *
		  FROM information_schema.columns
		 WHERE table_name   = LOWER(l_population_table)
		   AND table_schema = l_schema
		   AND column_name  = LOWER(l_column);
	c1_rec t_rif40_geolevels%ROWTYPE;
	c2_rec rif40_tables%ROWTYPE;
	c3_rec information_schema.columns%ROWTYPE;
--
	l_schema VARCHAR;
	sql_stmt VARCHAR;
	i INTEGER:=0;
BEGIN
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'add_population_to_rif40_geolevels_geometry', 'User % must be rif40 or have rif_manager role', 
			USER::VARCHAR			/* Username */);
	ELSIF l_geography IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10041, 'add_population_to_rif40_geolevels_geometry', 'Null geography');
	ELSIF l_geography IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10042, 'add_population_to_rif40_geolevels_geometry', 'Null population table for geography: %', 
			USER::VARCHAR			/* Geography */);
	END IF;
--
-- Check population table is a valid RIF denominator and exists
--
	OPEN c2_adpop(l_population_table);
	FETCH c2_adpop INTO c2_rec;
	CLOSE c2_adpop;
	IF c2_rec.table_name IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10018, 'add_population_to_rif40_geolevels_geometry', 'Geography: % Population table: % is not a RIF table', 
			l_geography::VARCHAR		/* Geography */,
			l_population_table::VARCHAR	/* Population table */);
	ELSIF c2_rec.isindirectdenominator != 1 THEN
		PERFORM rif40_log_pkg.rif40_error(-10019, 'add_population_to_rif40_geolevels_geometry', 'Geography: % Population table: % is a RIF table, but not an indirect denominator', 
			l_geography::VARCHAR		/* Geography */,
			l_population_table::VARCHAR	/* Population table */);
	ELSIF rif40_sql_pkg.rif40_is_object_resolvable(l_population_table) != 1 THEN
		PERFORM rif40_log_pkg.rif40_error(-10020, 'add_population_to_rif40_geolevels_geometry', 
			'Geography: % Population table: % is a RIF indirect denominator but is not resolvable', 
			l_geography::VARCHAR		/* Geography */,
			l_population_table::VARCHAR	/* Population table */);
	END IF;
	l_schema:=rif40_sql_pkg.rif40_object_resolve(l_population_table);
--
-- Do population update once per geolevel
--
	FOR c1_rec IN c1_adpop(l_geography) LOOP
--
-- Check geography geolevel is supported
--
		OPEN c3_adpop(l_population_table, l_schema, c1_rec.geolevel_name);
		FETCH c3_adpop INTO c3_rec;
		CLOSE c3_adpop;
		IF c3_rec.column_name IS NULL THEN
			PERFORM rif40_log_pkg.rif40_error(-10021, 'add_population_to_rif40_geolevels_geometry', 
				'Population table: %.% does not have % geography geolevel column: %', 
				l_schema::VARCHAR			/* Schema */, 
				LOWER(l_population_table)::VARCHAR	/* Population table */, 
				l_geography::VARCHAR			/* Geography */, 
				LOWER(c1_rec.geolevel_name)::VARCHAR	/* Geolevel name */);
		END IF;
--
-- Create UPDATE statement
--
		sql_stmt:='WITH a AS ('||E'\n'||
			  E'\t'||'SELECT MAX(year) AS max_year'||E'\n'|| 
			  E'\t'||'  FROM '||quote_ident(LOWER(l_population_table))||E'\n'||
			  '), b AS ('||E'\n'||
			  E'\t'||'SELECT '||quote_ident(LOWER(c1_rec.geolevel_name))||', TRUNC(age_sex_group/100) AS sex, year AS population_year, SUM(total) AS total'||E'\n'||
			  E'\t'||'  FROM '||quote_ident(LOWER(l_population_table))||' b, a'||E'\n'||
			  E'\t'||' WHERE b.year = a.max_year'||E'\n'||
			  E'\t'||' GROUP BY '||quote_ident(LOWER(c1_rec.geolevel_name))||', TRUNC(age_sex_group/100), year'||E'\n'||
			  '), c AS ('||E'\n'||
			  E'\t'||'SELECT b1.'||quote_ident(LOWER(c1_rec.geolevel_name))||', b1.total AS total_males, b2.total AS total_females, b1.population_year'||E'\n'||
			  E'\t'||'  FROM b b1, b b2'||E'\n'||
			  E'\t'||' WHERE b1.'||quote_ident(LOWER(c1_rec.geolevel_name))||' = b2.'||quote_ident(LOWER(c1_rec.geolevel_name))||''||E'\n'||
			  E'\t'||'   AND b1.sex    = 1'||E'\n'||
	 		  E'\t'||'   AND b2.sex    = 2'||E'\n'||
			  ')'||E'\n'||
			  'UPDATE '||quote_ident('t_rif40_'||LOWER(c1_rec.geography)||'_geometry')||' d'||E'\n'||
			  '   SET total_males = ('||E'\n'||
			  E'\t'||'SELECT total_males'||E'\n'||
			  E'\t'||'  FROM c'||E'\n'||
			  E'\t'||' WHERE c.'||quote_ident(LOWER(c1_rec.geolevel_name))||' = d.area_id),'||E'\n'||
			  '       total_females = ('||E'\n'||
			  E'\t'||'SELECT total_females'||E'\n'||
			  E'\t'||'  FROM c'||E'\n'||
			  E'\t'||' WHERE c.'||quote_ident(LOWER(c1_rec.geolevel_name))||' = d.area_id),'||E'\n'||
			  '       population_year = ('||E'\n'||
			  E'\t'||'SELECT population_year'||E'\n'||
			  E'\t'||'  FROM c'||E'\n'||
			  E'\t'||' WHERE c.'||quote_ident(LOWER(c1_rec.geolevel_name))||' = d.area_id)'||E'\n'||
 			  ' WHERE d.geolevel_name = '''||c1_rec.geolevel_name||'''';
		IF sql_stmt IS NULL THEN
			PERFORM rif40_log_pkg.rif40_error(-10037, 'add_population_to_rif40_geolevels_geometry', 'NULL SQL statement for %.%',
				c1_rec.geography::VARCHAR		/* Geography */,
				c1_rec.geolevel_name::VARCHAR		/* Geolevel name */);
		END IF;
		i:=i+1;
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'add_population_to_rif40_geolevels_geometry', 'SQL> %', sql_stmt::VARCHAR);
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	END LOOP;
--
-- Check geolevels were processed
--
	IF i = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-10017, 'add_population_to_rif40_geolevels_geometry', 'Geography: % No rows found in: t_rif40_geolevels',
			l_geography::VARCHAR		/* Geography */);
	END IF;
--
-- Re-analyze
--
	sql_stmt:='ANALYZE VERBOSE '||quote_ident('t_rif40_'||LOWER(l_geography)||'_geometry');
	IF sql_stmt IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10038, 'add_population_to_rif40_geolevels_geometry', 'NULL SQL statement for Geography: %',
			l_geography::VARCHAR		/* Geography */);
	END IF;
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
END;
]]></definition>
</function>

<function name="check_rif40_hierarchy_lookup_tables"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	check_rif40_hierarchy_lookup_tables()
Parameters:	Nothing
Returns:	Nothing
Description:	Diff geography hierarchy tables for 'missing', 'spurious additional' or 'multiple hierarchy' geolevel codes
		Calls rif40_geo_pkg.check_rif40_hierarchy_lookup_tables(geography)]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<definition><![CDATA[
/*

Function: 	check_rif40_hierarchy_lookup_tables()
Parameters:	Nothing
Returns:	Nothing
Description:	Diff geography hierarchy tables for 'missing' or 'spurious additional' or 'multiple hierarchy' geolevel codes
		Calls rif40_geo_pkg.check_rif40_hierarchy_lookup_tables(geography)
 */
DECLARE
	c0 CURSOR FOR
		SELECT *
		  FROM rif40_geographies;
--
	c0_rec rif40_geographies%ROWTYPE;
BEGIN
--
-- Must be rif40 or have rif_user or rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'check_rif40_hierarchy_lookup_tables', 'User % must be rif40 or have rif_user or rif_manager role', 
			USER::VARCHAR	/* Username */);
	END IF;
--
	FOR c0_rec IN c0 LOOP
		PERFORM rif40_geo_pkg.check_rif40_hierarchy_lookup_tables(c0_rec.geography);
	END LOOP;
	PERFORM rif40_log_pkg.rif40_log('INFO', 'check_rif40_hierarchy_lookup_tables', 'All geography codes check OK');
END;
]]></definition>
</function>

<function name="check_rif40_hierarchy_lookup_tables"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	check_rif40_hierarchy_lookup_tables()
Parameters:	Geography 
Returns:	Nothing
Description:	Diff geography hierarchy table for 'missing', 'spurious additional' or 'multiple hierarchy' geolevel codes

		Calls lf_check_rif40_hierarchy_lookup_tables() to do diff]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="l_geography" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	check_rif40_hierarchy_lookup_tables()
Parameters:	Geography 
Returns:	Nothing
Description:	Diff geography hierarchy table for 'missing', 'spurious additional' or 'multiple hierarchy' geolevel codes

		Calls lf_check_rif40_hierarchy_lookup_tables() to do diff
 */
DECLARE
	c1 CURSOR(l_geography VARCHAR) FOR
		SELECT *
		  FROM rif40_geographies
		 WHERE geography = l_geography;
	c1_rec rif40_geographies%ROWTYPE;
--
	e INTEGER:=0;
	f INTEGER:=0;
	g INTEGER:=0;
BEGIN
--
-- Must be rif40 or have rif_user or rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'check_rif40_hierarchy_lookup_tables', 'User % must be rif40 or have rif_user or rif_manager role', 
			USER::VARCHAR	/* Username */);
	END IF;
--
	IF l_geography IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10003, 'check_rif40_hierarchy_lookup_tables', 'NULL geography parameter');
	END IF;	
--
	OPEN c1(l_geography);
	FETCH c1 INTO c1_rec;
	CLOSE c1;
--
	IF c1_rec.geography IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10004, 'check_rif40_hierarchy_lookup_tables', 'geography: % not found', 
			l_geography::VARCHAR	/* Geography */);
	END IF;	
--
-- Call diff and multiple hierarchy tests
--
	e:=rif40_geo_pkg.lf_check_rif40_hierarchy_lookup_tables(c1_rec.geography, c1_rec.hierarchytable, 'missing');
	f:=rif40_geo_pkg.lf_check_rif40_hierarchy_lookup_tables(c1_rec.geography, c1_rec.hierarchytable, 'spurious additional');
	g:=rif40_geo_pkg.lf_check_rif40_hierarchy_lookup_tables(c1_rec.geography, c1_rec.hierarchytable, 'multiple hierarchy');
--
	IF e+f > 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-10005, 'check_rif40_hierarchy_lookup_tables', 'Geography: % codes check % missing, % spurious additional, % hierarchy fails', 
			c1_rec.geography	/* Geography */, 
			e::VARCHAR		/* Missing */, 
			f::VARCHAR		/* Spurious additional */, 
			g::VARCHAR		/* Multiple hierarchy */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('INFO', 'check_rif40_hierarchy_lookup_tables', 'Geography: % codes check OK', 
			c1_rec.geography::VARCHAR	/* Geography */);
	END IF;
END;
]]></definition>
</function>

<function name="create_rif40_geolevels_geometry_tables"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	create_rif40_geolevels_geometry_tables()
Parameters:	Nothing
Returns:	Nothing
Description:	Create rif40_geolevels_geometry tables

ADD GENERATED SQL]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<definition><![CDATA[
/*

Function: 	create_rif40_geolevels_geometry_tables()
Parameters:	Nothing
Returns:	Nothing
Description:	Create rif40_geolevels_geometry tables

 */
DECLARE
	c2geogeom2 CURSOR FOR
		SELECT * FROM rif40_geographies;
--
	c2_rec rif40_geographies%ROWTYPE;
BEGIN
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'create_rif40_geolevels_geometry_tables', 'User % must be rif40 or have rif_manager role', USER::VARCHAR);
	END IF;
--
-- For each geography:
--
	FOR c2_rec IN c2geogeom2 LOOP
		PERFORM rif40_geo_pkg.create_rif40_geolevels_geometry_tables(c2_rec.geography);
	END LOOP;
END;
]]></definition>
</function>

<function name="create_rif40_geolevels_geometry_tables"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	create_rif40_geolevels_geometry_tables()
Parameters:	Geography
Returns:	Nothing
Description:	Crea rif40_geolevels_geometry tables]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="t_geography" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	create_rif40_geolevels_geometry_tables()
Parameters:	Geography
Returns:	Nothing
Description:	Create rif40_geolevels_geometry tables

ADD GENERATED SQL

 */
DECLARE
 	c2geogeom CURSOR(l_geography VARCHAR) FOR
		SELECT * FROM rif40_geographies
		 WHERE geography = l_geography;
 	c3geogeom CURSOR(l_geography VARCHAR) FOR
		SELECT * FROM t_rif40_geolevels
		 WHERE geography = l_geography;
--
	c2_rec rif40_geographies%ROWTYPE;
	c3_rec t_rif40_geolevels%ROWTYPE;
--
	c3_count INTEGER:=0;
	func_sql VARCHAR;
	sql_stmt VARCHAR;
BEGIN
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'create_rif40_geolevels_geometry_tables', 'User % must be rif40 or have rif_manager role', USER::VARCHAR);
	END IF;
--
	IF t_geography IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10003, 'check_rif40_hierarchy_lookup_tables', 'NULL geography parameter');
	END IF;	
--
	OPEN c2geogeom(t_geography);
	FETCH c2geogeom INTO c2_rec;
	CLOSE c2geogeom;
--
	IF c2_rec.geography IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10004, 'create_rif40_geolevels_geometry_tables', 'geography: % not found', 
			t_geography::VARCHAR	/* Geography */);
	ELSE
--
-- Create a T_RIF40_<GEOGRAPHY>_GEOMETRY base table to inherit from 
--
		sql_stmt:='CREATE TABLE '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||' ('||E'\n'||
			'geography         CHARACTER VARYING(50)  NOT NULL,'||E'\n'||
			'geolevel_name     CHARACTER VARYING(30)  NOT NULL,'||E'\n'||
			'area_id           CHARACTER VARYING(300) NOT NULL,'||E'\n'||
			'name              CHARACTER VARYING(300) NULL,'||E'\n'||
			'optimised_geojson CHARACTER VARYING      NOT NULL,'||E'\n'||
			'area              NUMERIC(12,2)          NOT NULL,'||E'\n'||
			'total_males	   NUMERIC(12,2)          NULL,'||E'\n'||
			'total_females	   NUMERIC(12,2)          NULL,'||E'\n'||
			'population_year   NUMERIC(12,2)          NULL,'||E'\n'||
			'gid               INTEGER                NOT NULL)';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--		
-- Comment base table
--
		sql_stmt:='COMMENT ON TABLE '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||' IS ''Geolevels geometry: geometry for hierarchy of level with a geography. Use this table for INSERT/UPDATE/DELETE; use RIF40_GEOLEVELS for SELECT. In RIF40_GEOLEVELS if the user has the RIF_STUDENT role the geolevels are restricted to LADUA/DISTRICT level resolution or lower. This table contains no data on Oracle. This replaces the shapefiles used in previous RIF releases. Populating this table checks the lookup and hierarchy tables and thus it must be populated last. Any insert into T_RIF40_GEOLEVELS_GEOMETRY must be a single statement insert.''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||'.geography 	IS ''Geography (e.g EW2001)''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||'.geolevel_name 	IS ''Name of geolevel. This will be a column name in the numerator/denominator tables''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||'.area_id 	IS ''An area id, the value of a geolevel; i.e. the value of the column T_RIF40_GEOLEVELS.GEOLEVEL_NAME in table T_RIF40_GEOLEVELS.LOOKUP_TABLE''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||'.name 	IS ''The name of an area id''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||'.area 	IS ''The area in square km of an area id''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||'.total_males 	IS ''Total males''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||'.total_females 	IS ''Total females''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||'.population_year 	IS ''Year of population data''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||'.optimised_geojson 	IS ''Shapefile multipolygon in optimised GeoJSON format. RIF40_GEOGRAPHIES.MAX_GEOJSON_DIGITS determines the number of digits in the GeoJSON output and RIF40_GEOLEVELS.ST_SIMPLIFY_TOLERANCE determines the minimum distance (in metres for most projections) between simplified points. Will contain small slivers and overlaps due to limitation in the Douglas-Peucker algorithm (it works onj an object by object basis; the edge between two areas will therefore be processed independently and not necessarily in the same manner). This can be fixed using the PostGIS Topology extension and processing as edges. See also TOPO_OPTIMISED_GEOJSON; i.e. GeoJson optimised using ST_ChangeEdgeGeometry() and ST_Simplify(). The SRID is always 4326.''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||'.gid 	IS ''Geographic ID (artificial primary key originally created by shp2pgsql, equals RIF40_GEOLEVELS.GEOLEVEL_ID after ST_Union() conversion to single multipolygon per AREA_ID)''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Add a multipolygon columns SHAPEFILE_GEOMETRY and OPTIMISED_GEOMETRY with the SRID for the geography
--
		sql_stmt:='SELECT AddGeometryColumn('||quote_literal('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||', ''shapefile_geometry'', '||
			c2_rec.srid||', ''MULTIPOLYGON'', 2)';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='ALTER TABLE '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||' ALTER COLUMN shapefile_geometry SET NOT NULL';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||'.shapefile_geometry	 IS ''Spatial data for geolevel (PostGress/PostGIS only). Can also use SHAPEFILE instead,''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
		sql_stmt:='SELECT AddGeometryColumn('||quote_literal('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||', ''optimised_geometry'', 4326, ''MULTIPOLYGON'', 2)';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='ALTER TABLE '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||' ALTER COLUMN optimised_geometry SET NOT NULL';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||'.optimised_geometry	 IS ''Optimised spatial data for geolevel in SRID 4326 [WGS84] (PostGress/PostGIS only). Can also use SHAPEFILE instead. RIF40_GEOGRAPHIES.MAX_GEOJSON_DIGITS determines the number of digits in the GeoJSON output and RIF40_GEOLEVELS.ST_SIMPLIFY_TOLERANCE determines the minimum distance (in metres for most projections) between simplified points. Will contain small slivers and overlaps due to limitation in the Douglas-Peucker algorithm (it works onj an object by object basis; the edge between two areas will therefore be processed independently and not necessarily in the same manner. This is fixed using the PostGIS Topology extension and processing as edges.''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Add PK/UK indexes
--
		sql_stmt:='CREATE UNIQUE INDEX '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry_uk')||' ON '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||'(geography, gid, area_id)';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='ALTER TABLE '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||' ADD CONSTRAINT '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry_pk')||' PRIMARY KEY (geography, geolevel_name, area_id)';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Base table INSERT fuuntion
--
		func_sql:='CREATE OR REPLACE FUNCTION '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry_insert')||'()'||E'\n'||
			'RETURNS TRIGGER AS $func$'||E'\n'||
			'BEGIN'||E'\n';
--
-- For each geolevel with the geography:
--
		c3_count:=0;
		FOR c3_rec IN c3geogeom(c2_rec.geography) LOOP
--
-- Create partitions T_RIF40_GEOLEVELS_GEOMETRY_<GEOGRAPHY>_<GEOELVELS>
--
			c3_count:=c3_count+1;
			sql_stmt:='CREATE TABLE '||quote_ident('t_rif40_geolevels_geometry_'||
				LOWER(c2_rec.geography)||'_'||LOWER(c3_rec.geolevel_name))||E'\n'||
				'( CHECK (geography = '''||c2_rec.geography||
				''' AND geolevel_name = '''||c3_rec.geolevel_name||''')'||E'\n'||
				') INHERITS (t_rif40_'||LOWER(c2_rec.geography)||'_geometry)';
			IF c3_count = 1 THEN
				func_sql:=func_sql||E'\n'||'	IF NEW.geography = '''||c2_rec.geography||
					''' AND NEW.geolevel_name = '''||c3_rec.geolevel_name||''' THEN'||E'\n'||
					'INSERT INTO '||quote_ident('t_rif40_geolevels_geometry_'||
				LOWER(c2_rec.geography)||'_'||LOWER(c3_rec.geolevel_name))||' VALUES (NEW.*);';
			ELSE
				func_sql:=func_sql||E'\n'||'	ELSIF NEW.geography = '''||c2_rec.geography||
					''' AND NEW.geolevel_name = '''||c3_rec.geolevel_name||''' THEN'||E'\n'||
					'INSERT INTO '||quote_ident('t_rif40_geolevels_geometry_'||
				LOWER(c2_rec.geography)||'_'||LOWER(c3_rec.geolevel_name))||' VALUES (NEW.*);';
			END IF;
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Comment
--
			sql_stmt:='COMMENT ON TABLE '||quote_ident('t_rif40_geolevels_geometry_'||
				LOWER(c2_rec.geography)||'_'||LOWER(c3_rec.geolevel_name))||' 		IS ''Geolevels geometry: geometry for hierarchy of level with a geography. Use this table for INSERT/UPDATE/DELETE; use RIF40_GEOLEVELS for SELECT. In RIF40_GEOLEVELS if the user has the RIF_STUDENT role the geolevels are restricted to LADUA/DISTRICT level resolution or lower. This table contains no data on Oracle. This replaces the shapefiles used in previous RIF releases. Populating this table checks the lookup and hierarchy tables and thus it must be populated last. Any insert into T_RIF40_GEOLEVELS_GEOMETRY must be a single statement insert. This is the partition for geogrpahy: '||
				LOWER(c2_rec.geography)||', geo level: '||LOWER(c3_rec.geolevel_name)||'''';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_geolevels_geometry_'||
				LOWER(c2_rec.geography)||'_'||LOWER(c3_rec.geolevel_name))||'.geography 	IS ''Geography (e.g EW2001)''';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_geolevels_geometry_'||
				LOWER(c2_rec.geography)||'_'||LOWER(c3_rec.geolevel_name))||'.geolevel_name 	IS ''Name of geolevel. This will be a column name in the numerator/denominator tables''';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_geolevels_geometry_'||
				LOWER(c2_rec.geography)||'_'||LOWER(c3_rec.geolevel_name))||'.area_id 	IS ''An area id, the value of a geolevel; i.e. the value of the column T_RIF40_GEOLEVELS.GEOLEVEL_NAME in table T_RIF40_GEOLEVELS.LOOKUP_TABLE''';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_geolevels_geometry_'||
				LOWER(c2_rec.geography)||'_'||LOWER(c3_rec.geolevel_name))||'.optimised_geojson 	IS ''Shapefile multipolygon in optimised GeoJSON format. RIF40_GEOGRAPHIES.MAX_GEOJSON_DIGITS determines the number of digits in the GeoJSON output and RIF40_GEOLEVELS.ST_SIMPLIFY_TOLERANCE determines the minimum distance (in metres for most projections) between simplified points. Will contain small slivers and overlaps due to limitation in the Douglas-Peucker algorithm (it works on an object by object basis; the edge between two areas will therefore be processed independently and not necessarily in the same manner). This can be` fixed using the PostGIS Topology extension and processing as edges. See also TOPO_OPTIMISED_GEOJSON; i.e. GeoJson optimised using ST_ChangeEdgeGeometry() and ST_Simplify().''';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_geolevels_geometry_'||
				LOWER(c2_rec.geography)||'_'||LOWER(c3_rec.geolevel_name))||'.area 	IS ''The area in square km of an area id''';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_geolevels_geometry_'||
				LOWER(c2_rec.geography)||'_'||LOWER(c3_rec.geolevel_name))||'.name 	IS ''The name of an area id''';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_geolevels_geometry_'||
				LOWER(c2_rec.geography)||'_'||LOWER(c3_rec.geolevel_name))||'.gid 	IS ''Geographic ID (artificial primary key originally created by shp2pgsql, equals RIF40_GEOLEVELS.GEOLEVEL_ID after ST_Union() conversion to single multipolygon per AREA_ID)''';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_geolevels_geometry_'||
				LOWER(c2_rec.geography)||'_'||LOWER(c3_rec.geolevel_name))||'.shapefile_geometry	 IS ''Spatial data for geolevel (PostGress/PostGIS only). Can also use SHAPEFILE instead,''';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_geolevels_geometry_'||
				LOWER(c2_rec.geography)||'_'||LOWER(c3_rec.geolevel_name))||'.optimised_geometry	 IS ''Optimised spatial data for geolevel in SRID 4326 [WGS84] (PostGress/PostGIS only). Can also use SHAPEFILE instead. RIF40_GEOGRAPHIES.MAX_GEOJSON_DIGITS determines the number of digits in the GeoJSON output and RIF40_GEOLEVELS.ST_SIMPLIFY_TOLERANCE determines the minimum distance (in metres for most projections) between simplified points. Will contain small slivers and overlaps due to limitation in the Douglas-Peucker algorithm (it works onj an object by object basis; the edge between two areas will therefore be processed independently and not necessarily in the same manner. This is fixed using the PostGIS Topology extension and processing as edges.''';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
			sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_geolevels_geometry_'||
				LOWER(c2_rec.geography)||'_'||LOWER(c3_rec.geolevel_name))||'.total_males	 IS ''Total males.''';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_geolevels_geometry_'||
				LOWER(c2_rec.geography)||'_'||LOWER(c3_rec.geolevel_name))||'.total_females	 IS ''Total females.''';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='COMMENT ON COLUMN '||quote_ident('t_rif40_geolevels_geometry_'||
				LOWER(c2_rec.geography)||'_'||LOWER(c3_rec.geolevel_name))||'.population_year	 IS ''Population year.''';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		END LOOP;
--
-- Create base insert function
--
		func_sql:=func_sql||E'\n'||
'	ELSE'||E'\n'||
'--'||E'\n'||
'-- Eventually this will automatically add a partition'||E'\n'||
'--'||E'\n'||
'		PERFORM rif40_log_pkg.rif40_error(-10002, ''t_rif40_geolevels_geometry_insert'', ''no partition for geography: %, geolevel: %'','||E'\n'||
'			NEW.geography, NEW.geolevel_name);'||E'\n'||
'	END IF;'||E'\n'||
'	RETURN NULL;'||E'\n'||
'END;'||E'\n'||
'$func$'||E'\n'||
'LANGUAGE plpgsql';
		PERFORM rif40_sql_pkg.rif40_ddl(func_sql);
		sql_stmt:='COMMENT ON FUNCTION '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry_insert')||'() IS ''Partition INSERT function for geography: '||c2_rec.geography||'''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Trigger
--
		sql_stmt:='CREATE TRIGGER '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry_insert')||E'\n'||
			'BEFORE INSERT ON '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||E'\n'||
			'FOR EACH ROW EXECUTE PROCEDURE '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry_insert')||'()';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON TRIGGER '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry_insert')||E'\n'||E'\t'||'ON '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||' IS ''Partition INSERT trigger for geography: '||c2_rec.geography||'''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);

--
-- Analyze
--

		sql_stmt:='GRANT SELECT,INSERT,UPDATE,DELETE ON '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||' TO rif_manager';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='GRANT SELECT ON '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry')||' TO PUBLIC';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='ANALYZE VERBOSE '||quote_ident('t_rif40_'||LOWER(c2_rec.geography)||'_geometry');
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
	END IF;
--
END;
]]></definition>
</function>

<function name="create_rif40_geolevels_lookup_tables"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	create_rif40_geolevels_lookup_tables()
Parameters:	Nothing
Returns:	Nothing
Description:	Create and popualte rif40_geolevels lookup and create hierarchy tables]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<definition><![CDATA[
/*

Function: 	create_rif40_geolevels_lookup_tables()
Parameters:	Nothing
Returns:	Nothing
Description:	Create and popualte rif40_geolevels lookup and create hierarchy tables
 */
DECLARE
	c2geolook2 CURSOR FOR
		SELECT *
		  FROM rif40_geographies;
--
	c2_rec rif40_geographies%ROWTYPE;
BEGIN
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'create_rif40_geolevels_lookup_tables', 'User % must be rif40 or have rif_manager role', 
			USER::VARCHAR 	/* User name */);
	END IF;
--
	FOR c2_rec IN c2geolook2 LOOP
		PERFORM rif40_geo_pkg.create_rif40_geolevels_lookup_tables(c2_rec.geography);
	END LOOP;
END;
]]></definition>
</function>

<function name="create_rif40_geolevels_lookup_tables"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	create_rif40_geolevels_lookup_tables()
Parameters:	Geography
Returns:	Nothing
Description:	Create and popualte rif40_geolevels lookup and create hierarchy tables

Lookup table example:

CREATE TABLE ew2001_soa2001
AS
WITH a AS (
	SELECT soa2001 AS soa2001, NULL AS name, ST_Union(geom) AS geom
	  FROM x_ew01_soa2001
	 GROUP BY soa2001
)
SELECT soa2001, name
  FROM a
 ORDER BY 1;

Hierarchy table example

CREATE TABLE sahsuland_geography (
          level1 VARCHAR(100)
        , level2 VARCHAR(100)
        , level3 VARCHAR(100)
        , level4 VARCHAR(100)
);

The Hierarchy table is not populated; this is assumed to be done in ArcGIS
as ARcGIS has an aggregation function that uses best fit to build a hierarchy.
The below method will do the same. The method removes duplicates by picking the 
intersection where the intersected area most closely matches the smaller of the 2 areas

See: ../postgres/gis_intersection_prototype.sql]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="l_geography" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	create_rif40_geolevels_lookup_tables()
Parameters:	Geography
Returns:	Nothing
Description:	Create and populate rif40_geolevels lookup and create hierarchy tables

Lookup table example:

CREATE TABLE ew2001_soa2001
AS
WITH a AS (
	SELECT soa2001 AS soa2001, NULL AS name, ST_Union(geom) AS geom
	  FROM x_ew01_soa2001
	 GROUP BY soa2001
)
SELECT soa2001, name
  FROM a
 ORDER BY 1;

Hierarchy table example

CREATE TABLE sahsuland_geography (
          level1 VARCHAR(100)
        , level2 VARCHAR(100)
        , level3 VARCHAR(100)
        , level4 VARCHAR(100)
);

The Hierarchy table is not populated; this is assumed to be done in ArcGIS
as ARcGIS has an aggregation function that uses best fit to build a hierarchy.
The below method will do the same. The method removes duplicates by picking the 
intersection where the intersected area most closely matches the smaller of the 2 areas

See: ../postgres/gis_intersection_prototype.sql

 */
DECLARE
	c1geolook CURSOR(l_geography VARCHAR) FOR
		SELECT * 
		  FROM t_rif40_geolevels
		 WHERE geography = l_geography
		 ORDER BY geography, geolevel_id;
	c2geolook CURSOR(l_geography VARCHAR) FOR
		SELECT *
		  FROM rif40_geographies
		 WHERE geography = l_geography;
--
	c1_rec t_rif40_geolevels%ROWTYPE;
	c2_rec rif40_geographies%ROWTYPE;
--
	sql_stmt VARCHAR;
	hier_stmt1 VARCHAR;
	hier_stmt2 VARCHAR[]:=NULL;
	hier_stmt3 VARCHAR[]:=NULL;
	hier_stmt4 VARCHAR;
	previous_geography VARCHAR:=NULL;
	hierarchytable VARCHAR:=NULL;
	i INTEGER;
	last INTEGER;
BEGIN
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'create_rif40_geolevels_lookup_tables', 'User % must be rif40 or have rif_manager role', 
			USER::VARCHAR 	/* User name */);
	END IF;
--
-- Create lookup and Hierarchy tables
--
	FOR c1_rec IN c1geolook(l_geography) LOOP
		IF previous_geography IS NULL THEN
			OPEN c2geolook(c1_rec.geography);
			FETCH c2geolook INTO c2_rec;
			CLOSE c2geolook;
			hierarchytable:=c2_rec.hierarchytable;
			hier_stmt1:='CREATE TABLE '||quote_ident(LOWER(hierarchytable))||' ('||E'\n'||E'\t'||'  '||quote_ident(LOWER(c1_rec.geolevel_name))||' VARCHAR(100)'||E'\n';
		ELSIF previous_geography != c1_rec.geography THEN
			PERFORM rif40_log_pkg.rif40_log('INFO', 'create_rif40_geolevels_lookup_tables', 'Creating % geography hierarchy table: %',
				c1_rec.geography, hierarchytable);
			hier_stmt1:=hier_stmt1||')';
			PERFORM rif40_sql_pkg.rif40_ddl(hier_stmt1);
			hier_stmt1:='GRANT SELECT ON '||quote_ident(LOWER(hierarchytable))||' TO PUBLIC';
			PERFORM rif40_sql_pkg.rif40_ddl(hier_stmt1);
			i:=0;
			last:=0;
			FOREACH hier_stmt1 IN ARRAY hier_stmt3 LOOP /* Column comments */
				last:=last+1;
			END LOOP;	
			FOREACH hier_stmt1 IN ARRAY hier_stmt3 LOOP /* Indexes */
				i:=i+1;
				IF i != last THEN
					hier_stmt4:='CREATE INDEX '||hier_stmt1;
				ELSE
					hier_stmt4:='CREATE UNIQUE INDEX '||hier_stmt1;
				END IF;
				PERFORM rif40_sql_pkg.rif40_ddl(hier_stmt4);
			END LOOP;	
			FOREACH hier_stmt1 IN ARRAY hier_stmt2 LOOP
				PERFORM rif40_sql_pkg.rif40_ddl(hier_stmt1);
			END LOOP;	
			hier_stmt1:='ANALYZE VERBOSE '||quote_ident(LOWER(hierarchytable));
			PERFORM rif40_sql_pkg.rif40_ddl(hier_stmt1);
			OPEN c2geolook(previous_geography);
			FETCH c2geolook INTO c2_rec;
			CLOSE c2geolook;
			hier_stmt1:='COMMENT ON TABLE '||quote_ident(LOWER(hierarchytable))||' IS '||quote_literal(c2_rec.description||' geo-level hierarchy table');
			PERFORM rif40_sql_pkg.rif40_ddl(hier_stmt1);
--
-- Next geography
--
			OPEN c2geolook(c1_rec.geography);
			FETCH c2geolook INTO c2_rec;
			CLOSE c2geolook;
			hierarchytable:=c2_rec.hierarchytable;
--
-- Reset arrays
--
			hier_stmt2:=NULL;
			hier_stmt3:=NULL;
--
-- Create table - can be CTAS in future (see comment at top)
--
			hier_stmt1:='CREATE TABLE '||quote_ident(LOWER(hierarchytable))||' ('||E'\n'||E'\t'||'  '||quote_ident(LOWER(c1_rec.geolevel_name))||' VARCHAR(100)'||E'\n';
		ELSE
			hier_stmt1:=hier_stmt1||E'\t'||', '||quote_ident(LOWER(c1_rec.geolevel_name))||' VARCHAR(100)'||E'\n';
		END IF;
		hier_stmt2[c1_rec.geolevel_id]:='COMMENT ON COLUMN '||quote_ident(LOWER(hierarchytable))||'.'||quote_ident(LOWER(c1_rec.geolevel_name))||
			' IS '||quote_literal(c1_rec.description);
		hier_stmt3[c1_rec.geolevel_id]:='/* Create index */ '||quote_ident(LOWER(c1_rec.geolevel_name)||'_idx'||c1_rec.geolevel_id)||' ON '||
			quote_ident(LOWER(hierarchytable))||'('||quote_ident(LOWER(c1_rec.geolevel_name))||')';
		previous_geography:=c1_rec.geography;
--
		PERFORM rif40_log_pkg.rif40_log('INFO', 'create_rif40_geolevels_lookup_tables', 'Creating % geography % lookup table: %',
			c1_rec.geography, c1_rec.geolevel_name, c1_rec.lookup_table);
--
-- Create table - using CTAS
--
		sql_stmt:='CREATE TABLE '||quote_ident(LOWER(c1_rec.lookup_table))||E'\n'||'AS'||E'\n';
--
-- WITH block
--
		sql_stmt:=sql_stmt||'WITH a AS ('||E'\n';
		sql_stmt:=sql_stmt||E'\t'||'SELECT '||quote_ident(LOWER(c1_rec.shapefile_area_id_column))||' AS '||quote_ident(LOWER(c1_rec.geolevel_name));
		IF c1_rec.shapefile_desc_column IS NOT NULL THEN
			sql_stmt:=sql_stmt||', '||quote_ident(LOWER(c1_rec.shapefile_desc_column))||' AS '||quote_ident(LOWER(c1_rec.lookup_desc_column));
		ELSE
			sql_stmt:=sql_stmt||', NULL::Text AS '||quote_ident(LOWER(c1_rec.lookup_desc_column));
		END IF;
		sql_stmt:=sql_stmt||', ST_Union(geom) AS geom'||E'\n';
		IF c1_rec.centroids_table IS NOT NULL AND 
		   c1_rec.centroidxcoordinate_column IS NULL AND 
		   c1_rec.centroidycoordinate_column IS NULL THEN
			sql_stmt:=sql_stmt||E'\t'||'  FROM '||quote_ident(LOWER(c1_rec.centroids_table))||E'\n';
		ELSE
			sql_stmt:=sql_stmt||E'\t'||'  FROM '||quote_ident(LOWER(c1_rec.shapefile_table))||E'\n';
		END IF;
		IF c1_rec.shapefile_desc_column IS NOT NULL THEN
			sql_stmt:=sql_stmt||E'\t'||' GROUP BY '||quote_ident(LOWER(c1_rec.shapefile_area_id_column))||', '||quote_ident(LOWER(c1_rec.shapefile_desc_column))||E'\n';
		ELSE
			sql_stmt:=sql_stmt||E'\t'||' GROUP BY '||quote_ident(LOWER(c1_rec.shapefile_area_id_column))||E'\n';
		END IF;
		sql_stmt:=sql_stmt||')'||E'\n';
--
-- Main select
--
		sql_stmt:=sql_stmt||'SELECT '||quote_ident(LOWER(c1_rec.geolevel_name))||', '||quote_ident(LOWER(c1_rec.lookup_desc_column));
		IF c1_rec.centroids_table IS NOT NULL AND 
		   c1_rec.centroidxcoordinate_column IS NULL AND 
		   c1_rec.centroidycoordinate_column IS NULL THEN
			sql_stmt:=sql_stmt||', ST_X(a.geom) AS '||quote_ident(LOWER(c1_rec.centroidxcoordinate_column))||
				', ST_Y(a.geom) AS '||quote_ident(LOWER(c1_rec.centroidycoordinate_column))||E'\n'||
				'  FROM a'||E'\n';
		ELSE
			sql_stmt:=sql_stmt||E'\n'||'  FROM a'||E'\n';
		END IF;
		sql_stmt:=sql_stmt||' ORDER BY 1'||E'\n';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Fix name column type
--
		sql_stmt:='ALTER TABLE '||quote_ident(LOWER(c1_rec.lookup_table))||' ALTER COLUMN name TYPE VARCHAR(100);'||E'\n';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Index
--
		sql_stmt:='CREATE UNIQUE INDEX '||quote_ident(LOWER(c1_rec.lookup_table)||'_pk')||' ON '||quote_ident(LOWER(c1_rec.lookup_table))||
			'('||quote_ident(LOWER(c1_rec.geolevel_name))||')';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Grant
--
		sql_stmt:='GRANT SELECT ON '||quote_ident(LOWER(c1_rec.lookup_table))||' TO PUBLIC';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
--  Analyze
--
		sql_stmt:='ANALYZE VERBOSE '||quote_ident(LOWER(c1_rec.lookup_table));
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Comment
--
		sql_stmt:='COMMENT ON TABLE '||quote_ident(LOWER(c1_rec.lookup_table))||' IS '||quote_literal(c1_rec.description||' lookup table');
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||quote_ident(LOWER(c1_rec.lookup_table))||'.'||quote_ident(LOWER(c1_rec.geolevel_name))||' IS '''||quote_ident(LOWER(c1_rec.geolevel_name))||'''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||quote_ident(LOWER(c1_rec.lookup_table))||'.name IS '''||quote_ident(LOWER(c1_rec.geolevel_name))||' name''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	END LOOP;
--
-- Do the last Hierarchy table
--
	PERFORM rif40_log_pkg.rif40_log('INFO', 'create_rif40_geolevels_lookup_tables', 'Creating % geography hierarchy table: %',
		c1_rec.geography	/* Geography */, 
		hierarchytable		/* Hierarchy table */);
--
	hier_stmt1:=hier_stmt1||')';
	PERFORM rif40_sql_pkg.rif40_ddl(hier_stmt1);
	hier_stmt1:='ANALYZE VERBOSE '||quote_ident(LOWER(hierarchytable));
	PERFORM rif40_sql_pkg.rif40_ddl(hier_stmt1);
	hier_stmt1:='GRANT SELECT ON '||quote_ident(LOWER(hierarchytable))||' TO PUBLIC';
	PERFORM rif40_sql_pkg.rif40_ddl(hier_stmt1);
	i:=0;
	last:=0;
	FOREACH hier_stmt1 IN ARRAY hier_stmt3 LOOP /* Column comments */
		last:=last+1;
	END LOOP;	
	FOREACH hier_stmt1 IN ARRAY hier_stmt3 LOOP /* Indexes */
		i:=i+1;
		IF i != last THEN
			hier_stmt4:='CREATE INDEX '||hier_stmt1;
		ELSE
			hier_stmt4:='CREATE UNIQUE INDEX '||hier_stmt1;
		END IF;
		PERFORM rif40_sql_pkg.rif40_ddl(hier_stmt4);
	END LOOP;	
	FOREACH hier_stmt1 IN ARRAY hier_stmt2 LOOP
		PERFORM rif40_sql_pkg.rif40_ddl(hier_stmt1);
	END LOOP;	
	OPEN c2geolook(previous_geography);
	FETCH c2geolook INTO c2_rec;
	CLOSE c2geolook;
	hier_stmt1:='COMMENT ON TABLE '||quote_ident(LOWER(hierarchytable))||' IS '||quote_literal(c2_rec.description||' geo-level hierarchy table');
	PERFORM rif40_sql_pkg.rif40_ddl(hier_stmt1);
END;
]]></definition>
</function>

<function name="drop_rif40_geolevels_geometry_tables"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	drop_rif40_geolevels_geometry_tables()
Parameters:	Nothing
Returns:	Nothing
Description:	Drop rif40_geolevels_geometry tables]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<definition><![CDATA[
/*

Function: 	drop_rif40_geolevels_geometry_tables()
Parameters:	Nothing
Returns:	Nothing
Description:	Drop rif40_geolevels_geometry tables

 */
DECLARE
	c1 CURSOR FOR
		SELECT * FROM information_schema.tables 
		 WHERE table_name LIKE 't_rif40_%_geometry' AND table_name != 't_rif40_geolevels_geometry';
	c1a CURSOR(l_trigger VARCHAR) FOR
		SELECT * FROM information_schema.triggers 
		 WHERE trigger_name = l_trigger;
	c1b CURSOR(l_routines VARCHAR) FOR
		SELECT * FROM information_schema.routines 
		 WHERE routine_name = l_routines;
--
	c1_rec information_schema.tables%ROWTYPE;
	c1a_rec information_schema.triggers%ROWTYPE;
	c1b_rec information_schema.routines%ROWTYPE;
--
	sql_stmt VARCHAR;
BEGIN
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'drop_rif40_geolevels_geometry_tables', 'User % must be rif40 or have rif_manager role', 
			USER::VARCHAR /* Username */);
	END IF;
--
-- Drop existing objects
--
	FOR c1_rec IN c1 LOOP
		OPEN c1a(quote_ident(c1_rec.table_name||'_insert'));
		FETCH c1a INTO c1a_rec;
		CLOSE c1a;
		IF c1a_rec.trigger_name IS NOT NULL THEN
			sql_stmt:='DROP TRIGGER '||quote_ident(c1_rec.table_name||'_insert')||' ON '||c1_rec.table_name;
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		END IF;
		OPEN c1b(quote_ident(c1_rec.table_name||'_insert'));
		FETCH c1b INTO c1b_rec;
		CLOSE c1b;
		IF c1b_rec.routine_name IS NOT NULL THEN
			sql_stmt:='DROP FUNCTION '||quote_ident(c1_rec.table_name||'_insert')||'()';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		END IF;
		sql_stmt:='DROP TABLE '||quote_ident(c1_rec.table_name)||' CASCADE';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	END LOOP;
END;
]]></definition>
</function>

<function name="drop_rif40_geolevels_geometry_tables"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	drop_rif40_geolevels_geometry_tables()
Parameters:	Geography
Returns:	Nothing
Description:	Drop rif40_geolevels_geometry tables]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="t_geography" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	drop_rif40_geolevels_geometry_tables()
Parameters:	Geography
Returns:	Nothing
Description:	Drop rif40_geolevels_geometry tables

 */
DECLARE
	c1 CURSOR(l_table_name VARCHAR) FOR
		SELECT * FROM information_schema.tables 
		 WHERE table_name = quote_ident(l_table_name) AND table_name != 't_rif40_geolevels_geometry';
	c1a CURSOR(l_trigger VARCHAR) FOR
		SELECT * FROM information_schema.triggers 
		 WHERE trigger_name = l_trigger;
	c1b CURSOR(l_routines VARCHAR) FOR
		SELECT * FROM information_schema.routines 
		 WHERE routine_name = l_routines;
--
	c1_rec information_schema.tables%ROWTYPE;
	c1a_rec information_schema.triggers%ROWTYPE;
	c1b_rec information_schema.routines%ROWTYPE;
--
	sql_stmt VARCHAR;
BEGIN
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'drop_rif40_geolevels_geometry_tables', 'User % must be rif40 or have rif_manager role', 
			USER::VARCHAR /* Username */);
	END IF;
--
-- Drop existing objects
--
	FOR c1_rec IN c1('t_rif40_'||LOWER(t_geography)||'_geometry') LOOP
		OPEN c1a(quote_ident(c1_rec.table_name||'_insert'));
		FETCH c1a INTO c1a_rec;
		CLOSE c1a;
		IF c1a_rec.trigger_name IS NOT NULL THEN
			sql_stmt:='DROP TRIGGER '||quote_ident(c1_rec.table_name||'_insert')||' ON '||c1_rec.table_name;
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		END IF;
		OPEN c1b(quote_ident(c1_rec.table_name||'_insert'));
		FETCH c1b INTO c1b_rec;
		CLOSE c1b;
		IF c1b_rec.routine_name IS NOT NULL THEN
			sql_stmt:='DROP FUNCTION '||quote_ident(c1_rec.table_name||'_insert')||'()';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		END IF;
		sql_stmt:='DROP TABLE '||quote_ident(c1_rec.table_name)||' CASCADE';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	END LOOP;
END;
]]></definition>
</function>

<function name="drop_rif40_geolevels_lookup_tables"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	drop_rif40_geolevels_lookup_tables()
Parameters:	Nothing
Returns:	Nothing
Description:	Drop rif40_geolevels lookup and hierarchy tables]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<definition><![CDATA[
/*

Function: 	drop_rif40_geolevels_lookup_tables()
Parameters:	Nothing
Returns:	Nothing
Description:	Drop rif40_geolevels lookup and hierarchy tables

 */
DECLARE
	c1 CURSOR FOR
		SELECT * FROM information_schema.tables 
		 WHERE table_name IN (SELECT DISTINCT LOWER(lookup_table)
				        FROM t_rif40_geolevels WHERE lookup_table IS NOT NULL
				       UNION 
				      SELECT DISTINCT LOWER(hierarchytable)
				        FROM rif40_geographies
				       UNION 
				      SELECT DISTINCT LOWER(hierarchytable)||'_orig'
				        FROM rif40_geographies
				 /*    UNION 		-* NOT shapefile/centroid tables; these are loaded by ../shapefiles/shapefiles.sql and are now GIS objects *-
				      SELECT DISTINCT LOWER(shapefile_table)
				        FROM t_rif40_geolevels WHERE shapefile_table IS NOT NULL
				       UNION 
				      SELECT DISTINCT LOWER(centroids_table)
				        FROM t_rif40_geolevels WHERE centroids_table IS NOT NULL */);
--
	c1_rec information_schema.tables%ROWTYPE;
--
	sql_stmt VARCHAR;
BEGIN
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'drop_rif40_geolevels_lookup_tables', 'User % must be rif40 or have rif_manager role', 
			USER::VARCHAR 	/* User name */);
	END IF;
----
-- Drop existing objects
--
	FOR c1_rec IN c1 LOOP
		sql_stmt:='DROP TABLE '||quote_ident(LOWER(c1_rec.table_name))||' CASCADE';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	END LOOP;
END;
]]></definition>
</function>

<function name="drop_rif40_geolevels_lookup_tables"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	drop_rif40_geolevels_lookup_tables()
Parameters:	Geography
Returns:	Nothing
Description:	Drop rif40_geolevels lookup and hierarchy tables]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="geography" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	drop_rif40_geolevels_lookup_tables()
Parameters:	Geography
Returns:	Nothing
Description:	Drop rif40_geolevels lookup and hierarchy tables

 */
DECLARE
	c1 CURSOR(l_geography VARCHAR) FOR
		SELECT * FROM information_schema.tables 
		 WHERE table_name IN (SELECT DISTINCT LOWER(lookup_table)
				        FROM t_rif40_geolevels a
				       WHERE lookup_table IS NOT NULL
				         AND a.geography = l_geography
				       UNION 
				      SELECT DISTINCT LOWER(hierarchytable)
				        FROM rif40_geographies b
				       WHERE b.geography = l_geography
				       UNION 
				      SELECT DISTINCT LOWER(hierarchytable)||'_orig'
				        FROM rif40_geographies c
				       WHERE c.geography = l_geography
				 /*    UNION 		-* NOT shapefile/centroid tables; these are loaded by ../shapefiles/shapefiles.sql and are now GIS objects *-
				      SELECT DISTINCT LOWER(shapefile_table)
				        FROM t_rif40_geolevels WHERE shapefile_table IS NOT NULL
				       UNION 
				      SELECT DISTINCT LOWER(centroids_table)
				        FROM t_rif40_geolevels WHERE centroids_table IS NOT NULL */);
--
	c1_rec information_schema.tables%ROWTYPE;
--
	sql_stmt VARCHAR;
BEGIN
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'drop_rif40_geolevels_lookup_tables', 'User % must be rif40 or have rif_manager role', 
			USER::VARCHAR 	/* User name */);
	END IF;
----
-- Drop existing objects
--
	FOR c1_rec IN c1(geography) LOOP
		sql_stmt:='DROP TABLE '||quote_ident(LOWER(c1_rec.table_name))||' CASCADE';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	END LOOP;
END;
]]></definition>
</function>

<function name="fix_null_geolevel_names"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	fix_null_geolevel_names()
Parameters:	None
Returns:	Nothing
Description:	Fix NULL geolevel names in geography geolevel geometry and lookup table data, re-analyze
		Add unique index]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<definition><![CDATA[
/*

Function: 	fix_null_geolevel_names()
Parameters:	None
Returns:	Nothing
Description:	Fix NULL geolevel names in geography geolevel geometry and lookup table data, re-analyze
		Add unique index
 */
DECLARE
	c2_fixnul2 CURSOR FOR
		SELECT *
		  FROM rif40_geographies;
--
	c2_rec rif40_geographies%ROWTYPE;
BEGIN
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'fix_null_geolevel_names', 'User % must be rif40 or have rif_manager role', 
			USER::VARCHAR	/* Username */);
	END IF;
--
-- Create lookup and Hierarchy tables
--
	FOR c2_rec IN c2_fixnul2 LOOP
		PERFORM rif40_geo_pkg.fix_null_geolevel_names(c2_rec.geography);
	END LOOP;
--
	RETURN;
END;
]]></definition>
</function>

<function name="fix_null_geolevel_names"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	fix_null_geolevel_names()
Parameters:	geography
Returns:	Nothing
Description:	Fix NULL geolevel names in geography geolevel geometry and lookup table data, re-analyze
		Fix non-unique names in lookup tables and geolevel geometry table
		Add unique index

Fix NULL geolevel names in lookup table data example SQL>

CREATE TEMPORARY TABLE temp_fix_null_geolevel_names AS 
	SELECT DISTINCT a.ladua2001 /* source */, a.oa2001 /* target */, b2.name||' OA2001('||COALESCE(a.oa2001, 'UNK')||')' AS oa2001_name
          FROM ew2001_geography /* Hierarchy table */ a
                LEFT OUTER JOIN ew2001_ladua2001 b2 ON (a.ladua2001 = b2.ladua2001)
                /* highest resolution geolevel with complete descriptive names */
         WHERE NOT EXISTS (
                SELECT b1.name
                  FROM ew2001_coa2001 b1
                 WHERE b1.name IS NOT NULL
                   AND a.oa2001 /- target -/ = b1.oa2001);

CREATE UNIQUE INDEX oa2001_pk ON temp_fix_null_geolevel_names(oa2001);

ANALYZE VERBOSE temp_fix_null_geolevel_names;

UPDATE ew2001_coa2001 c
           SET name = (SELECT oa2001_name /* Replacement */ 
                         FROM temp_fix_null_geolevel_names a
                        WHERE a.oa2001 = c.oa2001)
         WHERE c.name IS NULL;

DROP TABLE temp_fix_null_geolevel_names;

ANALYZE VERBOSE ew2001_coa2001;

Fix NULL geolevel names in geography geolevel geometry data example SQL>

CREATE TEMPORARY TABLE temp_fix_null_geolevel_names AS 
SELECT DISTINCT a.ladua2001 /* source */, a.oa2001 /* target */, b2.name||' OA2001('||COALESCE(a.oa2001, 'UNK')||')' AS oa2001_name
          FROM ew2001_geography /* Hierarchy table */ a
                LEFT OUTER JOIN ew2001_ladua2001 b2 ON (a.ladua2001 = b2.ladua2001)
                /* highest resolution geolevel with complete descriptive names */
         WHERE NOT EXISTS (
                SELECT b1.area_id
                  FROM t_rif40_geolevels_geometry_ew01_oa2001 b1
                 WHERE b1.name IS NOT NULL
                   AND a.oa2001 /- target -/ = b1.area_id);

CREATE UNIQUE INDEX oa2001_pk ON temp_fix_null_geolevel_names(oa2001);

ANALYZE VERBOSE temp_fix_null_geolevel_names;

UPDATE t_rif40_geolevels_geometry_ew01_oa2001 c
           SET name = (SELECT oa2001_name /* Replacement */ 
                         FROM temp_fix_null_geolevel_names a
                        WHERE a.oa2001 = c.area_id)
         WHERE c.name IS NULL;

DROP TABLE temp_fix_null_geolevel_names;

ANALYZE VERBOSE ew2001_coa2001;

Fix non-unique names in lookup tables and geolevel geometry table example SQL

DROP TABLE IF EXISTS temp_fix_null_geolevel_names;

CREATE TEMPORARY TABLE temp_fix_null_geolevel_names AS
WITH a AS (
	SELECT name, COUNT(*) AS total
	  FROM ew2001_ward2001
	 GROUP BY name
	HAVING COUNT(*) > 1
)
SELECT DISTINCT b.ward2001, a.name, c.ladua2001, a.name||'('||c.ladua2001||')' AS new_name
  FROM a, ew2001_ward2001 b, ew2001_geography c
 WHERE a.name = b.name
   AND c.ward2001 = b.ward2001;

CREATE UNIQUE INDEX ward2001_pk ON temp_fix_null_geolevel_names(ward2001);
CREATE UNIQUE INDEX ward2001_uk ON temp_fix_null_geolevel_names(new_name);
ANALYZE VERBOSE temp_fix_null_geolevel_names;

UPDATE ew2001_ward2001 c
           SET name = (SELECT new_name /* Replacement */ 
                         FROM temp_fix_null_geolevel_names a
                        WHERE a.ward2001 = c.ward2001)
         WHERE c.ward2001 IN (SELECT ward2001
			  FROM temp_fix_null_geolevel_names);

UPDATE t_rif40_geolevels_geometry_ew01_ward2001 c
           SET name = (SELECT new_name /* Replacement */ 
                         FROM temp_fix_null_geolevel_names a
                        WHERE a.ward2001 = c.area_id)
         WHERE c.ward2001 IN (SELECT ward2001
			  FROM temp_fix_null_geolevel_names);
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="l_geography" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	fix_null_geolevel_names()
Parameters:	geography
Returns:	Nothing
Description:	Fix NULL geolevel names in geography geolevel geometry and lookup table data, re-analyze
		Fix non-unique names in lookup tables and geolevel geometry table
		Add unique index

Fix NULL geolevel names in lookup table data example SQL>

CREATE TEMPORARY TABLE temp_fix_null_geolevel_names AS 
	SELECT DISTINCT a.ladua2001 -* source *-, a.oa2001 -* target *-, b2.name||' OA2001('||COALESCE(a.oa2001, 'UNK')||')' AS oa2001_name
          FROM ew2001_geography -* Hierarchy table *- a
                LEFT OUTER JOIN ew2001_ladua2001 b2 ON (a.ladua2001 = b2.ladua2001)
                -* highest resolution geolevel with complete descriptive names *-
         WHERE NOT EXISTS (
                SELECT b1.name
                  FROM ew2001_coa2001 b1
                 WHERE b1.name IS NOT NULL
                   AND a.oa2001 /- target -/ = b1.oa2001);

CREATE UNIQUE INDEX oa2001_pk ON temp_fix_null_geolevel_names(oa2001);

ANALYZE VERBOSE temp_fix_null_geolevel_names;

UPDATE ew2001_coa2001 c
           SET name = (SELECT oa2001_name -* Replacement *- 
                         FROM temp_fix_null_geolevel_names a
                        WHERE a.oa2001 = c.oa2001)
         WHERE c.name IS NULL;

DROP TABLE temp_fix_null_geolevel_names;

ANALYZE VERBOSE ew2001_coa2001;

Fix NULL geolevel names in geography geolevel geometry data example SQL>

CREATE TEMPORARY TABLE temp_fix_null_geolevel_names AS 
SELECT DISTINCT a.ladua2001 -* source *-, a.oa2001 -* target *-, b2.name||' OA2001('||COALESCE(a.oa2001, 'UNK')||')' AS oa2001_name
          FROM ew2001_geography -* Hierarchy table *- a
                LEFT OUTER JOIN ew2001_ladua2001 b2 ON (a.ladua2001 = b2.ladua2001)
                -* highest resolution geolevel with complete descriptive names *-
         WHERE NOT EXISTS (
                SELECT b1.area_id
                  FROM t_rif40_geolevels_geometry_ew01_oa2001 b1
                 WHERE b1.name IS NOT NULL
                   AND a.oa2001 /- target -/ = b1.area_id);

CREATE UNIQUE INDEX oa2001_pk ON temp_fix_null_geolevel_names(oa2001);

ANALYZE VERBOSE temp_fix_null_geolevel_names;

UPDATE t_rif40_geolevels_geometry_ew01_oa2001 c
           SET name = (SELECT oa2001_name -* Replacement *- 
                         FROM temp_fix_null_geolevel_names a
                        WHERE a.oa2001 = c.area_id)
         WHERE c.name IS NULL;

DROP TABLE temp_fix_null_geolevel_names;

ANALYZE VERBOSE ew2001_coa2001;

Fix non-unique names in lookup tables and geolevel geometry table example SQL

DROP TABLE IF EXISTS temp_fix_null_geolevel_names;

CREATE TEMPORARY TABLE temp_fix_null_geolevel_names AS
WITH a AS (
	SELECT name, COUNT(*) AS total
	  FROM ew2001_ward2001
	 GROUP BY name
	HAVING COUNT(*) > 1
)
SELECT DISTINCT b.ward2001, a.name, c.ladua2001, a.name||'('||c.ladua2001||')' AS new_name
  FROM a, ew2001_ward2001 b, ew2001_geography c
 WHERE a.name = b.name
   AND c.ward2001 = b.ward2001;

CREATE UNIQUE INDEX ward2001_pk ON temp_fix_null_geolevel_names(ward2001);
CREATE UNIQUE INDEX ward2001_uk ON temp_fix_null_geolevel_names(new_name);
ANALYZE VERBOSE temp_fix_null_geolevel_names;

UPDATE ew2001_ward2001 c
           SET name = (SELECT new_name -* Replacement *- 
                         FROM temp_fix_null_geolevel_names a
                        WHERE a.ward2001 = c.ward2001)
         WHERE c.ward2001 IN (SELECT ward2001
			  FROM temp_fix_null_geolevel_names);

UPDATE t_rif40_geolevels_geometry_ew01_ward2001 c
           SET name = (SELECT new_name -* Replacement *- 
                         FROM temp_fix_null_geolevel_names a
                        WHERE a.ward2001 = c.area_id)
         WHERE c.ward2001 IN (SELECT ward2001
			  FROM temp_fix_null_geolevel_names);

 */

DECLARE
	c1_fixnul CURSOR(l_geography VARCHAR) FOR
		SELECT COUNT(geolevel_id) AS total_geolevel 
		  FROM t_rif40_geolevels
		 WHERE geography = l_geography;
	c2a_fixnul CURSOR(l_geography VARCHAR) FOR
		SELECT * 
		  FROM t_rif40_geolevels
		 WHERE geography = l_geography
		 ORDER BY geography, geolevel_id;
	c2_fixnul CURSOR(l_geography VARCHAR) FOR
		SELECT * 
		  FROM t_rif40_geolevels
		 WHERE geography = l_geography
		 ORDER BY geography, geolevel_id DESC;
	c3_fixnul 	REFCURSOR;
	c4_fixnul CURSOR(l_geography VARCHAR, l_geolevel_id INTEGER) FOR
		SELECT * 
		  FROM t_rif40_geolevels
		 WHERE geography   = l_geography
		   AND geolevel_id = l_geolevel_id;
	c6_fixnul CURSOR(l_geography VARCHAR) FOR
		SELECT * 
		  FROM rif40_geographies
		 WHERE geography   = l_geography;
--
	total_geolevel	INTEGER;
	desc_geolevel	INTEGER=NULL;
	total_desc	INTEGER=NULL;
	l_rows		INTEGER;
	c2a_rec 	t_rif40_geolevels%ROWTYPE;
	c2_rec 		t_rif40_geolevels%ROWTYPE;
	c3_rec 		RECORD;
	higher_c4_rec 	t_rif40_geolevels%ROWTYPE;
	c5_rec 		RECORD;
	c6_rec 		rif40_geographies%ROWTYPE;
--
	sql_stmt 	VARCHAR;
	i 		INTEGER:=0;
	j 		INTEGER:=0;
	re_analyze 	BOOLEAN;
BEGIN
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'fix_null_geolevel_names', 'User % must be rif40 or have rif_manager role', 
			USER::VARCHAR	/* Username */);
	END IF;
--
	OPEN c1_fixnul(l_geography);
	FETCH c1_fixnul INTO total_geolevel;
	CLOSE c1_fixnul;
--
	OPEN c6_fixnul(l_geography);
	FETCH c6_fixnul INTO c6_rec;
	CLOSE c6_fixnul;
	IF total_geolevel = 0 OR c6_rec.hierarchytable IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10031, 'fix_null_geolevel_names', 'Geography % not found', 
			l_geography::VARCHAR	/* Geography */);
	END IF;
--
-- First past. Start with lowest resolution geolevel 
--
	i:=total_geolevel;
--
-- Check geolevels were processed
--
	IF total_geolevel = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-10017, 'fix_null_geolevel_names', 'No rows found in: t_rif40_geolevels for geography: %',
			l_geography::VARCHAR 	/* Geography */);
	END IF;
--
	FOR c2a_rec IN c2a_fixnul(l_geography) LOOP
		j:=j+1;
--
-- Get the total description fields for the geolevel lookup table
--
		sql_stmt:='SELECT COUNT('||quote_ident(LOWER(c2a_rec.geolevel_name))||') AS total_area_ids,'||E'\n'||
			  '       COUNT('||quote_ident(LOWER(c2a_rec.lookup_desc_column))||') AS total_desc,'||E'\n'||
			  '       COUNT(DISTINCT('||quote_ident(LOWER(c2a_rec.lookup_desc_column))||')) AS total_uniq_desc'||E'\n'||
			  '  FROM '||quote_ident(LOWER(c2a_rec.lookup_table));
		PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'fix_null_geolevel_names', 'Pass: 1 Get the total description fields SQL> %', 
			sql_stmt::VARCHAR		/* SQL statement */);
		OPEN c3_fixnul FOR EXECUTE sql_stmt;
		FETCH c3_fixnul INTO c3_rec;
		CLOSE c3_fixnul;
--
-- OK, found a complete set of descriptions
--
		IF c3_rec.total_desc = c3_rec.total_area_ids AND c3_rec.total_desc = c3_rec.total_uniq_desc THEN
			PERFORM rif40_log_pkg.rif40_log('DEBUG2', 'fix_null_geolevel_names',
				'Pass: 1 Geography % geolevel % lookup table: % has % unique description rows (%)', 
				l_geography::VARCHAR 				/* Geography */, 
				c2a_rec.geolevel_name::VARCHAR			/* Geolevel name */, 
				c2a_rec.lookup_table::VARCHAR			/* Geolevel lookup table */,
				c3_rec.total_desc::VARCHAR			/* Geolevel lookup table unique description rows */, 
				LOWER(c2a_rec.lookup_desc_column)::VARCHAR 	/* Geolevel lookup table description column */);
--
-- Oops, there is a gap
--
			IF desc_geolevel IS NOT NULL AND c2a_rec.geolevel_id - desc_geolevel > 1 THEN
				PERFORM rif40_log_pkg.rif40_error(-10026, 'fix_null_geolevel_names', 
					'Pass: 1 Geography % gap found between geolevel IDs: % and % (with complete descriptive names) for geography: % not found',
					l_geography::VARCHAR 		/* Geography */, 
					desc_geolevel::VARCHAR 		/* First geolevel ID with complete descriptive names */,
					c2a_rec.geolevel_id::VARCHAR 	/* Current geolevel ID with complete descriptive names */,
					l_geography::VARCHAR 		/* Geography */);
			ELSE
				desc_geolevel:=c2a_rec.geolevel_id;
				total_desc:=c3_rec.total_desc;
			END IF;
/*		ELSE
			desc_geolevel checked later */
		END IF;
	END LOOP;
--
-- Check geolevels were processed
--
	IF j = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-10048, 'fix_null_geolevel_names', 
			'No geolevels were processed in: t_rif40_geolevels for geography: %, expected geolevels: %',
			l_geography::VARCHAR 	/* Geography */,
			total_geolevel::VARCHAR	/* Expected geolevels */);
	END IF;
--
-- Check there is a geolevel with complete descriptive names 
--
	IF desc_geolevel IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10027, 'fix_null_geolevel_names', 'No geolevel with complete descriptive names for geography: %',
			l_geography::VARCHAR 	/* Geography */);
	END IF;
--
-- Get the geolevel definition of the highest resolution geolevel with complete descriptive names. This is as the first name part of the defaulted
-- missing descriptions.
--
-- Abellan LEVEL3(01.001.000100)
--
	OPEN c4_fixnul(l_geography, desc_geolevel);
	FETCH c4_fixnul INTO higher_c4_rec;
	CLOSE c4_fixnul;
	IF higher_c4_rec IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10028, 'fix_null_geolevel_names', 'Geolevel ID: % (with complete descriptive names) for geography: % not found',
			desc_geolevel::VARCHAR 	/* Geolevel ID with complete descriptive names */,
			l_geography::VARCHAR 	/* Geography */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'fix_null_geolevel_names',
			'[10028] Geography % using geolevel % lookup table: % has % unique description rows (%) as the higher reference geolevel for descriptive names', 
			l_geography::VARCHAR					/* Geography */, 
			higher_c4_rec.geolevel_name::VARCHAR			/* Higher reference geolevel name */, 
			higher_c4_rec.lookup_table::VARCHAR			/* Higher reference geolevel lookup table */,
			total_desc::VARCHAR					/* Geolevel lookup table unique description rows */, 
			LOWER(higher_c4_rec.lookup_desc_column)::VARCHAR 	/* Geolevel lookup table description column */);
	END IF;
--
-- Second pass. Start with highest resolution geolevel 
--
	j:=0;
	FOR c2_rec IN c2_fixnul(l_geography) LOOP
		j:=j+1;
		i:=i-1;
		re_analyze:=FALSE;
--
-- Get the total description fields for the geolevel lookup table
--
		sql_stmt:='SELECT COUNT('||quote_ident(LOWER(c2_rec.geolevel_name))||') AS total_area_ids,'||E'\n'||
			  '       COUNT('||quote_ident(LOWER(c2_rec.lookup_desc_column))||') AS total_desc,'||E'\n'||
			  '       SUM(CASE WHEN '||quote_ident(LOWER(c2_rec.lookup_desc_column))||' IS NULL THEN 1 ELSE 0 END) AS total_null_desc,'||E'\n'||
			  '       COUNT(DISTINCT('||quote_ident(LOWER(c2_rec.lookup_desc_column))||')) AS total_uniq_desc'||E'\n'||
			  '  FROM '||quote_ident(LOWER(c2_rec.lookup_table));
		PERFORM rif40_log_pkg.rif40_log('DEBUG2', 'fix_null_geolevel_names', 'Pass: 2 Get the total description fields SQL> %', 
			sql_stmt::VARCHAR		/* SQL statement */);
		OPEN c3_fixnul FOR EXECUTE sql_stmt;
		FETCH c3_fixnul INTO c3_rec;
		CLOSE c3_fixnul;
--
-- Checks:
--
-- a) Lookup table empty
--
		l_rows:=NULL;
		IF c3_rec.total_area_ids = 0 THEN
			PERFORM rif40_log_pkg.rif40_error(-10022, 'fix_null_geolevel_names', 
				'Pass: 2a Geography % geolevel % lookup table: % has no rows', 
				l_geography::VARCHAR		/* Geography */, 
				c2_rec.geolevel_name::VARCHAR	/* Geolevel name */, 
				c2_rec.lookup_table::VARCHAR	/* Geolevel lookup table */);
--
-- b) level 1 (lowest resolution geolevel) must have only 1 row
--
		ELSIF c2_rec.geolevel_id = 1 AND c3_rec.total_area_ids > 1 THEN 
			PERFORM rif40_log_pkg.rif40_error(-10023, 'fix_null_geolevel_names',
				'Pass: 2b Geography % lowest resolution geolevel % lookup table: % has >1: % rows (%) - OK', 
				l_geography::VARCHAR				/* Geography */, 
				c2_rec.geolevel_name::VARCHAR			/* Geolevel name */, 
				c2_rec.lookup_table::VARCHAR			/* Geolevel lookup table */,
				c3_rec.total_desc::VARCHAR			/* Geolevel lookup table unique description rows */, 
				LOWER(c2_rec.lookup_desc_column)::VARCHAR 	/* Geolevel lookup table description column */);
--
-- c) OK - all present and unique
--
		ELSIF c3_rec.total_desc = c3_rec.total_area_ids AND c3_rec.total_desc = c3_rec.total_uniq_desc THEN
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'fix_null_geolevel_names',
				'Pass: 2c Geography % geolevel % lookup table: % has % unique description rows (%) - OK', 
				l_geography::VARCHAR				/* Geography */, 
				c2_rec.geolevel_name::VARCHAR			/* Geolevel name */, 
				c2_rec.lookup_table::VARCHAR			/* Geolevel lookup table */,
				c3_rec.total_desc::VARCHAR			/* Geolevel lookup table unique description rows */, 
				LOWER(c2_rec.lookup_desc_column)::VARCHAR 	/* Geolevel lookup table description column */);
--
-- d) Not unique
--
		ELSIF c3_rec.total_desc = c3_rec.total_area_ids AND c3_rec.total_desc != c3_rec.total_uniq_desc THEN
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'fix_null_geolevel_names',
				'Pass: 2d Geography % geolevel % lookup table: % has % description rows (%), only % are unique, % are NULL - FIX', 
				l_geography::VARCHAR				/* Geography */, 
				c2_rec.geolevel_name::VARCHAR			/* Geolevel name */, 
				c2_rec.lookup_table::VARCHAR			/* Geolevel lookup table */,
				c3_rec.total_desc::VARCHAR			/* Geolevel lookup table description rows */, 
				LOWER(c2_rec.lookup_desc_column)::VARCHAR 	/* Geolevel lookup table description column */,
				c3_rec.total_uniq_desc::VARCHAR			/* Geolevel lookup table unique description rows */,
				c3_rec.total_null_desc::VARCHAR			/* Geolevel lookup table NULL description rows */);
--
-- Fix non unique names
--
/*
DROP TABLE IF EXISTS temp_fix_null_geolevel_names;

CREATE TEMPORARY TABLE temp_fix_null_geolevel_names AS
WITH a AS (
	SELECT name, COUNT(*) AS total
	  FROM ew2001_ward2001
	 GROUP BY name
	HAVING COUNT(*) > 1
)
SELECT DISTINCT b.ward2001, a.name, c.ladua2001, a.name||'('||c.ladua2001||')' AS new_name
  FROM a, ew2001_ward2001 b, ew2001_geography c
 WHERE a.name = b.name
   AND c.ward2001 = b.ward2001;

CREATE UNIQUE INDEX ward2001_pk ON temp_fix_null_geolevel_names(ward2001);
CREATE UNIQUE INDEX ward2001_uk ON temp_fix_null_geolevel_names(new_name);
ANALYZE VERBOSE temp_fix_null_geolevel_names;

UPDATE ew2001_ward2001 c
           SET name = (SELECT new_name -* Replacement *- 
                         FROM temp_fix_null_geolevel_names a
                        WHERE a.ward2001 = c.ward2001)
         WHERE c.ward2001 IN (SELECT ward2001
			  FROM temp_fix_null_geolevel_names);

UPDATE t_rif40_geolevels_geometry_ew01_ward2001 c
           SET name = (SELECT new_name -* Replacement *- 
                         FROM temp_fix_null_geolevel_names a
                        WHERE a.ward2001 = c.area_id)
         WHERE c.ward2001 IN (SELECT ward2001
			  FROM temp_fix_null_geolevel_names);

 */
			sql_stmt:='DROP TABLE IF EXISTS temp_fix_null_geolevel_names';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='CREATE TEMPORARY TABLE temp_fix_null_geolevel_names AS /* Lookup table de-duplicate update */'||E'\n'||
				'WITH a AS ('||E'\n'||
				E'\t'||'SELECT name, COUNT(*) AS total'||E'\n'||
				E'\t'||'  FROM '||quote_ident(LOWER(c2_rec.lookup_table))||E'\n'||
				E'\t'||' GROUP BY name'||E'\n'||
				E'\t'||'HAVING COUNT(*) > 1'||E'\n'||
				')'||E'\n'||
				'SELECT DISTINCT b.'||quote_ident(LOWER(c2_rec.geolevel_name))||
					', a.name'||
					', c.'||quote_ident(LOWER(higher_c4_rec.geolevel_name))||
					', a.name'||'||''(''||c.'||quote_ident(LOWER(higher_c4_rec.geolevel_name))||'||'')'' AS new_name'||E'\n'||
				'  FROM a, '||quote_ident(LOWER(c2_rec.lookup_table))||' b, ew2001_geography c'||E'\n'||
				' WHERE a.name'||' = b.'||quote_ident(LOWER(c2_rec.geolevel_name))||''||E'\n'||
				'   AND c.'||quote_ident(LOWER(c2_rec.geolevel_name))||' = b.'||quote_ident(LOWER(c2_rec.geolevel_name));

			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='CREATE UNIQUE INDEX '||quote_ident(LOWER(c2_rec.geolevel_name))||'_pk ON'||
				' temp_fix_null_geolevel_names('||quote_ident(LOWER(c2_rec.geolevel_name))||')';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='CREATE UNIQUE INDEX '||quote_ident(LOWER(c2_rec.geolevel_name))||'_uk ON temp_fix_null_geolevel_names(new_name)';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='ANALYZE VERBOSE temp_fix_null_geolevel_names';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
			sql_stmt:='UPDATE /* d.1 */ '||quote_ident(LOWER(c2_rec.lookup_table))||' c'||E'\n'||
				'   SET name = (SELECT new_name /* Replacement 3 */ '||E'\n'||
				'		  FROM temp_fix_null_geolevel_names a'||E'\n'||
				'		 WHERE a.'||quote_ident(LOWER(c2_rec.geolevel_name))||' = c.'||quote_ident(LOWER(c2_rec.geolevel_name))||')'||E'\n'||
				' WHERE c.'||quote_ident(LOWER(c2_rec.geolevel_name))||' IN ('||E'\n'||
				E'\t'||'SELECT '||quote_ident(LOWER(c2_rec.geolevel_name))||E'\n'||
				E'\t'||'  FROM temp_fix_null_geolevel_names)';
			l_rows:=rif40_sql_pkg.rif40_ddl(sql_stmt);
--
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'fix_null_geolevel_names', 
				'Pass: 2d Geography % fixed geolevel %: % resolution duplicate lookup table % % descriptions', 
				l_geography::VARCHAR			/* Geography */, 
				c2_rec.geolevel_id::VARCHAR		/* Current geolevel ID (descending) */,
				c2_rec.geolevel_name::VARCHAR		/* Curent geolevel name */, 
				c2_rec.lookup_table::VARCHAR		/* Lookup table */,
				l_rows::VARCHAR				/* Rows updated */);
--
			sql_stmt:='UPDATE /* d.2 */ '||quote_ident('t_rif40_geolevels_geometry_'||LOWER(l_geography)||'_'||LOWER(c2_rec.geolevel_name))||' /* Geometry table */ c'||E'\n'||
				'   SET name = (SELECT new_name /* Replacement 4 */ '||E'\n'||
				'		  FROM temp_fix_null_geolevel_names a'||E'\n'||
				'		 WHERE a.'||quote_ident(LOWER(c2_rec.geolevel_name))||' = c.area_id)'||E'\n'||
				' WHERE c.area_id IN ('||E'\n'||
				E'\t'||'SELECT '||quote_ident(LOWER(c2_rec.geolevel_name))||E'\n'||
				E'\t'||'  FROM temp_fix_null_geolevel_names)';
			l_rows:=rif40_sql_pkg.rif40_ddl(sql_stmt);
--
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'fix_null_geolevel_names', 
				'Pass: 2d Geography % fixed geolevel %: % resolution duplicate geolevel geometry % % descriptions', 
				l_geography::VARCHAR			/* Geography */, 
				c2_rec.geolevel_id::VARCHAR		/* Current geolevel ID (descending) */,
				c2_rec.geolevel_name::VARCHAR		/* Curent geolevel name */, 
				quote_ident('t_rif40_geolevels_geometry_'||LOWER(l_geography)||'_'||LOWER(c2_rec.geolevel_name))::VARCHAR /* Geometry table */,
				l_rows::VARCHAR				/* Rows updated */);
--
			sql_stmt:='DROP TABLE temp_fix_null_geolevel_names';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			re_analyze:=TRUE;

--
-- e) Missing single item top level - fix using geography description
--
		ELSIF c2_rec.geolevel_id = 1 AND c3_rec.total_area_ids = 1 THEN /* Fix top level lookup */
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'fix_null_geolevel_names',
				'Pass: 2f Geography % geolevel % lookup table: % missing single item top level %/% incomplete description rows (%) - FIX ', 
				l_geography::VARCHAR				/* Geography */, 
				c2_rec.geolevel_name::VARCHAR			/* Geolevel name */, 
				c2_rec.lookup_table::VARCHAR			/* Geolevel lookup table */,
				c3_rec.total_desc::VARCHAR			/* Geolevel lookup table unique description rows */, 
				c3_rec.total_area_ids::VARCHAR			/* Geolevel lookup table unique name rows (AREA_IDs) */, 
				LOWER(c2_rec.lookup_desc_column)::VARCHAR 	/* Geolevel lookup table description column */);

			sql_stmt:='UPDATE /* e.1 */ '||quote_ident(LOWER(c2_rec.lookup_table))||E'\n'||
				  '   SET '||quote_ident(LOWER(c2_rec.lookup_desc_column))||' = '||quote_literal(l_geography);
			l_rows:=rif40_sql_pkg.rif40_ddl(sql_stmt);
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'fix_null_geolevel_names', 
				'Pass: 2e Geography % fixed geolevel %: % lowest resolution lookup table % % description', 
				l_geography::VARCHAR			/* Geography */, 
				c2_rec.geolevel_id::VARCHAR		/* Current geolevel ID (descending) */,
				c2_rec.geolevel_name::VARCHAR		/* Curent geolevel name */, 
				c2_rec.lookup_desc_column::VARCHAR	/* Lookup table */,
				l_rows::VARCHAR				/* Rows updated */);
--
-- cannot ALTER TABLE "sahsuland_level1" because it is being used by active queries in this session
--
--			sql_stmt:='ALTER TABLE '||quote_ident(LOWER(c2_rec.lookup_table))||' ALTER COLUMN '||quote_ident(LOWER(c2_rec.lookup_desc_column))||' SET NOT NULL';
--			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Re-create unique index
--
			sql_stmt:='DROP INDEX IF EXISTS '||quote_ident(LOWER(c2_rec.lookup_table)||'_uk2');
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='CREATE UNIQUE INDEX '||quote_ident(LOWER(c2_rec.lookup_table)||'_uk2')||
				' ON '||quote_ident(LOWER(c2_rec.lookup_table))||'('||quote_ident(LOWER(c2_rec.lookup_desc_column))||')';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Fix top level shapefile if possible
--
			IF c2_rec.shapefile_desc_column IS NOT NULL THEN 
				sql_stmt:='UPDATE /* e.2 */ '||quote_ident(LOWER(c2_rec.shapefile_table))||E'\n'||
				  '   SET '||quote_ident(LOWER(c2_rec.shapefile_desc_column))||
					' = (SELECT description FROM rif40_geographies WHERE geography = '''||l_geography||''')';
				l_rows:=rif40_sql_pkg.rif40_ddl(sql_stmt);
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'fix_null_geolevel_names', 
					'Pass: 2e Geography % fixed geolevel %: % lowest resolution shapefile table % description', 
					l_geography::VARCHAR			/* Geography */, 
					c2_rec.geolevel_id::VARCHAR		/* Current geolevel ID (descending) */,
					c2_rec.geolevel_name::VARCHAR		/* Curent geolevel name */, 
					l_rows::VARCHAR				/* Rows updated */);
			END IF;
--
-- Fix geometry table (it must exist)
--
			sql_stmt:='UPDATE /* e.3 */ '||quote_ident('t_rif40_'||LOWER(l_geography)||'_geometry')||E'\n'||
				  '   SET name = (SELECT description FROM rif40_geographies WHERE geography = '''||l_geography||''')'||E'\n'||
				  ' WHERE geolevel_name = '''||c2_rec.geolevel_name||'''';
			l_rows:=rif40_sql_pkg.rif40_ddl(sql_stmt);
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'fix_null_geolevel_names', 
				'Pass: 2e Geography % fixed geolevel %: % lowest resolution % % descriptions', 
				l_geography::VARCHAR				/* Geography */, 
				c2_rec.geolevel_id::VARCHAR			/* Current geolevel ID (descending) */,
				c2_rec.geolevel_name::VARCHAR			/* Curent geolevel name */, 
				't_rif40_'||LOWER(l_geography)||'_geometry'	/* Geometry table */,
				l_rows::VARCHAR					/* Rows updated */);
			re_analyze:=TRUE;
--
-- f) Level 2 (second lowest) resolution geolevel must be complete
--
		ELSIF c2_rec.geolevel_id = 2 AND c3_rec.total_desc != c3_rec.total_area_ids THEN
			PERFORM rif40_log_pkg.rif40_error(-10025, 'fix_null_geolevel_names',
				'Pass: 2f Geography % geolevel % lookup table: % has %/% incomplete description rows (%) - FIX ', 
				l_geography::VARCHAR				/* Geography */, 
				c2_rec.geolevel_name::VARCHAR			/* Geolevel name */, 
				c2_rec.lookup_table::VARCHAR			/* Geolevel lookup table */,
				c3_rec.total_desc::VARCHAR			/* Geolevel lookup table unique description rows */, 
				c3_rec.total_area_ids::VARCHAR			/* Geolevel lookup table unique name rows (AREA_IDs) */, 
				LOWER(c2_rec.lookup_desc_column)::VARCHAR 	/* Geolevel lookup table description column */);
--
-- g) Fix Level 3 (third lowest) resolution geolevel and so on if required
--
/*
CREATE TEMPORARY TABLE temp_fix_null_geolevel_names AS 
	SELECT DISTINCT a.ladua2001 -* source *-, a.oa2001 -* target *-, b2.name||' OA2001('||COALESCE(a.oa2001, 'UNK')||')' AS oa2001_name
          FROM ew2001_geography -* Hierarchy table *- a
                LEFT OUTER JOIN ew2001_ladua2001 b2 ON (a.ladua2001 = b2.ladua2001)
                -* highest resolution geolevel with complete descriptive names *-
         WHERE NOT EXISTS (
                SELECT b1.name
                  FROM ew2001_coa2001 b1
                 WHERE b1.name IS NOT NULL
                   AND a.oa2001 /- target -/ = b1.oa2001);

CREATE UNIQUE INDEX oa2001_pk ON temp_fix_null_geolevel_names(oa2001);

ANALYZE VERBOSE temp_fix_null_geolevel_names;

UPDATE ew2001_coa2001 c
           SET name = (SELECT oa2001_name -* Replacement *- 
                         FROM temp_fix_null_geolevel_names a
                        WHERE a.oa2001 = c.oa2001)
         WHERE c.name IS NULL;

DROP TABLE temp_fix_null_geolevel_names;

ANALYZE VERBOSE ew2001_coa2001;

 */
		ELSIF c3_rec.total_desc != c3_rec.total_area_ids THEN
			sql_stmt:='DROP TABLE IF EXISTS temp_fix_null_geolevel_names';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='CREATE TEMPORARY TABLE temp_fix_null_geolevel_names AS /* Lookup table update */'||E'\n'||
				E'\t'||'SELECT DISTINCT a.'||quote_ident(LOWER(higher_c4_rec.geolevel_name))||' /* source */, '||
					'a.'||quote_ident(LOWER(c2_rec.geolevel_name))||' /* target */, b2.'||COALESCE(quote_ident(LOWER(c2_rec.shapefile_desc_column)), 'name')||
					'||'' '||UPPER(c2_rec.geolevel_name)||'(''||COALESCE(a.'||quote_ident(LOWER(c2_rec.geolevel_name))||', ''UNK'')||'')'' AS '||
					quote_ident(LOWER(c2_rec.geolevel_name)||'_name')||E'\n'||
				E'\t'||'  FROM '||quote_ident(LOWER(c6_rec.hierarchytable))||' /* Hierarchy table */ a'||E'\n'||
				E'\t'||'	LEFT OUTER JOIN '||quote_ident(LOWER(higher_c4_rec.lookup_table))||' b2 ON '||
					'(a.'||quote_ident(LOWER(higher_c4_rec.geolevel_name))||' = b2.'||quote_ident(LOWER(higher_c4_rec.geolevel_name))||')'||E'\n'||
				E'\t'||E'\t'||'/* highest resolution geolevel with complete descriptive names */'||E'\n'||
				E'\t'||' WHERE NOT EXISTS ('||E'\n'||
				E'\t'||E'\t'||'SELECT b1.'||COALESCE(quote_ident(LOWER(c2_rec.shapefile_desc_column)), 'name')||E'\n'||
				E'\t'||E'\t'||'  FROM '||quote_ident(LOWER(c2_rec.lookup_table))||' b1'||E'\n'||
				E'\t'||E'\t'||' WHERE b1.'||COALESCE(quote_ident(LOWER(c2_rec.shapefile_desc_column)), 'name')||' IS NOT NULL'||E'\n'||
				E'\t'||E'\t'||'   AND a.'||quote_ident(LOWER(c2_rec.geolevel_name))||' /* target */ = '||
					'b1.'||quote_ident(LOWER(c2_rec.geolevel_name))||')';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='CREATE UNIQUE INDEX '||quote_ident(LOWER(c2_rec.geolevel_name))||'_pk ON'||
				' temp_fix_null_geolevel_names('||quote_ident(LOWER(c2_rec.geolevel_name))||')';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='ANALYZE VERBOSE temp_fix_null_geolevel_names';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='UPDATE /* f.1 */ '||quote_ident(LOWER(c2_rec.lookup_table))||' c'||E'\n'||
				'   SET name = (SELECT '||quote_ident(LOWER(c2_rec.geolevel_name)||'_name')||' /* Replacement 1 */ '||E'\n'||
				'		 FROM temp_fix_null_geolevel_names a'||E'\n'||
				'		WHERE a.'||quote_ident(LOWER(c2_rec.geolevel_name))||' = c.'||quote_ident(LOWER(c2_rec.geolevel_name))||')'||E'\n'||
				' WHERE c.'||COALESCE(quote_ident(LOWER(c2_rec.shapefile_desc_column)), 'name')||' IS NULL';
			l_rows:=rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Check l_rows is NOT 0 i.e. no rows were updated
--
			IF l_rows = 0 THEN
				PERFORM rif40_sql_pkg.rif40_method4('SELECT * FROM temp_fix_null_geolevel_names LIMIT 100', 
					'Pass: 2f Update 1 Dump of temp_fix_null_geolevel_names');
				PERFORM rif40_log_pkg.rif40_error(-10028, 'fix_null_geolevel_names', 
					'Pass: 2f Update 1 Geography % fixed geolevel %: % resolution lookup table % no rows updated', 
					l_geography::VARCHAR			/* Geography */, 
					c2_rec.geolevel_id::VARCHAR		/* Current geolevel ID (descending) */,
					c2_rec.geolevel_name::VARCHAR		/* Curent geolevel name */,
					c2_rec.lookup_table::VARCHAR		/* Lookup table */);
			ELSE
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'fix_null_geolevel_names', 
					'Pass: 2f Geography % fixed geolevel %: % resolution lookup table % % descriptions', 
					l_geography::VARCHAR			/* Geography */, 
					c2_rec.geolevel_id::VARCHAR		/* Current geolevel ID (descending) */,
					c2_rec.geolevel_name::VARCHAR		/* Curent geolevel name */, 
					c2_rec.lookup_table::VARCHAR		/* Lookup table */,
					l_rows::VARCHAR				/* Rows updated */);
			END IF;
			sql_stmt:='DROP TABLE temp_fix_null_geolevel_names';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);

/*
CREATE TEMPORARY TABLE temp_fix_null_geolevel_names AS 
SELECT DISTINCT a.ladua2001 -* source *-, a.oa2001 -* target *-, b2.name||' OA2001('||COALESCE(a.oa2001, 'UNK')||')' AS oa2001_name
          FROM ew2001_geography -* Hierarchy table *- a
                LEFT OUTER JOIN ew2001_ladua2001 b2 ON (a.ladua2001 = b2.ladua2001)
                -* highest resolution geolevel with complete descriptive names *-
         WHERE NOT EXISTS (
                SELECT b1.area_id
                  FROM t_rif40_geolevels_geometry_ew01_oa2001 b1
                 WHERE b1.name IS NOT NULL
                   AND a.oa2001 /- target -/ = b1.area_id);

CREATE UNIQUE INDEX oa2001_pk ON temp_fix_null_geolevel_names(oa2001);

ANALYZE VERBOSE temp_fix_null_geolevel_names;

UPDATE t_rif40_geolevels_geometry_ew01_oa2001 c
           SET name = (SELECT oa2001_name -* Replacement *- 
                         FROM temp_fix_null_geolevel_names a
                        WHERE a.oa2001 = c.area_id)
         WHERE c.name IS NULL;

DROP TABLE temp_fix_null_geolevel_names;

ANALYZE VERBOSE ew2001_coa2001;

 */
			sql_stmt:='CREATE TEMPORARY TABLE temp_fix_null_geolevel_names AS /* Geolevel geometry table update */'||E'\n'||
				E'\t'||'SELECT DISTINCT a.'||quote_ident(LOWER(higher_c4_rec.geolevel_name))||' /* source */, '||
					'a.'||quote_ident(LOWER(c2_rec.geolevel_name))||' /* target */, b2.'||COALESCE(quote_ident(LOWER(c2_rec.shapefile_desc_column)), 'name')||
					'||'' '||UPPER(c2_rec.geolevel_name)||'(''||COALESCE(a.'||quote_ident(LOWER(c2_rec.geolevel_name))||', ''UNK'')||'')'' AS '||
					quote_ident(LOWER(c2_rec.geolevel_name)||'_name')||E'\n'||
				E'\t'||'  FROM '||quote_ident(LOWER(c6_rec.hierarchytable))||' /* Hierarchy table */ a'||E'\n'||
				E'\t'||'	LEFT OUTER JOIN '||quote_ident(LOWER(higher_c4_rec.lookup_table))||' b2 ON '||
					'(a.'||quote_ident(LOWER(higher_c4_rec.geolevel_name))||' = b2.'||quote_ident(LOWER(higher_c4_rec.geolevel_name))||')'||E'\n'||
				E'\t'||E'\t'||'/* highest resolution geolevel with complete descriptive names */'||E'\n'||
				E'\t'||' WHERE NOT EXISTS ('||E'\n'||
				E'\t'||E'\t'||'SELECT b1.area_id'||E'\n'||
				E'\t'||E'\t'||'  FROM '||quote_ident('t_rif40_geolevels_geometry_'||LOWER(l_geography)||'_'||LOWER(c2_rec.geolevel_name))||' b1 /* Geometry table */'||E'\n'||
				E'\t'||E'\t'||' WHERE b1.'||COALESCE(quote_ident(LOWER(c2_rec.shapefile_desc_column)), 'name')||' IS NOT NULL'||E'\n'||
				E'\t'||E'\t'||'   AND a.'||quote_ident(LOWER(c2_rec.geolevel_name))||' /* target */ = b1.area_id)';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='CREATE UNIQUE INDEX '||quote_ident(LOWER(c2_rec.geolevel_name))||'_pk ON'||
				' temp_fix_null_geolevel_names('||quote_ident(LOWER(c2_rec.geolevel_name))||')';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='ANALYZE VERBOSE temp_fix_null_geolevel_names';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='UPDATE /* f.2 */ '||quote_ident('t_rif40_geolevels_geometry_'||LOWER(l_geography)||'_'||LOWER(c2_rec.geolevel_name))||' c /* Geometry table */'||E'\n'||
				'   SET name = (SELECT '||quote_ident(LOWER(c2_rec.geolevel_name)||'_name')||' /* Replacement 2 */ '||E'\n'||
				'		 FROM temp_fix_null_geolevel_names a'||E'\n'||
				'		WHERE a.'||quote_ident(LOWER(c2_rec.geolevel_name))||' = c.area_id)'||E'\n'||
				' WHERE c.name IS NULL';
			l_rows:=rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Check l_rows is NOT 0 i.e. no rows were updated
--
			IF l_rows = 0 THEN
				PERFORM rif40_log_pkg.rif40_log('WARNING', 'fix_null_geolevel_names', 
					'Pass: 2f Update 2 Geography % fixed geolevel %: % resolution geometry table % no rows updated', 
					l_geography::VARCHAR			/* Geography */, 
					c2_rec.geolevel_id::VARCHAR		/* Current geolevel ID (descending) */,
					c2_rec.geolevel_name::VARCHAR		/* Curent geolevel name */,
					quote_ident('t_rif40_geolevels_geometry_'||LOWER(l_geography)||'_'||LOWER(c2_rec.geolevel_name))::VARCHAR /* Geometry table */);
				PERFORM rif40_sql_pkg.rif40_method4('SELECT * FROM temp_fix_null_geolevel_names LIMIT 100', 
					'Pass: 2f Update 2 Dump of temp_fix_null_geolevel_names');
			ELSE
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'fix_null_geolevel_names', 
					'Pass: 2f Geography % fixed geolevel %: % resolution geometry table % % descriptions', 
					l_geography::VARCHAR			/* Geography */, 
					c2_rec.geolevel_id::VARCHAR		/* Current geolevel ID (descending) */,
					c2_rec.geolevel_name::VARCHAR		/* Curent geolevel name */, 
					quote_ident('t_rif40_geolevels_geometry_'||LOWER(l_geography)||'_'||LOWER(c2_rec.geolevel_name))::VARCHAR /* Geometry table */,
					l_rows::VARCHAR				/* Rows updated */);
			END IF;
--
			sql_stmt:='DROP TABLE temp_fix_null_geolevel_names';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Re-create unique index
--
			sql_stmt:='DROP INDEX IF EXISTS '||quote_ident(LOWER(c2_rec.lookup_table)||'_uk2');
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			sql_stmt:='CREATE UNIQUE INDEX '||quote_ident(LOWER(c2_rec.lookup_table)||'_uk2')||
				' ON '||quote_ident(LOWER(c2_rec.lookup_table))||'('||quote_ident(LOWER(c2_rec.lookup_desc_column))||')';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Unexpected logical condition
--
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-10029, 'fix_null_geolevel_names', 
				'Pass: 2 Geography % fixed geolevel %: % Unexpected logical condition in first loop; total_area_ids: %, total_desc: %, total_null_desc: %, total_uniq_desc: %', 
				l_geography::VARCHAR			/* Geography */, 
				c2_rec.geolevel_id::VARCHAR		/* Current geolevel ID (descending) */,
				c2_rec.geolevel_name::VARCHAR		/* Curent geolevel name */, 
				c3_rec.total_area_ids::VARCHAR,
				c3_rec.total_desc::VARCHAR,
				c3_rec.total_null_desc::VARCHAR,
				c3_rec.total_uniq_desc::VARCHAR);
		END IF;

--
--
-- Re-analyze lookup and shapefile tables
--
		IF re_analyze THEN
			sql_stmt:='ANALYZE VERBOSE '||quote_ident(LOWER(c2_rec.lookup_table));
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);	
			sql_stmt:='ANALYZE VERBOSE '||quote_ident(LOWER(c2_rec.shapefile_table));
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);	
		END IF;
	END LOOP;
--
-- Check geolevels were processed
--
	IF j = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-10049, 'fix_null_geolevel_names', 
			'No geolevels were processed in: t_rif40_geolevels for geography: %, expected geolevels: %',
			l_geography::VARCHAR 	/* Geography */,
			total_geolevel::VARCHAR	/* Expected geolevels */);
	END IF;
--
-- Re-create unique index
--
	sql_stmt:='DROP INDEX IF EXISTS '||quote_ident('t_rif40_'||LOWER(l_geography)||'_geometry_uk2');
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	sql_stmt:='CREATE UNIQUE INDEX '||quote_ident('t_rif40_'||LOWER(l_geography)||'_geometry_uk2')||
		' ON '||quote_ident('t_rif40_'||LOWER(l_geography)||'_geometry')||'(name)';
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Re-analyze geometry tables
--
	sql_stmt:='ANALYZE VERBOSE '||quote_ident('t_rif40_'||LOWER(l_geography)||'_geometry');
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);	
END;
]]></definition>
</function>

<function name="get_geojson_as_js"
		window-func="false"
		returns-setof="true"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="1000">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	get_geojson_as_js()
Parameters:	Geography, geolevel_view, geolevel_area, geolevel_area_id
Returns:	Text table
Description:	Get GeoJSON data as a Java variable. 
		For the disease mapping selection dialog phrase:
		"View the <geolevel view> (e.g. GOR2001) of <geolevel area> (e.g. London) and select at <geolevel select> (e.g. LADUA2001) level."

Execute a SQL statement like and return JS text:

WITH a AS (
        SELECT 0 ord, 'var spatialData={ "type": "FeatureCollection","features": [ /* Start */' js
        UNION
        SELECT row_number() over() ord,
               '{"type": "Feature","properties":{"area_id":"'||area_id||'","name":"'||COALESCE(name, ')||'"},"geometry": '||topo_optimised_geojson||'} /* '||row_number() over()||' : '||area_id||' : '||' : '||COALESCE(name, ')||' */' AS js
          FROM t_rif40_ew01_geometry
         WHERE geolevel_name = 'LADUA2001' /* <geolevel view> */ AND area_id IN (
                SELECT DISTINCT ladua2001 /* <geolevel view> */
                  FROM ew2001_geography /* Heirarchy table */ WHERE gor2001 /* <geolevel area> */ = 'H' /* <geolevel area id> */)
                UNION
                SELECT 999999 ord, ']} /* End */' js
)
SELECT CASE WHEN ord BETWEEN 2 AND 999998 THEN ','||js ELSE js END AS js
  FROM a
 ORDER BY ord;]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="l_geography" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="geolevel_view" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="geolevel_area" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="geolevel_area_id" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	get_geojson_as_js()
Parameters:	Geography, geolevel_view, geolevel_area, geolevel_area_id
Returns:	Text table
Description:	Get GeoJSON data as a Java variable. 
		For the disease mapping selection dialog phrase:
		"View the <geolevel view> (e.g. GOR2001) of <geolevel area> (e.g. London) and select at <geolevel select> (e.g. LADUA2001) level."

Execute a SQL statement like and return JS text:

WITH a AS (
        SELECT 0 ord, ''var spatialData={ "type": "FeatureCollection","features": [ /- Start -/'' js
        UNION
        SELECT row_number() over() ord,
               ''{"type": "Feature","properties":{"area_id":"''||area_id||''","name":"''||COALESCE(name, '')||''"},"geometry": ''||optimised_geojson||''} -/ ''||row_number() over()||'' : ''||area_id||'' : ''||'' : ''||COALESCE(name, '')||'' -/'' AS js
          FROM t_rif40_ew01_geometry
         WHERE geolevel_name = ''LADUA2001'' /- <geolevel view> -/ AND area_id IN (
                SELECT DISTINCT ladua2001 /- <geolevel view> -/
                  FROM ew2001_geography /- Heirarchy table /- WHERE gor2001 /- <geolevel area> -/ = ''H'' /- <geolevel area id> -/)
                UNION
                SELECT 999999 ord, '']} /- End -/'' js
)
SELECT CASE WHEN ord BETWEEN 2 AND 999998 THEN '',''||js ELSE js END AS js
  FROM a
 ORDER BY ord LIMIT 2;'

*/
DECLARE
	c1 CURSOR(l_geography VARCHAR) FOR
		SELECT *
		  FROM rif40_geographies
		 WHERE geography = l_geography;
	c2 CURSOR(l_geography VARCHAR, l_geolevel VARCHAR) FOR
		SELECT *
		  FROM rif40_geolevels
		 WHERE geography     = l_geography
		   AND geolevel_name = l_geolevel;
	c2b CURSOR(l_geography VARCHAR, l_geolevel VARCHAR) FOR
		SELECT *
		  FROM rif40_geolevels
		 WHERE geography     = l_geography
		   AND geolevel_name = l_geolevel;
	c3 REFCURSOR;
--
	c1_rec rif40_geographies%ROWTYPE;
	c2a_rec rif40_geolevels%ROWTYPE;
	c2b_rec rif40_geolevels%ROWTYPE;
	c3_rec RECORD;
	c4_rec RECORD;
--
	sql_stmt VARCHAR;
BEGIN
--
-- Must be rif40 or have rif_user or rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'get_geojson_as_js', 'User % must be rif40 or have rif_user or rif_manager role', 
			USER::VARCHAR	/* Username */);
	END IF;
--
-- Test geography
--
	IF l_geography IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10007, 'get_geojson_as_js', 'NULL geography parameter');
	END IF;	
--
	OPEN c1(l_geography);
	FETCH c1 INTO c1_rec;
	CLOSE c1;
--
	IF c1_rec.geography IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10008, 'get_geojson_as_js', 'geography: % not found', 
			l_geography::VARCHAR	/* Geography */);
	END IF;	
--
-- Test <geolevel view/area> exist
--
	OPEN c2(l_geography, geolevel_view);
	FETCH c2 INTO c2a_rec;
	CLOSE c2;
--
	IF c2a_rec.geolevel_name IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10009, 'get_geojson_as_js', 'geography: %, <geoevel view> %: not found', 
			l_geography::VARCHAR	/* Geography */, 
			geolevel_view::VARCHAR	/* geolevel view */);
	END IF;	
--
	OPEN c2b(l_geography, geolevel_area);
	FETCH c2b INTO c2b_rec;
	CLOSE c2b;
--
	IF c2b_rec.geolevel_name IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10010, 'get_geojson_as_js', 'geography: %, <geoevel area> %: not found', 
			l_geography::VARCHAR	/* Geography */, 
			geolevel_area::VARCHAR	/* Geoelvel area */);
	END IF;	
--
-- Test <geoevel area> resolution is higher than <geoevel view> resolution
-- e.g.
-- get_geojson_as_js() geography: EW01, <geoevel area> GOR2001 resolution (3) is NOT higher than <geoevel view> OA2001 resolution (7)
--
	IF c2a_rec.geolevel_id /* <geoevel view> */ < c2b_rec.geolevel_id /* <geoevel area> */ THEN
		PERFORM rif40_log_pkg.rif40_error(-10011, 'get_geojson_as_js', 'geography: %, <geoevel area> % resolution (%) higher than <geoevel view> % resolution (%)', 			
			l_geography::VARCHAR		/* Geography */, 
			geolevel_area::VARCHAR		/* Geolevel area */, 
			c2b_rec.geolevel_id::VARCHAR, 	/* Geolevel area ID (resolution) */
			geolevel_view::VARCHAR		/* geolevel view */, c2a_rec.geolevel_id::VARCHAR);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'get_geojson_as_js', 'geography: %, <geoevel area> % resolution (%) is NOT higher than <geoevel view> % resolution (%)', 		
			l_geography::VARCHAR		/* Geography */, 
			geolevel_area::VARCHAR		/* Geolevel area */, 
			c2b_rec.geolevel_id::VARCHAR	/* Geolevel area ID (resolution) */, 
			geolevel_view::VARCHAR		/* geolevel view */, 
			c2a_rec.geolevel_id::VARCHAR	/* Geolevel view ID (resolution) */);
	END IF;
--
-- Test  <geolevel area id> is valid
-- 
	sql_stmt:='SELECT COUNT(DISTINCT('||quote_ident(LOWER(geolevel_view))||')) AS total'||E'\n'||
		  '  FROM '||quote_ident(LOWER(c1_rec.hierarchytable))||E'\n'||
		  ' WHERE '||quote_ident(LOWER(geolevel_area))||' = '||quote_literal(geolevel_area_id);
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'get_geojson_as_js', 'SQL> %;', sql_stmt::VARCHAR);
	OPEN c3 FOR EXECUTE sql_stmt;
	FETCH c3 INTO c3_rec;
	CLOSE c3;
	IF c3_rec.total = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-10012, 'get_geojson_as_js', 'geography: %, <geoevel area> % id % does not exist in hierarchy table: %', 			
			l_geography::VARCHAR			/* Geography */, 
			geolevel_area::VARCHAR			/* Geoelvel area */,  
			geolevel_area_id::VARCHAR		/* Geoelvel area ID */, 
			LOWER(c1_rec.hierarchytable)::VARCHAR	/* Hierarchy table */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'get_geojson_as_js', 'geography: %, <geoevel area> % id % will return: % area_id', 		
			l_geography::VARCHAR		/* Geography */, 
			geolevel_area::VARCHAR		/* Geoelvel area */, 
			geolevel_area_id::VARCHAR	/* Geoelvel area ID */, 
			c3_rec.total::VARCHAR		/* Number of area_ids */);
	END IF;
--
-- Create SQL statement
-- 
	sql_stmt:='WITH a AS ('||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'SELECT 0 ord, ''var spatialData={ "type": "FeatureCollection","features": [ /* Start */'' js'||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'UNION'||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'SELECT row_number() over() ord,'||E'\n'; 
	sql_stmt:=sql_stmt||E'\t'||'       ''{"type": "Feature","properties":{"area_id":"''||area_id||''","name":"''||COALESCE(name, '''')||''"},"geometry": ''||optimised_geojson||''} /* ''||'||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'row_number() over()||'' : ''||area_id||'' : ''||'' : ''||COALESCE(name, '''')||'' */ '' AS js'||E'\n'; 
	sql_stmt:=sql_stmt||E'\t'||'  FROM '||quote_ident('t_rif40_'||LOWER(l_geography)||'_geometry')||E'\n';
	sql_stmt:=sql_stmt||E'\t'||' WHERE geolevel_name = '''||quote_ident(UPPER(geolevel_view))||''' /* <geolevel view> */ AND area_id IN ('||E'\n'; 
	sql_stmt:=sql_stmt||E'\t'||E'\t'||'SELECT DISTINCT '||quote_ident(LOWER(geolevel_view))||' /* <geolevel view> */'||E'\n'; 
	sql_stmt:=sql_stmt||E'\t'||E'\t'||'  FROM '||quote_ident(LOWER(c1_rec.hierarchytable))||' /* Heirarchy table */ WHERE '||
		quote_ident(LOWER(geolevel_area))||' /* <geolevel area> */ = '||quote_literal(geolevel_area_id)||' /* <geolevel area id> */)'||E'\n'; 
	sql_stmt:=sql_stmt||E'\t'||E'\t'||'UNION'||E'\n';
	sql_stmt:=sql_stmt||E'\t'||E'\t'||'SELECT 999999 ord, '']} /* End */'' js'||E'\n';
	sql_stmt:=sql_stmt||')'||E'\n';
	sql_stmt:=sql_stmt||'SELECT CASE WHEN ord BETWEEN 2 AND 999998 THEN '',''||js ELSE js END AS js'||E'\n';
	sql_stmt:=sql_stmt||'  FROM a'||E'\n';
	sql_stmt:=sql_stmt||' ORDER BY ord';
--
-- Execute SQL statement, returning JS
--
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'get_geojson_as_js', 'SQL> %;', sql_stmt::VARCHAR);
	FOR c4_rec IN EXECUTE sql_stmt LOOP
		RETURN NEXT c4_rec.js;
	END LOOP;
--
	RETURN;
END;
]]></definition>
</function>

<function name="get_srid_projection_parameters"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	get_srid_projection_parameters()
Parameters:	Geography, projection parameter
Returns:	Projection parameter value
Description:	Get projection parameter value from SPATIAL_REF_SYS for geography

Typically used to get the units (+units). 

WITH a AS (
	SELECT string_to_array(unnest(string_to_array(proj4text, ' ')), '=') AS projparams 
	  FROM spatial_ref_sys
	 WHERE srid = 27700
)
SELECT projparams[1] AS param, projparams[2] AS value
  FROM a
 WHERE projparams[1] IS NOT NULL;

  param   |                      value                       
----------+--------------------------------------------------
 +proj    | tmerc
 +lat_0   | 49
 +lon_0   | -2
 +k       | 0.9996012717
 +x_0     | 400000
 +y_0     | -100000
 +ellps   | airy
 +towgs84 | 446.448,-125.157,542.06,0.15,0.247,0.842,-20.489
 +units   | m
 +no_defs | 
(10 rows)]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="character varying"/>
	</return-type>
	<parameter name="l_geography" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_param" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*
Function: 	get_srid_projection_parameters()
Parameters:	Geography, projection parameter
Returns:	Projection parameter value
Description:	Get projection parameter value from SPATIAL_REF_SYS for geography

Typically used to get the units (+units). 

WITH a AS (
	SELECT string_to_array(unnest(string_to_array(proj4text, ' ')), '=') AS projparams 
	  FROM spatial_ref_sys
	 WHERE srid = 27700
)
SELECT projparams[1] AS param, projparams[2] AS value
  FROM a
 WHERE projparams[1] IS NOT NULL;

  param   |                      value                       
----------+--------------------------------------------------
 +proj    | tmerc
 +lat_0   | 49
 +lon_0   | -2
 +k       | 0.9996012717
 +x_0     | 400000
 +y_0     | -100000
 +ellps   | airy
 +towgs84 | 446.448,-125.157,542.06,0.15,0.247,0.842,-20.489
 +units   | m
 +no_defs | 
(10 rows)
 */
DECLARE
	c1_srid CURSOR(l_geography VARCHAR, l_param VARCHAR) FOR
		WITH a AS (
			SELECT string_to_array(unnest(string_to_array(proj4text, ' ')), '=') AS projparams 
			  FROM spatial_ref_sys
			 WHERE srid = (SELECT srid FROM rif40_geographies WHERE geography = l_geography)
		)
		SELECT projparams[1] AS param, projparams[2] AS value
		  FROM a
		 WHERE projparams[1] = l_param;
	c1_rec RECORD;
BEGIN
	OPEN c1_srid(l_geography, l_param);
	FETCH c1_srid INTO c1_rec;
	CLOSE c1_srid;
--
	IF c1_rec.param IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-19001, 'get_srid_projection_parameters', 'Geography (%) or projection parameter (%) is invalid', 
			l_geography::VARCHAR 	/* Geography */,
			l_param::VARCHAR	/* Projection parameter */);
	END IF;
--
	RETURN c1_rec.value;
END;
]]></definition>
</function>

<function name="lf_check_rif40_hierarchy_lookup_tables"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	lf_check_rif40_hierarchy_lookup_tables()
Parameters:	Geography, hierarchy table, type: 'missing', 'spurious additional' or 'multiple hierarchy'
Returns:	Nothing
Description:	Diff geography hierarchy table using dynamic method 4
		Also tests the hierarchy, i.e. all a higher resolutuion is contained by one of the next higher and so on

Example of dynamic SQL. Note the use of an array return type to achieve method 4

WITH /* missing */ a1 AS (
        SELECT COUNT(*) AS level1_total
          FROM (
                SELECT level1 FROM sahsuland_geography
                EXCEPT
                SELECT level1 FROM sahsuland_level1) as1)
, a2 AS (
        SELECT COUNT(*) AS level2_total
          FROM (
                SELECT level2 FROM sahsuland_geography
                EXCEPT
                SELECT level2 FROM sahsuland_level2) as2)
, a3 AS (
        SELECT COUNT(*) AS level3_total
          FROM (
                SELECT level3 FROM sahsuland_geography
                EXCEPT
                SELECT level3 FROM sahsuland_level3) as3)
, a4 AS (
        SELECT COUNT(*) AS level4_total
          FROM (
                SELECT level4 FROM sahsuland_geography
                EXCEPT
                SELECT level4 FROM sahsuland_level4) as4)
SELECT ARRAY[a1.level1_total, a2.level2_total, a3.level3_total, a4.level4_total] AS res_array
FROM a1, a2, a3, a4;

Or:

WITH /* hierarchy */ a2 AS (
        SELECT COUNT(*) AS level2_total
          FROM (
                SELECT level2, COUNT(DISTINCT(level1)) AS total
                  FROM sahsuland_geography
                 GROUP BY level2
                HAVING COUNT(DISTINCT(level1)) > 1) AS2)
, a3 AS (
        SELECT COUNT(*) AS level3_total
          FROM (
                SELECT level3, COUNT(DISTINCT(level2)) AS total
                  FROM sahsuland_geography
                 GROUP BY level3
                HAVING COUNT(DISTINCT(level2)) > 1) AS3)
, a4 AS (
        SELECT COUNT(*) AS level4_total
          FROM (
                SELECT level4, COUNT(DISTINCT(level3)) AS total
                  FROM sahsuland_geography
                 GROUP BY level4
                HAVING COUNT(DISTINCT(level3)) > 1) AS4)
SELECT ARRAY[a2.level2_total, a3.level3_total, a4.level4_total] AS res_array
FROM a2, a3, a4;

]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="l_geography" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_hierarchytable" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_type" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	lf_check_rif40_hierarchy_lookup_tables()
Parameters:	Geography, hierarchy table, type: 'missing', 'spurious additional' or 'multiple hierarchy'
Returns:	Nothing
Description:	Diff geography hierarchy table using dynamic method 4
		Also tests the hierarchy, i.e. all a higher resolutuion is contained by one of the next higher and so on

Example of dynamic SQL. Note the use of an array return type to achieve method 4

WITH /- missing -/ a1 AS (
        SELECT COUNT(*) AS level1_total
          FROM (
                SELECT level1 FROM sahsuland_geography
                EXCEPT
                SELECT level1 FROM sahsuland_level1) as1)
, a2 AS (
        SELECT COUNT(*) AS level2_total
          FROM (
                SELECT level2 FROM sahsuland_geography
                EXCEPT
                SELECT level2 FROM sahsuland_level2) as2)
, a3 AS (
        SELECT COUNT(*) AS level3_total
          FROM (
                SELECT level3 FROM sahsuland_geography
                EXCEPT
                SELECT level3 FROM sahsuland_level3) as3)
, a4 AS (
        SELECT COUNT(*) AS level4_total
          FROM (
                SELECT level4 FROM sahsuland_geography
                EXCEPT
                SELECT level4 FROM sahsuland_level4) as4)
SELECT ARRAY[a1.level1_total, a2.level2_total, a3.level3_total, a4.level4_total] AS res_array
FROM a1, a2, a3, a4;

Or: 

WITH -* hierarchy *- a2 AS (
        SELECT COUNT(*) AS level2_total
          FROM (
                SELECT level2, COUNT(DISTINCT(level1)) AS total
                  FROM sahsuland_geography
                 GROUP BY level2
                HAVING COUNT(DISTINCT(level1)) > 1) AS2)
, a3 AS (
        SELECT COUNT(*) AS level3_total
          FROM (
                SELECT level3, COUNT(DISTINCT(level2)) AS total
                  FROM sahsuland_geography
                 GROUP BY level3
                HAVING COUNT(DISTINCT(level2)) > 1) AS3)
, a4 AS (
        SELECT COUNT(*) AS level4_total
          FROM (
                SELECT level4, COUNT(DISTINCT(level3)) AS total
                  FROM sahsuland_geography
                 GROUP BY level4
                HAVING COUNT(DISTINCT(level3)) > 1) AS4)
SELECT ARRAY[a2.level2_total, a3.level3_total, a4.level4_total] AS res_array
FROM a2, a3, a4;
 
 */
DECLARE
	c2 CURSOR(l_geography VARCHAR) FOR
		SELECT * 
		  FROM t_rif40_geolevels
		 WHERE geography = l_geography
		 ORDER BY geolevel_id;
	c3 REFCURSOR;
	c4 CURSOR(l_geography VARCHAR, l_geolevel_id INTEGER) FOR
		SELECT * 
		  FROM t_rif40_geolevels
		 WHERE geography   = l_geography
		   AND geolevel_id = l_geolevel_id
		 ORDER BY geolevel_id;
--
	c2_rec t_rif40_geolevels%ROWTYPE;
	c3_rec RECORD;
	c4_rec t_rif40_geolevels%ROWTYPE;
--
	sql_stmt 		VARCHAR;
	previous_geolevel_name 	VARCHAR:=NULL;
	i INTEGER;
	e INTEGER:=0;
	field INTEGER;
BEGIN
--
-- Must be rif40 or have rif_user or rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'lf_check_rif40_hierarchy_lookup_tables', 'User % must be rif40 or have rif_user or rif_manager role', 
			USER::VARCHAR	/* Username */);
	END IF;
--
	sql_stmt:='WITH /* '||l_type||' */ ';
	i:=0;
	FOR c2_rec IN c2(l_geography) LOOP
		i:=i+1;
		IF l_type = 'multiple hierarchy' THEN
			IF i = 1 THEN
				NULL;
			ELSIF i > 2 THEN
				sql_stmt:=sql_stmt||', '||quote_ident('a'||c2_rec.geolevel_id)||' AS ('||E'\n';
				sql_stmt:=sql_stmt||E'\t'||'SELECT COUNT(*) AS '||quote_ident(LOWER(c2_rec.geolevel_name)||'_total')||E'\n';
				sql_stmt:=sql_stmt||E'\t'||'  FROM ('||E'\n';
			ELSE
				sql_stmt:=sql_stmt||quote_ident('a'||c2_rec.geolevel_id)||' AS ('||E'\n';
				sql_stmt:=sql_stmt||E'\t'||'SELECT COUNT(*) AS '||quote_ident(LOWER(c2_rec.geolevel_name)||'_total')||E'\n';
				sql_stmt:=sql_stmt||E'\t'||'  FROM ('||E'\n';
			END IF;
		ELSE
			IF i != 1 THEN
				sql_stmt:=sql_stmt||', '||quote_ident('a'||c2_rec.geolevel_id)||' AS ('||E'\n';
			ELSE
				sql_stmt:=sql_stmt||quote_ident('a'||c2_rec.geolevel_id)||' AS ('||E'\n';
			END IF;
			sql_stmt:=sql_stmt||E'\t'||'SELECT COUNT(*) AS '||quote_ident(LOWER(c2_rec.geolevel_name)||'_total')||E'\n';
			sql_stmt:=sql_stmt||E'\t'||'  FROM ('||E'\n';
		END IF;
		IF l_type = 'missing' THEN
			sql_stmt:=sql_stmt||E'\t'||E'\t'||'SELECT '||quote_ident(LOWER(c2_rec.geolevel_name))||' FROM '||quote_ident(LOWER(l_hierarchytable))||E'\n';
			sql_stmt:=sql_stmt||E'\t'||E'\t'||'EXCEPT'||E'\n';
			sql_stmt:=sql_stmt||E'\t'||E'\t'||'SELECT '||quote_ident(LOWER(c2_rec.geolevel_name))||' FROM '||quote_ident(LOWER(c2_rec.lookup_table))||
				') '||quote_ident('as'||c2_rec.geolevel_id)||')'||E'\n';
		ELSIF l_type = 'spurious additional' THEN
			sql_stmt:=sql_stmt||E'\t'||E'\t'||'SELECT '||quote_ident(LOWER(c2_rec.geolevel_name))||' FROM '||quote_ident(LOWER(c2_rec.lookup_table))||E'\n';
			sql_stmt:=sql_stmt||E'\t'||E'\t'||'EXCEPT'||E'\n';
			sql_stmt:=sql_stmt||E'\t'||E'\t'||'SELECT '||quote_ident(LOWER(c2_rec.geolevel_name))||' FROM '||quote_ident(LOWER(l_hierarchytable))||
				') '||quote_ident('as'||c2_rec.geolevel_id)||')'||E'\n';
		ELSIF l_type = 'multiple hierarchy' THEN
			IF previous_geolevel_name IS NOT NULL THEN
				sql_stmt:=sql_stmt||E'\t'||E'\t'||'SELECT '||quote_ident(LOWER(c2_rec.geolevel_name))||
					', COUNT(DISTINCT('||previous_geolevel_name||')) AS total'||E'\n';
				sql_stmt:=sql_stmt||E'\t'||E'\t'||'  FROM '||quote_ident(LOWER(l_hierarchytable))||E'\n';
				sql_stmt:=sql_stmt||E'\t'||E'\t'||' GROUP BY '||quote_ident(LOWER(c2_rec.geolevel_name))||E'\n';
				sql_stmt:=sql_stmt||E'\t'||E'\t'||'HAVING COUNT(DISTINCT('||previous_geolevel_name||')) > 1'||
					') '||quote_ident('as'||c2_rec.geolevel_id)||')'||E'\n';
			END IF;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-10017, 'lf_check_rif40_hierarchy_lookup_tables', 
				'Invalid check type: %, valid types are: ''missing'', ''spurious additional'', or ''multiple hierarchy''', 
				l_type::VARCHAR 	/* Check type */);
		END IF;
		previous_geolevel_name:=quote_ident(LOWER(c2_rec.geolevel_name));
	END LOOP;
	sql_stmt:=sql_stmt||'SELECT ARRAY[';
	i:=0;
	FOR c2_rec IN c2(l_geography) LOOP
		i:=i+1;
		IF l_type = 'multiple hierarchy' THEN
			IF i = 1 THEN
				NULL;
			ELSIF i > 2 THEN
				sql_stmt:=sql_stmt||', '||quote_ident('a'||c2_rec.geolevel_id)||'.'||quote_ident(LOWER(c2_rec.geolevel_name)||'_total');
			ELSE
				sql_stmt:=sql_stmt||quote_ident('a'||c2_rec.geolevel_id)||'.'||quote_ident(LOWER(c2_rec.geolevel_name)||'_total');
			END IF;
		ELSE
			IF i != 1 THEN
				sql_stmt:=sql_stmt||', '||quote_ident('a'||c2_rec.geolevel_id)||'.'||quote_ident(LOWER(c2_rec.geolevel_name)||'_total');
			ELSE
				sql_stmt:=sql_stmt||quote_ident('a'||c2_rec.geolevel_id)||'.'||quote_ident(LOWER(c2_rec.geolevel_name)||'_total');
			END IF;
		END IF;
	END LOOP;
	sql_stmt:=sql_stmt||'] AS res_array'||E'\n'||'FROM ';
	i:=0;
	FOR c2_rec IN c2(l_geography) LOOP
		i:=i+1;
		IF l_type = 'multiple hierarchy' THEN
			IF i = 1 THEN
				NULL;
			ELSIF i > 2 THEN
				sql_stmt:=sql_stmt||', '||quote_ident('a'||c2_rec.geolevel_id);
			ELSE
				sql_stmt:=sql_stmt||quote_ident('a'||c2_rec.geolevel_id);
			END IF;
		ELSE
			IF i != 1 THEN
				sql_stmt:=sql_stmt||', '||quote_ident('a'||c2_rec.geolevel_id);
			ELSE
				sql_stmt:=sql_stmt||quote_ident('a'||c2_rec.geolevel_id);
			END IF;
		END IF;
	END LOOP;
--
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'lf_check_rif40_hierarchy_lookup_tables', 'SQL> %;', sql_stmt::VARCHAR);
	OPEN c3 FOR EXECUTE sql_stmt;
	FETCH c3 INTO c3_rec;
--
-- Process results array
--
	i:=0;
	FOREACH field IN ARRAY c3_rec.res_array LOOP
		i:=i+1;
		OPEN c4(l_geography, i);
		FETCH c4 INTO c4_rec;
		CLOSE c4;
		IF field != 0 THEN
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'lf_check_rif40_hierarchy_lookup_tables', 'Geography: % geolevel %: [%] % codes: %', 
				l_geography::VARCHAR			/* Geography */, 
				i::VARCHAR				/* Geolevel ID */, 
				LOWER(c4_rec.geolevel_name)::VARCHAR	/* Geolevel name */, 
				l_type::VARCHAR				/* Check type */, 
				field::VARCHAR				/* Area ID */);
			e:=e+1;
		ELSE
			PERFORM rif40_log_pkg.rif40_log('INFO', 'lf_check_rif40_hierarchy_lookup_tables', 'Geography: % geolevel %: [%] no % codes', 
				l_geography::VARCHAR			/* Geography */, 
				i::VARCHAR				/* Geolevel ID */, 
				LOWER(c4_rec.geolevel_name)::VARCHAR	/* Geolevel name */, 
				l_type::VARCHAR				/* Check type */);
		END IF;
	END LOOP;
--
	RETURN e;
END;
]]></definition>
</function>

<function name="populate_hierarchy_table"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	populate_hierarchy_table()
Parameters:	Nothing
Returns:	Nothing
Description:	Populate hierarchy table]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<definition><![CDATA[
/*

Function: 	populate_hierarchy_table()
Parameters:	Nothing
Returns:	Nothing
Description:	Populate hierarchy table

 */
DECLARE
	c2_hier2 CURSOR FOR
		SELECT *
		  FROM rif40_geographies;
--
	c2_rec rif40_geographies%ROWTYPE;
BEGIN
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'populate_hierarchy_table', 'User % must be rif40 or have rif_manager role', 
			USER::VARCHAR	/* Username */);
	END IF;
--
-- Create lookup and Hierarchy tables
--
	FOR c2_rec IN c2_hier2 LOOP
		PERFORM rif40_geo_pkg.populate_hierarchy_table(c2_rec.geography, c2_rec.hierarchytable);
	END LOOP;
--
	RETURN;
END;
]]></definition>
</function>

<function name="populate_hierarchy_table"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	populate_hierarchy_table()
Parameters:	geography
Returns:	Nothing
Description:	Populate hierarchy table
		Check rows were inserted
		Re-index
		Analyze
		Check intersections

This algorithm implments the prototype in: ../postgres/gis_intersection_prototype.sql. The SAHSU alogoritm differs in that
Where intersections overlap (e.g. level4 appears in more than 1 level3) the level3 with the greatest intersected area is chosen 
This is differed to ARCGis - see the prototype file for a more detailed investigation

This function must be run after rif40_geo_pkg.populate_rif40_geometry_tables() i.e. area_id, optimised_geometry and optimised_geometry must exist

Population SQL used to fail with (fixed with ST_MakeValid()):

ERROR:  Error performing intersection: TopologyException: found non-noded intersection between LINESTRING (-2.99198 53.3669, -2.98262 53.367) and LINESTRING (-2.98556 53.367, -2.98854 53.3655) at -2.9855578257498308 53.366966593247653

To test for invalid polygons:

SELECT area_id, ST_Isvalid(optimised_geometry) AS v1, ST_Isvalid(optimised_geometry) AS v2
  FROM t_rif40_geolevels_geometry_ew01_oa2001
 WHERE NOT ST_Isvalid(optimised_geometry) OR NOT ST_Isvalid(optimised_geometry);

NOTICE:  Self-intersection at or near point -2.9855576987063932 53.366966657364905
NOTICE:  Self-intersection at or near point -2.9855576987063932 53.366966657364905
NOTICE:  Self-intersection at or near point -4.1539493321927816 51.672864859911542
NOTICE:  Self-intersection at or near point -4.1539493321927816 51.672864859911542
NOTICE:  Self-intersection at or near point 0.27233850962861539 50.88057609104721
NOTICE:  Self-intersection at or near point 0.27233850962861539 50.88057609104721
  area_id   | v1 | v2 
------------+----+----
 00CBFD0032 | t  | f
 00NUQQ0006 | t  | f
 21UHHJ0015 | t  | f
(3 rows)

Example population SQL>

INSERT INTO ew2001_geography (scntry2001, cntry2001, gor2001, ladua2001, ward2001, soa2001, oa2001)
WITH x12 AS ( /* Subqueries x12 ... x67: intersection aggregate geometries starting from the lowest resolution.
               Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.
               Calculate the area of the higher resolution geolevel and the area of the intersected area */
SELECT a1.area_id AS scntry2001, a2.area_id AS cntry2001,
       ST_Area(a2.optimised_geometry) AS a2_area,
       ST_Area(ST_Intersection(a1.optimised_geometry, a2.optimised_geometry)) a12_area
  FROM t_rif40_geolevels_geometry_ew01_scntry2001 a1 CROSS JOIN t_rif40_geolevels_geometry_ew01_cntry2001 a2
 WHERE ST_Intersects(a1.optimised_geometry, a2.optimised_geometry)
), x23 AS ( /* Subqueries x23 ... x67: intersection aggregate geometries starting from the lowest resolution.
               Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.
               Calculate the area of the higher resolution geolevel and the area of the intersected area */
SELECT a2.area_id AS cntry2001, a3.area_id AS gor2001,
       ST_Area(a3.optimised_geometry) AS a3_area,
       ST_Area(ST_Intersection(a2.optimised_geometry, a3.optimised_geometry)) a23_area
  FROM t_rif40_geolevels_geometry_ew01_cntry2001 a2 CROSS JOIN t_rif40_geolevels_geometry_ew01_gor2001 a3
 WHERE ST_Intersects(a2.optimised_geometry, a3.optimised_geometry)
), x34 AS ( /* Subqueries x34 ... x67: intersection aggregate geometries starting from the lowest resolution.
               Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.
               Calculate the area of the higher resolution geolevel and the area of the intersected area */
SELECT a3.area_id AS gor2001, a4.area_id AS ladua2001,
       ST_Area(a4.optimised_geometry) AS a4_area,
       ST_Area(ST_Intersection(a3.optimised_geometry, a4.optimised_geometry)) a34_area
  FROM t_rif40_geolevels_geometry_ew01_gor2001 a3 CROSS JOIN t_rif40_geolevels_geometry_ew01_ladua2001 a4
 WHERE ST_Intersects(a3.optimised_geometry, a4.optimised_geometry)
), x45 AS ( /* Subqueries x45 ... x67: intersection aggregate geometries starting from the lowest resolution.
               Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.
               Calculate the area of the higher resolution geolevel and the area of the intersected area */
SELECT a4.area_id AS ladua2001, a5.area_id AS ward2001,
       ST_Area(a5.optimised_geometry) AS a5_area,
       ST_Area(ST_Intersection(a4.optimised_geometry, a5.optimised_geometry)) a45_area
  FROM t_rif40_geolevels_geometry_ew01_ladua2001 a4 CROSS JOIN t_rif40_geolevels_geometry_ew01_ward2001 a5
 WHERE ST_Intersects(a4.optimised_geometry, a5.optimised_geometry)
), x56 AS ( /* Subqueries x56 ... x67: intersection aggregate geometries starting from the lowest resolution.
               Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.
               Calculate the area of the higher resolution geolevel and the area of the intersected area */
SELECT a5.area_id AS ward2001, a6.area_id AS soa2001,
       ST_Area(a6.optimised_geometry) AS a6_area,
       ST_Area(ST_Intersection(a5.optimised_geometry, a6.optimised_geometry)) a56_area
  FROM t_rif40_geolevels_geometry_ew01_ward2001 a5 CROSS JOIN t_rif40_geolevels_geometry_ew01_soa2001 a6
 WHERE ST_Intersects(a5.optimised_geometry, a6.optimised_geometry)
), x67 AS ( /* Subqueries x67 ... x67: intersection aggregate geometries starting from the lowest resolution.
               Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.
               Calculate the area of the higher resolution geolevel and the area of the intersected area */
SELECT a6.area_id AS soa2001, a7.area_id AS oa2001,
       ST_Area(a7.optimised_geometry) AS a7_area,
       ST_Area(ST_Intersection(a6.optimised_geometry, a7.optimised_geometry)) a67_area
  FROM t_rif40_geolevels_geometry_ew01_soa2001 a6 CROSS JOIN t_rif40_geolevels_geometry_ew01_oa2001 a7
 WHERE ST_Intersects(a6.optimised_geometry, a7.optimised_geometry)
), y AS ( /* Join x78 ... x67intersections, pass through the computed areas, compute intersected area/higher resolution geolevel area,
             compute maximum intersected area/higher resolution geolevel area using an analytic partition of all
             duplicate higher resolution geolevels */
SELECT x12.scntry2001, 
       x12.cntry2001, 
       x23.gor2001, 
       x34.ladua2001, 
       x45.ward2001, 
       x56.soa2001, 
       x67.oa2001, 
       CASE WHEN x12.a2_area > 0 THEN x12.a12_area/x12.a2_area ELSE NULL END test12,
       MAX(x12.a12_area/x12.a2_area) OVER (PARTITION BY x12.cntry2001) AS max12,
       CASE WHEN x23.a3_area > 0 THEN x23.a23_area/x23.a3_area ELSE NULL END test23,
       MAX(x23.a23_area/x23.a3_area) OVER (PARTITION BY x23.gor2001) AS max23,
       CASE WHEN x34.a4_area > 0 THEN x34.a34_area/x34.a4_area ELSE NULL END test34,
       MAX(x34.a34_area/x34.a4_area) OVER (PARTITION BY x34.ladua2001) AS max34,
       CASE WHEN x45.a5_area > 0 THEN x45.a45_area/x45.a5_area ELSE NULL END test45,
       MAX(x45.a45_area/x45.a5_area) OVER (PARTITION BY x45.ward2001) AS max45,
       CASE WHEN x56.a6_area > 0 THEN x56.a56_area/x56.a6_area ELSE NULL END test56,
       MAX(x56.a56_area/x56.a6_area) OVER (PARTITION BY x56.soa2001) AS max56,
       CASE WHEN x67.a7_area > 0 THEN x67.a67_area/x67.a7_area ELSE NULL END test67,
       MAX(x67.a67_area/x67.a7_area) OVER (PARTITION BY x67.oa2001) AS max67
  FROM x12, x23, x34, x45, x56, x67
 WHERE x12.cntry2001 = x23.cntry2001
   AND x23.gor2001 = x34.gor2001
   AND x34.ladua2001 = x45.ladua2001
   AND x45.ward2001 = x56.ward2001
   AND x56.soa2001 = x67.soa2001
)
SELECT /* Select y intersection, eliminating duplicates using selecting the lower geolevel resolution
         with the largest intersection by area for each (higher resolution) geolevel */
       scntry2001, cntry2001, gor2001, ladua2001, ward2001, soa2001, oa2001
  FROM y
 WHERE max12 = test12
   AND max23 = test23
   AND max34 = test34
   AND max45 = test45
   AND max56 = test56
   AND max67 = test67
 ORDER BY 1, 2, 3, 4]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="l_geography" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	populate_hierarchy_table()
Parameters:	geography
Returns:	Nothing
Description:	Populate hierarchy table
		Check rows were inserted
		Re-index
		Analyze
		Check intersections

This algorithm implments the prototype in: ../postgres/gis_intersection_prototype.sql. The SAHSU alogoritm differs in that
Where intersections overlap (e.g. level4 appears in more than 1 level3) the level3 with the greatest intersected area is chosen 
This is differed to ARCGis - see the prototype file for a more detailed investigation

This function must be run after rif40_geo_pkg.populate_rif40_geometry_tables() i.e. area_id, optimised_geometry and optimised_geometry must exist

Population SQL used to fail with (fixed with ST_MakeValid()):

ERROR:  Error performing intersection: TopologyException: found non-noded intersection between LINESTRING (-2.99198 53.3669, -2.98262 53.367) and LINESTRING (-2.98556 53.367, -2.98854 53.3655) at -2.9855578257498308 53.366966593247653

To test for invalid polygons:

SELECT area_id, ST_Isvalid(optimised_geometry) AS v1, ST_Isvalid(optimised_geometry) AS v2
  FROM t_rif40_geolevels_geometry_ew01_oa2001
 WHERE NOT ST_Isvalid(optimised_geometry) OR NOT ST_Isvalid(optimised_geometry);

NOTICE:  Self-intersection at or near point -2.9855576987063932 53.366966657364905
NOTICE:  Self-intersection at or near point -2.9855576987063932 53.366966657364905
NOTICE:  Self-intersection at or near point -4.1539493321927816 51.672864859911542
NOTICE:  Self-intersection at or near point -4.1539493321927816 51.672864859911542
NOTICE:  Self-intersection at or near point 0.27233850962861539 50.88057609104721
NOTICE:  Self-intersection at or near point 0.27233850962861539 50.88057609104721
  area_id   | v1 | v2 
------------+----+----
 00CBFD0032 | t  | f
 00NUQQ0006 | t  | f
 21UHHJ0015 | t  | f
(3 rows)

Example population SQL>

INSERT INTO ew2001_geography (scntry2001, cntry2001, gor2001, ladua2001, ward2001, soa2001, oa2001)
WITH x12 AS ( -* Subqueries x12 ... x67: intersection aggregate geometries starting from the lowest resolution.
               Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.
               Calculate the area of the higher resolution geolevel and the area of the intersected area *-
SELECT a1.area_id AS scntry2001, a2.area_id AS cntry2001,
       ST_Area(a2.optimised_geometry) AS a2_area,
       ST_Area(ST_Intersection(a1.optimised_geometry, a2.optimised_geometry)) a12_area
  FROM t_rif40_geolevels_geometry_ew01_scntry2001 a1 CROSS JOIN t_rif40_geolevels_geometry_ew01_cntry2001 a2
 WHERE ST_Intersects(a1.optimised_geometry, a2.optimised_geometry)
), x23 AS ( -* Subqueries x23 ... x67: intersection aggregate geometries starting from the lowest resolution.
               Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.
               Calculate the area of the higher resolution geolevel and the area of the intersected area *-
SELECT a2.area_id AS cntry2001, a3.area_id AS gor2001,
       ST_Area(a3.optimised_geometry) AS a3_area,
       ST_Area(ST_Intersection(a2.optimised_geometry, a3.optimised_geometry)) a23_area
  FROM t_rif40_geolevels_geometry_ew01_cntry2001 a2 CROSS JOIN t_rif40_geolevels_geometry_ew01_gor2001 a3
 WHERE ST_Intersects(a2.optimised_geometry, a3.optimised_geometry)
), x34 AS ( -* Subqueries x34 ... x67: intersection aggregate geometries starting from the lowest resolution.
               Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.
               Calculate the area of the higher resolution geolevel and the area of the intersected area *-
SELECT a3.area_id AS gor2001, a4.area_id AS ladua2001,
       ST_Area(a4.optimised_geometry) AS a4_area,
       ST_Area(ST_Intersection(a3.optimised_geometry, a4.optimised_geometry)) a34_area
  FROM t_rif40_geolevels_geometry_ew01_gor2001 a3 CROSS JOIN t_rif40_geolevels_geometry_ew01_ladua2001 a4
 WHERE ST_Intersects(a3.optimised_geometry, a4.optimised_geometry)
), x45 AS ( -* Subqueries x45 ... x67: intersection aggregate geometries starting from the lowest resolution.
               Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.
               Calculate the area of the higher resolution geolevel and the area of the intersected area *-
SELECT a4.area_id AS ladua2001, a5.area_id AS ward2001,
       ST_Area(a5.optimised_geometry) AS a5_area,
       ST_Area(ST_Intersection(a4.optimised_geometry, a5.optimised_geometry)) a45_area
  FROM t_rif40_geolevels_geometry_ew01_ladua2001 a4 CROSS JOIN t_rif40_geolevels_geometry_ew01_ward2001 a5
 WHERE ST_Intersects(a4.optimised_geometry, a5.optimised_geometry)
), x56 AS ( -* Subqueries x56 ... x67: intersection aggregate geometries starting from the lowest resolution.
               Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.
               Calculate the area of the higher resolution geolevel and the area of the intersected area *-
SELECT a5.area_id AS ward2001, a6.area_id AS soa2001,
       ST_Area(a6.optimised_geometry) AS a6_area,
       ST_Area(ST_Intersection(a5.optimised_geometry, a6.optimised_geometry)) a56_area
  FROM t_rif40_geolevels_geometry_ew01_ward2001 a5 CROSS JOIN t_rif40_geolevels_geometry_ew01_soa2001 a6
 WHERE ST_Intersects(a5.optimised_geometry, a6.optimised_geometry)
), x67 AS ( -* Subqueries x67 ... x67: intersection aggregate geometries starting from the lowest resolution.
               Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.
               Calculate the area of the higher resolution geolevel and the area of the intersected area *-
SELECT a6.area_id AS soa2001, a7.area_id AS oa2001,
       ST_Area(a7.optimised_geometry) AS a7_area,
       ST_Area(ST_Intersection(a6.optimised_geometry, a7.optimised_geometry)) a67_area
  FROM t_rif40_geolevels_geometry_ew01_soa2001 a6 CROSS JOIN t_rif40_geolevels_geometry_ew01_oa2001 a7
 WHERE ST_Intersects(a6.optimised_geometry, a7.optimised_geometry)
), y AS ( -* Join x78 ... x67intersections, pass through the computed areas, compute intersected area/higher resolution geolevel area,
             compute maximum intersected area/higher resolution geolevel area using an analytic partition of all
             duplicate higher resolution geolevels *-
SELECT x12.scntry2001, 
       x12.cntry2001, 
       x23.gor2001, 
       x34.ladua2001, 
       x45.ward2001, 
       x56.soa2001, 
       x67.oa2001, 
       CASE WHEN x12.a2_area > 0 THEN x12.a12_area/x12.a2_area ELSE NULL END test12,
       MAX(x12.a12_area/x12.a2_area) OVER (PARTITION BY x12.cntry2001) AS max12,
       CASE WHEN x23.a3_area > 0 THEN x23.a23_area/x23.a3_area ELSE NULL END test23,
       MAX(x23.a23_area/x23.a3_area) OVER (PARTITION BY x23.gor2001) AS max23,
       CASE WHEN x34.a4_area > 0 THEN x34.a34_area/x34.a4_area ELSE NULL END test34,
       MAX(x34.a34_area/x34.a4_area) OVER (PARTITION BY x34.ladua2001) AS max34,
       CASE WHEN x45.a5_area > 0 THEN x45.a45_area/x45.a5_area ELSE NULL END test45,
       MAX(x45.a45_area/x45.a5_area) OVER (PARTITION BY x45.ward2001) AS max45,
       CASE WHEN x56.a6_area > 0 THEN x56.a56_area/x56.a6_area ELSE NULL END test56,
       MAX(x56.a56_area/x56.a6_area) OVER (PARTITION BY x56.soa2001) AS max56,
       CASE WHEN x67.a7_area > 0 THEN x67.a67_area/x67.a7_area ELSE NULL END test67,
       MAX(x67.a67_area/x67.a7_area) OVER (PARTITION BY x67.oa2001) AS max67
  FROM x12, x23, x34, x45, x56, x67
 WHERE x12.cntry2001 = x23.cntry2001
   AND x23.gor2001 = x34.gor2001
   AND x34.ladua2001 = x45.ladua2001
   AND x45.ward2001 = x56.ward2001
   AND x56.soa2001 = x67.soa2001
)
SELECT -* Select y intersection, eliminating duplicates using selecting the lower geolevel resolution
         with the largest intersection by area for each (higher resolution) geolevel *-
       scntry2001, cntry2001, gor2001, ladua2001, ward2001, soa2001, oa2001
  FROM y
 WHERE max12 = test12
   AND max23 = test23
   AND max34 = test34
   AND max45 = test45
   AND max56 = test56
   AND max67 = test67
 ORDER BY 1, 2, 3, 4;

 */
DECLARE
	c1_hier CURSOR(l_geography VARCHAR) FOR
		SELECT * 
		  FROM t_rif40_geolevels
		 WHERE geography = l_geography
		 ORDER BY geography, geolevel_id;
	c2_hier CURSOR(l_geography VARCHAR) FOR
		SELECT * FROM pg_indexes
		 WHERE schemaname = USER
		   AND tablename IN (SELECT DISTINCT LOWER(hierarchytable)
				       FROM rif40_geographies
				      WHERE geography = l_geography)
		 ORDER BY 1;	
	c3 REFCURSOR;
	c4_hier CURSOR(l_geography VARCHAR) FOR
		SELECT *
		  FROM rif40_geographies
		 WHERE geography = l_geography;
	c1_rec t_rif40_geolevels%ROWTYPE;
	c2_rec rif40_geographies%ROWTYPE;
	c3_rec	RECORD;
	c4_rec rif40_geographies%ROWTYPE;
--
	columns		VARCHAR;
	sql_stmt 	VARCHAR;
	i		INTEGER:=0;
	num_geolevels	INTEGER:=0;
--
	geolevel_name			VARCHAR[];
	shapefile_table      		VARCHAR[];
 	shapefile_area_id_column	VARCHAR[];
 	shapefile_desc_column		VARCHAR[];
 	geolevel_table			VARCHAR[];
--
	stp TIMESTAMP WITH TIME ZONE;
	etp TIMESTAMP WITH TIME ZONE;
	took INTERVAL;
BEGIN
--
	stp:=clock_timestamp();
--
-- Must be rif40 or have rif_user or rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'populate_hierarchy_table', 'User % must be rif40 or have rif_user or rif_manager role', 
			USER::VARCHAR	/* Username */);
	END IF;
--
	IF l_geography IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10003, 'populate_hierarchy_table', 'NULL geography parameter');
	END IF;	
--
	OPEN c4_hier(l_geography);
	FETCH c4_hier INTO c4_rec;
	CLOSE c4_hier;
--
	IF c4_rec.geography IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10004, 'populate_hierarchy_table', 'geography: % not found', 
			l_geography::VARCHAR	/* Geography */);
	END IF;	
--
	PERFORM rif40_log_pkg.rif40_log('INFO', 'populate_hierarchy_table', 'Populating % geography hierarchy table: %',
		l_geography, c4_rec.hierarchytable);
--
-- INSERT statement
--
	sql_stmt:='INSERT INTO '||quote_ident(LOWER(c4_rec.hierarchytable))||' (';
	FOR c1_rec IN c1_hier(l_geography) LOOP
		i:=i+1;
		geolevel_name[i]:=quote_ident(LOWER(c1_rec.geolevel_name));
		shapefile_table[i]:=quote_ident(LOWER(c1_rec.shapefile_table));      	
 		shapefile_area_id_column[i]:=quote_ident(LOWER(c1_rec.shapefile_area_id_column));	
 		shapefile_desc_column[i]:=quote_ident(LOWER(c1_rec.shapefile_desc_column));	
		geolevel_table[i]:=quote_ident('t_rif40_geolevels_geometry_'||LOWER(l_geography)||'_'||LOWER(c1_rec.geolevel_name));
		IF i = 1 THEN
			columns:=geolevel_name[i];
		ELSE
			columns:=columns||', '||geolevel_name[i];
		END IF;
	END LOOP;
	num_geolevels:=i;
	IF num_geolevels = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-10017, 'populate_hierarchy_table', 'No rows found in: t_rif40_geolevels for geography %', 
			l_geography::VARCHAR /* Geography */);
	END IF;
	sql_stmt:=sql_stmt||columns||')'||E'\n';
--
-- Start SELECT statement; WITH clause; aggreagate geometries
--
-- Removed ST_Union for performance reasons
--

--
-- WITH clause - INTERSECTION
--
	FOR i IN 1 .. num_geolevels LOOP /* WITH clause - INTERSECTION */
/* E.g

x23 AS (
	SELECT a2.area_id AS level2, a3.area_id AS level3,
  	       ST_Area(a3.geom) AS a3_area,
	       ST_Area(ST_Intersection(a2.geom, a3.geom)) a23_area
          FROM a2 CROSS JOIN a3
	 WHERE ST_Intersects(a2.geom, a3.geom)
 */
		IF i = 1 THEN
			sql_stmt:=sql_stmt||
				'WITH x'||i||i+1||' AS ( /* Subqueries x'||i||i+1||' ... x'||num_geolevels-1||num_geolevels||': intersection aggregate geometries starting from the lowest resolution.'||E'\n'||
         		      	E'\t'||'       Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.'||E'\n'||
 	       			E'\t'||'       Calculate the area of the higher resolution geolevel and the area of the intersected area */'||E'\n'||
				'SELECT a'||i||'.area_id AS '||geolevel_name[i]||', a'||i+1||'.area_id AS '||geolevel_name[i+1]||','||E'\n'||
				'       ST_Area(a'||i+1||'.optimised_geometry) AS a'||i+1||'_area,'||E'\n'||
				'       ST_Area(ST_Intersection(a'||i||'.optimised_geometry, a'||i+1||'.optimised_geometry)) AS a'||i||i+1||'_area'||E'\n'||
				'  FROM '||geolevel_table[i]||' a'||i||' CROSS JOIN '||geolevel_table[i+1]||' a'||i+1||''||E'\n'||
				' WHERE ST_Intersects(a'||i||'.optimised_geometry, a'||i+1||'.optimised_geometry)'||E'\n'||
				'), ';
		ELSIF i < (num_geolevels-1) THEN
			sql_stmt:=sql_stmt||
				'x'||i||i+1||' AS ( /* Subqueries x'||i||i+1||' ... x'||num_geolevels-1||num_geolevels||': intersection aggregate geometries starting from the lowest resolution.'||E'\n'||
         		      	E'\t'||'       Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.'||E'\n'||
 	       			E'\t'||'       Calculate the area of the higher resolution geolevel and the area of the intersected area */'||E'\n'||
				'SELECT a'||i||'.area_id AS '||geolevel_name[i]||', a'||i+1||'.area_id AS '||geolevel_name[i+1]||','||E'\n'||
				'       ST_Area(a'||i+1||'.optimised_geometry) AS a'||i+1||'_area,'||E'\n'||
				'       ST_Area(ST_Intersection(a'||i||'.optimised_geometry, a'||i+1||'.optimised_geometry)) AS a'||i||i+1||'_area'||E'\n'||
				'  FROM '||geolevel_table[i]||' a'||i||' CROSS JOIN '||geolevel_table[i+1]||' a'||i+1||''||E'\n'||
				' WHERE ST_Intersects(a'||i||'.optimised_geometry, a'||i+1||'.optimised_geometry)'||E'\n'||
				'), ';
		ELSIF i < num_geolevels THEN
/* E.g.

 x34 AS (
	SELECT a3.level3, a4.level4,
	       total_a3_gid, total_a4_gid,
  	       ST_Area(a4.geom) AS a4_area,
	       ST_Area(ST_Intersection(a3.geom, a4.geom)) a34_area
          FROM a3 CROSS JOIN a4
	 WHERE ST_Intersects(a3.geom, a4.geom)
*/
			sql_stmt:=sql_stmt||
				'x'||i||i+1||' AS ( /* Subqueries x'||i||i+1||' ... x'||num_geolevels-1||num_geolevels||': intersection aggregate geometries starting from the lowest resolution.'||E'\n'||
         		      	E'\t'||'       Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.'||E'\n'||
 	       			E'\t'||'       Calculate the area of the higher resolution geolevel and the area of the intersected area */'||E'\n'||
				'SELECT a'||i||'.area_id AS '||geolevel_name[i]||', a'||i+1||'.area_id AS '||geolevel_name[i+1]||','||E'\n'||
				'       ST_Area(a'||i+1||'.optimised_geometry) AS a'||i+1||'_area,'||E'\n'||
				'       ST_Area(ST_Intersection(a'||i||'.optimised_geometry, a'||i+1||'.optimised_geometry)) AS a'||i||i+1||'_area'||E'\n'||
				'  FROM '||geolevel_table[i]||' a'||i||' CROSS JOIN '||geolevel_table[i+1]||' a'||i+1||''||E'\n'||
				' WHERE ST_Intersects(a'||i||'.optimised_geometry, a'||i+1||'.optimised_geometry)'||E'\n'||
				'), ';
		END IF;
	END LOOP;
--
-- Compute intersected area, order analytically
--

/*
y AS ( 
	SELECT x12.level1, x12.level2, x23.level3, x34.level4, 
	       CASE WHEN a2_area > 0 THEN a12_area/a2_area ELSE NULL END test12,
	       CASE WHEN a3_area > 0 THEN a23_area/a3_area ELSE NULL END test23,
	       CASE WHEN a4_area > 0 THEN a34_area/a4_area ELSE NULL END test34,
	       MAX(a12_area/a2_area) OVER (PARTITION BY x12.level2) AS max12,
	       MAX(a23_area/a3_area) OVER (PARTITION BY x23.level3) AS max23,
	       MAX(a34_area/a4_area) OVER (PARTITION BY x34.level4) AS max34
	  FROM x12, x23, x34
	 WHERE x12.level2 = x23.level2
   	   AND x23.level3 = x34.level3
)
 */
	sql_stmt:=sql_stmt||
		'y AS ( /* Join x'||i||i+1||' ... x'||num_geolevels-1||num_geolevels||
			'intersections, pass through the computed areas, compute intersected area/higher resolution geolevel area,'||E'\n'||
		E'\t'||'     compute maximum intersected area/higher resolution geolevel area using an analytic partition of all'||E'\n'||
		E'\t'||'     duplicate higher resolution geolevels */'||E'\n';
	FOR i IN 1 .. num_geolevels LOOP /* x12.level1, x12.level2, x23.level3, x34.level4, */
		IF i < num_geolevels THEN
			IF i = 1 THEN
				sql_stmt:=sql_stmt||
					'SELECT x'||i||i+1||'.'||geolevel_name[i]||', '||E'\n';
			END IF;
			sql_stmt:=sql_stmt||
				'       x'||i||i+1||'.'||geolevel_name[i+1]||', '||E'\n';
		END IF;
	END LOOP;
	FOR i IN 1 .. num_geolevels LOOP /* CASE MAX analytic clause */ 
		IF i < num_geolevels THEN
			sql_stmt:=sql_stmt||
	    		   	'       CASE WHEN x'||i||i+1||'.a'||i+1||'_area > 0 THEN x'||i||i+1||'.a'||i||i+1||'_area/x'||i||i+1||'.a'||i+1||
				'_area ELSE NULL END test'||i||i+1||','||E'\n';
			sql_stmt:=sql_stmt||
				'       MAX(x'||i||i+1||'.a'||i||i+1||'_area/x'||i||i+1||'.a'||i+1||'_area)'||
				' OVER (PARTITION BY x'||i||i+1||'.'||geolevel_name[i+1]||') AS max'||i||i+1||','||E'\n';
		END IF;
	END LOOP;
	sql_stmt:=SUBSTR(sql_stmt, 1, LENGTH(sql_stmt)-LENGTH(','||E'\n')) /* Chop off last ",\n" */||E'\n';
	FOR i IN 1 .. num_geolevels LOOP /* FROM clause */ 
		IF i < num_geolevels THEN
			IF i = 1 THEN
				sql_stmt:=sql_stmt||
					'  FROM x'||i||i+1;
			ELSE
				sql_stmt:=sql_stmt||
					', x'||i||i+1;
			END IF;
		END IF;
	END LOOP;
	FOR i IN 1 .. (num_geolevels-2) LOOP /* WHERE clause */ 
		IF i = 1 THEN
			sql_stmt:=sql_stmt||E'\n'||
				' WHERE x'||i||i+1||'.'||geolevel_name[i+1]||' = x'||i+1||i+2||'.'||geolevel_name[i+1];
		ELSE
			sql_stmt:=sql_stmt||E'\n'||
				'   AND x'||i||i+1||'.'||geolevel_name[i+1]||' = x'||i+1||i+2||'.'||geolevel_name[i+1];
		END IF;
	END LOOP;
	sql_stmt:=sql_stmt||E'\n'||')'||E'\n';
--
-- Final SELECT
--
	sql_stmt:=sql_stmt||'SELECT /* Select y intersection, eliminating duplicates using selecting the lower geolevel resolution'||E'\n'||
         E'\t'||' with the largest intersection by area for each (higher resolution) geolevel */'||E'\n'||'       '||columns||E'\n';
	sql_stmt:=sql_stmt||'  FROM y'||E'\n';
/*
SELECT level1, level2, level3, level4,
  FROM y
 WHERE max12 = test12
   AND max23 = test23
   AND max34 = test34
 ORDER BY 1, 2, 3, 4;  
 */
	FOR i IN 1 .. num_geolevels LOOP /* FROM clause */ 
		IF i < num_geolevels THEN
			IF i = 1 THEN
				sql_stmt:=sql_stmt||' WHERE max'||i||i+1||' = test'||i||i+1||E'\n';
			ELSE
				sql_stmt:=sql_stmt||'   AND max'||i||i+1||' = test'||i||i+1||E'\n';
			END IF;
		END IF;
	END LOOP;
	sql_stmt:=sql_stmt||' ORDER BY 1, 2, 3, 4';
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'populate_hierarchy_table', 'SQL> %', sql_stmt::VARCHAR);
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Check rows were inserted
--
	sql_stmt:='SELECT COUNT(*) AS total FROM '||quote_ident(LOWER(c4_rec.hierarchytable));
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'populate_hierarchy_table', 'SQL> %', sql_stmt::VARCHAR);
	OPEN c3 FOR EXECUTE sql_stmt;
	FETCH c3 INTO c3_rec;
	CLOSE c3;	
	IF c3_rec.total = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-10016, 'populate_hierarchy_table', 'No rows found in % geography hierarchy table: %', 
			l_geography::VARCHAR 			/* Geography */,
			quote_ident(LOWER(c4_rec.hierarchytable))	/* Hierarchy table */);
	END IF;
--
-- Re-index
--
	FOR c2_rec IN c2_hier(l_geography) LOOP
		sql_stmt:='REINDEX INDEX /* '||quote_ident(c2_rec.tablename)||' */ '||quote_ident(c2_rec.indexname);
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	END LOOP;
--
-- Analyze
--
	sql_stmt:='ANALYZE VERBOSE '||quote_ident(LOWER(c4_rec.hierarchytable));
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Check intersections
--
	PERFORM rif40_geo_pkg.check_rif40_hierarchy_lookup_tables(l_geography);
--
	etp:=clock_timestamp();
	took:=age(etp, stp);
	PERFORM rif40_log_pkg.rif40_log('INFO', 'populate_hierarchy_table', 'Populated % rows in % geography hierarchy table: % in %', 
		c3_rec.total::VARCHAR 					/* Rows */,
		l_geography::VARCHAR 					/* Geography */,
		quote_ident(LOWER(c4_rec.hierarchytable))::VARCHAR	/* Hierarchy table */,
		took::VARCHAR						/* Time taken */);
--
	RETURN;
END;
]]></definition>
</function>

<function name="populate_rif40_geometry_tables"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	populate_rif40_geometry_tables()
Parameters:	Nothing
Returns:	Nothing
Description:	Populate geographic specific geometry tables

Calls:		rif40_geo_pkg.populate_rif40_geometry_tables(geography);]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<definition><![CDATA[
/*

Function: 	populate_rif40_geometry_tables()
Parameters:	Nothing
Returns:	Nothing
Description:	Populate geographic specific geometry tables

Calls:		rif40_geo_pkg.populate_rif40_geometry_tables(geography);

 */
DECLARE
	c0 CURSOR FOR
		SELECT *
		  FROM rif40_geographies;
--
	c0_rec rif40_geographies%ROWTYPE;
	i INTEGER:=0;
BEGIN
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'populate_rif40_geometry_tables', 'User % must be rif40 or have rif_manager role', USER::VARCHAR);
	END IF;
--
	FOR c0_rec IN c0 LOOP
		PERFORM rif40_geo_pkg.populate_rif40_geometry_tables(c0_rec.geography);
		i:=i+1;
	END LOOP;
	IF i = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-10014, 'populate_rif40_geometry_tables', 'No geographies set up');
	END IF;
	PERFORM rif40_log_pkg.rif40_log('INFO', 'populate_rif40_geometry_tables', 'All geography geometry tables populated OK');
END;
]]></definition>
</function>

<function name="populate_rif40_geometry_tables"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	populate_rif40_geometry_tables()
Parameters:	Geography 
Returns:	Nothing
Description:	Populate geographic specific geometry tables

INSERT INTO t_rif40_ew01_geometry(
        geography, geolevel_name, area_id, name, gid, area, shapefile_geometry, optimised_geometry, optimised_geojson)
WITH a AS ( /* Aggregate geometries with the same area_id */
        SELECT 'SCNTRY2001' AS geolevel_name, scntry2001 AS area_id,        	name AS name, ST_MakeValid(ST_Union(geom)) AS geom
          FROM x_ew01_scntry2001
         GROUP BY scntry2001, name
        UNION
        SELECT 'CNTRY2001' AS geolevel_name, cntry2001 AS area_id,           	name AS name, ST_MakeValid(ST_Union(geom)) AS geom
          FROM x_ew01_cntry2001
         GROUP BY cntry2001, name
        UNION
        SELECT 'GOR2001' AS geolevel_name, gor2001 AS area_id,       		gorname AS name, ST_MakeValid(ST_Union(geom)) AS geom
          FROM x_ew01_gor2001
         GROUP BY gor2001, gorname
        UNION
        SELECT 'LADUA2001' AS geolevel_name, ladua2001 AS area_id,           	laduaname AS name, ST_MakeValid(ST_Union(geom)) AS geom
          FROM x_ew01_ladua2001
         GROUP BY ladua2001, laduaname
        UNION
        SELECT 'WARD2001' AS geolevel_name, ward2001 AS area_id,             	wardname AS name, ST_MakeValid(ST_Union(geom)) AS geom
          FROM x_ew01_ward2001
         GROUP BY ward2001, wardname
        UNION
        SELECT 'SOA2001' AS geolevel_name, soa2001 AS area_id,       		NULL AS name, ST_MakeValid(ST_Union(geom)) AS geom
          FROM x_ew01_soa2001
         GROUP BY soa2001
        UNION
        SELECT 'OA2001' AS geolevel_name, coa2001 AS area_id,        		NULL AS name, ST_MakeValid(ST_Union(geom)) AS geom
          FROM x_ew01_coa2001
         GROUP BY coa2001
), b /* t_rif40_geolevels */ AS (
        SELECT geography, geolevel_name, geolevel_id AS gid, st_simplify_tolerance
          FROM t_rif40_geolevels
         WHERE geography = 'EW01'
), c /* rif40_geographies */ AS (
        SELECT max_geojson_digits
          FROM rif40_geographies
         WHERE geography = 'EW01'
), d AS (
        SELECT a.geolevel_name, geom, area_id, name, ST_MakeValid(ST_SimplifyPreserveTopology(geom, b.st_simplify_tolerance)) AS simplified_topology
          FROM a, b
         WHERE a.geolevel_name = b.geolevel_name
)
SELECT 'EW01' geography, b.geolevel_name, area_id, NULLIF(name, 'Unknown: ['||area_id||']') AS name, b.gid /* RIF40_GEOLEVELS.GEOLEVEL_ID */,
        round(CAST(ST_area(geom)/1000000 AS numeric), 1) AS area,
        ST_Multi(geom) AS shapefile_geometry, 
        ST_MakeValid(ST_transform(ST_Multi(simplified_topology), 4326 /* WGS 84 */)) AS optimised_geometry,
	ST_AsGeoJson(
		ST_transform(
        		simplified_topology, 4326 /* WGS 84 */),
       				c.max_geojson_digits, 0 /* no options */) AS optimised_geojson
  FROM b, c, d
 WHERE b.geolevel_name = d.geolevel_name
 ORDER BY 1, 2, 3;

UPDATE t_rif40_geolevels a
   SET avg_npoints_geom = b1.avg_npoints_geom,
       avg_npoints_opt  = b1.avg_npoints_opt,
       file_geojson_len = b1.file_geojson_len,
       leg_geom         = b1.leg_geom,
       leg_opt          = b1.leg_opt
  FROM (
        SELECT geolevel_name,
               ROUND(CAST(AVG(ST_NPOINTS(SHAPEFILE_GEOMETRY)) AS numeric), 1) AS avg_npoints_geom,
               ROUND(CAST(AVG(ST_NPoints(optimised_geometry)) AS numeric), 1) AS avg_npoints_opt,
               ROUND(CAST(SUM(length(optimised_geojson)) AS numeric), 1) AS file_geojson_len,
               ROUND(CAST(AVG(ST_perimeter(shapefile_geometry)/ST_NPoints(shapefile_geometry)) AS numeric), 1) AS leg_geom,
               ROUND(CAST(AVG(ST_perimeter(optimised_geometry)/ST_NPoints(optimised_geometry)) AS numeric), 1) AS leg_opt
         FROM t_rif40_ew01_geometry b
         GROUP BY geolevel_name) AS b1
 WHERE a.geolevel_name = b1.geolevel_name
   AND a.geography     = 'EW01';
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="l_geography" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	populate_rif40_geometry_tables()
Parameters:	Geography 
Returns:	Nothing
Description:	Populate geographic specific geometry tables

INSERT INTO t_rif40_ew01_geometry(
        geography, geolevel_name, area_id, name, gid, area, shapefile_geometry, optimised_geometry, optimised_geojson)
WITH a AS ( -* Aggregate geometries with the same area_id *-
        SELECT 'SCNTRY2001' AS geolevel_name, scntry2001 AS area_id,         name AS name, ST_MakeValid(ST_Union(geom)) AS geom
          FROM x_ew01_scntry2001
         GROUP BY scntry2001, name
        UNION
        SELECT 'CNTRY2001' AS geolevel_name, cntry2001 AS area_id,           name AS name, ST_MakeValid(ST_Union(geom)) AS geom
          FROM x_ew01_cntry2001
         GROUP BY cntry2001, name
        UNION
        SELECT 'GOR2001' AS geolevel_name, gor2001 AS area_id,       gorname AS name, ST_MakeValid(ST_Union(geom)) AS geom
          FROM x_ew01_gor2001
         GROUP BY gor2001, gorname
        UNION
        SELECT 'LADUA2001' AS geolevel_name, ladua2001 AS area_id,           laduaname AS name, ST_MakeValid(ST_Union(geom)) AS geom
          FROM x_ew01_ladua2001
         GROUP BY ladua2001, laduaname
        UNION
        SELECT 'WARD2001' AS geolevel_name, ward2001 AS area_id,             wardname AS name, ST_MakeValid(ST_Union(geom)) AS geom
          FROM x_ew01_ward2001
         GROUP BY ward2001, wardname
        UNION
        SELECT 'SOA2001' AS geolevel_name, soa2001 AS area_id,       NULL AS name, ST_MakeValid(ST_Union(geom)) AS geom
          FROM x_ew01_soa2001
         GROUP BY soa2001
        UNION
        SELECT 'OA2001' AS geolevel_name, coa2001 AS area_id,        NULL AS name, ST_MakeValid(ST_Union(geom)) AS geom
          FROM x_ew01_coa2001
         GROUP BY coa2001
), b -* t_rif40_geolevels *- AS (
        SELECT geography, geolevel_name, geolevel_id AS gid, st_simplify_tolerance
          FROM t_rif40_geolevels
         WHERE geography = 'EW01'
), c -* rif40_geographies *- AS (
        SELECT max_geojson_digits
          FROM rif40_geographies
         WHERE geography = 'EW01'
), d AS (
        SELECT a.geolevel_name, geom, area_id, name, ST_MakeValid((ST_SimplifyPreserveTopology(geom, b.st_simplify_tolerance)) AS simplified_topology
          FROM a, b
         WHERE a.geolevel_name = b.geolevel_name
)
SELECT 'EW01' geography, b.geolevel_name, area_id, NULLIF(name, 'Unknown: ['||area_id||']') AS name, b.gid -* RIF40_GEOLEVELS.GEOLEVEL_ID *-,
        round(CAST(ST_area(geom)/1000000 AS numeric), 1) AS area,
        ST_Multi(geom) AS shapefile_geometry, 
        ST_MakeValid(ST_transform(ST_Multi(simplified_topology), 4326 -* WGS 84 *-)) AS optimised_geometry,
	ST_AsGeoJson(
		ST_transform(
        		simplified_topology, 4326 -* WGS 84 *-),
       				c.max_geojson_digits, 0 -* no options *-) AS optimised_geojson
  FROM b, c, d
 WHERE b.geolevel_name = d.geolevel_name
 ORDER BY 1, 2, 3;

UPDATE t_rif40_geolevels a
   SET avg_npoints_geom = b1.avg_npoints_geom,
       avg_npoints_opt  = b1.avg_npoints_opt,
       file_geojson_len = b1.file_geojson_len,
       leg_geom         = b1.leg_geom,
       leg_opt          = b1.leg_opt
  FROM (
        SELECT geolevel_name,
               ROUND(CAST(AVG(ST_NPOINTS(SHAPEFILE_GEOMETRY)) AS numeric), 1) AS avg_npoints_geom,
               ROUND(CAST(AVG(ST_NPoints(optimised_geometry)) AS numeric), 1) AS avg_npoints_opt,
               ROUND(CAST(SUM(length(optimised_geojson)) AS numeric), 1) AS file_geojson_len,
               ROUND(CAST(AVG(ST_perimeter(shapefile_geometry)/ST_NPoints(shapefile_geometry)) AS numeric), 1) AS leg_geom,
               ROUND(CAST(AVG(ST_perimeter(optimised_geometry)/ST_NPoints(optimised_geometry)) AS numeric), 1) AS leg_opt
         FROM t_rif40_ew01_geometry b
         GROUP BY geolevel_name) AS b1
 WHERE a.geolevel_name = b1.geolevel_name
   AND a.geography     = 'EW01';

 */
DECLARE
	c1 CURSOR(l_geography VARCHAR) FOR
		SELECT *
		  FROM rif40_geographies
		 WHERE geography = l_geography;
	c2 CURSOR(l_geography VARCHAR) FOR
		SELECT * 
		  FROM t_rif40_geolevels
		 WHERE geography = l_geography
		 ORDER BY geolevel_id;
	c3 REFCURSOR;
--
	c1_rec rif40_geographies%ROWTYPE;
	c2_rec t_rif40_geolevels%ROWTYPE;
	c3_rec RECORD;
--
	sql_stmt VARCHAR;
	i INTEGER:=0;
	insert_rows INTEGER:=0;
	update_rows INTEGER:=0;
BEGIN
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'populate_rif40_geometry_tables', 'User % must be rif40 or have rif_manager role', 
			USER::VARCHAR	/* Username */);
	END IF;
--
	IF l_geography IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10005, 'populate_rif40_geometry_tables', 'NULL geography parameter');
	END IF;	
--
	OPEN c1(l_geography);
	FETCH c1 INTO c1_rec;
	CLOSE c1;
--
	IF c1_rec.geography IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-10006, 'populate_rif40_geometry_tables', 'geography: % not found', 
			l_geography::VARCHAR	/* Geograpy */);
	END IF;	
--
	sql_stmt:='DELETE FROM '||quote_ident('t_rif40_'||LOWER(c1_rec.geography)||'_geometry');
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
	sql_stmt:='INSERT INTO '||quote_ident('t_rif40_'||LOWER(c1_rec.geography)||'_geometry')||'('||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'geography, geolevel_name, area_id, name, gid, area, shapefile_geometry, optimised_geometry, optimised_geojson)'||E'\n';	
	sql_stmt:=sql_stmt||'WITH a AS ( /* Aggregate geometries with the same area_id */'||E'\n';
	FOR c2_rec IN c2(l_geography) LOOP
		i:=i+1;
		IF i > 1 THEN
			sql_stmt:=sql_stmt||E'\t'||'UNION'||E'\n';
		END IF;
		sql_stmt:=sql_stmt||E'\t'||'SELECT '||quote_literal(UPPER(c2_rec.geolevel_name))||' AS geolevel_name, '||quote_ident(LOWER(c2_rec.shapefile_area_id_column))||' AS area_id, ';
		IF c2_rec.shapefile_desc_column IS NOT NULL THEN
			sql_stmt:=sql_stmt||E'\t'||'     '||quote_ident(LOWER(c2_rec.shapefile_desc_column))||' AS name,'||E'\n';
		ELSE
			sql_stmt:=sql_stmt||E'\t'||'     NULL::Text AS name,'||E'\n';
		END IF;
--
-- ST_MakeValid() replaced - causing corruption in simplification algorithm
--
--		sql_stmt:=sql_stmt||E'\t'||'     ST_MakeValid(ST_Union(geom)) AS geom'||E'\n';
--
-- the other way around could be tried
--
--		sql_stmt:=sql_stmt||E'\t'||'     ST_Union(ST_MakeValid(geom)) AS geom'||E'\n';
--
-- ST_Buffer() replacement for simplification algorithm issue (but removed from simplification as causing issues)
-- now removed as causing geometry errors in intersection code (actually it is the ST_simplify() optimised_geometry
-- causing trouble):
--
-- psql:rif40_geolevels_ew01_geometry.sql:174: ERROR:  Error performing intersection: TopologyException: found non-noded intersection between LINESTRING (-2.9938 53.3669, -2.98342 53.367) and LINESTRING (-2.98556 53.367, -2.98556 53.367) at -2.9855578257498334 53.366966593247653
--
--		sql_stmt:=sql_stmt||E'\t'||'     ST_Union(CASE WHEN ST_IsValid(geom) = FALSE THEN ST_Buffer(geom, 0.0) ELSE geom END) AS geom	/* Make valid if required, Union polygons together */'||E'\n';
--
-- Current favorite. May need to go back to the original below and use ST_Buffer(geom, 0.0) in the initial read into the
-- simplification algoriithm:
--
--		sql_stmt:=sql_stmt||E'\t'||'     ST_Union(geom) AS geom'||E'\n';
--
-- Current version. this is a more sophistication version of: ST_Union(ST_MakeValid(geom))
--
		sql_stmt:=sql_stmt||E'\t'||'     ST_Union(CASE WHEN ST_IsValid(geom) = FALSE THEN ST_MakeValid(geom) ELSE geom END) AS geom	/* Make valid if required, Union polygons together */'||E'\n';
--
		sql_stmt:=sql_stmt||E'\t'||'  FROM '||quote_ident(LOWER(c2_rec.shapefile_table))||E'\n';
		IF c2_rec.shapefile_desc_column IS NOT NULL THEN
			sql_stmt:=sql_stmt||E'\t'||' GROUP BY '||quote_ident(LOWER(c2_rec.shapefile_area_id_column))||', '||quote_ident(LOWER(c2_rec.shapefile_desc_column))||E'\n';
		ELSE
			sql_stmt:=sql_stmt||E'\t'||' GROUP BY '||quote_ident(LOWER(c2_rec.shapefile_area_id_column))||E'\n';
		END IF;
	END LOOP;
	IF i = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-10015, 'populate_rif40_geometry_tables', 'No rows found in: t_rif40_geolevels');
	END IF;
	sql_stmt:=sql_stmt||'), b /* t_rif40_geolevels */ AS ('||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'SELECT geography, geolevel_name, geolevel_id AS gid, st_simplify_tolerance'||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'  FROM t_rif40_geolevels'||E'\n';
	sql_stmt:=sql_stmt||E'\t'||' WHERE geography = '||quote_literal(c1_rec.geography)||E'\n';
	sql_stmt:=sql_stmt||'), c /* rif40_geographies */ AS ('||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'SELECT max_geojson_digits'||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'  FROM rif40_geographies'||E'\n';
	sql_stmt:=sql_stmt||E'\t'||' WHERE geography = '||quote_literal(c1_rec.geography)||E'\n';
	sql_stmt:=sql_stmt||'), d AS ('||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'SELECT a.geolevel_name, geom, area_id, name,'||E'\n';
--	sql_stmt:=sql_stmt||E'\t'||'       ST_MakeValid(ST_SimplifyPreserveTopology(geom, b.st_simplify_tolerance)) AS simplified_topology'||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'       ST_SimplifyPreserveTopology(geom, b.st_simplify_tolerance) AS simplified_topology'||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'  FROM a, b'||E'\n';
	sql_stmt:=sql_stmt||E'\t'||' WHERE a.geolevel_name = b.geolevel_name'||E'\n';
	sql_stmt:=sql_stmt||')'||E'\n';
	sql_stmt:=sql_stmt||'SELECT '||quote_literal(c1_rec.geography)||
		' geography, b.geolevel_name, area_id, NULLIF(name, ''Unknown: [''||area_id||'']'') AS name, b.gid /* RIF40_GEOLEVELS.GEOLEVEL_ID */,'||E'\n';
	sql_stmt:=sql_stmt||'        round(CAST(ST_area(geom)/1000000 AS numeric), 1) AS area,'||E'\n';
	sql_stmt:=sql_stmt||'        ST_Multi(geom) AS shapefile_geometry, '||E'\n';
--	sql_stmt:=sql_stmt||'        ST_MakeValid(ST_transform(ST_Multi(simplified_topology), 4326 /* WGS 84 */)) AS optimised_geometry,'||E'\n';
	sql_stmt:=sql_stmt||'        ST_transform(ST_Multi(simplified_topology), 4326 /* WGS 84 */) AS optimised_geometry,'||E'\n';
	sql_stmt:=sql_stmt||'        ST_AsGeoJson('||E'\n';
	sql_stmt:=sql_stmt||E'\t'||E'\t'||'ST_transform('||E'\n';
	sql_stmt:=sql_stmt||E'\t'||E'\t'||E'\t'||'simplified_topology, 4326 /* WGS 84 */),'||E'\n';
	sql_stmt:=sql_stmt||E'\t'||E'\t'||E'\t'||E'\t'||'c.max_geojson_digits, 0 /* no options */) AS optimised_geojson'||E'\n';
	sql_stmt:=sql_stmt||'  FROM b, c, d'||E'\n';
	sql_stmt:=sql_stmt||' WHERE b.geolevel_name = d.geolevel_name'||E'\n';
	sql_stmt:=sql_stmt||' ORDER BY 1, 2, 3';
--
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'populate_rif40_geometry_tables', 'SQL> %;', sql_stmt::VARCHAR);
	insert_rows:=rif40_sql_pkg.rif40_ddl(sql_stmt);
--
	sql_stmt:='UPDATE t_rif40_geolevels a'||E'\n';
	sql_stmt:=sql_stmt||'   SET avg_npoints_geom = b1.avg_npoints_geom,'||E'\n';
	sql_stmt:=sql_stmt||'       avg_npoints_opt  = b1.avg_npoints_opt,'||E'\n'; 
	sql_stmt:=sql_stmt||'       file_geojson_len = b1.file_geojson_len,'||E'\n'; 
	sql_stmt:=sql_stmt||'       leg_geom         = b1.leg_geom,'||E'\n'; 
	sql_stmt:=sql_stmt||'       leg_opt          = b1.leg_opt'||E'\n';
	sql_stmt:=sql_stmt||'  FROM ('||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'SELECT geolevel_name,'||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'       ROUND(CAST(AVG(ST_NPOINTS(SHAPEFILE_GEOMETRY)) AS numeric), 1) AS avg_npoints_geom,'||E'\n'; 
	sql_stmt:=sql_stmt||E'\t'||' 	   ROUND(CAST(AVG(ST_NPoints(optimised_geometry)) AS numeric), 1) AS avg_npoints_opt,'||E'\n'; 
	sql_stmt:=sql_stmt||E'\t'||' 	   ROUND(CAST(SUM(length(optimised_geojson)) AS numeric), 1) AS file_geojson_len,'||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'       ROUND(CAST(AVG(ST_perimeter(shapefile_geometry)/ST_NPoints(shapefile_geometry)) AS numeric), 1) AS leg_geom,'||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'       ROUND(CAST(AVG(ST_perimeter(optimised_geometry)/ST_NPoints(optimised_geometry)) AS numeric), 1) AS leg_opt'||E'\n'; 
	sql_stmt:=sql_stmt||E'\t'||' FROM t_rif40_'||quote_ident(LOWER(c1_rec.geography))||'_geometry b'||E'\n';
	sql_stmt:=sql_stmt||E'\t'||' GROUP BY geolevel_name) AS b1'||E'\n';
	sql_stmt:=sql_stmt||' WHERE a.geolevel_name = b1.geolevel_name'||E'\n';
	sql_stmt:=sql_stmt||'   AND a.geography     = '||quote_literal(c1_rec.geography);
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'populate_rif40_geometry_tables', 'SQL> %;', sql_stmt::VARCHAR);
	update_rows:=rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Check rows were inserted
--
	sql_stmt:='SELECT COUNT(*) AS total FROM '||quote_ident('t_rif40_'||LOWER(c1_rec.geography)||'_geometry');
	OPEN c3 FOR EXECUTE sql_stmt;
	FETCH c3 INTO c3_rec;
	CLOSE c3;	
	IF c3_rec.total = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-10016, 'populate_rif40_geometry_tables', 'No rows found in: geography: % % geometry table',
			c1_rec.geography::VARCHAR					/* Geography */, 
			't_rif40_'||LOWER(c1_rec.geography)||'_geometry'::VARCHAR	/* Geolevel geometry table */);
	END IF;
--
-- Add GIST indexes. GIN are for vectors only (they are better for static objects and and faster. Will not work for weighted vectors)
--
	sql_stmt:='CREATE INDEX '||quote_ident('t_rif40_'||LOWER(c1_rec.geography)||'_geo_gin1')||' ON '||quote_ident('t_rif40_'||LOWER(c1_rec.geography)||'_geometry')||' USING GIST(shapefile_geometry)';
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	sql_stmt:='CREATE INDEX '||quote_ident('t_rif40_'||LOWER(c1_rec.geography)||'_geo_gin2')||' ON '||quote_ident('t_rif40_'||LOWER(c1_rec.geography)||'_geometry')||' USING GIST(optimised_geometry)';
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Re-index, re-analyze
--
	sql_stmt:='REINDEX INDEX '||quote_ident('t_rif40_'||LOWER(c1_rec.geography)||'_geometry_pk');
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	sql_stmt:='REINDEX INDEX '||quote_ident('t_rif40_'||LOWER(c1_rec.geography)||'_geometry_uk');
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	sql_stmt:='ANALYZE VERBOSE '||quote_ident('t_rif40_'||LOWER(c1_rec.geography)||'_geometry');
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
	PERFORM rif40_log_pkg.rif40_log('INFO', 'populate_rif40_geometry_tables', 'Geography: % % geometry table populated with % rows', 
		c1_rec.geography::VARCHAR					/* Geography */, 
		't_rif40_'||LOWER(c1_rec.geography)||'_geometry'::VARCHAR	/* Geolevel geometry table */, 
		insert_rows::VARCHAR						/* Rows inserted */);
END;
]]></definition>
</function>

<function name="rif40_get_default_comparison_area"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_get_default_comparison_area()
Parameters:	Geography, geolevel_select, geolevel_selection ARRAY
Returns:	Array of area IDs of default comparison area
Description:	Get default comparison area

1. Get the default comparison area (defaultcomparea) and hierarchy table name <hierarchytable> from RIF40_GEOGRPAHIES
2. Returns DISTINCT <defaultcomparea> FROM <hierarchytable> WHERE <geolevel_select> IN (SELECT unnest(<geolevel_selection>))
   i.e. all areas at the default comparison area level covered by the users selected geolevels

Test statement:

SELECT array_agg(DISTINCT level2) AS comparision_area /* defaultcomparea */
  FROM sahsuland_geography /* hierarchytable */
 WHERE level2 /* <Gelevel select> */ IN (
	SELECT unnest(level2_array)
	  FROM (
		SELECT array_agg(level2) AS level2_array FROM sahsuland_level2) a /* Geolevel selection array */);]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="character varying" dimension="1"/>
	</return-type>
	<parameter name="l_geography" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="geolevel_select" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="geolevel_selection" in="true">
		<type name="character varying" dimension="1"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	rif40_get_default_comparison_area()
Parameters:	Geography, geolevel_select, geolevel_selection ARRAY
Returns:	Array of area IDs of default comparison area
Description:	Get default comparison area

1. Get the default comparison area (defaultcomparea) and hierarchy table name <hierarchytable> from RIF40_GEOGRPAHIES
2. Returns DISTINCT <defaultcomparea> FROM <hierarchytable> WHERE <geolevel_select> IN (SELECT unnest(<geolevel_selection>))
   i.e. all areas at the default comparison area level covered by the users selected geolevels

Test statement:

SELECT array_agg(DISTINCT level2) AS comparison_area
  FROM sahsuland_geography 
 WHERE level2 IN (
	SELECT unnest(level2_array)
	  FROM (
		SELECT array_agg(level2) AS level2_array FROM sahsuland_level2) a);

 */
DECLARE
	c1gdca CURSOR(l_geography VARCHAR) FOR
		SELECT defaultcomparea, hierarchytable
		  FROM rif40_geographies a
		 WHERE a.geography = l_geography;
	c2gdca		REFCURSOR;	
	c1gdca_rec 	RECORD;
	c2gdca_rec 	RECORD;
--
	sql_stmt 	VARCHAR;
--
	error_message 	VARCHAR;
	v_detail 	VARCHAR:='(Not supported until 9.2; type SQL statement into psql to see remote error)';
BEGIN
--
-- Get comparison geolevel - is the default set in rif40_geographies
--
	OPEN c1gdca(l_geography);
	FETCH c1gdca INTO c1gdca_rec;
	IF NOT FOUND THEN
		PERFORM rif40_log_pkg.rif40_error(-10013, 'rif40_get_default_comparison_area', 
			'Cannot find rif40_geographies geography: %',
			l_geography::VARCHAR			/* Geography */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_get_default_comparison_area', 
			'Default comparision area for geography: % is: %',
			l_geography::VARCHAR			/* Geography */,
			c1gdca_rec.defaultcomparea::VARCHAR	/* Default comparison area defined for geography */);
	END IF;
	CLOSE c1gdca;
--
	sql_stmt:='SELECT array_agg(DISTINCT '||quote_ident(LOWER(c1gdca_rec.defaultcomparea))||') AS comparision_area /* defaultcomparea */'||E'\n'||
'  FROM '||quote_ident(LOWER(c1gdca_rec.hierarchytable))||' /* hierarchytable */'||E'\n'||
' WHERE '||quote_ident(LOWER(geolevel_select))||' /* <Gelevel select> */ IN ('||E'\n'||
'	SELECT unnest($1))';
--
-- Execute SQL statement, returning comparison area
--
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_get_default_comparison_area', 'SQL> %;', sql_stmt::VARCHAR);
	OPEN c2gdca FOR EXECUTE sql_stmt USING geolevel_selection;
	FETCH c2gdca INTO c2gdca_rec;
	CLOSE c2gdca;
--
	RETURN c2gdca_rec.comparision_area;
EXCEPTION
	WHEN others THEN
-- 
-- Not supported until 9.2
--
--		IF v_version THEN
--			GET STACKED DIAGNOTICS v_detail = PG_EXCETION_DETAIL;
--		END IF;
		error_message:='rif40_get_default_comparison_area() caught: '||E'\n'||SQLERRM::VARCHAR||' in SQL (see previous trapped error)'||E'\n'||'Detail: '||v_detail::VARCHAR;
		RAISE INFO '1: %', error_message;
--
		RAISE;
END;
]]></definition>
</function>

<function name="simplify_geometry"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	simplify_geometry()
Parameters:	Geography, 
                minimum point resolution (default 1 - assumed metre, but depends on the geometry), 
                override for rif40_geolevels.st_simplify_tolerance
Returns:	Nothing
Description:	Simplify geography geometry. Carried out in three phases:

Phase III: Create the polygons table, Update spatial geolevel table]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="l_geography" in="true" default-value="1">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_min_point_resolution" in="true">
		<type name="numeric"/>
	</parameter>
	<definition><![CDATA[
DECLARE
/*
Function: 	simplify_geometry()
Parameters:	Geography, 
                minimum point resolution (default 1 - assumed metre, but depends on the geometry), 
                override for rif40_geoelvels.st_simplify_tolerance
Returns:	Nothing
Description:	Simplify geography geometry. Carried out in three phases:

Phase III: Create the polygons table, Update spatial geolevel table
 */
	c1_sg	CURSOR FOR
		SELECT * 
		  FROM t_rif40_geolevels
		 WHERE geography = l_geography;
	c1_rec RECORD;
--
	sql_stmt	VARCHAR[];
--
	stp TIMESTAMP WITH TIME ZONE;
	etp TIMESTAMP WITH TIME ZONE;
	took INTERVAL;
BEGIN
--
	stp:=clock_timestamp();
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'simplify_geometry', 'User % must be rif40 or have rif_manager role', 
			USER::VARCHAR	/* Username */);
	END IF;
--
	FOR c1_rec IN c1_sg LOOP
		PERFORM rif40_geo_pkg.simplify_geometry(c1_rec.geography, c1_rec.geolevel_name, 
			NULL /* Filter */, 
			l_min_point_resolution /* minimum point resolution (default 1 - assumed metre, but depends on the geometry) */,
			c1_rec.st_simplify_tolerance /* Default for geolevel */);
	END LOOP;
--
-- Drop temporary tables
--
	sql_stmt[1]:='DROP TABLE IF EXISTS simplification_lines';
	sql_stmt[2]:='DROP TABLE IF EXISTS simplification_points';
	sql_stmt[3]:='DROP TABLE IF EXISTS simplification_polygons';
	sql_stmt[4]:='DROP TABLE IF EXISTS simplification_lines_join_duplicates';
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
	etp:=clock_timestamp();
	took:=age(etp, stp);
	PERFORM rif40_log_pkg.rif40_log('INFO', 'simplify_geometry', 'Simplified % geography in: %', 
		l_geography::VARCHAR, 
		took::VARCHAR);
--
END;
]]></definition>
</function>

<function name="simplify_geometry"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_geo_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	simplify_geometry()
Parameters:	Geography, geolevel, 
                geolevel; filter (for testing, no default), 
                minimum point resolution (default 1 - assumed metre, but depends on the geometry), 
                override for rif40+geoelvelsl_st_simplify_tolerance
Returns:	Nothing
Description:	Simplify geography geolevel]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="l_geography" in="true" default-value="NULL::character varying">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_geolevel" in="true" default-value="1">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_filter" in="true" default-value="1">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_min_point_resolution" in="true">
		<type name="numeric"/>
	</parameter>
	<parameter name="l_st_simplify_tolerance" in="true">
		<type name="numeric"/>
	</parameter>
	<definition><![CDATA[
DECLARE
/*
 */
	sql_stmt	VARCHAR[];
--
	stp TIMESTAMP WITH TIME ZONE;
	etp TIMESTAMP WITH TIME ZONE;
	took INTERVAL;
--
	error_message 	VARCHAR;
	v_detail 	VARCHAR:='(Not supported until 9.2; type SQL statement into psql to see remote error)';
BEGIN
--
	stp:=clock_timestamp();
--
-- Must be rif40 or have rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-10001, 'simplify_geometry', 'User % must be rif40 or have rif_manager role', 
			USER::VARCHAR	/* Username */);
	END IF;
--
-- Phase I: Create the points table
--
-- Create a sequence so that points are in the original order specified by ST_DumpPoints()
-- Convert geometry to points, reduce precision to 1m
-- Test 1 - check last_pointflow = one per area (should be zero)
-- Detect and classify duplcates within co-ordinates (a side effect of the round)
--
-- O: original - first or last point in area
-- N: Not a dupicate
-- Y: A dupicate (two or more consecutive points sharing the same co-ordinate); removed later
-- L: Loop duplicate (two or more NON consecutive points sharing the same co-ordinate)
--
-- Count up number of distinct area_id using the same co-ordinate
-- Test 2 for un-detected duplicates
-- Join up adjacent edges
-- Create the points table
-- Test 3 and 4 - Checks - MUST BE 0
--	
-- a) Areas with no join sequence
-- b) Areas with mis-joined sequences
--
-- Create a list of joined_area_ids (i.e. the num_join_seq is 1)
-- Update from list of joined_area_ids (i.e. the num_join_seq is 1)
--
	PERFORM rif40_geo_pkg._simplify_geometry_phase_I(l_geography, l_geolevel, l_filter, l_min_point_resolution, l_st_simplify_tolerance);
--
-- Phase II: Create the lines table
--
	PERFORM rif40_geo_pkg._simplify_geometry_phase_II(l_geography, l_geolevel, l_filter, l_min_point_resolution, l_st_simplify_tolerance);
--
-- Phase III: Create the polygons table
--
	PERFORM rif40_geo_pkg._simplify_geometry_phase_III(l_geography, l_geolevel, l_filter, l_min_point_resolution, l_st_simplify_tolerance);
--
	etp:=clock_timestamp();
	took:=age(etp, stp);
	PERFORM rif40_log_pkg.rif40_log('INFO', 'simplify_geometry', 'Simplified % geography geolevel %: %', 
		l_geography::VARCHAR, 
		l_geolevel::VARCHAR, 
		took::VARCHAR);
--
EXCEPTION
	WHEN others THEN
-- 
-- Not supported until 9.2
--
--		IF v_version THEN
--			GET STACKED DIAGNOTICS v_detail = PG_EXCETION_DETAIL;
--		END IF;
		error_message:='simplify_geometry('||l_geography::VARCHAR||', '||l_geolevel::VARCHAR||') caught: '||E'\n'||SQLERRM::VARCHAR||' in SQL (see previous trapped error)'||E'\n'||'Detail: '||v_detail::VARCHAR;
		RAISE INFO '1: %', error_message;
--
		RAISE;
END;
]]></definition>
</function>

<function name="rif40_add_to_debug"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_log_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_add_to_debug()
Parameters:	Debug string pairs <function name><debug level>, <function name><debug level>, ...
Returns:	Nothing
Description:	Add debug string pairs to debug string.
		Debug string example 'rif40_log:DEBUG4', 'rif40_error:DEBUG4'

		Function name is the name of a valid RIF40 function owned by RIF40 with NO schema component
		Debug level is one of: 'DEBUG1', 'DEBUG2', 'DEBUG3', 'DEBUG4'
 		Checks: you will get a warning; the debug string pair will be ignored

		If the pair already exists you will get a warning
		If the function name already exists the previous pair is replaced]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="debug_text" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	rif40_add_to_debug()
Parameters:	Debug string pairs <function name><debug level>, <function name><debug level>, ...
Returns:	Nothing
Description:	Add debug string pairs to debug string.
		Debug string example 'rif40_log:DEBUG4', 'rif40_error:DEBUG4'

		Function name is the name of a valid RIF40 function owned by RIF40 with NO schema component
		Debug level is one of: 'DEBUG1', 'DEBUG2', 'DEBUG3', 'DEBUG4'
 		Checks: you will get a warning; the debug string pair will be ignored

		If the pair already exists you will get a warning
		If the function name already exists the previous pair is replaced
 */
DECLARE
	c1a2d CURSOR FOR 
		SELECT CURRENT_SETTING('rif40.send_debug_to_info') AS send_debug_to_info, 
		       CURRENT_SETTING('rif40.debug') AS debug;
	c2a2d CURSOR(l_debug_text VARCHAR) FOR 
		WITH a AS (
			SELECT rif40_log_pkg.rif40_get_debug(l_debug_text) AS debug 			/* Valid new debug */
		), b AS (
			SELECT rif40_log_pkg.rif40_get_debug(CURRENT_SETTING('rif40.debug')) AS debug 	/* Old debug */
		)
		SELECT (a.debug).function_name AS function_name,
  		       (a.debug).debug AS old_debug,
  		       (a.debug).debug AS new_debug,
		       SUBSTR((a.debug).debug::TEXT, 6)::INTEGER AS old_debug_level,
		       SUBSTR((a.debug).debug::TEXT, 6)::INTEGER AS new_debug_level
		  FROM a
		 WHERE (a.debug).function_name NOT IN (SELECT (b.debug).function_name FROM b)		/* New debug */
		UNION
		SELECT (b.debug).function_name AS function_name,
  		       (b.debug).debug AS old_debug,
  		       (b.debug).debug AS new_debug,
		       SUBSTR((b.debug).debug::TEXT, 6)::INTEGER AS old_debug_level,
		       SUBSTR((b.debug).debug::TEXT, 6)::INTEGER AS new_debug_level
		  FROM b
		 WHERE (b.debug).function_name NOT IN (SELECT (a.debug).function_name FROM a)		/* Old debug */
		UNION
		SELECT (a.debug).function_name AS function_name,
  		       (a.debug).debug AS old_debug,
  		       (b.debug).debug AS new_debug,
		       SUBSTR((a.debug).debug::TEXT, 6)::INTEGER AS old_debug_level,
		       SUBSTR((b.debug).debug::TEXT, 6)::INTEGER AS new_debug_level
		  FROM a, b
		 WHERE (a.debug).function_name = (b.debug).function_name				/* Updated debug */
		ORDER BY 1;
--
	c1a2da_rec RECORD;
	c1a2db_rec RECORD;
	c2a2d_rec RECORD;
--
	sql_stmt VARCHAR;
	i INTEGER:=0;
--
BEGIN
--
-- Check for NULL
--
	IF debug_text IS NULL THEN
		RETURN;
	END IF;
--
	OPEN c1a2d;	/* Before */
	FETCH c1a2d INTO c1a2da_rec;
	CLOSE c1a2d;
--
-- Re-process debug string
--
	sql_stmt:='SET rif40.debug = ''';
	FOR c2a2d_rec IN c2a2d(debug_text) LOOP
		i:=i+1;
		IF rif40_log_pkg.rif40_is_debug_enabled('rif40_add_to_debug', 'DEBUG4') AND c1a2da_rec.send_debug_to_info = 'on' THEN
			RAISE INFO 'rif40_add_to_debug() Function %() % to %', c2a2d_rec.function_name, c2a2d_rec.old_debug_level, c2a2d_rec.new_debug_level;
		ELSIF rif40_log_pkg.rif40_is_debug_enabled('rif40_add_to_debug', 'DEBUG4') THEN
			RAISE DEBUG 'rif40_add_to_debug() Function %() % to %', c2a2d_rec.function_name, c2a2d_rec.old_debug_level, c2a2d_rec.new_debug_level;
		END IF;
		IF i = 1 THEN
			sql_stmt:=sql_stmt||c2a2d_rec.function_name||':'||c2a2d_rec.new_debug;
		ELSE
			sql_stmt:=sql_stmt||', '||c2a2d_rec.function_name||':'||c2a2d_rec.new_debug;
		END IF;
	END LOOP;
	sql_stmt:=sql_stmt||'''';
--
	IF i > 0 THEN
		IF rif40_log_pkg.rif40_is_debug_enabled('rif40_add_to_debug', 'DEBUG4') AND c1a2da_rec.send_debug_to_info = 'on' THEN
			RAISE INFO 'SQL> %;', sql_stmt;
		ELSIF rif40_log_pkg.rif40_is_debug_enabled('rif40_add_to_debug', 'DEBUG4') THEN
			RAISE DEBUG 'SQL> %;', sql_stmt;
		END IF;
		EXECUTE sql_stmt;
	ELSE
		RAISE WARNING 'rif40_add_to_debug() all debug string pairs in "%" are invalid', debug_text;
	END IF;
--
	OPEN c1a2d;	/* After */
	FETCH c1a2d INTO c1a2db_rec;
	CLOSE c1a2d;
--
	IF rif40_log_pkg.rif40_is_debug_enabled('rif40_add_to_debug', 'DEBUG4') AND c1a2db_rec.send_debug_to_info = 'on' THEN
		RAISE INFO 'rif40_add_to_debug() SET DEBUG from: "%" to: "%"', c1a2da_rec.debug, c1a2db_rec.debug;
	ELSIF rif40_log_pkg.rif40_is_debug_enabled('rif40_add_to_debug', 'DEBUG4') THEN
		RAISE DEBUG 'rif40_add_to_debug() SET DEBUG from: "%" to: "%"', c1a2da_rec.debug, c1a2db_rec.debug;
	END IF;
END;
]]></definition>
</function>

<function name="rif40_error"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_log_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_error()
Parameters:	error code, function name, format, args ...
Returns:	Nothing
Description:	This is the error handler!

 desc rif40_error_messages
 Name                                                                     Null?    Type
 ------------------------------------------------------------------------ -------- -------------------------------------------------
 ERROR_CODE                                                               NOT NULL NUMBER(5)
 TAG                                                                      NOT NULL VARCHAR2(80)
 TABLE_NAME                                                                        VARCHAR2(30)
 CAUSE                                                                    NOT NULL VARCHAR2(4000)
 ACTION                                                                   NOT NULL VARCHAR2(512)
 MESSAGE                                                                  NOT NULL VARCHAR2(512)
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="l_error_code" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="function_name" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="format_and_args" variadic="true">
		<type name="character varying" dimension="1"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	rif40_error()
Parameters:	error code, function name, format, args ...
Returns:	Nothing
Description:	This is the error handler!

 desc rif40_error_messages
 Name                                                                     Null?    Type
 ------------------------------------------------------------------------ -------- -------------------------------------------------
 ERROR_CODE                                                               NOT NULL NUMBER(5)
 TAG                                                                      NOT NULL VARCHAR2(80)
 TABLE_NAME                                                                        VARCHAR2(30)
 CAUSE                                                                    NOT NULL VARCHAR2(4000)
 ACTION                                                                   NOT NULL VARCHAR2(512)
 MESSAGE                                                                  NOT NULL VARCHAR2(512)

 */
DECLARE
	c2err CURSOR(l_function_name VARCHAR) FOR 
		SELECT l.lanname||' function' object_type, 
			COALESCE(n.nspname, r.rolname)||'.'||p.proname object_name 					/* Functions */
		  FROM pg_language l, pg_type t, pg_roles r, pg_proc p
			LEFT OUTER JOIN pg_namespace n ON (n.oid = p.pronamespace)			
		 WHERE p.prolang    = l.oid
		   AND p.prorettype = t.oid
		   AND p.proowner   = (SELECT oid FROM pg_roles WHERE rolname = 'rif40')
		   AND p.proowner   = r.oid
		   AND p.proname    = LOWER(l_function_name);	
--
	c2err_rec RECORD;
--
	format VARCHAR;
	output VARCHAR;
	format_len INTEGER;
	chr_count INTEGER:=0;
	arg_count INTEGER:=0;
	max_args INTEGER;
	chr VARCHAR;
--
	l_function_name VARCHAR;
	l_action VARCHAR;
BEGIN
--
-- Get error message from DB
--
	l_action:=rif40_log_pkg.rif40_get_error_code_action(l_error_code, function_name);
--
-- Check format and args are not NULL
--
	IF format_and_args IS NULL THEN
		output:='<NO MESSAGE>';
	ELSE
		arg_count:=array_lower(format_and_args, 1);
		max_args:=array_upper(format_and_args, 1);
		format:=format_and_args[arg_count];
		output:='';
		format_len:=LENGTH(format);
		IF format_len = 0 THEN
			RETURN;
		END IF;
--
-- Format string
--
		LOOP
			chr_count:=chr_count+1;
			IF chr_count > format_len THEN 
				EXIT;
			END IF;
			chr:=SUBSTRING(format, chr_count, 1);
			IF chr = '%' AND SUBSTRING(format, chr_count+1, 1) = '%' THEN 		/* %% */
				output:=output||'%%';
				chr_count:=chr_count+1;
			ELSIF chr = '%' THEN							/* Arg */
				arg_count:=arg_count+1;
				IF arg_count > max_args THEN					/* run out of args */
					EXIT;
				END IF;
				output:=output||COALESCE(format_and_args[arg_count]::TEXT, '');
			ELSE
				output:=output||chr;
			END IF;
--
		END LOOP;
		IF arg_count != max_args THEN
			RAISE WARNING 'rif40_error() Message in %(): too many/too few args (got: %; expecting %) for format: %', function_name, max_args, arg_count, format;
		END IF;
	END IF;
--
-- Check function name exists
--
	OPEN c2err(function_name);
	FETCH c2err INTO c2err_rec;
	CLOSE c2err;
	IF c2err_rec.object_name IS NULL THEN
		RAISE WARNING 'rif40_error() function name %() NOT FOUND.', function_name;
		l_function_name:='<UNKNOWN>';
	ELSE
		l_function_name:=c2err_rec.object_name;
 	END IF;
--
-- RAISE error
--
	IF l_action IS NULL THEN
		RAISE EXCEPTION '%(): %', l_function_name, output;
	ELSE
		RAISE EXCEPTION '%(): %', l_function_name, output USING HINT=l_action;
	END IF;
END;
]]></definition>
</function>

<function name="rif40_get_debug"
		window-func="false"
		returns-setof="true"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="1000">
	<schema name="rif40_log_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_get_debug()
Parameters:	Debug string pairs <function name><debug level>, <function name><debug level>, ...
Returns:	1 or more RIF40_LOG_PKG.RIF40_DEBUG_RECORD records
Description:	Get set of 1 or more RIF40_LOG_PKG.RIF40_DEBUG_RECORD records]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="rif40_log_pkg.rif40_debug_record"/>
	</return-type>
	<parameter name="debug_text" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	rif40_get_debug()
Parameters:	Debug string pairs <function name><debug level>, <function name><debug level>, ...
Returns:	1 or more RIF40_LOG_PKG.RIF40_DEBUG_RECORD records
Description:	Get set of 1 or more RIF40_LOG_PKG.RIF40_DEBUG_RECORD records
 */
DECLARE
	c1rg CURSOR(l_debug VARCHAR) FOR 
		SELECT RTRIM(LTRIM(UNNEST(STRING_TO_ARRAY(l_debug, ',')))) AS debug;
	c2rg CURSOR(l_function_name VARCHAR) FOR 
		SELECT l.lanname||' function' object_type, 
			COALESCE(n.nspname, r.rolname)||'.'||p.proname object_name 					/* Functions */
		  FROM pg_language l, pg_type t, pg_roles r, pg_proc p
			LEFT OUTER JOIN pg_namespace n ON (n.oid = p.pronamespace)			
		 WHERE p.prolang    = l.oid
		   AND p.prorettype = t.oid
		   AND p.proowner   = (SELECT oid FROM pg_roles WHERE rolname = 'rif40')
		   AND p.proowner   = r.oid
		   AND p.proname    = LOWER(l_function_name);	
--
	c1rg_rec RECORD;
	c2rg_rec RECORD;
--
	rec RIF40_LOG_PKG.RIF40_DEBUG_RECORD;
	v VARCHAR[];
	l_debug VARCHAR;
	l_function_name VARCHAR;
BEGIN
--
-- Check for NULL
--
	IF debug_text IS NULL THEN
		RETURN;
	END IF;
--
	FOR c1rg_rec IN c1rg(debug_text) LOOP
		IF c1rg_rec.debug IS NOT NULL THEN
			v:=NULL;
			v:=STRING_TO_ARRAY(c1rg_rec.debug, ':');
--
-- Check function name exists
--
			l_function_name:=v[array_lower(v, 1)];
			OPEN c2rg(l_function_name);
			FETCH c2rg INTO c2rg_rec;
			CLOSE c2rg;
--
			IF array_lower(v, 1) != array_upper(v, 1)-1 THEN
				RAISE WARNING 'rif40_debug_record() expecting two elements converting v(%) to RIF40_LOG_PKG.RIF40_DEBUG_RECORD', c1rg_rec.debug;
			ELSIF c2rg_rec.object_name IS NULL THEN
				RAISE WARNING 'rif40_debug_record() function name %() NOT FOUND.', l_function_name;
			ELSE
				rec.function_name:=l_function_name;
				l_debug:=v[array_lower(v, 1)+1];
				IF l_debug NOT IN ('DEBUG1', 'DEBUG2', 'DEBUG3', 'DEBUG4') THEN
					RAISE WARNING 'rif40_debug_record() function %() invalid <debug level> % converting v(%) to RIF40_LOG_PKG.RIF40_DEBUG_RECORD', 
						c2rg_rec.object_name, l_debug, c1rg_rec.debug;
				ELSE
					rec.debug:=l_debug;
					RETURN NEXT rec;
				END IF;
			END IF;
		END IF;
	END LOOP;
--
	RETURN;
END;
]]></definition>
</function>

<function name="rif40_get_error_code_action"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_log_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_get_error_code_action()
Parameters:	error code, function name
Returns:	RIF40_ERROR_MESSAGES.ACTION or NULL
Description:	Get action for EXCEPTION HINT]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="character varying"/>
	</return-type>
	<parameter name="l_error_code" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="function_name" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	rif40_get_error_code_action()
Parameters:	error code, function name
Returns:	RIF40_ERROR_MESSAGES.ACTION or NULL
Description:	Get action for EXCEPTION HINT
 */
DECLARE
	c1err CURSOR(l_code INTEGER) FOR
		SELECT * 
		  FROM rif40_error_messages
		 WHERE l_code = rif40_error_messages.error_code;
--
	c1err_rec RECORD;
BEGIN
	OPEN c1err(l_error_code);
	FETCH c1err INTO c1err_rec;
	CLOSE c1err;
	IF c1err_rec.action IS NULL THEN
		RAISE WARNING 'rif40_get_error_code_action() function name %() NO ERROR MESSAGE FOUND IN DB FOR: %.', 
			COALESCE(function_name, '<ONKNOWN>'), l_error_code;
		RETURN NULL;
	END IF;
--
	RETURN c1err_rec.action;
EXCEPTION
	WHEN others THEN
		RAISE WARNING 'rif40_get_error_code_action() function name %() GETTING ERROR MESSAGE FOUND IN DB FOR: % RAISED %. [IGNORED]', 
			COALESCE(function_name, '<ONKNOWN>'), l_error_code, SQLERRM;
		RETURN NULL;
END;
]]></definition>
</function>

<function name="rif40_is_debug_enabled"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_log_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_is_debug_enabled()
Parameters:	Debug string pairs <function name><debug level>, <function name><debug level>, ...
Returns:	Boolean (TRUE/FALSE)
Description:
		Function name is the name of a valid RIF40 function owned by RIF40 with NO schema component
		Debug level is one of: 'DEBUG1', 'DEBUG2', 'DEBUG3', 'DEBUG4']]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="function_name" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="debug" in="true">
		<type name="rif40_log_pkg.rif40_log_debug_level"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	rif40_is_debug_enabled()
Parameters:	Debug string pairs <function name><debug level>, <function name><debug level>, ...
Returns:	Boolean (TRUE/FALSE)
Description:
		Function name is the name of a valid RIF40 function owned by RIF40 with NO schema component
		Debug level is one of: 'DEBUG1', 'DEBUG2', 'DEBUG3', 'DEBUG4'
 */
DECLARE
	c2ide CURSOR(l_function_name VARCHAR) FOR 
		SELECT l.lanname||' function' object_type, 
			COALESCE(n.nspname, r.rolname)||'.'||p.proname object_name 					/* Functions */
		  FROM pg_language l, pg_type t, pg_roles r, pg_proc p
			LEFT OUTER JOIN pg_namespace n ON (n.oid = p.pronamespace)			
		 WHERE p.prolang    = l.oid
		   AND p.prorettype = t.oid
		   AND p.proowner   = (SELECT oid FROM pg_roles WHERE rolname = 'rif40')
		   AND p.proowner   = r.oid
		   AND p.proname    = LOWER(l_function_name);	
	c3ide CURSOR(l_function_name VARCHAR) FOR 
		WITH a AS (
			SELECT rif40_log_pkg.rif40_get_debug(CURRENT_SETTING('rif40.debug')) AS debug 	/* Current debug */
		)
		SELECT (a.debug).function_name AS function_name,
  		       (a.debug).debug AS current_debug,
		       SUBSTR((a.debug).debug::TEXT, 6)::INTEGER AS current_debug_level
		  FROM a
		 WHERE (a.debug).function_name = l_function_name					/* Remove function */
		ORDER BY 1;
--
	c2ide_rec RECORD;
	c3ide_rec RECORD;
--
	debug_level INTEGER;
	ret BOOLEAN:=FALSE;
BEGIN
--
-- Check for NULL
--
	IF function_name IS NULL OR debug IS NULL THEN
		RETURN ret;
	END IF;
--
-- Check function name exists
--
	OPEN c2ide(function_name);
	FETCH c2ide INTO c2ide_rec;
	CLOSE c2ide;
	IF c2ide_rec.object_name IS NULL THEN
		RAISE WARNING 'rif40_is_debug_enabled() function name %() NOT FOUND.', function_name;
--
-- Check debug level
--
	ELSIF debug NOT IN ('DEBUG1', 'DEBUG2', 'DEBUG3', 'DEBUG4') THEN
		RAISE WARNING 'rif40_is_debug_enabled() function %() invalid <debug level> % to RIF40_LOG_PKG.RIF40_DEBUG_RECORD', 
		c2ide_rec.object_name, debug;
	ELSE
		debug_level:=SUBSTR(debug::TEXT, 6)::INTEGER;
		OPEN c3ide(function_name);
		FETCH c3ide INTO c3ide_rec;
		CLOSE c3ide;
		IF debug_level <= c3ide_rec.current_debug_level THEN
			ret:=TRUE;
		END IF;
	END IF;
--
-- Do not call rif40_is_debug_enabled() or you will recurse in an undivine manner
--
--	RAISE INFO 'rif40_is_debug_enabled() function %() debug_level (%); c3ide_rec.current_debug_level (%) - %',
--		function_name, debug_level, c3ide_rec.current_debug_level, ret;
--
	RETURN ret;
END;
]]></definition>
</function>

<function name="rif40_log"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_log_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_log()
Parameters:	Debug level, function name, format, args ...
Returns:	Nothing
Description:	Log to INFO/DEBUG/WARNING. This is not the error handler!

		Debug level is one of: 'WARNING', 'INFO', 'DEBUG1', 'DEBUG2', 'DEBUG3', 'DEBUG4'
		Function name is the name of a valid RIF40 function owned by RIF40 with NO schema component (or you will get a warning)
		Foramt and args is a variadic VARCHAR array; minimum size 1 in the same format as RAISE, ie. % is the replacement character, %% escapes %. 
		Printf style %s will cause strange plurals (i.e. the s is ignored)
		args must equal format specifiers (%) (or you will get a warning)

		Log messages do not have to exist in RIF40 error messages

		This function will eventually call a further function to do an autonomous INSERT into rif40_log_messages using dblink]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="debug_level" in="true">
		<type name="rif40_log_pkg.rif40_log_debug_level"/>
	</parameter>
	<parameter name="function_name" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="format_and_args" variadic="true">
		<type name="character varying" dimension="1"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	rif40_log()
Parameters:	Debug level, function name, format, args ...
Returns:	Nothing
Description:	Log to INFO/DEBUG/WARNING. This is not the error handler!

		Debug level is one of: 'WARNING', 'INFO', 'DEBUG1', 'DEBUG2', 'DEBUG3', 'DEBUG4'
		Function name is the name of a valid RIF40 function owned by RIF40 with NO schema component (or you will get a warning)
		Foramt and args is a variadic VARCHAR array; minimum size 1 in the same format as RAISE, ie. % is the replacement character, %% escapes %. 
		Printf style %s will cause strange plurals (i.e. the s is ignored)
		args must equal format specifiers (%) (or you will get a warning)

		Log messages do not have to exist in RIF40 error messages

		This function will eventually call a further function to do an autonomous INSERT into rif40_log_messages using dblink
 */
DECLARE
	c1log CURSOR FOR 
		SELECT CURRENT_SETTING('rif40.send_debug_to_info') AS send_debug_to_info, 
		       CURRENT_SETTING('rif40.debug') AS debug;
	c2log CURSOR(l_function_name VARCHAR) FOR 
		SELECT l.lanname||' function' object_type, 
			COALESCE(n.nspname, r.rolname)||'.'||p.proname object_name 					/* Functions */
		  FROM pg_language l, pg_type t, pg_roles r, pg_proc p
			LEFT OUTER JOIN pg_namespace n ON (n.oid = p.pronamespace)			
		 WHERE p.prolang    = l.oid
		   AND p.prorettype = t.oid
		   AND p.proowner   = (SELECT oid FROM pg_roles WHERE rolname = 'rif40')
		   AND p.proowner   = r.oid
		   AND p.proname    = LOWER(l_function_name);	
--
	c1log_rec RECORD;
	c2log_rec RECORD;
--
	format VARCHAR;
	output VARCHAR;
	format_len INTEGER;
	chr_count INTEGER:=0;
	arg_count INTEGER:=0;
	max_args INTEGER;
	chr VARCHAR;
BEGIN
--
-- Check format and args are not NULL
--
	IF format_and_args IS NULL THEN
		RETURN;
	END IF;
	arg_count:=array_lower(format_and_args, 1);
	max_args:=array_upper(format_and_args, 1);
	format:=format_and_args[arg_count];
	output:='';
	format_len:=LENGTH(format);
	IF format_len = 0 THEN
		RETURN;
	END IF;
--
-- Format string
--
	LOOP
		chr_count:=chr_count+1;
		IF chr_count > format_len THEN 
			EXIT;
		END IF;
		chr:=SUBSTRING(format, chr_count, 1);
		IF chr = '%' AND SUBSTRING(format, chr_count+1, 1) = '%' THEN 		/* %% */
			output:=output||'%%';
			chr_count:=chr_count+1;
		ELSIF chr = '%' THEN							/* Arg */
			arg_count:=arg_count+1;
			IF arg_count > max_args THEN					/* run out of args */
				EXIT;
			END IF;
			output:=output||COALESCE(format_and_args[arg_count]::TEXT, '');
		ELSE
			output:=output||chr;
		END IF;
--
	END LOOP;
	IF arg_count != max_args THEN
		RAISE WARNING 'rif40_log() Message in %(): too many/too few args (got: %; expecting %) for format: %', function_name, max_args, arg_count, format;
	END IF;
--
-- Check function name exists
--
	OPEN c2log(function_name);
	FETCH c2log INTO c2log_rec;
	CLOSE c2log;
	IF c2log_rec.object_name IS NULL THEN
		RAISE WARNING 'rif40_log() function name %() NOT FOUND.', function_name;
 	END IF;
--
-- Get logging parameters
--
	OPEN c1log;
	FETCH c1log INTO c1log_rec;
	CLOSE c1log;
--
	IF debug_level = 'WARNING' THEN
		RAISE WARNING '%(): %', function_name, output;
	ELSIF debug_level = 'INFO' THEN
		RAISE INFO '%(): %', function_name, output;
	ELSIF c1log_rec.send_debug_to_info = 'on' AND rif40_log_pkg.rif40_is_debug_enabled(function_name, debug_level) THEN
		RAISE INFO '[%] %(): %', debug_level, function_name, output;
	ELSIF rif40_log_pkg.rif40_is_debug_enabled(function_name, debug_level) THEN
		RAISE DEBUG '%(): %', function_name, output;
	END IF;
--
END;
]]></definition>
</function>

<function name="rif40_log_setup"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_log_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_log_setup()
Parameters:	None
Returns:	Nothing
Description:	Print log setup]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<definition><![CDATA[
/*

Function: 	rif40_log_setup()
Parameters:	None
Returns:	Nothing
Description:	Print log setup
 */
DECLARE
	c1lgs CURSOR FOR 
		SELECT CURRENT_SETTING('rif40.send_debug_to_info') AS send_debug_to_info, 
		       CURRENT_SETTING('rif40.debug') AS debug;
--
	c1lgs_rec RECORD;
BEGIN
	OPEN c1lgs;
	FETCH c1lgs INTO c1lgs_rec;
	CLOSE c1lgs;
--
	RAISE INFO 'rif40_log_setup() send DEBUG to INFO: %; debug function list: [%]', c1lgs_rec.send_debug_to_info, c1lgs_rec.debug;
END;
]]></definition>
</function>

<function name="rif40_remove_from_debug"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_log_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_remove_from_debug()
Parameters:	function name
Returns:	Nothing
Description:	Remove function name from debug string. 
		Debug string example 'rif40_log:DEBUG4', 'rif40_error:DEBUG4'

		Function name is the name of a valid RIF40 function owned by RIF40 with NO schema component]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="function_name" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	rif40_remove_from_debug()
Parameters:	function name
Returns:	Nothing
Description:	Remove function name from debug string. 
		Debug string example 'rif40_log:DEBUG4', 'rif40_error:DEBUG4'

		Function name is the name of a valid RIF40 function owned by RIF40 with NO schema component

 */
DECLARE
	c1r4d CURSOR FOR 
		SELECT CURRENT_SETTING('rif40.send_debug_to_info') AS send_debug_to_info, 
		       CURRENT_SETTING('rif40.debug') AS debug;
	c2r4d CURSOR(l_function_name VARCHAR) FOR 
		WITH a AS (
			SELECT rif40_log_pkg.rif40_get_debug(CURRENT_SETTING('rif40.debug')) AS debug 	/* Current debug */
		)
		SELECT (a.debug).function_name AS function_name,
  		       (a.debug).debug AS old_debug,
  		       (a.debug).debug AS new_debug,
		       SUBSTR((a.debug).debug::TEXT, 6)::INTEGER AS old_debug_level,
		       SUBSTR((a.debug).debug::TEXT, 6)::INTEGER AS new_debug_level
		  FROM a
		 WHERE (a.debug).function_name != l_function_name					/* Remove function */
		ORDER BY 1;
	c3r4d CURSOR(l_function_name VARCHAR) FOR 
		SELECT l.lanname||' function' object_type, 
			COALESCE(n.nspname, r.rolname)||'.'||p.proname object_name 					/* Functions */
		  FROM pg_language l, pg_type t, pg_roles r, pg_proc p
			LEFT OUTER JOIN pg_namespace n ON (n.oid = p.pronamespace)			
		 WHERE p.prolang    = l.oid
		   AND p.prorettype = t.oid
		   AND p.proowner   = (SELECT oid FROM pg_roles WHERE rolname = 'rif40')
		   AND p.proowner   = r.oid
		   AND p.proname    = LOWER(l_function_name);	
--
	c1r4da_rec RECORD;
	c1r4db_rec RECORD;
	c2r4d_rec RECORD;
	c3r4d_rec RECORD;
--
	sql_stmt VARCHAR;
	i INTEGER:=0;
BEGIN
--
-- Check for NULL
--
	IF function_name IS NULL THEN
		RETURN;
	END IF;
--
-- Validate function name
--
	OPEN c3r4d(function_name);	
	FETCH c3r4d INTO c3r4d_rec;
	CLOSE c3r4d;
	IF c3r4d_rec.object_name IS NULL THEN
		RAISE WARNING 'rif40_remove_from_debug() function name %() NOT FOUND.', function_name;
		RETURN;
	END IF;
--
	OPEN c1r4d;	/* Before */
	FETCH c1r4d INTO c1r4da_rec;
	CLOSE c1r4d;
--
-- Re-process debug string
--
	sql_stmt:='SET rif40.debug = ''';
	FOR c2r4d_rec IN c2r4d(function_name) LOOP
		i:=i+1;
		IF rif40_log_pkg.rif40_is_debug_enabled('rif40_remove_from_debug', 'DEBUG4') AND c1r4da_rec.send_debug_to_info = 'on' THEN
			RAISE INFO 'rif40_remove_from_debug() Function %() % to %', c2r4d_rec.function_name, c2r4d_rec.old_debug_level, c2r4d_rec.new_debug_level;
		ELSIF rif40_log_pkg.rif40_is_debug_enabled('rif40_remove_from_debug', 'DEBUG4') THEN
			RAISE DEBUG 'rif40_remove_from_debug() Function %() % to %', c2r4d_rec.function_name, c2r4d_rec.old_debug_level, c2r4d_rec.new_debug_level;
		END IF;
		IF i = 1 THEN
			sql_stmt:=sql_stmt||c2r4d_rec.function_name||':'||c2r4d_rec.new_debug;
		ELSE
			sql_stmt:=sql_stmt||', '||c2r4d_rec.function_name||':'||c2r4d_rec.new_debug;
		END IF;
	END LOOP;
	sql_stmt:=sql_stmt||'''';
--
	IF i > 0 THEN
		IF rif40_log_pkg.rif40_is_debug_enabled('rif40_remove_from_debug', 'DEBUG4') AND c1r4da_rec.send_debug_to_info = 'on' THEN
			RAISE INFO 'SQL> %;', sql_stmt;
		ELSIF rif40_log_pkg.rif40_is_debug_enabled('rif40_remove_from_debug', 'DEBUG4') THEN
			RAISE DEBUG 'SQL> %;', sql_stmt;
		END IF;
		EXECUTE sql_stmt;
	END IF;
--
	OPEN c1r4d;	/* After */
	FETCH c1r4d INTO c1r4db_rec;
	CLOSE c1r4d;
--
	IF rif40_log_pkg.rif40_is_debug_enabled('rif40_remove_from_debug', 'DEBUG4') AND c1r4db_rec.send_debug_to_info = 'on' THEN
		RAISE INFO 'rif40_remove_from_debug() SET DEBUG from: "%" to: "%"', c1r4da_rec.debug, c1r4db_rec.debug;
	ELSIF rif40_log_pkg.rif40_is_debug_enabled('rif40_remove_from_debug', 'DEBUG4') THEN
		RAISE DEBUG 'rif40_remove_from_debug() SET DEBUG from: "%" to: "%"', c1r4da_rec.debug, c1r4db_rec.debug;
	END IF;
END;
]]></definition>
</function>

<function name="rif40_send_debug_to_info"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_log_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_send_debug_to_info()
Parameters:	Enable (BOOLEAN)
Returns:	Nothing
Description:	Set/unset rif40.send_debug_to_info]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="enable" in="true">
		<type name="boolean"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	rif40_send_debug_to_info()
Parameters:	Enable (BOOLEAN)
Returns:	Nothing
Description:	Set/unset rif40.send_debug_to_info
 */
DECLARE
	c1d2i CURSOR FOR 
		SELECT CURRENT_SETTING('rif40.send_debug_to_info') AS send_debug_to_info, 
		       CURRENT_SETTING('rif40.debug') AS debug;
--
	c1d2i_rec RECORD;
--
	sql_stmt VARCHAR;
BEGIN
	OPEN c1d2i;
	FETCH c1d2i INTO c1d2i_rec;
	CLOSE c1d2i;
--
	IF enable THEN
		sql_stmt:='SET rif40.send_debug_to_info = ''on''';
	ELSE
		sql_stmt:='SET rif40.send_debug_to_info = ''off''';
	END IF;
	IF rif40_log_pkg.rif40_is_debug_enabled('rif40_send_debug_to_info', 'DEBUG4') AND (enable OR c1d2i_rec.send_debug_to_info = 'on') THEN
		RAISE INFO 'SQL> %;', sql_stmt;
	ELSIF rif40_log_pkg.rif40_is_debug_enabled('rif40_send_debug_to_info', 'DEBUG4') THEN
		RAISE DEBUG 'SQL> %;', sql_stmt;
	END IF;
	EXECUTE sql_stmt;
--	
	OPEN c1d2i;
	FETCH c1d2i INTO c1d2i_rec;
	CLOSE c1d2i;
--
	RAISE INFO 'rif40_send_debug_to_info(%) SET send DEBUG to INFO: %', enable, c1d2i_rec.send_debug_to_info;
END;
]]></definition>
</function>

<function name="cleanup_orphaned_extract_and_map_tables"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY DEFINER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sm_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function:	cleanup_orphaned_extract_and_map_tables()
Parameter:	Truncate tables (default FALSE)
Returns:	Nothing
Description:	Cleanup and map and extract tables not referenced by a study (runs as rif40)
		Do not drop table if it contains any data unless truncate is true
		Orphans are defined as tables in rif_studies schema no longer referenced by studies

Note:		DO NOT PUT TABLES INTO THE rif_studies SCHEMA MANUALLY - they will be deleted if empty]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="truncate" in="true" default-value="false">
		<type name="boolean"/>
	</parameter>
	<definition><![CDATA[
DECLARE
/*
Function:	cleanup_orphaned_extract_and_map_tables()
Parameter:	Truncate tables (default FALSE)
Returns:	Nothing
Description:	Cleanup and map and extract tables not referenced by a study (runs as rif40)
		Do not drop table if it contains any data unless truncate is true
		Orphans are defined as tables in rif_studies schema no longer referenced by studies

Note:		DO NOT PUT TABLES INTO THE rif_studies SCHEMA MANUALLY - they will be deleted if empty
 */
	c1_clorpf CURSOR FOR
		SELECT table_name /* tables in rif_studies schema no longer referenced by studies */
		  FROM information_schema.tables
		 WHERE table_schema = 'rif_studies'
		   AND table_type   = 'BASE TABLE'
		EXCEPT
		SELECT extract_table
		  FROM t_rif40_studies
		EXCEPT
		SELECT map_table
		  FROM t_rif40_studies
		 ORDER BY 1;
	c2_clorpf REFCURSOR;
	c1_rec RECORD;
	c2_rec RECORD;
--
	sql_stmt	VARCHAR;
	t_ddl		INTEGER:=0;
	ddl_stmts	VARCHAR[];
BEGIN
	FOR c1_rec IN c1_clorpf LOOP
		sql_stmt:='SELECT COUNT(study_id) AS total'||E'\n'||
			'  FROM ('||E'\n'||
			'SELECT study_id'||E'\n'||
			'  FROM rif_studies.'||c1_rec.table_name||E'\n'||
			' LIMIT 1) a';
		OPEN c2_clorpf FOR EXECUTE sql_stmt;
		FETCH c2_clorpf INTO c2_rec;
		IF NOT FOUND THEN
			CLOSE c2_clorpf;
			PERFORM rif40_log_pkg.rif40_error(-90661, 'cleanup_orphaned_extract_and_map_tables', 
				'[90661] Extract/map table % not found',
				c1_rec.table_name::VARCHAR);
		END IF;
		CLOSE c2_clorpf;
--
		IF c2_rec.total = 0 THEN
			PERFORM rif40_log_pkg.rif40_log('INFO', 'cleanup_orphaned_extract_and_map_tables', 
				'[90662] Extract/map table % does not contain data; will be cleaned up',
				c1_rec.table_name::VARCHAR);
			sql_stmt:='DROP TABLE rif_studies.'||c1_rec.table_name;
			t_ddl:=t_ddl+1;	
			ddl_stmts[t_ddl]:=sql_stmt;
		ELSIF truncate THEN
			PERFORM rif40_log_pkg.rif40_log('INFO', 'cleanup_orphaned_extract_and_map_tables', 
				'[90663] Extract/map table % contains data; truncate is TRUE; will be cleaned up',
				c1_rec.table_name::VARCHAR);
			sql_stmt:='TRUNCATE TABLE rif_studies.'||c1_rec.table_name;
			t_ddl:=t_ddl+1;	
			ddl_stmts[t_ddl]:=sql_stmt;
			sql_stmt:='DROP TABLE rif_studies.'||c1_rec.table_name;
			t_ddl:=t_ddl+1;	
			ddl_stmts[t_ddl]:=sql_stmt;
		ELSE
			PERFORM rif40_log_pkg.rif40_log('INFO', 'cleanup_orphaned_extract_and_map_tables', 
				'[90664] Extract/map table % contains data; will not be cleaned up',
				c1_rec.table_name::VARCHAR);
		END IF;
	END LOOP;
--
-- Now drop the tables
--
	IF t_ddl > 0 THEN
		PERFORM rif40_sql_pkg.rif40_ddl(ddl_stmts);
		PERFORM rif40_log_pkg.rif40_log('INFO', 'cleanup_orphaned_extract_and_map_tables', 
			'[90665] % orphaned extract/map table(s) cleaned up',
			t_ddl::VARCHAR);
	END IF;
END;
]]></definition>
</function>

<function name="rif40_clone_study"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sm_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function:	rif40_clone_study()
Parameter:	Study ID
Returns:	New study ID
Description:	Clone study [testing purposes only] from tables:

RIF40_INV_CONDITIONS 
RIF40_INV_COVARIATES 
RIF40_INVESTIGATIONS 
RIF40_STUDY_AREAS 
RIF40_COMPARISON_AREAS 
RIF40_STUDY_SHARES
RIF40_STUDIES 

Does not clone:

RIF40_STUDY_SQL
RIF40_STUDY_SQL_LOG
RIF40_RESULTS
RIF40_CONTEXTUAL_STATS
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="study_id" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
/*
Function:	rif40_clone_study()
Parameter:	Study ID
Returns:	New study ID
Description:	Clone study [testing purposes only] from tables:

RIF40_INV_CONDITIONS 
RIF40_INV_COVARIATES 
RIF40_INVESTIGATIONS 
RIF40_STUDY_AREAS 
RIF40_COMPARISON_AREAS 
RIF40_STUDY_SHARES
RIF40_STUDIES 

Does not clone:

RIF40_STUDY_SQL
RIF40_STUDY_SQL_LOG
RIF40_RESULTS
RIF40_CONTEXTUAL_STATS

 */
	sql_stmt	VARCHAR[];
	rows		INTEGER;
BEGIN
	sql_stmt[7]:='INSERT INTO rif40_inv_conditions(condition) SELECT condition FROM rif40_inv_conditions WHERE study_id = '||study_id::VARCHAR;
	sql_stmt[6]:='INSERT INTO rif40_inv_covariates(geography, covariate_name, study_geolevel_name, min, max)
		 SELECT geography, covariate_name, study_geolevel_name, min, max FROM rif40_inv_covariates WHERE study_id = '||study_id::VARCHAR;
	sql_stmt[5]:='INSERT INTO rif40_investigations(geography, inv_name, inv_description, genders, numer_tab, 
			year_start, year_stop, max_age_group, min_age_group) 
			SELECT geography, inv_name, inv_description, genders, numer_tab, 
			year_start, year_stop, max_age_group, min_age_group FROM rif40_investigations WHERE study_id = '||study_id::VARCHAR;
	sql_stmt[4]:='INSERT INTO rif40_study_areas(area_id, band_id) SELECT area_id, band_id FROM rif40_study_areas WHERE study_id = '||study_id::VARCHAR;
	sql_stmt[3]:='INSERT INTO rif40_comparison_areas(area_id) SELECT area_id FROM rif40_comparison_areas WHERE study_id = '||study_id::VARCHAR;
	sql_stmt[2]:='INSERT INTO rif40_study_shares(grantee_username) SELECT grantee_username FROM rif40_study_shares WHERE study_id = '||study_id::VARCHAR;
	sql_stmt[1]:='INSERT INTO rif40_studies(geography, project, study_name, study_type,
 		comparison_geolevel_name, study_geolevel_name, denom_tab,            
 		year_start, year_stop, max_age_group, min_age_group, 
 		suppression_value, extract_permitted, transfer_permitted) SELECT geography, project, study_name, study_type,
 		comparison_geolevel_name, study_geolevel_name, denom_tab,            
 		year_start, year_stop, max_age_group, min_age_group, 
 		suppression_value, extract_permitted, transfer_permitted FROM rif40_studies WHERE study_id = '||study_id::VARCHAR;
--
	rows:=rif40_sql_pkg.rif40_ddl(sql_stmt);

	PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_clone_study', 
		'[90930] Cloned study: %; % rows inserted',
		 study_id::VARCHAR		/* Study ID */,
		 rows::VARCHAR 			/* Rows inserted */);
--
	RETURN currval('rif40_study_id_seq'::regclass);
END;
]]></definition>
</function>

<function name="rif40_compute_results"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sm_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[A]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="study_id" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
/*
Function:	rif40_compute_results()
Parameter:	Study ID
Returns:	Success or failure [BOOLEAN]
		Note this is to allow SQL executed by study extraction/results created to be logged (Postgres does not allow autonomous transactions)
		Verification and error checking raises EXCEPTIONS in the usual way; and will cause the SQL log to be lost
Description:	Compute results from extract table. Create map table

INSERT INTO rif40_results (study_id, inv_id, band_id, genders, direct_standardisation, adjusted, observed)
WITH a AS (
	SELECT study_id, band_id, sex,
	       SUM(COALESCE(inv_1, 0)) AS inv_1_observed
	  FROM s217_extract
	 WHERE study_or_comparison = 'S'
	 GROUP BY study_id, band_id, sex
)
SELECT study_id, 217 AS inv_id, band_id, 1 AS genders, 0 AS direct_standardisation, 0 AS adjusted, inv_1_observed AS observed
  FROM a
 WHERE sex = 1
UNION
SELECT study_id, 217 AS inv_id, band_id, 2 AS genders, 0 AS direct_standardisation, 0 AS adjusted, inv_1_observed AS observed
  FROM a
 WHERE sex = 2
UNION
SELECT study_id, 217 AS inv_id, band_id, 3 AS genders, 0 AS direct_standardisation, 0 AS adjusted, SUM(COALESCE(inv_1_observed, 0)) AS observed
  FROM a
 GROUP BY study_id, band_id
 ORDER BY 1, 2, 3, 4, 5, 6;

 */
	c1comp CURSOR(l_study_id INTEGER) FOR
		SELECT * 
		  FROM rif40_studies a
		 WHERE a.study_id = l_study_id;
	c1acomp CURSOR(l_study_id INTEGER) FOR
		SELECT * 
		  FROM rif40_studies a
		 WHERE a.study_id = l_study_id;
	c2comp CURSOR(l_study_id INTEGER) FOR
		SELECT * 
		  FROM rif40_investigations a
		 WHERE a.study_id = l_study_id
		 ORDER BY inv_id;
	c3comp CURSOR(l_study_id INTEGER) FOR
		SELECT *
		  FROM rif40_study_shares a
		 WHERE l_study_id = a.study_id;
	c4comp CURSOR FOR
		SELECT col_description(a.oid, c.ordinal_position) AS description, c.column_name
		  FROM information_schema.columns c, pg_class a
			LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
		 WHERE a.relowner IN (SELECT oid FROM pg_roles WHERE rolname = 'rif40')
		   AND a.relname = 't_rif40_results'
		   AND a.relname = c.table_name
		 ORDER BY 1;
--
	c1_rec RECORD;
	c1a_rec RECORD;
	c2_rec RECORD;
	c3_rec RECORD;
	c4_rec RECORD;
--
	sql_stmt	VARCHAR;
	ddl_stmts	VARCHAR[];
	i		INTEGER:=0;
	t_ddl		INTEGER:=1;
	inv_array	INTEGER[];
	inv		INTEGER;
BEGIN
	OPEN c1comp(study_id);
	FETCH c1comp INTO c1_rec;
	OPEN c1acomp(study_id);
	FETCH c1acomp INTO c1a_rec;
	IF NOT FOUND THEN
		CLOSE c1comp;
		CLOSE c1acomp;
		PERFORM rif40_log_pkg.rif40_error(-90641, 'rif40_compute_results', 
			'Study ID % not found',
			study_id::VARCHAR		/* Study ID */);
	END IF;
	CLOSE c1comp;
	CLOSE c1acomp;
--
-- Calculate observed
--
-- [No genders support]
--
	sql_stmt:='INSERT INTO rif40_results (study_id, inv_id, band_id, genders, direct_standardisation, adjusted, observed)'||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'WITH a AS ('||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'SELECT study_id, band_id, sex,';
	FOR c2_rec IN c2comp(study_id) LOOP
		i:=i+1;
		inv_array[i]:=c2_rec.inv_id;
		IF i = 1 THEN
		       	sql_stmt:=sql_stmt||E'\n'||E'\t'||'       SUM(COALESCE(inv_'||i::VARCHAR||', 0)) AS inv_'||i::VARCHAR||'_observed'||
				E'\t'||'/* '||c2_rec.inv_id||' -  '||c2_rec.numer_tab||' - '||c2_rec.inv_description||' */';
		ELSE
		       	sql_stmt:=sql_stmt||','||E'\n'||E'\t'||'       SUM(COALESCE(inv_'||i::VARCHAR||', 0)) AS inv_'||i::VARCHAR||'_observed'||
				E'\t'||'/* '||c2_rec.inv_id||' -  '||c2_rec.numer_tab||' - '||c2_rec.inv_description||' */';
		END IF;
	END LOOP;
	sql_stmt:=sql_stmt||E'\t'||'	  FROM '||LOWER(c1_rec.extract_table)||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'	 WHERE study_or_comparison = ''S'''||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'	 GROUP BY study_id, band_id, sex'||E'\n';
	sql_stmt:=sql_stmt||')'||E'\n';
	FOREACH inv IN ARRAY inv_array LOOP
		IF i > 1 THEN
			sql_stmt:=sql_stmt||'UNION'||E'\n';
		END IF;
		sql_stmt:=sql_stmt||'SELECT study_id, '||inv::VARCHAR||' AS inv_id, band_id, 1 AS genders, 0 /* Indirect */ AS direct_standardisation, 0 /* Unadjusted */ AS adjusted, inv_'||
			i::VARCHAR||'_observed AS observed'||E'\n';
		sql_stmt:=sql_stmt||'  FROM a'||E'\n';
		sql_stmt:=sql_stmt||' WHERE sex = 1'||E'\n';
		sql_stmt:=sql_stmt||'UNION'||E'\n';
		sql_stmt:=sql_stmt||'SELECT study_id, '||inv::VARCHAR||' AS inv_id, band_id, 2 AS genders, 0 /* Indirect */ AS direct_standardisation, 0 /* Unadjusted */ AS adjusted, inv_'||
			i::VARCHAR||'_observed AS observed'||E'\n';
		sql_stmt:=sql_stmt||'  FROM a'||E'\n';
		sql_stmt:=sql_stmt||' WHERE sex = 2'||E'\n';
		sql_stmt:=sql_stmt||'UNION'||E'\n';
		sql_stmt:=sql_stmt||'SELECT study_id, '||inv::VARCHAR||
			' AS inv_id, band_id, 3 /* both */ AS genders, 0 /* Indirect */ AS direct_standardisation, 0 /* Unadjusted */ AS adjusted, SUM(COALESCE(inv_'||
			i::VARCHAR||'_observed, 0)) AS observed'||E'\n';
		sql_stmt:=sql_stmt||'  FROM a'||E'\n';
		sql_stmt:=sql_stmt||' GROUP BY study_id, band_id'||E'\n';
	END LOOP;
	sql_stmt:=sql_stmt||' ORDER BY 1, 2, 3, 4, 5, 6';
--
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_compute_results', 	
		'SQL> %;',
		sql_stmt::VARCHAR);
	IF rif40_sm_pkg.rif40_execute_insert_statement(study_id, sql_stmt, 'rif40_results observed INSERT'::VARCHAR) = FALSE THEN 
		RETURN FALSE;
	END IF;
--
-- Create map table [DOES NOT CREATE ANY ROWS]
--
-- [CONTAINS NO GEOMETRY]
--
	ddl_stmts[t_ddl]:='CREATE TABLE rif_studies.'||LOWER(c1_rec.map_table)||' AS SELECT * FROM rif40_results WHERE study_id = '||
		study_id::VARCHAR||' /* Current study ID */ LIMIT 1'::VARCHAR; 
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_compute_results', 	
		'SQL> %;',
		ddl_stmts[t_ddl]::VARCHAR);
--
-- Truncate it anyway to make sure
--
	t_ddl:=t_ddl+1;	
	ddl_stmts[t_ddl]:='TRUNCATE TABLE rif_studies.'||LOWER(c1_rec.map_table);
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_compute_results', 	
		'SQL> %;',
		ddl_stmts[t_ddl]::VARCHAR);
--
-- Grant to study owner and all grantees in rif40_study_shares if extract_permitted=1 
--
	IF c1_rec.extract_permitted = 1 THEN
		sql_stmt:='GRANT SELECT,INSERT,TRUNCATE ON rif_studies.'||LOWER(c1_rec.map_table)||' TO '||USER;
		t_ddl:=t_ddl+1;	
		ddl_stmts[t_ddl]:=sql_stmt;
		FOR c3_rec IN c3comp(study_id) LOOP
			sql_stmt:='GRANT SELECT,INSERT ON rif_studies.'||LOWER(c1_rec.map_table)||' TO '||c3_rec.grantee_username;
			t_ddl:=t_ddl+1;	
			ddl_stmts[t_ddl]:=sql_stmt;
		END LOOP;
	END IF;
--
-- Comment
--
	sql_stmt:='COMMENT ON TABLE rif_studies.'||LOWER(c1_rec.map_table)||' IS ''Study :'||study_id::VARCHAR||' extract table''';
	t_ddl:=t_ddl+1;	
	ddl_stmts[t_ddl]:=sql_stmt;
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_compute_results', 	
		'SQL> %;',
		ddl_stmts[t_ddl]::VARCHAR);
	FOR c4_rec IN c4comp LOOP
		sql_stmt:='COMMENT ON COLUMN rif_studies.'||LOWER(c1_rec.map_table)||'.'||c4_rec.column_name||
			' IS '''||c4_rec.description||'''';
		t_ddl:=t_ddl+1;	
		ddl_stmts[t_ddl]:=sql_stmt;
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_compute_results', 	
			'SQL> %;',
			ddl_stmts[t_ddl]::VARCHAR);
	END LOOP;

--
-- Execute DDL code as rif40
--
	IF rif40_sm_pkg.rif40_study_ddl_definer(c1_rec.study_id, c1_rec.username, c1a_rec.audsid, ddl_stmts) = FALSE THEN
		RETURN FALSE;
	END IF;
--
-- Now do real insert
--
	sql_stmt:='INSERT INTO rif_studies.'||LOWER(c1_rec.map_table)||' SELECT * FROM rif40_results WHERE study_id = '||
		study_id::VARCHAR||' /* Current study ID */ ORDER BY 1, 2, 3, 4, 5, 6'::VARCHAR; 
	IF rif40_sm_pkg.rif40_execute_insert_statement(study_id, sql_stmt, 'Map table observed INSERT'::VARCHAR) = FALSE THEN 
		RETURN FALSE;
	END IF;
--
-- Index, analyze
--
	ddl_stmts:=NULL;
	t_ddl:=1;
	sql_stmt:='ALTER TABLE rif_studies.'||LOWER(c1_rec.map_table)||' ADD CONSTRAINT "'||LOWER(c1_rec.map_table)||'_pk" PRIMARY KEY (study_id, band_id, inv_id, genders, adjusted, direct_standardisation)';
	ddl_stmts[t_ddl]:=sql_stmt;
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_compute_results', 	
		'SQL> %;',
		sql_stmt::VARCHAR);
	t_ddl:=t_ddl+1;	
	sql_stmt:='ANALYZE rif_studies.'||LOWER(c1_rec.map_table);
	ddl_stmts[t_ddl]:=sql_stmt;
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_compute_results', 	
		'SQL> %;',
		sql_stmt::VARCHAR);
--
-- Execute DDL code as rif40
--
	IF rif40_sm_pkg.rif40_study_ddl_definer(c1_rec.study_id, c1_rec.username, c1a_rec.audsid, ddl_stmts) = FALSE THEN
		RETURN FALSE;
	END IF;

--
	PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_compute_results', 
		'[90645] Study ID % map table % created',
		study_id::VARCHAR,
		c1_rec.map_table::VARCHAR);
--
-- Next expected...
--
	PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_compute_results', 
		'[90645] Study ID % rif40_compute_results() not fully implemented',
		study_id::VARCHAR);
	RETURN TRUE;
--
END;
]]></definition>
</function>

<function name="rif40_create_disease_mapping_example"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sm_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_create_disease_mapping_example()
Parameters:	Geography, geolevel view, geolevel area, geolevel map, geolevel select, 
		geolevel selection array, project, study name, denominator table, numerator table,
 		year_start, year_stop,
		investigation ICD conditions array, investigation descriptions array, covariate array
Returns:	Nothing
Description:	Create disease mapping exmaple

Setup a disease mapping example.

WARNING: This function does not test the validity of the inputs, it relies on the trigger functions.
This allows it to be used for test putposes

1. Setup geographic area to be studied

View the geolevel <geolevel_view> of <geolevel_area> and select at <geolevel_select> geolevel and map at <geolevel_map>. 
Provide list of areas selected <geolevel_selection>

E.g. [Values required in ()'s]

Geography: 		England and Wales 2001 (EW01)
Geolevel view: 		2001 Government office region (GOR2001)
Geolevel area: 		London (H)
Geolevel map: 		2001 Census statistical ward (WARD2001)
Gelevel select: 	2001 local area district/unitary authority (LADUA2001)
Geolevel selection:	Array of LADUA2001

Geolevel view and area define the geolevel and area to be mapped (so the user can select geolevel section)
Gelevel select defines the geoelevel the user will select at
Geolevel map define the geolevel the RIF will map at
Geolevel selection is an array of <geolevel_select> that the user selected. The forms the study area.
The comparison geolevel is the default set in rif40_geographies
The comparison area is the RIF default (the array produced by rif40_geo_pkg.get_default_comparison_area())

2. INSERT INTO rif40_studies

RIF40_STUDIES defaults (schema):

username		USER
study_id 		(nextval('rif40_study_id_seq'::regclass))::integer
study_date		LOCALIMESTAMP
study_state		C
audsid			sys_context('USERENV'::character varying, 'SESSIONID'::character varying)

RIF40_STUDIES defaults (from trigger):

extract_table		S_<study_id>_EXTRACT
map_table		S_<study_id>_MAP

RIF40_STUDIES defaults (this function):

study_type		1		[disease mapping]
direct_stand_tab	NULL
suppression_value	parameter "SuppressionValue"
extract_permitted	1 for SAHSU geogrpahy, 0 otherwise
transfer_permitted	1 for SAHSU geogrpahy, 0 otherwise

RIF40_STUDIES values  (where different from parameter names):
 
comparison_geolevel_name	<geolevel_view>
study_geolevel_name		<geolevel_map>
min_age_group, max_age_group	MIN/MAX defined for denominator

3. INSERT INTO rif40_investigations

RIF40_INVESTIGATIONS defaults (schema)

username		USER
study_id 		(currval('rif40_study_id_seq'::regclass))::integer
inv_id			(nextval('rif40_inv_id_seq'::regclass))::integer
classifier		QUANTILE
classifier_bands	5
investigation_state	C
mh_test_type		No test

RIF40_INVESTIGATIONS defaults (this function):

genders			3 [both]
min_age_group, max_age_group	MIN/MAX defined for denominator
inv_name		INV_<n> [index in investigation ICD conditions array]

4. INSERT INTO rif40_inv_conditions

RIF40_INV_CONDITIONS defaults (schema)

username		USER
study_id 		(currval('rif40_study_id_seq'::regclass))::integer
inv_id			(nextval('rif40_inv_id_seq'::regclass))::integer
line_number		1

5. INSERT INTO rif40_study_areas

RIF40_STUDY_AREAS defaults (schema)

username		USER
study_id 		(currval('rif40_study_id_seq'::regclass))::integer

RIF40_STUDY_AREAS defaults (this function)

band_id			<n> [index in geolevel selection array]	

6. INSERT INTO rif40_comparison_areas

RIF40_COMPARISON_AREAS defaults (schema)

username		USER
study_id 		(currval('rif40_study_id_seq'::regclass))::integer

The actual comparison area comes from rif40_geo_pkg.rif40_get_default_comparison_area().
This returns all areas at the default comparison area level covered by the users selected geolevels.

7. INSERT INTO rif40_inv_covariates

RIF40_INV_COVARIATES defaults (schema)

username		USER
study_id 		(currval('rif40_study_id_seq'::regclass))::integer
inv_id			(nextval('rif40_inv_id_seq'::regclass))::integer


RIF40_INV_COVARIATES defaults (this function)

min, max		MIN/MAX for covariate
study_geolevel_name	study_geolevel_name FROM rif40_studies

8. INSERT INTO rif40_study_shares if any RIF DB role is a RIF manager and extraction is permitted

RIF40_STUDY_SHARES defaults (schema)

grantor			USER
study_id 		(currval('rif40_study_id_seq'::regclass))::integer
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="geography" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="geolevel_view" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="geolevel_area" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="geolevel_map" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="geolevel_select" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="geolevel_selection" in="true">
		<type name="character varying" dimension="1"/>
	</parameter>
	<parameter name="project" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="study_name" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="denom_tab" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="numer_tab" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="year_start" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="year_stop" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="investigation_icd_array" in="true">
		<type name="character varying" dimension="1"/>
	</parameter>
	<parameter name="investigation_desc_array" in="true">
		<type name="character varying" dimension="1"/>
	</parameter>
	<parameter name="covariate_array" in="true">
		<type name="character varying" dimension="1"/>
	</parameter>
	<definition><![CDATA[
/*
Function: 	rif40_create_disease_mapping_example()
Parameters:	Geography, geolevel view, geolevel area, geolevel map, geolevel select, 
		geolevel selection array, project, study name, denominator table, numerator table,
 		year_start, year_stop,
		investigation ICD conditions array, investigation descriptions array, covariate array
Returns:	Nothing
Description:	Create disease mapping exmaple

Setup a disease mapping example.

WARNING: This function does not test the validity of the inputs, it relies on the trigger functions.
This allows it to be used for test putposes

1. Setup geographic area to be studied

View the geolevel <geolevel_view> of <geolevel_area> and select at <geolevel_select> geolevel and map at <geolevel_map>. 
Provide list of areas selected <geolevel_selection>

E.g. [Values required in ()'s]

Geography: 		England and Wales 2001 (EW01)
Geolevel view: 		2001 Government office region (GOR2001)
Geolevel area: 		London (H)
Geolevel map: 		2001 Census statistical ward (WARD2001)
Gelevel select: 	2001 local area district/unitary authority (LADUA2001)
Geolevel selection:	Array of LADUA2001

Geolevel view and area define the geolevel and area to be mapped (so the user can select geolevel section)
Gelevel select defines the geoelevel the user will select at
Geolevel map define the geolevel the RIF will map at
Geolevel selection is an array of <geolevel_select> that the user selected. The forms the study area.
The comparison geolevel is the default set in rif40_geographies
The comparison area is the RIF default (the array produced by rif40_geo_pkg.get_default_comparison_area())

2. INSERT INTO rif40_studies

RIF40_STUDIES defaults (schema):

username		USER
study_id 		(nextval('rif40_study_id_seq'::regclass))::integer
study_date		LOCALIMESTAMP
study_state		C
audsid			sys_context('USERENV'::character varying, 'SESSIONID'::character varying)

RIF40_STUDIES defaults (from trigger):

extract_table		S_<study_id>_EXTRACT
map_table		S_<study_id>_MAP

RIF40_STUDIES defaults (this function):

study_type		1		[disease mapping]
direct_stand_tab	NULL
suppression_value	parameter "SuppressionValue"
extract_permitted	1 for SAHSU geogrpahy, 0 otherwise
transfer_permitted	1 for SAHSU geogrpahy, 0 otherwise

RIF40_STUDIES values  (where different from parameter names):
 
comparison_geolevel_name	<geolevel_view>
study_geolevel_name		<geolevel_map>
min_age_group, max_age_group	MIN/MAX defined for denominator

3. INSERT INTO rif40_investigations

RIF40_INVESTIGATIONS defaults (schema)

username		USER
study_id 		(currval('rif40_study_id_seq'::regclass))::integer
inv_id			(nextval('rif40_inv_id_seq'::regclass))::integer
classifier		QUANTILE
classifier_bands	5
investigation_state	C
mh_test_type		No test

RIF40_INVESTIGATIONS defaults (this function):

genders			3 [both]
min_age_group, max_age_group	MIN/MAX defined for denominator
inv_name		INV_<n> [index in investigation ICD conditions array]

4. INSERT INTO rif40_inv_conditions

RIF40_INV_CONDITIONS defaults (schema)

username		USER
study_id 		(currval('rif40_study_id_seq'::regclass))::integer
inv_id			(nextval('rif40_inv_id_seq'::regclass))::integer
line_number		1

5. INSERT INTO rif40_study_areas

RIF40_STUDY_AREAS defaults (schema)

username		USER
study_id 		(currval('rif40_study_id_seq'::regclass))::integer

RIF40_STUDY_AREAS defaults (this function)

band_id			<n> [index in geolevel selection array]	

6. INSERT INTO rif40_comparison_areas

RIF40_COMPARISON_AREAS defaults (schema)

username		USER
study_id 		(currval('rif40_study_id_seq'::regclass))::integer

The actual comparison area comes from rif40_geo_pkg.rif40_get_default_comparison_area().
This returns all areas at the default comparison area level covered by the users selected geolevels.

7. INSERT INTO rif40_inv_covariates

RIF40_INV_COVARIATES defaults (schema)

username		USER
study_id 		(currval('rif40_study_id_seq'::regclass))::integer
inv_id			(nextval('rif40_inv_id_seq'::regclass))::integer


RIF40_INV_COVARIATES defaults (this function)

min, max		MIN/MAX for covariate
study_geolevel_name	study_geolevel_name FROM rif40_studies

8. INSERT INTO rif40_study_shares if any RIF DB role is a RIF manager and extraction is permitted

RIF40_STUDY_SHARES defaults (schema)

grantor			USER
study_id 		(currval('rif40_study_id_seq'::regclass))::integer

 */
DECLARE
	c1cdm CURSOR(l_table_name VARCHAR) FOR  
		WITH a AS (
			SELECT a.age_group_id, MIN(a.offset) AS min_age_group, MAX(a.offset) AS max_age_group
			  FROM rif40_age_groups a, rif40_tables b
			 WHERE a.age_group_id = b.age_group_id
			   AND b.table_name   = l_table_name
			 GROUP BY a.age_group_id
		)
		SELECT min_age_group, max_age_group, 
		       b.fieldname AS min_age_group_name,
		       c.fieldname AS max_age_group_name
		  FROM a
			LEFT OUTER JOIN rif40_age_groups b ON (a.age_group_id = b.age_group_id AND a.min_age_group = b.offset) 
			LEFT OUTER JOIN rif40_age_groups c ON (a.age_group_id = c.age_group_id AND a.max_age_group = c.offset); 
	c1cdm_rec RECORD;
	c2cdm CURSOR FOR
		SELECT p2.param_name, 
		       CASE WHEN pg_has_role(USER, 'rif_no_suppression', 'USAGE') THEN 1 /* Not Suppressed */ ELSE p2.param_value::INTEGER END suppression_value
		  FROM rif40.rif40_parameters p2
		 WHERE p2.param_name = 'SuppressionValue';
	c2cdm_rec RECORD;
	c3cdm CURSOR(l_geography VARCHAR) FOR
		SELECT defaultcomparea, hierarchytable
		  FROM rif40_geographies a
		 WHERE a.geography = l_geography;
	c3cdm_rec RECORD;
	c4cdm CURSOR FOR /* Valid RIF users */
		SELECT rolname, pg_has_role(rolname, 'rif_manager', 'USAGE') AS is_rif_manager
		  FROM pg_roles r, pg_namespace n
		 WHERE (pg_has_role(rolname, 'rif_user', 'USAGE') OR pg_has_role(rolname, 'rif_manager', 'USAGE'))
		   AND n.nspowner = r.oid
		   AND nspname = rolname;
	c4cdm_rec RECORD;
--
	i 			INTEGER:=0;
	l_inv_name	 	VARCHAR;
	l_area_id 		VARCHAR;
	icd 			VARCHAR;
	comparision_area	VARCHAR[];
	study_area_count	INTEGER;
	comparison_area_count	INTEGER;
	covariate_count		INTEGER;
-- 
	sql_stmt		VARCHAR;
--
	l_extract_permitted 	INTEGER:=0;
	l_transfer_permitted 	INTEGER:=0;
--
BEGIN
--
-- Check INVESTIGATION array are the same length
--
	IF array_length(investigation_icd_array, 1) != array_length(investigation_desc_array, 1) THEN
		PERFORM rif40_log_pkg.rif40_error(-90901, 'rif40_create_disease_mapping_example', 
			'icd array length (%) != description array length (%)',
			array_length(investigation_icd_array, 1)::VARCHAR,
			array_length(investigation_desc_array, 1)::VARCHAR);
	END IF;
--
-- Get MIN/MAX age groups. Check table exists
--
	OPEN c1cdm(numer_tab);
	FETCH c1cdm INTO c1cdm_rec;
	IF NOT FOUND THEN
		PERFORM rif40_log_pkg.rif40_error(-90902, 'rif40_create_disease_mapping_example', 
			'Cannot find numerator table: %',
			numer_tab::VARCHAR);
	END IF;
	CLOSE c1cdm;
--
-- Get suppression_value
--
	OPEN c2cdm;
	FETCH c2cdm INTO c2cdm_rec;
	IF NOT FOUND THEN
		PERFORM rif40_log_pkg.rif40_error(-90903, 'rif40_create_disease_mapping_example', 
			'Cannot find SuppressionValue parameter');
	END IF;
	CLOSE c2cdm;
--
-- Get comparison geolevel - is the default set in rif40_geographies
--
	OPEN c3cdm(geography);
	FETCH c3cdm INTO c3cdm_rec;
	IF NOT FOUND THEN
		PERFORM rif40_log_pkg.rif40_error(-90904, 'rif40_create_disease_mapping_example', 
			'Cannot find rif40_geographies geography: %',
			geography::VARCHAR);
	END IF;
	CLOSE c3cdm;
--
-- Set up IG - SAHSU no restrictions; otherwise full restrictions
--
	IF geography = 'SAHSU' THEN
		l_extract_permitted:=1;
		l_transfer_permitted:=1;
	END IF;
--
-- 2. INSERT INTO rif40_studies
--
	INSERT INTO rif40_studies (
 		geography, project, study_name, study_type,
 		comparison_geolevel_name, study_geolevel_name, denom_tab,            
 		year_start, year_stop, max_age_group, min_age_group, 
 		suppression_value, extract_permitted, transfer_permitted)
	VALUES (
		 geography 			/* geography */,
		 project 			/* project */, 
		 study_name 			/* study_name */,
		 1 				/* study_type [disease mapping] */,
		 c3cdm_rec.defaultcomparea	/* comparison_geolevel_name */,
		 geolevel_map 			/* study_geolevel_name */,   
		 denom_tab 			/* denom_tab */,            
		 year_start			/* year_start */,       
		 year_stop 			/* year_stop */,      
		 c1cdm_rec.max_age_group 	/* max_age_group */, 
		 c1cdm_rec.min_age_group 	/* min_age_group */, 
		 c2cdm_rec.suppression_value 	/* suppression_value */, 
		 l_extract_permitted 		/* extract_permitted */, 
		 l_transfer_permitted		/* transfer_permitted */);
	PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_create_disease_mapping_example', 
		'[90905] Created study: % % for project %',  
		currval('rif40_study_id_seq'::regclass)::VARCHAR,
		study_name::VARCHAR,
		project::VARCHAR);
	PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_create_disease_mapping_example', 
		'[90906] View the geolevel % of "%" and select at % geolevel and map at %; default comparison area %',
		geolevel_view::VARCHAR,
		geolevel_area::VARCHAR, 
		geolevel_select::VARCHAR,
		geolevel_map::VARCHAR,
		c3cdm_rec.defaultcomparea::VARCHAR);
	PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'rif40_create_disease_mapping_example', 
		'[90907] List of areas selected: "%"', 
		array_to_string(geolevel_selection, '","')::VARCHAR);
	PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_create_disease_mapping_example', 
		'[90908] Denominator: %; period: %-%; age groups % to %',
		denom_tab::VARCHAR,
		year_start::VARCHAR,
		year_stop::VARCHAR,
		c1cdm_rec.min_age_group_name::VARCHAR,
		c1cdm_rec.max_age_group_name::VARCHAR);
	PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_create_disease_mapping_example', 
		'[90909] Suppression value: %; extract permitted: %; transfer permitted %',
		c2cdm_rec.suppression_value::VARCHAR,
		l_extract_permitted::VARCHAR,
		l_transfer_permitted::VARCHAR);
--
-- 3. INSERT INTO rif40_investigations
--
-- Process investigations array
--
	FOREACH icd IN ARRAY investigation_icd_array LOOP
		i:=i+1;
		l_inv_name:='INV_'||i::VARCHAR;
		INSERT INTO rif40_investigations(
			geography,
			inv_name,
			inv_description,
			genders,
			numer_tab, 
			year_start,
			year_stop, 
			max_age_group,
			min_age_group
		)
		VALUES (
		 	geography 		/* geography */,
			l_inv_name 		/* inv_name */,  
			investigation_desc_array[i]	/* inv_description */,
			3			/* genders [both] */,
			numer_tab		/* numer_tab */,
		 	year_start		/* year_start */,       
			year_stop 		/* year_stop */,      
			c1cdm_rec.max_age_group /* max_age_group */, 
			c1cdm_rec.min_age_group /* min_age_group */);
--
-- 4. INSERT INTO rif40_inv_conditions
--
		INSERT INTO rif40_inv_conditions(
			condition)
		VALUES (
			investigation_icd_array[i]	/* ICD */);
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_create_disease_mapping_example', 	
			'[90910] Created investigation: % (%): %; numerator: %; condition: "%"',  
			currval('rif40_inv_id_seq'::regclass)::VARCHAR,
			l_inv_name::VARCHAR,
			investigation_desc_array[i]::VARCHAR,
			numer_tab::VARCHAR,
			investigation_icd_array[i]::VARCHAR);
	END LOOP;
--
-- 5. INSERT INTO rif40_study_areas
--
-- Process geolevel_selection array, populate study areas
--
/*
	i:=0;
	FOREACH l_area_id IN ARRAY geolevel_selection LOOP
		i:=i+1;
		INSERT INTO rif40_study_areas(
			area_id,
			band_id)
		VALUES (
			l_area_id,
			i);
		PERFORM rif40_log_pkg.rif40_log('DEBUG4', 'rif40_create_disease_mapping_example', 	
			'Study area band: %, area_id: %',
			i::VARCHAR,
			l_area_id::VARCHAR);
	END LOOP;
 */
	IF geolevel_map = geolevel_select THEN
		INSERT INTO rif40_study_areas(area_id, band_id) 
		SELECT unnest(geolevel_selection) /* at Geolevel select */ AS study_area, ROW_NUMBER() OVER() AS band_id;
--
-- User selection carried out at different level to mapping
--
	ELSE
		BEGIN    
			sql_stmt:='INSERT INTO rif40_study_areas(area_id, band_id)'||E'\n'||
				'SELECT DISTINCT '||LOWER(geolevel_map)||', ROW_NUMBER() OVER() AS band_id'||E'\n'||
				E'\t'||'  FROM '||LOWER(c3cdm_rec.hierarchytable)||E'\n'||
				E'\t'||' WHERE '||LOWER(geolevel_select)||' IN ('||E'\n'||
				E'\t'||'SELECT unnest($1) /* at Geolevel select */ AS study_area)';
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_create_disease_mapping_example', 	
				'SQL> %;',
				sql_stmt::VARCHAR);
			EXECUTE sql_stmt USING geolevel_selection;
  	     	EXCEPTION
			WHEN others THEN
				PERFORM rif40_log_pkg.rif40_error(-90912, 'rif40_create_disease_mapping_example',
					'[90911] INSERT INTO rif40_study_areas % raised by: %',
					sqlerrm::VARCHAR		/* Error */,
					sql_stmt::VARCHAR		/* SQL */);      
		END;
	END IF;
	GET DIAGNOSTICS study_area_count = ROW_COUNT;

--
-- Get default comparison area, populate comparison areas [INSERT/trigger]
--
	comparision_area:=rif40_geo_pkg.rif40_get_default_comparison_area(geography, geolevel_select, geolevel_selection);
	IF comparision_area IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-90913, 'rif40_create_disease_mapping_example', 
			'rif40_geo_pkg.rif40_get_default_comparison_area(%, %, <geolevel_selection>) returned NULL',
			geography::VARCHAR,
			geolevel_select::VARCHAR);
	END IF;
--
-- 6. INSERT INTO rif40_comparison_areas
--
/*
	FOREACH l_area_id IN ARRAY comparision_area LOOP
		INSERT INTO  rif40_comparison_areas(
			area_id)
		VALUES (
			l_area_id);
		PERFORM rif40_log_pkg.rif40_log('DEBUG4', 'rif40_create_disease_mapping_example', 	
			'Comparison area_id: %',
			l_area_id::VARCHAR);
	END LOOP;
 */
	INSERT INTO rif40_comparison_areas(area_id) SELECT unnest(comparision_area) AS comparision_area;
	GET DIAGNOSTICS comparison_area_count = ROW_COUNT;
--
-- 7. INSERT INTO rif40_inv_covariates
--
	INSERT INTO rif40_inv_covariates(geography, covariate_name, study_geolevel_name, min, max) 
		WITH a AS (
			SELECT unnest(covariate_array) AS covariate_name, geolevel_map AS study_geolevel_name, geography AS geography 
		)
		SELECT a.geography, a.covariate_name, a.study_geolevel_name, b.min, b.max
		  FROM a
			LEFT OUTER JOIN rif40_covariates b ON 
				(a.covariate_name = b.covariate_name AND a.study_geolevel_name = b.geolevel_name AND a.geography = b.geography);
	GET DIAGNOSTICS covariate_count = ROW_COUNT;
--
	PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_create_disease_mapping_example', 	
		'[90914] Inserted % study area(s); % comparision area(s) [default comparison area geolevel: %]; % covariate(s)',
		study_area_count::VARCHAR,
		comparison_area_count::VARCHAR,
		c3cdm_rec.defaultcomparea::VARCHAR,
		covariate_count::VARCHAR);
--
-- 8. INSERT INTO rif40_study_shares if any RIF DB role is a RIF manager and extraction is permitted
--
	FOR c4cdm_rec IN c4cdm LOOP
		IF c4cdm_rec.is_rif_manager AND l_extract_permitted = 1 THEN
			INSERT INTO rif40_study_shares(grantee_username) VALUES (c4cdm_rec.rolname);
			PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_create_disease_mapping_example', 
				'[90915] Shared study % to %',
				currval('rif40_study_id_seq'::regclass)::VARCHAR,
				c4cdm_rec.rolname::VARCHAR);	
		END IF;
	END LOOP;
--
END;
]]></definition>
</function>

<function name="rif40_create_extract"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sm_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function:	rif40_create_extract()
Parameter:	Study ID
Returns:	Success or failure [BOOLEAN]
		Note this is to allow SQL executed by study extraction/results created to be logged (Postgres does not allow autonomous transactions)
		Verification and error checking raises EXCEPTIONS in the usual way; and will cause the SQL log to be lost
Description:	Create extract table. Calls rif40_insert_extract() to populate extract table.

Notes:

1. SQL created by rif40_study_ddl_definer() runs as rif40_sm_pkg NOT the user. This is so all objects created can be explicitly granted to the user
2. Same on Postgres and Postgres/Oracle FDW variants. Oracle remote execution is handled by rif40_insert_extract()

Check extract table does not exist
Check extract is permitted

Create extract table

The basis for this is the performance tests created from the new EHA extract for Lea in September 2012
The table has the following standard columns

CREATE TABLE <extract_table> (
 	year                    SMALLINT 	NOT NULL,
	study_or_comparison	VARCHAR(1) 	NOT NULL,
	study_id		INTEGER 	NOT NULL,
 	area_id                 VARCHAR 	NOT NULL,
	band_id			INTEGER,
 	sex                     SMALLINT,
 	age_group               VARCHAR,
 	total_pop               DOUBLE PRECISION,

One column per distinct covariate

 	<rif40_inv_covariates.covariate_name>    VARCHAR,

One column per investigation

 	<rif40_investigations>.<inv_name>        VARCHAR);

Index: year, study_or_comparison if no partitoning
       area_id, band_id, sex, age_group

Comment extract table and columns

Grant to study owner and all grantees in rif40_study_shares if extract_permitted=1 

Call rif40_sm_pkg.rif40_study_ddl_definer (i.e. runs as rif40_sm_pkg owner rif40) to process

Call rif40_insert_extract() to populate extract table.

Vacuum analyze

Partitioned by RANGE year

Call rif40_sm_pkg.rif40_study_ddl_definer (i.e. runs as rif40_sm_pkg owner rif40) to process]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="study_id" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
/*
Function:	rif40_create_extract()
Parameter:	Study ID
Returns:	Success or failure [BOOLEAN]
		Note this is to allow SQL executed by study extraction/results created to be logged (Postgres does not allow autonomous transactions)
		Verification and error checking raises EXCEPTIONS in the usual way; and will cause the SQL log to be lost
Description:	Create extract table. Calls rif40_insert_extract() to populate extract table.

Notes:

1. SQL created by rif40_study_ddl_definer() runs as rif40_sm_pkg NOT the user. This is so all objects created can be explicitly granted to the user
2. Same on Postgres and Postgres/Oracle FDW variants. Oracle remote execution is handled by rif40_insert_extract()

Check extract table does not exist
Check extract is permitted

Create extract table

The basis for this is the performance tests created from the new EHA extract for Lea in September 2012
The table has the following standard columns

CREATE TABLE <extract_table> (
 	year                    SMALLINT 	NOT NULL,
	study_or_comparison	VARCHAR(1) 	NOT NULL,
	study_id		INTEGER 	NOT NULL,
 	area_id                 VARCHAR 	NOT NULL,
	band_id			INTEGER,
 	sex                     SMALLINT,
 	age_group               VARCHAR,
 	total_pop               DOUBLE PRECISION,

One column per distinct covariate

 	<rif40_inv_covariates.covariate_name>    VARCHAR,

One column per investigation

 	<rif40_investigations>.<inv_name>        VARCHAR);

Index: year, study_or_comparison if no partitoning
       area_id, band_id, sex, age_group

Comment extract table and columns

Grant to study owner and all grantees in rif40_study_shares if extract_permitted=1 

Call rif40_sm_pkg.rif40_study_ddl_definer (i.e. runs as rif40_sm_pkg owner rif40) to process

Call rif40_insert_extract() to populate extract table.

Vacuum analyze

Partitioned by RANGE year

Call rif40_sm_pkg.rif40_study_ddl_definer (i.e. runs as rif40_sm_pkg owner rif40) to process
 */
	c1_creex CURSOR(l_study_id INTEGER) FOR
		SELECT *
		  FROM rif40_studies a
		 WHERE l_study_id = a.study_id;
	c1a_creex CURSOR(l_study_id INTEGER) FOR
		SELECT *
		  FROM rif40_studies a
		 WHERE l_study_id = a.study_id;
	c2_creex CURSOR(l_study_id INTEGER) FOR
		SELECT DISTINCT(a.covariate_name) AS covariate_name
		  FROM rif40_inv_covariates a
		 WHERE l_study_id = a.study_id
		 ORDER BY a.covariate_name;
	c3_creex CURSOR(l_study_id INTEGER) FOR
		SELECT *
		  FROM rif40_investigations a
		 WHERE l_study_id = a.study_id
  		 ORDER BY inv_id;
	c4_creex CURSOR(l_study_id INTEGER) FOR
		SELECT *
		  FROM rif40_study_shares a
		 WHERE l_study_id = a.study_id;
	c1_rec RECORD;
	c1a_rec RECORD;
	c2_rec RECORD;
	c3_rec RECORD;
	c4_rec RECORD;
--
	schema 		VARCHAR;
--
	sql_stmt 	VARCHAR;
	ddl_stmts	VARCHAR[];
	t_ddl		INTEGER:=0;
--
	index_column	VARCHAR;
	index_columns 	VARCHAR[] := ARRAY['area_id', 'band_id', 'sex', 'age_group']; 
	table_column	VARCHAR;
	table_columns	VARCHAR[] := ARRAY['year', 'study_or_comparison', 'study_id', 'area_id',
		'band_id', 'sex',  'age_group', 'total_pop'];
	column_comments	VARCHAR[] := ARRAY['Year', 'Study (S) or comparison (C) area', 'Study ID', 'Area ID',
		'Band ID', 'Sex',  'Age group', 'Total population'];
	i		INTEGER:=0;
BEGIN
	OPEN c1_creex(study_id);
	FETCH c1_creex INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1_creex;
		PERFORM rif40_log_pkg.rif40_error(-90601, 'rif40_create_extract', 
			'Study ID % not found',
			study_id::VARCHAR);
	END IF;
	CLOSE c1_creex;
	OPEN c1a_creex(study_id);
	FETCH c1a_creex INTO c1a_rec;
	CLOSE c1a_creex;
--
-- Check extract table does not exist
--
	IF c1_rec.extract_table IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-90602, 'rif40_create_extract', 
			'RIF40_STUDIES study % extract table: not defined',
			c1_rec.study_id::VARCHAR	/* Study id */);
	END IF;
	schema:=rif40_sql_pkg.rif40_object_resolve(c1_rec.extract_table::VARCHAR);
	IF schema IS NULL AND c1_rec.study_state = 'V'  THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_create_extract', 
			'[90603] RIF40_STUDIES study % extract table: % defined, awaiting creation',
			c1_rec.study_id::VARCHAR	/* Study id */,
			c1_rec.extract_table::VARCHAR 	/* extract_table */);
	ELSIF c1_rec.study_state != 'V' THEN
		PERFORM rif40_log_pkg.rif40_error(-90604, 'rif40_create_extract', 
			'RIF40_STUDIES study % extract table: %; in wrong state: %',
			c1_rec.study_id::VARCHAR	/* Study id */,
			c1_rec.extract_table::VARCHAR 	/* extract_table */,
			c1_rec.study_state::VARCHAR	/* State */);
	ELSE /* schema IS NOT NULL */
		PERFORM rif40_log_pkg.rif40_error(-90605, 'rif40_create_extract', 
			'RIF40_STUDIES study % extract table: %; exists in schema: %',
			c1_rec.study_id::VARCHAR	/* Study id */,
			c1_rec.extract_table::VARCHAR 	/* extract_table */,
			schema::VARCHAR			/* Schema */);
	END IF;         
--
-- Check extract is permitted
--
	IF c1_rec.extract_permitted != 1 THEN
		PERFORM rif40_log_pkg.rif40_error(-90606, 'rif40_create_extract', 
			'RIF40_STUDIES study % extract not currently permitted [use RIF IG tool]',
			c1_rec.study_id::VARCHAR	/* Study id */);
	END IF;

--
-- Check extract is bweing run by study owner
--
	IF c1_rec.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-90607, 'rif40_create_extract', 
			'RIF40_STUDIES study % extract must be run by study owner % not %',
			c1_rec.study_id::VARCHAR	/* Study id */,
			c1_rec.username::VARCHAR	/* Study owner */,
			USER::VARCHAR			/* User of this function */);
	END IF;

--
-- Create extract table
--
-- The basis for this is the performance tests created from the new EHA extract for Lea in September 2012
-- The table has the following standard columns
--
--CREATE TABLE <extract_table> (
-- 	year                    SMALLINT 	NOT NULL,
--	study_or_comparison	VARCHAR(1) 	NOT NULL,
--	study_id		INTEGER 	NOT NULL,
-- 	area_id                 VARCHAR 	NOT NULL,
--	band_id			INTEGER,
-- 	sex                     SMALLINT,
-- 	age_group               VARCHAR,
-- 	total_pop               DOUBLE PRECISION,
--
	sql_stmt:='CREATE TABLE rif_studies.'||LOWER(c1_rec.extract_table)||' ('||E'\n'||
		 	E'\t'||'year                    SMALLINT 	NOT NULL,'||E'\n'||
			E'\t'||'study_or_comparison	VARCHAR(1) 	NOT NULL,'||E'\n'||
			E'\t'||'study_id		INTEGER 	NOT NULL,'||E'\n'||
 			E'\t'||'area_id                 VARCHAR 	NOT NULL,'||E'\n'||
			E'\t'||'band_id			INTEGER,'||E'\n'||
 			E'\t'||'sex                     SMALLINT,'||E'\n'||
 			E'\t'||'age_group               SMALLINT,'||E'\n';
--
-- One column per distinct covariate
--
-- 	<rif40_inv_covariates>.<covariate_name>    VARCHAR,
--
	FOR c2_rec IN c2_creex(study_id) LOOP
		sql_stmt:=sql_stmt||E'\t'||LOWER(c2_rec.covariate_name)||'               VARCHAR,'||E'\n'; /* Covariate value always coerced to a VARCHAR */
		table_columns:=array_append(table_columns, c2_rec.covariate_name::VARCHAR);
		column_comments:=array_append(column_comments, c2_rec.covariate_name::VARCHAR);
	END LOOP;
--
-- One column per investigation
--
-- 	<rif40_investigations>.<inv_name>          VARCHAR);
--
	FOR c3_rec IN c3_creex(study_id) LOOP
		sql_stmt:=sql_stmt||E'\t'||LOWER(c3_rec.inv_name)||'               BIGINT,'||E'\n';
		table_columns:=array_append(table_columns, LOWER(c3_rec.inv_name)::VARCHAR);
		column_comments:=array_append(column_comments, c3_rec.inv_description::VARCHAR);
	END LOOP;
	sql_stmt:=sql_stmt||E'\t'||'total_pop               DOUBLE PRECISION)';
--
	t_ddl:=t_ddl+1;	
	ddl_stmts[t_ddl]:=sql_stmt;

--
-- Partitioned by RANGE year, study_or_comparison
--

--
-- Comment extract table and columns
--
	sql_stmt:='COMMENT ON TABLE rif_studies.'||LOWER(c1_rec.extract_table)||' IS '''||c1_rec.description||'''';
	t_ddl:=t_ddl+1;	
	ddl_stmts[t_ddl]:=sql_stmt;
	FOREACH table_column IN ARRAY table_columns LOOP
		i:=i+1;
		sql_stmt:='COMMENT ON COLUMN rif_studies.'||LOWER(c1_rec.extract_table)||'.'||table_column||' IS '''||column_comments[i]||'''';
		t_ddl:=t_ddl+1;	
		ddl_stmts[t_ddl]:=sql_stmt;
	END LOOP;

--
-- Grant to study owner and all grantees in rif40_study_shares if extract_permitted=1 
--
	IF c1_rec.extract_permitted = 1 THEN
		sql_stmt:='GRANT SELECT,INSERT,TRUNCATE ON rif_studies.'||LOWER(c1_rec.extract_table)||' TO '||USER;
		t_ddl:=t_ddl+1;	
		ddl_stmts[t_ddl]:=sql_stmt;
		FOR c4_rec IN c4_creex(study_id) LOOP
			sql_stmt:='GRANT SELECT,INSERT ON rif_studies.'||LOWER(c1_rec.extract_table)||' TO '||c4_rec.grantee_username;
			t_ddl:=t_ddl+1;	
			ddl_stmts[t_ddl]:=sql_stmt;
		END LOOP;
	END IF;

--
-- Call rif40_sm_pkg.rif40_study_ddl_definer (i.e. runs as rif40_sm_pkg owner rif40)
--
	IF rif40_sm_pkg.rif40_study_ddl_definer(c1_rec.study_id, c1_rec.username, c1a_rec.audsid, ddl_stmts) = FALSE THEN
		PERFORM rif40_log_pkg.rif40_log ('WARNING', 'rif40_create_extract', 
			'[90607] RIF40_STUDIES study % extract creation failed, see previous warnings',
			c1_rec.study_id::VARCHAR	/* Study id */);
		RETURN FALSE;
	END IF;
--
-- Call rif40_insert_extract() to populate extract table.
-- 
	IF rif40_sm_pkg.rif40_insert_extract(c1_rec.study_id) = FALSE THEN
		PERFORM rif40_log_pkg.rif40_log ('WARNING', 'rif40_create_extract', 
			'[90608] RIF40_STUDIES study % populated extract failed, see previous warnings',
			c1_rec.study_id::VARCHAR	/* Study id */);
		RETURN FALSE;
	END IF;
--
-- Reset DDL statement array
--
	ddl_stmts:=NULL;
	t_ddl:=0;
--
-- Index: year, study_or_comparison if no partitoning
--	  area_id, band_id, sex, age_group
--
-- NEEDS TO BE MOVED TO AFTER INSERT, ADD PK
--
	IF c1_rec.partition_parallelisation = 0 THEN
		index_columns:=array_cat(index_columns, ARRAY['year', 'study_or_comparison']::VARCHAR[]);
	END IF;
	FOREACH index_column IN ARRAY index_columns LOOP
		sql_stmt:='CREATE INDEX '||LOWER(c1_rec.extract_table)||'_'||index_column||
			' ON rif_studies.'||LOWER(c1_rec.extract_table)||'('||index_column||')';
		t_ddl:=t_ddl+1;	
		ddl_stmts[t_ddl]:=sql_stmt;
	END LOOP;

--
-- Vacuum analyze - raises 25001 "VACUUM cannot run inside a transaction block"
--
-- DEFER TO LATER
--
	sql_stmt:='ANALYZE rif_studies.'||LOWER(c1_rec.extract_table);
	t_ddl:=t_ddl+1;	
	ddl_stmts[t_ddl]:=sql_stmt;
--
-- Call rif40_sm_pkg.rif40_study_ddl_definer (i.e. runs as rif40_sm_pkg owner rif40)
--
	IF rif40_sm_pkg.rif40_study_ddl_definer(c1_rec.study_id, c1_rec.username, c1a_rec.audsid, ddl_stmts) = FALSE THEN
		PERFORM rif40_log_pkg.rif40_log ('WARNING', 'rif40_create_extract', 
			'[90609] RIF40_STUDIES study % extract index/analyze failed, see previous warnings',
			c1_rec.study_id::VARCHAR	/* Study id */);
		RETURN FALSE;
	END IF;
--
	RETURN TRUE;
END;
]]></definition>
</function>

<function name="rif40_create_insert_statement"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sm_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[A]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="character varying"/>
	</return-type>
	<parameter name="study_id" in="true" default-value="NULL::integer">
		<type name="integer"/>
	</parameter>
	<parameter name="study_or_comparison" in="true" default-value="NULL::integer">
		<type name="character varying"/>
	</parameter>
	<parameter name="year_start" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="year_stop" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
/*
Function:	rif40_create_insert_statement()
Parameter:	Study ID, study or comparison (S/C), year_start, year_stop
Returns:	SQL statement
Description:	Create INSERT SQL statement
 */
	c1insext CURSOR(l_study_id INTEGER) FOR
		SELECT * 
		  FROM rif40_studies a
		 WHERE a.study_id = l_study_id;
	c2insext CURSOR(l_table VARCHAR) FOR
		SELECT *
		  FROM information_schema.columns a
		 WHERE a.table_schema = 'rif_studies'
		   AND a.table_name   = l_table
		 ORDER BY a.ordinal_position;
	c3insext CURSOR(l_study_id INTEGER) FOR
		SELECT COUNT(DISTINCT(numer_tab)) AS distinct_numerators
		  FROM rif40_investigations a
		 WHERE a.study_id = l_study_id;
	c4insext CURSOR(l_study_id INTEGER) FOR
		WITH b AS (
			SELECT DISTINCT(a.numer_tab) AS numer_tab
			  FROM rif40_investigations a
		 	 WHERE a.study_id   = l_study_id
		)
		SELECT b.numer_tab,
 		       t.description, t.total_field, t.year_start, t.year_stop, 
   		       t.sex_field_name, t.age_group_field_name, t.age_sex_group_field_name, t.age_group_id
		  FROM b, rif40_tables t 
		 WHERE t.table_name = b.numer_tab;
	c5insext CURSOR(l_study_id INTEGER, l_numer_tab VARCHAR) FOR
		SELECT *
		  FROM rif40_investigations a
		 WHERE a.study_id  = l_study_id
		   AND a.numer_tab = l_numer_tab
 		 ORDER BY inv_id;
	c6insext CURSOR(l_study_id INTEGER, l_inv_id INTEGER) FOR
		SELECT *
		  FROM rif40_inv_conditions a
		 WHERE a.study_id = l_study_id
		   AND a.inv_id = l_inv_id
 		 ORDER BY inv_id, line_number;
	c7insext CURSOR(l_study_id INTEGER) FOR
		SELECT DISTINCT covariate_name AS covariate_name
		  FROM rif40_inv_covariates a
		 WHERE a.study_id = l_study_id
 		 ORDER BY covariate_name;
	c8insext CURSOR(l_study_id INTEGER) FOR
		SELECT b.denom_tab,
 		       t.description, t.total_field, t.year_start, t.year_stop,
   		       t.sex_field_name, t.age_group_field_name, t.age_sex_group_field_name, t.age_group_id, 
		       MIN(a.offset) AS min_age_group, MAX(a.offset) AS max_age_group
		  FROM rif40_studies b, rif40_tables t, rif40_age_groups a
		 WHERE t.table_name   = b.denom_tab
		   AND t.age_group_id = a.age_group_id
		   AND b.study_id     = l_study_id
		 GROUP BY b.denom_tab,
 		       t.description, t.total_field, t.year_start, t.year_stop,
   		       t.sex_field_name, t.age_group_field_name, t.age_sex_group_field_name, t.age_group_id;
	c1_rec RECORD;
	c2_rec RECORD;
	c3_rec RECORD;
	c4_rec RECORD;
	c5_rec RECORD;
	c6_rec RECORD;
	c7_rec RECORD;
	c8_rec RECORD;
--
	sql_stmt	VARCHAR;
	i		INTEGER:=0;
	j		INTEGER:=0;
	k		INTEGER:=0;
	inv_array	VARCHAR[];
	inv_join_array	VARCHAR[];
--
	areas_table	VARCHAR:='g_rif40_study_areas';
BEGIN
--
-- Use different areas_table for comparision (it has no band_id)
--	
	IF study_or_comparison = 'C' THEN
		areas_table:='g_rif40_comparison_areas';
	END IF;
	OPEN c1insext(study_id);
	FETCH c1insext INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1insext;
		PERFORM rif40_log_pkg.rif40_error(-90641, 'rif40_create_insert_statement', 
			'Study ID % not found',
			study_id::VARCHAR		/* Study ID */);
	END IF;
	CLOSE c1insext;
--
-- Create INSERT statement
-- 
	sql_stmt:='INSERT INTO '||LOWER(c1_rec.extract_table)||' ('||E'\n';
--
-- Add columns
-- 
	FOR c2_rec IN c2insext(LOWER(c1_rec.extract_table)) LOOP
		i:=i+1;
		IF i = 1 THEN
			sql_stmt:=sql_stmt||E'\t'||c2_rec.column_name;
		ELSE
			sql_stmt:=sql_stmt||','||c2_rec.column_name;
		END IF;
	END LOOP;
	IF i = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-90642, 'rif40_create_insert_statement', 
			'Study ID % no columns found for extract table: %',
			study_id::VARCHAR		/* Study ID */,		
			c1_rec.extract_table::VARCHAR 	/* Extract table */);
	END IF;
--
-- Get number of distinct numerators
--
	OPEN c3insext(study_id);
	FETCH c3insext INTO c3_rec;
	IF NOT FOUND THEN
		CLOSE c3insext;
		PERFORM rif40_log_pkg.rif40_error(-90643, 'rif40_create_insert_statement', 
			'Study ID % not found',
			study_id::VARCHAR		/* Study ID */);
	END IF;
	CLOSE c3insext;
	sql_stmt:=sql_stmt||') /* '||c3_rec.distinct_numerators::VARCHAR||' numerator(s) */'||E'\n';
--
-- Get denominator setup
--
	OPEN c8insext(study_id);
	FETCH c8insext INTO c8_rec;
	IF NOT FOUND THEN
		CLOSE c8insext;
		PERFORM rif40_log_pkg.rif40_error(-90644, 'rif40_create_insert_statement', 
			'Study ID % not found',
			study_id::VARCHAR		/* Study ID */);
	END IF;
	CLOSE c8insext;
--
--
-- Loop through distinct numerators
--
	i:=0;
	FOR c4_rec IN c4insext(study_id) LOOP
		i:=i+1;
--
-- Open WITH clause (common table expression)
-- 
		IF i = 1 THEN
			sql_stmt:=sql_stmt||'WITH n'||i::VARCHAR||' AS ('||E'\t'||'/* '||c4_rec.numer_tab||' - '||c4_rec.description||' */'||E'\n';
		ELSE
			sql_stmt:=sql_stmt||', n'||i::VARCHAR||' AS ('||E'\t'||'/* '||c4_rec.numer_tab||' - '||c4_rec.description||' */'||E'\n';
		END IF;
--
-- Numerator JOINS
--
		inv_join_array[i]:=E'\t'||'LEFT OUTER JOIN n'||i::VARCHAR||' ON ( '||
			E'\t'||'/* '||c4_rec.numer_tab||' - '||c4_rec.description||' */'||E'\n'||
			E'\t'||E'\t'||'    d.area_id'||E'\t'||E'\t'||' = n'||i::VARCHAR||'.area_id'||E'\n'||
			E'\t'||E'\t'||'AND d.year'||E'\t'||E'\t'||' = n'||i::VARCHAR||'.year'||E'\n'||
--
-- [Add conversion support for differing age/sex/group names; convert to AGE_SEX_GROUP]
--
			E'\t'||E'\t'||'AND d.'||LOWER(c8_rec.age_sex_group_field_name)||E'\t'||' = n'||i::VARCHAR||'.n_age_sex_group)';
				/* List of numerator joins (for use in FROM clause) */
		sql_stmt:=sql_stmt||E'\t'||'SELECT s.area_id'||E'\t'||E'\t'||'/* Study or comparision resolution */,'||E'\n';
		sql_stmt:=sql_stmt||E'\t'||'       c.year,'||E'\n';
--
-- [Add support for differing age/sex/group names; convert to AGE_SEX_GROUP]
--
		sql_stmt:=sql_stmt||E'\t'||'       c.'||LOWER(c4_rec.age_sex_group_field_name)||' AS n_age_sex_group,'||E'\n';
--
-- Individual investigations [add age group/sex/year filters]
-- 
		FOR c5_rec IN c5insext(study_id, c4_rec.numer_tab) LOOP
			j:=j+1;
			inv_array[j]:='       COALESCE('||
				'n'||i::VARCHAR||'.inv_'||c5_rec.inv_id::VARCHAR||'_'||LOWER(c5_rec.inv_name)||
				', 0) AS inv_'||c5_rec.inv_id::VARCHAR||'_'||LOWER(c5_rec.inv_name); 
				/* List of investigations (for use in final SELECT) */
			IF j > 1 THEN
				sql_stmt:=sql_stmt||','||E'\n';
			END IF;
			sql_stmt:=sql_stmt||E'\t'||'       SUM(CASE '||E'\t'||E'\t'||'/* Numerators - can overlap */'||E'\n';
			sql_stmt:=sql_stmt||E'\t'||E'\t'||E'\t'||'WHEN (('||E'\t'||'/* Investigation '||j::VARCHAR||' ICD filters */'||E'\n';
--
-- Add conditions
--
			k:=0;
			FOR c6_rec IN c6insext(study_id, c5_rec.inv_id) LOOP
				k:=k+1;
				IF k = 1 THEN
					sql_stmt:=sql_stmt||E'\t'||E'\t'||E'\t'||E'\t'||'    '||c6_rec.condition||' /* Filter '||k::VARCHAR||' */';
				ELSE
					sql_stmt:=sql_stmt||E'\n'||E'\t'||E'\t'||E'\t'||E'\t'||' OR '||c6_rec.condition||' /* Filter '||k::VARCHAR||' */';
				END IF;
			END LOOP;
			sql_stmt:=sql_stmt||') /* '||k::VARCHAR||' lines of conditions: study: '||
				study_id::VARCHAR||', inv: '||c5_rec.inv_id::VARCHAR||' */'||E'\n';
			sql_stmt:=sql_stmt||E'\t'||E'\t'||E'\t'||'AND (1=1'||E'\n';
--
-- Processing years filter
--
/*			IF year_start = year_stop THEN
				sql_stmt:=sql_stmt||E'\t'||E'\t'||E'\t'||'   AND (c.year = $2'||E'\t'||'-* Denominator (INSERT) year filter *-'||E'\n';
			ELSE
				sql_stmt:=sql_stmt||E'\t'||E'\t'||E'\t'||'   AND (c.year BETWEEN $2 AND $3'||E'\t'||'-* Denominator (INSERT) year filter *-'||E'\n';
			END IF; */
--
-- Investigation filters: year, age group, genders
--
			IF c5_rec.year_start = c5_rec.year_stop THEN
				sql_stmt:=sql_stmt||E'\t'||E'\t'||E'\t'||'   AND  c.year = '||c5_rec.year_start::VARCHAR||E'\n';
			ELSIF c4_rec.year_start = c5_rec.year_start AND c4_rec.year_stop = c5_rec.year_stop THEN
				sql_stmt:=sql_stmt||E'\t'||E'\t'||E'\t'||E'\t'||'        /* No year filter required for investigation '||j::VARCHAR||' */'||E'\n';
			ELSE
				sql_stmt:=sql_stmt||E'\t'||E'\t'||E'\t'||'   AND  c.year BETWEEN '||c5_rec.year_start::VARCHAR||
					' AND '||c5_rec.year_stop::VARCHAR||E'\n';
			END IF;
			IF c5_rec.genders = 3 THEN
				sql_stmt:=sql_stmt||E'\t'||E'\t'||E'\t'||E'\t'||'        /* No genders filter required for investigation '||j::VARCHAR||' */'||E'\n';
			ELSE
				sql_stmt:=sql_stmt||E'\t'||E'\t'||E'\t'||'   AND  TRUNC(c.'||LOWER(c4_rec.age_sex_group_field_name)||'/100) = '||c5_rec.genders::VARCHAR||E'\n';
			END IF;
			IF c8_rec.min_age_group = c5_rec.min_age_group AND c8_rec.max_age_group = c5_rec.max_age_group THEN
				sql_stmt:=sql_stmt||E'\t'||E'\t'||E'\t'||E'\t'||'        /* No age group filter required for investigation '||j::VARCHAR||' */)'||E'\n';
			ELSE 
				sql_stmt:=sql_stmt||E'\t'||E'\t'||E'\t'||'   AND  MOD(c.'||LOWER(c4_rec.age_sex_group_field_name)||', 100) BETWEEN '||
					c5_rec.min_age_group::VARCHAR||' AND '||c5_rec.max_age_group::VARCHAR||
					' /* Investigation '||j::VARCHAR||' year, age group filter */)'||E'\n';
			END IF;
--
			IF c4_rec.total_field IS NULL THEN /* Handle total fields */
				sql_stmt:=sql_stmt||E'\t'||E'\t'||E'\t'||') THEN 1'||E'\n';
			ELSE
				sql_stmt:=sql_stmt||E'\t'||E'\t'||E'\t'||') THEN '||LOWER(c4_rec.total_field)||E'\n';
			END IF;
			sql_stmt:=sql_stmt||E'\t'||E'\t'||E'\t'||'ELSE 0'||E'\n';
			sql_stmt:=sql_stmt||E'\t'||'       END) inv_'||c5_rec.inv_id::VARCHAR||'_'||LOWER(c5_rec.inv_name)||
				E'\t'||'/* Investigation '||j::VARCHAR||' - '||c5_rec.inv_description||' */ ';
		END LOOP;
--
-- Check at least one investigation
--
		IF j = 0 THEN
			PERFORM rif40_log_pkg.rif40_error(-90642, 'rif40_create_insert_statement', 
				'Study ID % no investigations created: distinct numerator: %',
				study_id::VARCHAR		/* Study ID */,		
				c4_rec.numer_tab::VARCHAR 	/* Distinct numerators */);
		END IF;
		sql_stmt:=sql_stmt||E'\n';

--
-- From clause
--
		sql_stmt:=sql_stmt||E'\t'||'  FROM '||LOWER(c4_rec.numer_tab)||' c, '||E'\t'||'/* '||c4_rec.description||' */'||E'\n';
		sql_stmt:=sql_stmt||E'\t'||'       '||areas_table||' s '||E'\t'||'/* Study or comparision area to be extracted */'||E'\n';
		IF study_or_comparison = 'C' THEN
			sql_stmt:=sql_stmt||E'\t'||' WHERE c.'||LOWER(c1_rec.comparison_geolevel_name)||' = s.area_id '||E'\t'||'/* Comparison selection */'||E'\n';
		ELSE
			sql_stmt:=sql_stmt||E'\t'||' WHERE c.'||LOWER(c1_rec.study_geolevel_name)||' = s.area_id '||E'\t'||'/* Study selection */'||E'\n';
		END IF;
--
-- [Add correct age_sex_group limits]
--
		IF c8_rec.min_age_group = c1_rec.min_age_group AND c8_rec.max_age_group = c1_rec.max_age_group THEN
			sql_stmt:=sql_stmt||E'\t'||'       /* No age group filter required for denominator */'||E'\n';
		ELSE 
			sql_stmt:=sql_stmt||E'\t'||'   AND MOD(c.'||LOWER(c8_rec.age_sex_group_field_name)||', 100) BETWEEN '||
				c1_rec.min_age_group::VARCHAR||' AND '||c1_rec.max_age_group::VARCHAR||
				' /* All valid age groups for denominator */'||E'\n';
		END IF;
		sql_stmt:=sql_stmt||E'\t'||'   AND s.study_id = $1'||E'\t'||E'\t'||'/* Current study ID */'||E'\n';
--
-- Processing years filter
--
		IF year_start = year_stop THEN
			sql_stmt:=sql_stmt||E'\t'||'   AND c.year = $2'||E'\t'||E'\t'||'/* Denominator (INSERT) year filter */'||E'\n';
		ELSE
			sql_stmt:=sql_stmt||E'\t'||'   AND c.year BETWEEN $2 AND $3'||E'\t'||'/* Denominator (INSERT) year filter */'||E'\n';
		END IF;
--
-- Group by clause
-- [Add support for differing age/sex/group names]
--
		sql_stmt:=sql_stmt||E'\t'||' GROUP BY c.year, s.area_id, c.'||LOWER(c4_rec.age_sex_group_field_name)||E'\n';

--
-- Close WITH clause (common table expression)
-- 
		sql_stmt:=sql_stmt||') /* '||c4_rec.numer_tab||' - '||c4_rec.description||' */'||E'\n';
--
	END LOOP;
--
-- Denominator CTE
--
	sql_stmt:=sql_stmt||', d AS ('||E'\n';
	IF study_or_comparison = 'C' THEN
		sql_stmt:=sql_stmt||E'\t'||'SELECT d1.year, s.area_id, NULL::INTEGER AS band_id, d1.'||LOWER(c8_rec.age_sex_group_field_name)||
			', SUM(COALESCE('||LOWER(coalesce(c8_rec.total_field, 'total'))||', 0)) AS total_pop'||E'\n';
	ELSE
		sql_stmt:=sql_stmt||E'\t'||'SELECT d1.year, s.area_id, s.band_id, d1.'||LOWER(c8_rec.age_sex_group_field_name)||
			', SUM(COALESCE('||LOWER(coalesce(c8_rec.total_field, 'total'))||', 0)) AS total_pop'||E'\n';
	END IF;
	sql_stmt:=sql_stmt||E'\t'||'  FROM '||LOWER(c1_rec.denom_tab)||' d1, '||areas_table||' s'||E'\t'||'/* Study or comparison area to be extracted */'||E'\n';
	sql_stmt:=sql_stmt||E'\t'||' WHERE d1.year = $2'||E'\t'||E'\t'||'/* Denominator (INSERT) year filter */'||E'\n';
	IF study_or_comparison = 'C' THEN
		sql_stmt:=sql_stmt||E'\t'||'   AND s.area_id  = d1.'||LOWER(c1_rec.comparison_geolevel_name)||E'\t'||'/* Comparison geolevel join */'||E'\n';
	ELSE
		sql_stmt:=sql_stmt||E'\t'||'   AND s.area_id  = d1.'||LOWER(c1_rec.study_geolevel_name)||E'\t'||'/* Study geolevel join */'||E'\n';
	END IF;
	sql_stmt:=sql_stmt||E'\t'||'   AND s.area_id  IS NOT NULL'||E'\t'||'/* Exclude NULL geolevel */'||E'\n';
	sql_stmt:=sql_stmt||E'\t'||'   AND s.study_id = $1'||E'\t'||E'\t'||'/* Current study ID */'||E'\n';
--
-- [Add correct age_sex_group limits]
--
	IF c8_rec.min_age_group = c1_rec.min_age_group AND c8_rec.max_age_group = c1_rec.max_age_group THEN
		sql_stmt:=sql_stmt||E'\t'||'       /* No age group filter required for denominator */'||E'\n';
	ELSE 
		sql_stmt:=sql_stmt||E'\t'||'   AND MOD(c.'||LOWER(c8_rec.age_sex_group_field_name)||', 100) BETWEEN '||
			c1_rec.min_age_group::VARCHAR||' AND '||c1_rec.max_age_group::VARCHAR||
			' /* All valid age groups for denominator */'||E'\n';
	END IF;
--
-- [Add gender filter]
--
	IF study_or_comparison = 'C' THEN
		sql_stmt:=sql_stmt||E'\t'||' GROUP BY d1.year, s.area_id, '||LOWER(c8_rec.age_sex_group_field_name)||E'\n';
	ELSE
		sql_stmt:=sql_stmt||E'\t'||' GROUP BY d1.year, s.area_id, s.band_id, d1.'||LOWER(c8_rec.age_sex_group_field_name)||E'\n';
	END IF;
	sql_stmt:=sql_stmt||')'||E'\n';
--
-- Main SQL statement
--
	sql_stmt:=sql_stmt||'SELECT d.year,'||E'\n';
	sql_stmt:=sql_stmt||'       '''||study_or_comparison||''' AS study_or_comparison,'||E'\n';
	sql_stmt:=sql_stmt||'       $1 AS study_id,'||E'\n';
	sql_stmt:=sql_stmt||'       d.area_id,'||E'\n';
	sql_stmt:=sql_stmt||'       d.band_id,'||E'\n';
--
-- [Add support for differing age/sex/group names]
--
	sql_stmt:=sql_stmt||'       TRUNC(d.'||LOWER(c8_rec.age_sex_group_field_name)||'/100) AS sex,'||E'\n';
	sql_stmt:=sql_stmt||'       MOD(d.'||LOWER(c8_rec.age_sex_group_field_name)||', 100) AS age_group,'||E'\n';
--
-- Add covariate names (Assumes 1 covariate table)
--
	k:=0;
	FOR c7_rec IN c7insext(study_id) LOOP
		k:=k+1;
		IF study_or_comparison = 'C' THEN
			sql_stmt:=sql_stmt||'       NULL::INTEGER AS '||LOWER(c7_rec.covariate_name)||','||E'\n';
		ELSE
			sql_stmt:=sql_stmt||'       c.'||LOWER(c7_rec.covariate_name)||','||E'\n';
		END IF;
	END LOOP;
--
-- Add investigations 
--
	sql_stmt:=sql_stmt||array_to_string(inv_array, ','||E'\n')||', '||E'\n';
--
-- Add denominator
--
	sql_stmt:=sql_stmt||'       d.total_pop'||E'\n';
--
-- FROM clause
--
	sql_stmt:=sql_stmt||'  FROM d'||E'\t'||E'\t'||E'\t'||'/* Denominator - '||c8_rec.description||' */'||E'\n';
	sql_stmt:=sql_stmt||array_to_string(inv_join_array, E'\n')||E'\n';
	IF study_or_comparison = 'S' THEN
		sql_stmt:=sql_stmt||E'\t'||'LEFT OUTER JOIN '||LOWER(c1_rec.covariate_table)||' c ON ('||E'\t'||'/* Covariates */'||E'\n';
		sql_stmt:=sql_stmt||E'\t'||E'\t'||'    d.area_id = c.'||LOWER(c1_rec.study_geolevel_name)||E'\n';
		sql_stmt:=sql_stmt||E'\t'||E'\t'||'AND d.year    = c.year)'||E'\n';
	END IF;
--
-- ORDER BY caluse
--
	sql_stmt:=sql_stmt||' ORDER BY 1, 2, 3, 4, 5, 6, 7';
--
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_create_insert_statement', 
		'SQL> %;', sql_stmt::VARCHAR);
--
	RETURN sql_stmt;
--
END;
]]></definition>
</function>

<function name="rif40_delete_study"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sm_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function:	rif40_delete_study()
Parameter:	Study ID
Returns:	Nothing
Description:	Delete study from tables:

RIF40_STUDY_SQL
RIF40_STUDY_SQL_LOG
RIF40_RESULTS
RIF40_CONTEXTUAL_STATS
RIF40_INV_CONDITIONS 
RIF40_INV_COVARIATES 
RIF40_INVESTIGATIONS 
RIF40_STUDY_AREAS 
RIF40_COMPARISON_AREAS 
RIF40_STUDY_SHARES
RIF40_STUDIES

Truncate extract and map tables if defined

Call: cleanup_orphaned_extract_and_map_tables()
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="study_id" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
/*
Function:	rif40_delete_study()
Parameter:	Study ID
Returns:	Nothing
Description:	Delete study from tables:

RIF40_STUDY_SQL
RIF40_STUDY_SQL_LOG
RIF40_RESULTS
RIF40_CONTEXTUAL_STATS
RIF40_INV_CONDITIONS 
RIF40_INV_COVARIATES 
RIF40_INVESTIGATIONS 
RIF40_STUDY_AREAS 
RIF40_COMPARISON_AREAS 
RIF40_STUDY_SHARES
RIF40_STUDIES 

Truncate extract and map tables if defined

Call: cleanup_orphaned_extract_and_map_tables()

 */
	c1_delst	CURSOR(l_study_id INTEGER) FOR
		SELECT *
		  FROM rif40_studies a
		 WHERE l_study_id = a.study_id;
	c1_rec		RECORD;
--
	sql_stmt	VARCHAR[];
	rows		INTEGER;
	schema 		VARCHAR;
BEGIN
	OPEN c1_delst(study_id);
	FETCH c1_delst INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1_delst;
		PERFORM rif40_log_pkg.rif40_error(-90601, 'rif40_delete_study', 
			'Study ID % not found',
			study_id::VARCHAR);
	END IF;
	CLOSE c1_delst;
--
	sql_stmt[1]:='DELETE FROM rif40_study_sql WHERE study_id = '||study_id::VARCHAR;
	sql_stmt[2]:='DELETE FROM rif40_study_sql_log WHERE study_id = '||study_id::VARCHAR;
	sql_stmt[3]:='DELETE FROM rif40_results WHERE study_id = '||study_id::VARCHAR;
	sql_stmt[4]:='DELETE FROM rif40_contextual_stats WHERE study_id = '||study_id::VARCHAR;
	sql_stmt[5]:='DELETE FROM rif40_inv_conditions WHERE study_id = '||study_id::VARCHAR;
	sql_stmt[6]:='DELETE FROM rif40_inv_covariates WHERE study_id = '||study_id::VARCHAR;
	sql_stmt[7]:='DELETE FROM rif40_investigations WHERE study_id = '||study_id::VARCHAR;
	sql_stmt[8]:='DELETE FROM rif40_study_areas WHERE study_id = '||study_id::VARCHAR;
	sql_stmt[9]:='DELETE FROM rif40_comparison_areas WHERE study_id = '||study_id::VARCHAR;
	sql_stmt[10]:='DELETE FROM rif40_study_shares WHERE study_id = '||study_id::VARCHAR;
	sql_stmt[11]:='DELETE FROM rif40_studies WHERE study_id = '||study_id::VARCHAR;
--
-- Drop extract and map tables if defined
-- (Cannot be dropped yets - requires definer function to cleanup all zero sized orphaned extract tables)
--
	schema:=rif40_sql_pkg.rif40_object_resolve(c1_rec.extract_table::VARCHAR);
	IF schema IS NOT NULL AND has_table_privilege(USER, schema||'.'||c1_rec.extract_table, 'truncate') THEN
		sql_stmt[array_length(sql_stmt, 1)+1]:='TRUNCATE TABLE '||schema||'.'||LOWER(c1_rec.extract_table);
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_delete_study', 
			'[90940] Will truncate extract table % for study %',
			c1_rec.extract_table::VARCHAR	/* Extract table */,
			study_id::VARCHAR		/* Study ID */);
--		sql_stmt[array_length(sql_stmt, 1)+1]:='DROP TABLE '||schema||'.'||LOWER(c1_rec.extract_table);
	END IF;
	schema:=rif40_sql_pkg.rif40_object_resolve(c1_rec.map_table::VARCHAR);
	IF schema IS NOT NULL AND has_table_privilege(USER, schema||'.'||c1_rec.map_table, 'truncate') THEN
		sql_stmt[array_length(sql_stmt, 1)+1]:='TRUNCATE TABLE '||schema||'.'||LOWER(c1_rec.map_table);
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_delete_study', 
			'[90941] Will truncate map table % for study %',
			c1_rec.map_table::VARCHAR	/* Map table */,
			study_id::VARCHAR		/* Study ID */);
--		sql_stmt[array_length(sql_stmt, 1)+1]:='DROP TABLE '||schema||'.'||LOWER(c1_rec.map_table);
	END IF;
--
	rows:=rif40_sql_pkg.rif40_ddl(sql_stmt);

	PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_delete_study', 
		'[90942] Deleted study: %; % rows deleted',
		 study_id::VARCHAR		/* Study ID */,
		 rows::VARCHAR 			/* Rows deleted */);
--
-- Cleanup and map and extract tables not referenced by a study (runs as rif40)
--
	PERFORM rif40_sm_pkg.cleanup_orphaned_extract_and_map_tables();
--
	RETURN;
END;
]]></definition>
</function>

<function name="rif40_execute_insert_statement"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sm_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function:	rif40_execute_insert_statement()
Parameter:	Study ID, SQL statement, description, year_start, year_stop
Returns:	Success or failure [BOOLEAN]
		Note this is to allow SQL executed by study extraction/results created to be logged (Postgres does not allow autonomous transactions)
		Verification and error checking raises EXCEPTIONS in the usual way; and will cause the SQL log to be lost
Description:	Execute INSERT SQL statement
		Log statements. Stop and return FALSE on error]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="study_id" in="true" default-value="NULL::integer">
		<type name="integer"/>
	</parameter>
	<parameter name="sql_stmt" in="true" default-value="NULL::integer">
		<type name="character varying"/>
	</parameter>
	<parameter name="description" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="year_start" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="year_stop" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
/*
Function:	rif40_execute_insert_statement()
Parameter:	Study ID, SQL statement, description, year_start, year_stop
Returns:	Success or failure [BOOLEAN]
		Note this is to allow SQL executed by study extraction/results created to be logged (Postgres does not allow autonomous transactions)
		Verification and error checking raises EXCEPTIONS in the usual way; and will cause the SQL log to be lost
Description:	Execute INSERT SQL statement
		Log statements. Stop and return FALSE on error
 */
	c1exinst CURSOR(l_study_id INTEGER) FOR
		SELECT MAX(statement_number) AS max_statement_number
		  FROM rif40_study_sql_log a
		 WHERE l_study_id = a.study_id;
	c2exinst REFCURSOR;
	c1_rec RECORD;
--
	l_rows		INTEGER:=0;
	stp		TIMESTAMP WITH TIME ZONE := clock_timestamp();
	etp		TIMESTAMP WITH TIME ZONE;
	elapsed_time	FLOAT:=0;
	l_log_message	VARCHAR:='OK';
	l_sqlcode	VARCHAR:='00000';
	t_ddl 		INTEGER;
	query_plan	VARCHAR[];
	query_plan_text	VARCHAR;
--
-- INSERT INTO t_rif_study_sql (view wont work until statement_type is fixed
--
-- 1 CREATE
-- 2 INSERT
-- 3 POST_INSERT
-- 4 NUMERATOR_CHECK
-- 5 DENOMINATOR_CHECK
--
	l_statement_type VARCHAR:='INSERT' /* INSERT: Local Postgres statement */;
	i		INTEGER:=0;
BEGIN
--
-- Get the maximum statement number for the logs
--
	OPEN c1exinst(study_id);
	FETCH c1exinst INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1exinst;
		PERFORM rif40_log_pkg.rif40_error(-90426, 'rif40_execute_insert_statement', 
			'Study ID % not found',
			study_id::VARCHAR		/* Study ID */);
	END IF;
	CLOSE c1exinst;
	t_ddl:=COALESCE(c1_rec.max_statement_number, 0)+1;
--
	BEGIN
		IF SUBSTR(sql_stmt, 1, 7) = 'EXPLAIN' THEN
			IF year_start IS NOT NULL AND year_stop IS NOT NULL AND year_start != year_stop THEN
				OPEN c2exinst FOR EXECUTE sql_stmt USING study_id, year_start, year_stop;
			ELSIF year_start IS NOT NULL AND year_stop IS NOT NULL AND year_start = year_stop THEN
				OPEN c2exinst FOR EXECUTE sql_stmt USING study_id, year_start;
			ELSE
				OPEN c2exinst FOR EXECUTE sql_stmt USING study_id;
			END IF;
			GET DIAGNOSTICS l_rows = ROW_COUNT;
 			LOOP
				i:=i+1;
				FETCH c2exinst INTO query_plan_text;
				EXIT WHEN NOT FOUND;
				query_plan[i]:=query_plan_text;
			END LOOP;
			etp:=clock_timestamp();
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_execute_insert_statement', 
				'[90427] Study ID %, statement: %'||E'\n'||'Description: %'||E'\n'||' query plan:'||E'\n'||'%'::VARCHAR,
				study_id::VARCHAR				/* Study ID */,
				t_ddl::VARCHAR					/* Statement number */,
				description::VARCHAR				/* Description */,
				array_to_string(query_plan, E'\n')::VARCHAR	/* Query plan */);
			l_log_message:=description::VARCHAR||' OK, took: '||age(etp, stp)::VARCHAR;
		ELSE
			IF year_start IS NOT NULL AND year_stop IS NOT NULL AND year_start != year_stop THEN
				EXECUTE sql_stmt USING study_id, year_start, year_stop;
			ELSIF year_start IS NOT NULL AND year_stop IS NOT NULL AND year_start = year_stop THEN
				EXECUTE sql_stmt USING study_id, year_start;
			ELSE
				EXECUTE sql_stmt USING study_id;
			END IF;
			GET DIAGNOSTICS l_rows = ROW_COUNT;
			etp:=clock_timestamp();
			l_log_message:=description::VARCHAR||' OK, inserted '||l_rows::VARCHAR||' rows, took: '||age(etp, stp)::VARCHAR;
		END IF;
     	EXCEPTION
--
-- Handle all errors
--
		WHEN others THEN
			etp:=clock_timestamp();
			l_sqlcode:=SQLSTATE;
			l_log_message:=format('ERROR, [90428] %s %s "%s" raised, took: %s', 
				description::VARCHAR		/* Description */,
				l_sqlcode::VARCHAR		/* SQLSTATE */,
				sqlerrm::VARCHAR		/* Error */,
				age(etp, stp)::VARCHAR		/* Human readable time take */);      
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_execute_insert_statement',
				'[90429] Study %: statement % (%) error: % "%" raised by'||E'\n'||'SQL> %;'||E'\n'||'After: %'::VARCHAR,
				study_id::VARCHAR		/* Study ID */,
				description::VARCHAR		/* Description */,
				t_ddl::VARCHAR			/* Statement number */,
				l_sqlcode::VARCHAR		/* SQLSTATE */,
				sqlerrm::VARCHAR		/* Error */,
				sql_stmt::VARCHAR		/* SQL */,
				age(etp, stp)::VARCHAR		/* Human readable time take */);      
			RETURN FALSE;
	END;
--
	elapsed_time:=EXTRACT(EPOCH FROM etp-stp);
--
-- Log statement 
--
	INSERT INTO rif40_study_sql_log(
		username, study_id, statement_type, statement_number, log_message, log_sqlcode, rowcount, start_time, elapsed_time)
	VALUES (
		USER, study_id,l_statement_type, 
		t_ddl, l_log_message, l_sqlcode, coalesce(l_rows, 0), stp, elapsed_time);
	INSERT INTO rif40_study_sql(username, study_id, statement_type, statement_number, sql_text, line_number)
	VALUES (USER, study_id, l_statement_type, t_ddl, sql_stmt, 1);  
--
	PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_execute_insert_statement',
		'[90430] Study %: %',
		study_id::VARCHAR,		/* Study ID */
		l_log_message::VARCHAR		/* Log message */);
--
	RETURN TRUE;
--
END;
]]></definition>
</function>

<function name="rif40_insert_extract"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sm_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[A]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="study_id" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
/*
Function:	rif40_insert_extract()
Parameter:	Study ID
Returns:	Success or failure [BOOLEAN]
		Note this is to allow SQL executed by study extraction/results created to be logged (Postgres does not allow autonomous transactions)
		Verification and error checking raises EXCEPTIONS in the usual way; and will cause the SQL log to be lost
Description:	Insert data into extract table


 */
	c1insext2 CURSOR(l_study_id INTEGER) FOR
		SELECT * 
		  FROM rif40_studies a
		 WHERE a.study_id = l_study_id;
	c1_rec RECORD;
--
	sql_stmt		VARCHAR;
--
	stp		TIMESTAMP WITH TIME ZONE := clock_timestamp();
	etp		TIMESTAMP WITH TIME ZONE;
BEGIN
	OPEN c1insext2(study_id);
	FETCH c1insext2 INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1insext2;
		PERFORM rif40_log_pkg.rif40_error(-90641, 'rif40_insert_extract', 
			'Study ID % not found',
			study_id::VARCHAR		/* Study ID */);
	END IF;
	CLOSE c1insext2;
--
-- Study area insert
--
	sql_stmt:='INSERT INTO g_rif40_study_areas(study_id, area_id, band_id)'||E'\n'||
		'SELECT study_id, area_id, band_id FROM rif40_study_areas WHERE study_id = $1 /* Current study ID */'::VARCHAR;
	IF rif40_sm_pkg.rif40_execute_insert_statement(study_id, sql_stmt, 'Study area insert'::VARCHAR) = FALSE THEN 
		RETURN FALSE;
	END IF;
--
-- Study extract insert
--	
-- This will eventually support paralleisation. Do year by year for the moment
--
	FOR i IN c1_rec.year_start .. c1_rec.year_stop LOOP
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_insert_extract', 
			'[90642] Study ID % INSERT study year %',
			study_id::VARCHAR		/* Study ID */,
			i::VARCHAR);
--
-- Do explain plan at the same time
--
		IF i = c1_rec.year_start THEN
			sql_stmt:=rif40_sm_pkg.rif40_create_insert_statement(study_id, 'S', i, i);
			IF rif40_sm_pkg.rif40_execute_insert_statement(study_id, 
				'EXPLAIN (VERBOSE, FORMAT text)'||E'\n'||sql_stmt, 
				'Study extract insert '||i::VARCHAR||' (EXPLAIN)'::VARCHAR, i, i) = FALSE THEN 
				RETURN FALSE;
			ELSIF rif40_sm_pkg.rif40_execute_insert_statement(study_id, 
				'EXPLAIN (ANALYZE, VERBOSE, COSTS, BUFFERS, /* TIMING, (9.2+) */ FORMAT text)'||E'\n'||sql_stmt, 
				'Study extract '||i::VARCHAR||' insert (EXPLAIN ANALYZE)'::VARCHAR, i, i) = FALSE THEN 
				RETURN FALSE;
			END IF;
		ELSIF rif40_sm_pkg.rif40_execute_insert_statement(study_id, sql_stmt, 
			'Study extract insert '||i::VARCHAR, i, i) = FALSE THEN 
			RETURN FALSE;
		END IF;
	END LOOP;
--
-- Comparison area insert
--
	sql_stmt:='INSERT INTO g_rif40_comparison_areas(study_id, area_id)'||E'\n'||
		'SELECT study_id, area_id FROM rif40_comparison_areas WHERE study_id = $1 /* Current study ID */'::VARCHAR;
	IF rif40_sm_pkg.rif40_execute_insert_statement(study_id, sql_stmt, 'Comparison area insert'::VARCHAR) = FALSE THEN 
		RETURN FALSE;
	END IF;
--
-- Comparison extract insert
--	
-- This will eventually support paralleisation. Do year by year for the moment
--
	FOR i IN c1_rec.year_start .. c1_rec.year_stop LOOP
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_insert_extract', 
			'[90643] Study ID % INSERT comparison year %',
			study_id::VARCHAR		/* Study ID */,
			i::VARCHAR);
--
-- Do explain plan at the same time
--
		IF i = c1_rec.year_start THEN
			sql_stmt:=rif40_sm_pkg.rif40_create_insert_statement(study_id, 'C', i, i);
			IF rif40_sm_pkg.rif40_execute_insert_statement(study_id, 
				'EXPLAIN (VERBOSE, FORMAT text)'||E'\n'||sql_stmt, 
				'Comparison extract insert '||i::VARCHAR||' (EXPLAIN)'::VARCHAR, i, i) = FALSE THEN 
				RETURN FALSE;
			ELSIF rif40_sm_pkg.rif40_execute_insert_statement(study_id, 
				'EXPLAIN (ANALYZE, VERBOSE, COSTS, BUFFERS, /* TIMING, (9.2+) */ FORMAT text)'||E'\n'||sql_stmt, 
				'Comparison extract '||i::VARCHAR||' insert (EXPLAIN ANALYZE)'::VARCHAR, i, i) = FALSE THEN 
				RETURN FALSE;
			END IF;
		ELSIF rif40_sm_pkg.rif40_execute_insert_statement(study_id, sql_stmt, 
			'Comparison extract insert '||i::VARCHAR, i, i) = FALSE THEN 
			RETURN FALSE;
		END IF;
	END LOOP;
--
	etp:=clock_timestamp();
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_insert_extract', 
		'[90644] Study ID % extract table INSERT in %',
		study_id::VARCHAR		/* Study ID */,
		age(etp, stp)::VARCHAR);
--
	RETURN TRUE;
--
END;
]]></definition>
</function>

<function name="rif40_reset_study"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sm_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function:	rif40_reset_study()
Parameter:	Study ID
Returns:	Nothing
Description:	Reset study to the 'C' (created state) so it can be re-run

Delete study from tables:

RIF40_STUDY_SQL
RIF40_STUDY_SQL_LOG
RIF40_RESULTS
RIF40_CONTEXTUAL_STATS

Truncate extract and map tables if defined

Update study state to 'C'

Call: cleanup_orphaned_extract_and_map_tables()
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="study_id" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
/*
Function:	rif40_reset_study()
Parameter:	Study ID
Returns:	Nothing
Description:	Reset study to the 'C' (created state) so it can be re-run

Delete study from tables:

RIF40_STUDY_SQL
RIF40_STUDY_SQL_LOG
RIF40_RESULTS
RIF40_CONTEXTUAL_STATS

Truncate extract and map tables if defined

Update study state to C

Call: cleanup_orphaned_extract_and_map_tables()
 */
	c1_reset CURSOR(l_study_id INTEGER) FOR
		SELECT *
		  FROM rif40_studies a
		 WHERE l_study_id = a.study_id;
	c1_rec		RECORD;
--
	sql_stmt	VARCHAR[];
	rows		INTEGER;
	schema 		VARCHAR;
--
	study_upd_count INTEGER;
	inv_upd_count INTEGER;
BEGIN
	OPEN c1_reset(study_id);
	FETCH c1_reset INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1_reset;
		PERFORM rif40_log_pkg.rif40_error(-90945, 'rif40_reset_study', 
			'Study ID % not found',
			study_id::VARCHAR);
	END IF;
	CLOSE c1_reset;
--
	sql_stmt[1]:='DELETE FROM rif40_study_sql WHERE study_id = '||study_id::VARCHAR;
	sql_stmt[2]:='DELETE FROM rif40_study_sql_log WHERE study_id = '||study_id::VARCHAR;
	sql_stmt[3]:='DELETE FROM rif40_results WHERE study_id = '||study_id::VARCHAR;
	sql_stmt[4]:='DELETE FROM rif40_contextual_stats WHERE study_id = '||study_id::VARCHAR;
--
-- Drop extract and map tables if defined
-- (Cannot be dropped yets - requires definer function to cleanup all zero sized orphaned extract tables)
--
	schema:=rif40_sql_pkg.rif40_object_resolve(c1_rec.extract_table::VARCHAR);
	IF schema IS NOT NULL AND has_table_privilege(USER, schema||'.'||c1_rec.extract_table, 'truncate') THEN
		sql_stmt[array_length(sql_stmt, 1)+1]:='TRUNCATE TABLE '||schema||'.'||LOWER(c1_rec.extract_table);
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_reset_study', 
			'[90946] Will truncate extract table % for study %',
			c1_rec.extract_table::VARCHAR	/* Extract table */,
			study_id::VARCHAR		/* Study ID */);
--		sql_stmt[array_length(sql_stmt, 1)+1]:='DROP TABLE '||schema||'.'||LOWER(c1_rec.extract_table);
	END IF;
	schema:=rif40_sql_pkg.rif40_object_resolve(c1_rec.map_table::VARCHAR);
	IF schema IS NOT NULL AND has_table_privilege(USER, schema||'.'||c1_rec.map_table, 'truncate') THEN
		sql_stmt[array_length(sql_stmt, 1)+1]:='TRUNCATE TABLE '||schema||'.'||LOWER(c1_rec.map_table);
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_reset_study', 
			'[90947] Will truncate map table % for study %',
			c1_rec.map_table::VARCHAR	/* Map table */,
			study_id::VARCHAR		/* Study ID */);
--		sql_stmt[array_length(sql_stmt, 1)+1]:='DROP TABLE '||schema||'.'||LOWER(c1_rec.map_table);
	END IF;
--
	rows:=rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Update study state
--
	EXECUTE 'UPDATE rif40_investigations a
	   SET investigation_state = ''C''
 	 WHERE a.study_id = $1' USING study_id;
	GET DIAGNOSTICS study_upd_count = ROW_COUNT;
	EXECUTE 'UPDATE rif40_studies a
	   SET study_state = ''C''
 	 WHERE a.study_id = $1' USING study_id;
	GET DIAGNOSTICS inv_upd_count = ROW_COUNT;
--
	PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_reset_study', 
		'[90948] Reset study: %; % rows deleted; % study, % investigation(s) updated',
		study_id::VARCHAR		/* Study ID */,
		rows::VARCHAR 			/* Rows deleted */,
		study_upd_count::VARCHAR 	/* Study update count */,
		inv_upd_count::VARCHAR 		/* Study update count */);
--
-- Cleanup and map and extract tables not referenced by a study (runs as rif40)
--
	PERFORM rif40_sm_pkg.cleanup_orphaned_extract_and_map_tables();
--
	RETURN;
--
END;
]]></definition>
</function>

<function name="rif40_run_study"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sm_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function:	rif40_run_study()
Parameter:	Study ID
Returns:	Success or failure [BOOLEAN]
		Note this is to allow SQL executed by study extraction/results created to be logged (Postgres does not allow autonomous transactions)
		Verification and error checking raises EXCEPTIONS in the usual way; and will cause the SQL log to be lost
		
Description:	Run study 

Check study state - 

C: created, not verfied; 
V: verified, but no other work done; 
E: extracted imported or created, but no results or maps created; 
R: results computed; 
U: upgraded record from V3.1 RIF (has an indeterminate state; probably R).

Define transition
Create extract, call: rif40_sm_pkg.rif40_create_extract()
Runs as rif40_sm_pkg NOT the user. This is so all objects created can be explicitly granted to the user
Compute results, call: rif40_sm_pkg.rif40_compute_results()
Do update. This forces verification
(i.e. change in study_State on rif40_studies calls rif40_sm_pkg.rif40_verify_state_change)
Recurse until complete]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="study_id" in="true" default-value="0">
		<type name="integer"/>
	</parameter>
	<parameter name="recursion_level" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
/*
Function:	rif40_run_study()
Parameter:	Study ID
Returns:	Success or failure [BOOLEAN]
		Note this is to allow SQL executed by study extraction/results created to be logged (Postgres does not allow autonomous transactions)
		Verification and error checking raises EXCEPTIONS in the usual way; and will cause the SQL log to be lost
Description:	Run study 

Check study state - 

C: created, not verfied; 
V: verified, but no other work done; 
E - extracted imported or created, but no results or maps created; 
R: results computed; 
U: upgraded record from V3.1 RIF (has an indeterminate state; probably R).

Define transition
Create extract, call: rif40_sm_pkg.rif40_create_extract()
Runs as rif40_sm_pkg NOT the user. This is so all objects created can be explicitly granted to the user
Compute results, call: rif40_sm_pkg.rif40_compute_results()
Do update. This forces verification
(i.e. change in study_State on rif40_studies calls rif40_sm_pkg.rif40_verify_state_change)
Recurse until complete
 */
	c1_runst CURSOR(l_study_id INTEGER) FOR
		WITH b AS (
			SELECT COUNT(inv_id) AS investigation_count
			  FROM rif40_investigations c
			 WHERE l_study_id = c.study_id
		)
		SELECT study_state, a.study_id, b.investigation_count 
		  FROM t_rif40_studies a, b /* MUST USE TABLE NOT VIEWS WHEN USING LOCKS/WHERE CURRENT OF */
		 WHERE l_study_id = a.study_id
		   FOR UPDATE;
	c1_rec RECORD;
--
	new_study_state 	VARCHAR;
	investigation_count 	INTEGER;
	study_count 		INTEGER;
	n_recursion_level 	INTEGER:=recursion_level+1;
--
	stp		TIMESTAMP WITH TIME ZONE := clock_timestamp();
	etp		TIMESTAMP WITH TIME ZONE;
BEGIN
--
-- Check study state and define transition
--
	OPEN c1_runst(study_id);
	FETCH c1_runst INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1_runst;
		PERFORM rif40_log_pkg.rif40_error(-90701, 'rif40_run_study', 
			'Study ID % not found',
			study_id::VARCHAR);
	END IF;
--
	IF c1_rec.study_state = 'C' THEN
		 new_study_state = 'V';
	ELSIF c1_rec.study_state = 'V' THEN
		 new_study_state = 'E';
	ELSIF c1_rec.study_state = 'E' THEN
		 new_study_state = 'R';
	ELSE
		CLOSE c1_runst;
		PERFORM rif40_log_pkg.rif40_error(-90702, 'rif40_run_study', 
			'Study ID % cannot be run, in state: %, needs to be in ''V'' or ''E''',
			study_id::VARCHAR,
			c1_rec.study_state::VARCHAR);
	END IF;
--
-- Create extract, call: rif40_sm_pkg.rif40_create_extract()
--
	IF new_study_state = 'E' THEN
		IF rif40_sm_pkg.rif40_create_extract(c1_rec.study_id) = FALSE THEN
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_run_study',
				'[90703] Call rif40_create_extract() for study % failed, see previous warnings',
				c1_rec.study_id::VARCHAR);
			CLOSE c1_runst;
			RETURN FALSE;
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_run_study',
				'[90704] Call rif40_create_extract() for study % OK',
				c1_rec.study_id::VARCHAR);
		END IF;
--
-- Compute results, call: rif40_sm_pkg.rif40_compute_results()
--
	ELSIF new_study_state = 'R' THEN
		IF rif40_sm_pkg.rif40_compute_results(c1_rec.study_id) = FALSE THEN
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_run_study',
				'[90705] Call rif40_compute_results() for study % failed, see previous warnings',
				c1_rec.study_id::VARCHAR);
			CLOSE c1_runst;
			RETURN FALSE;
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_run_study',
				'[90706] Call rif40_compute_results() for study % OK',
				c1_rec.study_id::VARCHAR);
		END IF;
	END IF;

--
-- Do update. This forces verification
-- (i.e. change in study_State on rif40_studies calls rif40_sm_pkg.rif40_verify_state_change)
--
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_run_study',
		'[90707] Start state transition (%=>%) for study %',
		c1_rec.study_state::VARCHAR,
		new_study_state::VARCHAR,
		c1_rec.study_id::VARCHAR);
	UPDATE rif40_investigations a SET investigation_state = new_study_state WHERE a.study_id = c1_rec.study_id;
	GET DIAGNOSTICS investigation_count = ROW_COUNT;
	IF investigation_count != c1_rec.investigation_count THEN
		PERFORM rif40_log_pkg.rif40_error(-90708, 'rif40_run_study', 
			'Excpeting to update % investigation(s), updated % during state transition (%=>%) for study %',
			c1_rec.investigation_count::VARCHAR,
			investigation_count::VARCHAR,
			c1_rec.study_state::VARCHAR,
			new_study_state::VARCHAR,
			c1_rec.study_id::VARCHAR);
	END IF;
--
-- MUST USE TABLE NOT VIEWS WHEN USING LOCKS/WHERE CURRENT OF
--
	UPDATE rif40_studies a SET study_state = new_study_state WHERE a.study_id = c1_rec.study_id;
	GET DIAGNOSTICS study_count = ROW_COUNT;
	etp:=clock_timestamp();
	PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_run_study',
		'[90709] Recurse [%] Completed state transition (%=>%) for study % with % investigation(s); time taken %',
		n_recursion_level::VARCHAR,
		c1_rec.study_state::VARCHAR,
		new_study_state::VARCHAR,
		c1_rec.study_id::VARCHAR,
		investigation_count::VARCHAR,
		age(etp, stp)::VARCHAR);
 
	CLOSE c1_runst;
--
-- Recurse until complete
--
	IF new_study_state != c1_rec.study_state AND new_study_state IN ('V', 'E') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_run_study',
			'[90710] Recurse [%] rif40_run_study using new state % for study %',
			n_recursion_level::VARCHAR,
			new_study_state::VARCHAR,
			c1_rec.study_id::VARCHAR);
		IF rif40_sm_pkg.rif40_run_study(c1_rec.study_id, n_recursion_level) = FALSE THEN /* Halt on failure */
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_run_study',
				'[90711] Recurse [%] rif40_run_study to new state % for study % failed, see previous warnings',
				n_recursion_level::VARCHAR,
				new_study_state::VARCHAR,
				c1_rec.study_id::VARCHAR);
			RETURN FALSE;
		END IF;
	ELSIF new_study_state != c1_rec.study_state AND new_study_state = 'R' THEN
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_run_study', E'\n'||
'************************************************************************'||E'\n'||
'*                                                                      *'||E'\n'||
'* [90712] Completed study %                         *'||E'\n'||
'*                                                                      *'||E'\n'||
'************************************************************************',
			RPAD(c1_rec.study_id::VARCHAR, 20)::VARCHAR);
	ELSE
		OPEN c1_runst(study_id);
		FETCH c1_runst INTO c1_rec;
		IF NOT FOUND THEN
			CLOSE c1_runst;
			PERFORM rif40_log_pkg.rif40_error(-90713, 'rif40_run_study', 
				'Study ID % not found, study in unexpected and unknown state',
				study_id::VARCHAR);
		END IF;
		PERFORM rif40_log_pkg.rif40_error(-90714, 'rif40_run_study', 
			'Study % in unexpected state %',
			c1_rec.study_id::VARCHAR,
			c1_rec.study_state::VARCHAR);
	END IF;
--
-- All recursion unwound
--
	IF recursion_level = 0 THEN
		etp:=clock_timestamp();
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_run_study',
			'[90713] Recursion complete rif40_run_study study % with % investigation(s); time taken %',
			c1_rec.study_id::VARCHAR,
			investigation_count::VARCHAR,
			age(etp, stp)::VARCHAR);
	END IF;
--
	RETURN TRUE;
END;
]]></definition>
</function>

<function name="rif40_study_ddl_definer"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY DEFINER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sm_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function:	rif40_study_ddl_definer()
Parameter:	Study ID, username [study owner], audsid, DDL statements to execute
Returns:	Success or failure [BOOLEAN]
		Note this is to allow SQL executed by study extraction/results created to be logged (Postgres does not allow autonomous transactions)
		Verification and error checking raises EXCEPTIONS in the usual way; and will cause the SQL log to be lost
Description:	Execute DDL statements as RIF40 (so the user cannot control access to extracted data)
		Log statements. Stop and return FALSE on error
Notes:

1. SQL created runs as rif40_sm_pkg NOT the user. This is so all objects created can be explicitly granted to the user
2. Verify AUDSID and USER

	Verify AUDSID and USER
	Study AUDSID and function AUDSID must be the same
	Study username and session username must be the same
	Study username and function username must be the same
	Study AUDSID and session AUDSID must be the same
	Confirm calling function is rif40_create_extract() [needs 9.3]

   Note that this currently limits this function to being executed by rif40_create_extract()
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="study_id" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="username" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="audsid" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="ddl_stmts" in="true">
		<type name="character varying" dimension="1"/>
	</parameter>
	<definition><![CDATA[
DECLARE
/*
Function:	rif40_study_ddl_definer()
Parameter:	Study ID, username [study owner], audsid, DDL statements to execute
Returns:	Success or failure [BOOLEAN]
		Note this is to allow SQL executed by study extraction/results created to be logged (Postgres does not allow autonomous transactions)
		Verification and error checking raises EXCEPTIONS in the usual way; and will cause the SQL log to be lost
Description:	Execute DDL statements as RIF40 (so the user cannot control access to extracted data)
		Log statements. Stop and return FALSE on error
Notes:

1. SQL created runs as rif40_sm_pkg NOT the user. This is so all objects created can be explicitly granted to the user
2. Verify AUDSID and USER

	Verify AUDSID and USER
	Study AUDSID and function AUDSID must be the same
	Study username and session username must be the same
	Study username and function username must be the same
	Study AUDSID and session AUDSID must be the same
	Confirm calling function is rif40_create_extract() [needs 9.2]

   Note that this currently limits this function to being executed by rif40_create_extract()

Issues:

Fix statement type in view/make it an integer

psql:v4_0_sahsuland_examples.sql:178: ERROR:  column "statement_type" is of type smallint but expression is of type text
LINE 11:     NEW.statement_type -* no default value *-,
             ^
HINT:  You will need to rewrite or cast the expression.
QUERY:  INSERT INTO t_rif40_study_sql (
                                username,
                                study_id,
                                statement_type,
                                statement_number,
                                sql_text,
                                line_number)
                        VALUES(
                                coalesce(NEW.username, "current_user"()),
                                coalesce(NEW.study_id, (currval('rif40_study_id_seq'::regclass))::integer),
                                NEW.statement_type -* no default value *-,
                                NEW.statement_number -* no default value *-,
                                NEW.sql_text -* no default value *-,
                                NEW.line_number -* no default value *-)
CONTEXT:  PL/pgSQL function "trgf_rif40_study_sql" line 8 at SQL statement
SQL statement "INSERT INTO rif40_study_sql(statement_type, statement_number, sql_text, line_number)
                VALUES (1::INTEGER -* Local Postgres statement *-, t_ddl, sql_stmt, 1::INTEGER)"
PL/pgSQL function "rif40_create_extract" line 193 at SQL statement

 */
	c1stddl CURSOR(l_study_id INTEGER) FOR
		SELECT MAX(statement_number) AS max_statement_number
		  FROM t_rif40_study_sql_log a
		 WHERE l_study_id = a.study_id;
	c2stddl CURSOR(l_study_id INTEGER) FOR
		SELECT *
		  FROM t_rif40_studies a
		 WHERE l_study_id = a.study_id;
	c1_rec RECORD;
	c2_rec RECORD;
--
	sql_stmt 	VARCHAR;
	t_ddl		INTEGER:=0;
	l_rows		INTEGER:=0;
	stp		TIMESTAMP WITH TIME ZONE := clock_timestamp();
	etp		TIMESTAMP WITH TIME ZONE;
	elapsed_time	FLOAT:=0;
	l_log_message	VARCHAR:='OK';
	l_sqlcode	VARCHAR:='00000';
--
-- INSERT INTO t_rif_study_sql (view wont work until statement_type is fixed
--
-- 1 CREATE
-- 2 INSERT
-- 3 POST_INSERT
-- 4 NUMERATOR_CHECK
-- 5 DENOMINATOR_CHECK
--
	l_statement_type VARCHAR:='CREATE' /* CREATE: Local Postgres statement */;
	session_audsid	VARCHAR:=SYS_CONTEXT('USERENV', 'SESSIONID');
BEGIN
--
-- Verify AUDSID and USER
-- Study AUDSID and function AUDSID must be the same
-- Study username and session username must be the same
-- Study username and function username must be the same
-- Study AUDSID and session AUDSID must be the same
-- 
-- Note that this currently limits this function to being executed by rif40_run_study()
--
	OPEN c2stddl(study_id);
	FETCH c2stddl INTO c2_rec;
	IF NOT FOUND THEN
		CLOSE c2stddl;
		PERFORM rif40_log_pkg.rif40_error(-90620, 'rif40_study_ddl_definer', 
			'Study ID % not found',
			study_id::VARCHAR		/* Study ID */);
	END IF;
	CLOSE c2stddl;
	IF c2_rec.audsid != audsid THEN
		PERFORM rif40_log_pkg.rif40_error(-90621, 'rif40_study_ddl_definer', 
			'Study ID % wrong audsid, expecting: %; got: %',
			study_id::VARCHAR		/* Study ID */,
			c2_rec.audsid::VARCHAR		/* Record AUDSID */,
			audsid::VARCHAR			/* Function AUDSID */);
	ELSIF c2_rec.username != username THEN
		PERFORM rif40_log_pkg.rif40_error(-90622, 'rif40_study_ddl_definer', 
			'Study ID % wrong username, expecting: %; got: %',
			study_id::VARCHAR		/* Study ID */,
			c2_rec.username::VARCHAR	/* Record USERNAME */,
			username::VARCHAR		/* Function USERNAME */);
	ELSIF session_user != username THEN
		PERFORM rif40_log_pkg.rif40_error(-90623, 'rif40_study_ddl_definer', 
			'Study ID % wrong session username, expecting: %; got: %; execution context user: %',
			study_id::VARCHAR		/* Study ID */,
			session_user::VARCHAR		/* Session USERNAME */,
			username::VARCHAR		/* Function USERNAME */,
			current_user::VARCHAR		/* Execution context USERNAME */);
	ELSIF session_audsid != audsid THEN
		PERFORM rif40_log_pkg.rif40_error(-90624, 'rif40_study_ddl_definer', 
			'Study ID % wrong session AUDSID, expecting: %; got: %; execution context user: %',
			study_id::VARCHAR		/* Study ID */,
			session_audsid::VARCHAR		/* Session USERNAME */,
			audsid::VARCHAR			/* Function USERNAME */,
			current_user::VARCHAR		/* Execution context USERNAME */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_study_ddl_definer', 
			'[90625] Study ID % session, record and function username verified: %; AUDSID verified: %, execution context user: %',
			study_id::VARCHAR		/* Study ID */,
			session_user::VARCHAR		/* Session USERNAME */,
			audsid::VARCHAR			/* Function AUDSID */,
			current_user::VARCHAR		/* Execution context USERNAME (RIF40) */);
	END IF;

--
-- Confirm calling function is rif40_create_extract() [needs 9.3/PG_CONTEXT]
--

--
-- Get the maximum statement number for the logs
--
	OPEN c1stddl(study_id);
	FETCH c1stddl INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1stddl;
		PERFORM rif40_log_pkg.rif40_error(-90626, 'rif40_study_ddl_definer', 
			'Study ID % not found',
			study_id::VARCHAR		/* Study ID */);
	END IF;
	CLOSE c1stddl;
	t_ddl:=COALESCE(c1_rec.max_statement_number, 0);
	IF t_ddl > 0 THEN
		l_statement_type:='POST_INSERT';
	END IF;
--
	FOREACH sql_stmt IN ARRAY ddl_stmts LOOP
		t_ddl:=t_ddl+1;	
--
-- Execute statement
--
		IF sql_stmt IS NOT NULL THEN
			BEGIN
				l_rows:=rif40_sql_pkg.rif40_ddl(sql_stmt);
--
				etp:=clock_timestamp();
				l_log_message:='OK, took: '||age(etp, stp);
 		     	EXCEPTION
--
-- Handle all errors
--
				WHEN others THEN
					etp:=clock_timestamp();
					l_sqlcode:=SQLSTATE;
					l_log_message:=format('ERROR, [90627] %s "%s" raised, took: %s', 
						l_sqlcode::VARCHAR		/* Error */,
						sqlerrm::VARCHAR		/* Error */,
						age(etp, stp)::VARCHAR		/* Human readable time take */);      
					PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_study_ddl_definer',
						'[90628] Study %: statement % error: % "%" raised by'||E'\n'||'SQL> %;'||E'\n'||' after: %',
						study_id::VARCHAR,		/* Study ID */
						t_ddl::VARCHAR			/* Statement number */,
						l_sqlcode::VARCHAR		/* Error */,
						sqlerrm::VARCHAR		/* Error */,
						sql_stmt::VARCHAR		/* SQL */,
						age(etp, stp)::VARCHAR		/* Human readable time take */);      
			END;
--
			elapsed_time:=EXTRACT(EPOCH FROM etp-stp);
--
-- Log statement 
--
			INSERT INTO t_rif40_study_sql_log(
				username, study_id, statement_type, statement_number, log_message, log_sqlcode, rowcount, start_time, elapsed_time, audsid)
			VALUES (
				username, study_id,l_statement_type, 
				t_ddl, l_log_message, l_sqlcode, coalesce(l_rows, 0), stp, elapsed_time, audsid);
			INSERT INTO t_rif40_study_sql(username, study_id, statement_type, statement_number, sql_text, line_number)
			VALUES (username, study_id, l_statement_type, t_ddl, sql_stmt, 1);  
--
--  Detect failure
--
			EXIT WHEN l_sqlcode != '00000' /* OK */;
		END IF;
	END LOOP;
--
	IF l_sqlcode != '00000' /* OK */ THEN
		PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_study_ddl_definer',
			'[90629] Study %: error prevents further processing',
			study_id::VARCHAR		/* Study ID */);
		RETURN FALSE;
	ELSE
		RETURN TRUE;
	END IF;
END;
]]></definition>
</function>

<function name="rif40_verify_state_change"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sm_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function:	rif40_verify_state_change()
Parameter:	Study ID, old study state, new study state
Returns:	New state after verification
Description:	State change function/checking functions - check:

Verify state transition
All study_id tables are populated
Results are not created before the appropriate state has been reached
Any not implemented WARNINGS become errors
Functionality reduction restrictions. Restricted to:
	One covariate
 	No direct standardisation (rif40_studies.direct_stand_tab IS NULL)
	Covariate study_geolevel_name must be the same as rif40_studies.study_geolevel_name
	Disease mapping only
	AGE_SEX_GROUP column only (i.e. no separate AGE_GROUP/AGE/SEX columns)

Study state - 

C: created, not verfied; 
V: verified, but no other work done; 
E - extracted imported or created, but no results or maps created; 
R: results computed; 
U: upgraded record from V3.1 RIF (has an indeterminate state; probably R).
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="character varying"/>
	</return-type>
	<parameter name="study_id" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="old_study_state" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="new_study_state" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
DECLARE
/*
Function:	rif40_verify_state_change()
Parameter:	Study ID, old study state, new study state
Returns:	New state after verification
Description:	State change function/checking functions - check:

Verify state transition
All study_id tables are populated
Results are not created before the appropriate state has been reached
Any not implemented WARNINGS become errors
Functionality reduction restrictions. Restricted to:
	One covariate
 	No direct standardisation (rif40_studies.direct_stand_tab IS NULL)
	Covariate study_geolevel_name must be the same as rif40_studies.study_geolevel_name
	Disease mapping only
	AGE_SEX_GROUP column only (i.e. no separate AGE_GROUP/AGE/SEX columns)

Study state - 

C: created, not verfied; 
V: verified, but no other work done; 
E - extracted imported or created, but no results or maps created; 
R: results computed; 
U: upgraded record from V3.1 RIF (has an indeterminate state; probably R).

*/
	c1_verst REFCURSOR;
	c2_verst CURSOR(l_study_id INTEGER) FOR
		WITH b AS (
			SELECT COUNT(inv_id) AS investigation_count
			  FROM rif40_investigations b1
			 WHERE l_study_id = b1.study_id
		), c AS ( 
			SELECT MAX(inv_covariate_count) AS max_inv_covariate_count
			  FROM (
				SELECT inv_id, COUNT(covariate_name) AS inv_covariate_count
				  FROM rif40_inv_covariates c1
				 WHERE l_study_id = c1.study_id
				 GROUP BY inv_id) c2
		)
		SELECT study_state, a.study_id, b.investigation_count, c.max_inv_covariate_count,
		       direct_stand_tab, study_type, 
		       d.age_sex_group_field_name AS denom_age_sex_group_field_name, denom_tab
		  FROM rif40_studies a, b, c, rif40_tables d
		 WHERE l_study_id  = a.study_id
		   AND a.denom_tab = d.table_name;
	c3_verst CURSOR(l_study_id INTEGER) FOR
		SELECT COUNT(a.study_geolevel_name) AS total_study_geolevel_name
		  FROM rif40_inv_covariates a, rif40_studies b
		 WHERE a.study_id            = b.study_id
		   AND a.study_geolevel_name != b.study_geolevel_name
		   AND l_study_id            = a.study_id;
	c4_verst CURSOR(l_study_id INTEGER) FOR
		SELECT age_sex_group_field_name AS numer_age_sex_group_field_name, numer_tab, inv_id
		  FROM rif40_investigations a, rif40_tables t
		 WHERE a.numer_tab = t.table_name
		   AND l_study_id  = a.study_id;
--
	c1_rec RECORD;
	c2_rec RECORD;
	c3_rec RECORD;
	c4_rec RECORD;
--
	c_v_transition_tables VARCHAR[] := ARRAY['rif40_inv_conditions', 'rif40_investigations', 
		'rif40_study_areas', 'rif40_comparison_areas'];
	v_e_transition_tables VARCHAR[] := ARRAY['rif40_study_sql', 'rif40_study_sql_log', 'rif40_inv_conditions', 'rif40_investigations', 
		'rif40_study_areas', 'rif40_comparison_areas'];
	e_r_transition_tables VARCHAR[] := ARRAY['rif40_study_sql', 'rif40_study_sql_log', 'rif40_inv_conditions', 'rif40_investigations', 
		'rif40_study_areas', 'rif40_comparison_areas', 'rif40_results' /*, 'rif40_contextual_stats' */];
	results_tables VARCHAR[] := ARRAY['rif40_results' /*, 'rif40_contextual_stats' */];
	transition_tables VARCHAR[];
	l_table VARCHAR;
	sql_stmt VARCHAR;
	missing_study_id_rows INTEGER:=0;
	unexpected_results_rows INTEGER:=0;
	not_implemented INTEGER:=0;
BEGIN
--
-- Verify state transition
--
	IF old_study_state = 'R' AND new_study_state != old_study_state THEN
		PERFORM rif40_log_pkg.rif40_error(-90800, 'rif40_verify_state_change', 
			'Attempting to change the state (%=>%) of upgraded RIF30 study %. Please clone',
			old_study_state::VARCHAR,
			new_study_state::VARCHAR,
			study_id::VARCHAR);
	ELSIF old_study_state = 'R' AND new_study_state != old_study_state THEN
		PERFORM rif40_log_pkg.rif40_error(-90801, 'rif40_verify_state_change', 
			'Attempting to change the state (%=>%) of a completed study %. Please clone',
			old_study_state::VARCHAR,
			new_study_state::VARCHAR,
			study_id::VARCHAR);
	ELSIF new_study_state = 'C' THEN /* Reset */
		transition_tables:=c_v_transition_tables;
	ELSIF old_study_state = 'C' AND new_study_state = 'V' THEN
		transition_tables:=c_v_transition_tables;
	ELSIF old_study_state = 'V' AND new_study_state = 'E' THEN
		transition_tables:=v_e_transition_tables;
	ELSIF old_study_state = 'E' AND new_study_state = 'R' THEN
		transition_tables:=e_r_transition_tables;
	ELSE
		PERFORM rif40_log_pkg.rif40_error(-90802, 'rif40_verify_state_change', 
			'Attempting invalid state transition (%=>%) for study %',
			old_study_state::VARCHAR,
			new_study_state::VARCHAR,
			study_id::VARCHAR);		
	END IF;
--
-- Check all study_id tables are populated
--
	FOREACH l_table IN ARRAY transition_tables LOOP
		sql_stmt:='SELECT COUNT(study_id) AS total FROM '||LOWER(l_table)||' WHERE study_id = $1';
		PERFORM rif40_log_pkg.rif40_log('DEBUG2', 'rif40_verify_state_change', 	
			'SQL> %;',
			sql_stmt::VARCHAR);
		OPEN c1_verst FOR EXECUTE sql_stmt USING study_id;
		FETCH c1_verst INTO c1_rec;
		IF c1_rec.total = 0 THEN
			missing_study_id_rows:=missing_study_id_rows+1;
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_verify_state_change', 
				'[90803] % table has no rows during attempted state transition (%=>%) for study %',
				l_table::VARCHAR,
				old_study_state::VARCHAR,
				new_study_state::VARCHAR,
				study_id::VARCHAR);		
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_verify_state_change', 
				'[90803] % table has % rows during attempted state transition (%=>%) for study %',
				l_table::VARCHAR,
				c1_rec.total::VARCHAR,
				old_study_state::VARCHAR,
				new_study_state::VARCHAR,
				study_id::VARCHAR);		
		END IF;
		CLOSE c1_verst;
	END LOOP;
	IF missing_study_id_rows > 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-90804, 'rif40_verify_state_change', 
			'% study_id tables have no rows during attempted state transition (%=>%) for study %',
			missing_study_id_rows::VARCHAR,
			old_study_state::VARCHAR,
			new_study_state::VARCHAR,
			study_id::VARCHAR);		
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_verify_state_change', 
			'[90804] No study_id tables have no rows during attempted state transition (%=>%) for study %',
			old_study_state::VARCHAR,
			new_study_state::VARCHAR,
			study_id::VARCHAR);		
	END IF;
--
-- Results are not created before the appropriate state has been reached
--
	IF old_study_state IN ('C', 'V') THEN
		FOREACH l_table IN ARRAY results_tables LOOP
			sql_stmt:='SELECT COUNT(study_id) AS total FROM '||LOWER(l_table)||' WHERE study_id = $1';
			PERFORM rif40_log_pkg.rif40_log('DEBUG2', 'rif40_verify_state_change', 	
				'SQL> %;',
				sql_stmt::VARCHAR);
			OPEN c1_verst FOR EXECUTE sql_stmt USING study_id;
			FETCH c1_verst INTO c1_rec;
			IF c1_rec.total = 0 THEN
				NULL;
			ELSE
				unexpected_results_rows:=unexpected_results_rows+1;
				PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_verify_state_change', 
					'[90805] Results % table has % rows during attempted state transition (%=>%) for study %',
					l_table::VARCHAR,
					c1_rec.total::VARCHAR,
					old_study_state::VARCHAR,
					new_study_state::VARCHAR,
					study_id::VARCHAR);
			END IF;
			CLOSE c1_verst;
		END LOOP;
		IF unexpected_results_rows > 0 THEN
			PERFORM rif40_log_pkg.rif40_error(-90806, 'rif40_verify_state_change', 
				'% study_id results tables have no rows during attempted state transition (%=>%) for study %',
				unexpected_results_rows::VARCHAR,
				old_study_state::VARCHAR,
				new_study_state::VARCHAR,
				study_id::VARCHAR);		
		ELSE	
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_verify_state_change', 
				'[90806] No study_id results tables have no rows during attempted state transition (%=>%) for study %',
				old_study_state::VARCHAR,
				new_study_state::VARCHAR,
				study_id::VARCHAR);		
		END IF;
	END IF;
--
-- Any not implemented WARNINGS become errors
-- Functionality reduction restrictions. Restricted to:
--	One covariate
-- 	No direct standardisation (rif40_studies.direct_stand_tab IS NULL)
--	Disease mapping only
--	AGE_SEX_GROUP column only (i.e. no separate AGE_GROUP/AGE/SEX columns)
--
	OPEN c2_verst(study_id);
	FETCH c2_verst INTO c2_rec;
	IF NOT FOUND THEN
		PERFORM rif40_log_pkg.rif40_error(-90807, 'rif40_verify_state_change', 
			'Study not found during attempted state transition (%=>%) for study %',
			old_study_state::VARCHAR,
			new_study_state::VARCHAR,
			study_id::VARCHAR);
	END IF;
	CLOSE c2_verst;
--
	IF c2_rec.max_inv_covariate_count > 1 THEN
		not_implemented:=not_implemented+1;
		PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_verify_state_change', 
			'[90808] Multiple covariates (% investigations()) not yet supported during attempted state transition (%=>%) for study %',
			c2_rec.max_inv_covariate_count::VARCHAR,
			old_study_state::VARCHAR,
			new_study_state::VARCHAR,
			study_id::VARCHAR);		
	END IF;
	IF c2_rec.direct_stand_tab IS NOT NULL THEN
		not_implemented:=not_implemented+1;
		PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_verify_state_change', 
			'[90809] Direct standardisation using % not yet supported during attempted state transition (%=>%) for study %',
			c2_rec.direct_stand_tab::VARCHAR,
			old_study_state::VARCHAR,
			new_study_state::VARCHAR,
			study_id::VARCHAR);		
	END IF;
	FOR c4_rec IN c4_verst(study_id) LOOP
		IF c4_rec.numer_age_sex_group_field_name IS NULL THEN
			not_implemented:=not_implemented+1;
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_verify_state_change', 
				'[90810] AGE_GROUP+SEX columns not yet supported (AGE_SEX_GROUP only) for numerator table % during attempted state transition (%=>%) for study %, investigation %',
				c4_rec.numer_tab::VARCHAR,
				old_study_state::VARCHAR,
				new_study_state::VARCHAR,
				study_id::VARCHAR,
				c4_rec.inv_id::VARCHAR);		
		END IF;
	END LOOP;
	IF c2_rec.denom_age_sex_group_field_name IS NULL THEN
		not_implemented:=not_implemented+1;
		PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_verify_state_change', 
			'[90811] AGE_GROUP+SEX columns not yet supported (AGE_SEX_GROUP only) for denominator table % during attempted state transition (%=>%) for study %',
			c2_rec.denom_tab::VARCHAR,
			old_study_state::VARCHAR,
			new_study_state::VARCHAR,
			study_id::VARCHAR);		
	END IF;
--
-- Study type:
-- 	1 - disease mapping, 
--	11 - Risk Analysis (many areas, one band), 
--	12 - Risk Analysis (point sources), 
--	13 - Risk Analysis (exposure covariates), 
--	14 - Risk Analysis (coverage shapefile), 
--	15 - Risk Analysis (exposure shapefile)
--
	IF c2_rec.study_type != 1 THEN
		not_implemented:=not_implemented+1;
		PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_verify_state_change', 
			'[90812] Non disease mapping studies (%) not yet supported during attempted state transition (%=>%) for study %',
			c2_rec.study_type::VARCHAR,
			old_study_state::VARCHAR,
			new_study_state::VARCHAR,
			study_id::VARCHAR);	
	END IF;
--
--	Covariate study_geolevel_name must be the same as rif40_studies.study_geolevel_name
--
	OPEN c3_verst(study_id);
	FETCH c3_verst INTO c3_rec;
	IF NOT FOUND THEN
		PERFORM rif40_log_pkg.rif40_error(-90813, 'rif40_verify_state_change', 
			'Study not found in rif40_inv_covariates during attempted state transition (%=>%) for study %',
			old_study_state::VARCHAR,
			new_study_state::VARCHAR,
			study_id::VARCHAR);
	END IF;
	CLOSE c3_verst;
	IF c3_rec.total_study_geolevel_name != 0 THEN
		not_implemented:=not_implemented+1;
		PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_verify_state_change', 
			'[90814] % investigation covariates found with differing <study_geolevel_name> - not yet supported during attempted state transition (%=>%) for study %',
			c3_rec.total_study_geolevel_name::VARCHAR,
			old_study_state::VARCHAR,
			new_study_state::VARCHAR,
			study_id::VARCHAR);	
	END IF;
--
	IF not_implemented > 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-90815, 'rif40_verify_state_change', 
			'% not yet supported features during attempted state transition (%=>%) for study %',
			not_implemented::VARCHAR,
			old_study_state::VARCHAR,
			new_study_state::VARCHAR,
			study_id::VARCHAR);
	END IF;
--		
	PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_verify_state_change', 
		'[90816] Attempted state transition (%=>%) verified for study %',
		old_study_state::VARCHAR,
		new_study_state::VARCHAR,
		study_id::VARCHAR);
--
	RETURN new_study_state;
END;
]]></definition>
</function>

<function name="_print_table_size"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	_print_table_size()
Parameters:	Table name
Returns:	Size of table in bytes 
Description:	Print size of table nicely]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="bigint"/>
	</return-type>
	<parameter name="table_name" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*
Function: 	_print_table_size()
Parameters:	Table name
Returns:	Size of table and indexes in bytes 
Description:	Print size of table nicely
 */
DECLARE
	t_size BIGINT;
	rel_size BIGINT;
BEGIN
	t_size:=pg_table_size(table_name);
	rel_size:=pg_total_relation_size(table_name);
	PERFORM rif40_log_pkg.rif40_log('INFO', '_print_table_size', 'Size of table %: %; indexes: %', 
		table_name::VARCHAR				/* Table name */,
		pg_size_pretty(t_size)::VARCHAR			/* Size of table */,
		pg_size_pretty(rel_size-t_size)::VARCHAR	/* Size of indexes */);
--
	RETURN rel_size;
END;
]]></definition>
</function>

<function name="_rif40_explain_ddl"
		window-func="false"
		returns-setof="true"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="1000">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	_rif40_explain_ddl()
Parameters:	SQL statement
Returns: 	TABLE of explain_line
Description:	Coerce EXPLAIN output into a table with a known column. 
		Supports EXPLAIN and EXPLAIN ANALYZE as text ONLY.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<parameter name="explain_line">
		<type name="text"/>
	</parameter>
	</return-type>
	<parameter name="sql_stmt" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*
Function: 	_rif40_explain_ddl()
Parameters:	SQL statement
Returns: 	TABLE of explain_line
Description:	Coerce EXPLAIN output into a table with a known column
		Supports EXPLAIN and EXPLAIN ANALYZE as text ONLY
 */
BEGIN
--
-- Must be rifupg34, rif40 or have rif_user or rif_manager role
--
	IF USER != 'rifupg34' AND NOT rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-20999, '_rif40_explain_ddl', 'User % must be rif40 or have rif_user or rif_manager role', 
			USER::VARCHAR);
	END IF;
--
	RETURN QUERY EXECUTE sql_stmt;
END;
]]></definition>
</function>

<function name="does_role_exist"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	does_role_exist()
Parameters:	Username
Returns:	TRUE or FALSE 
Description:	Does the role exist

To prevent errors like this:

rif40=> \COPY t_rif40_studies FROM '../sahsuv3_v4/data/t_rif40_studies.csv' WITH (FORMAT csv, QUOTE '"', ESCAPE '\\');
ERROR:  42704: role "LINDAB@PRIVATE.NET" does not exist
CONTEXT:  PL/pgSQL function "trigger_fct_t_rif40_studies_checks" line 127 at FETCH
COPY t_rif40_studies, line 1: "1046,LINDAB@PRIVATE.NET,EW01,SAHSU,Enter study name here,,,,S1046_EXTRACT,S1046_MAP,2013-03-22 17:15..."
LOCATION:  get_role_oid, acl.c:4822]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="username" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*
Function: 	does_role_exist()
Parameters:	Username
Returns:	TRUE or FALSE 
Description:	Does the role exist

To prevent errors like this:

rif40=> \COPY t_rif40_studies FROM '../sahsuv3_v4/data/t_rif40_studies.csv' WITH (FORMAT csv, QUOTE '"', ESCAPE '\');
ERROR:  42704: role "LINDAB@PRIVATE.NET" does not exist
CONTEXT:  PL/pgSQL function "trigger_fct_t_rif40_studies_checks" line 127 at FETCH
COPY t_rif40_studies, line 1: "1046,LINDAB@PRIVATE.NET,EW01,SAHSU,Enter study name here,,,,S1046_EXTRACT,S1046_MAP,2013-03-22 17:15..."
LOCATION:  get_role_oid, acl.c:4822

 */
DECLARE
	c1_umors CURSOR(l_username VARCHAR) FOR
		SELECT rolname FROM pg_roles WHERE rolname = l_username;
	c1_rec RECORD;
BEGIN
	OPEN c1_umors(username);	
	FETCH c1_umors INTO c1_rec;
	CLOSE c1_umors;
--
	IF c1_rec.rolname = username THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
]]></definition>
</function>

<function name="is_rif40_manager_or_schema"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	is_rif40_manager_or_schema()
Parameters:	None
Returns:	TRUE or FALSE 
Description:	Is user rif40 or does the user have the rif_manager role?]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<definition><![CDATA[
/*

Function: 	is_rif40_manager_or_schema()
Parameters:	None
Returns:	TRUE or FALSE 
Description:	Is user rif40 or does the user have the rif_manager role?
 */
DECLARE
BEGIN
	IF USER = 'rif40' THEN
		RETURN TRUE;
	ELSIF pg_has_role(USER, 'rif_manager', 'USAGE') THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
]]></definition>
</function>

<function name="is_rif40_user_manager_or_schema"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	is_rif40_user_manager_or_schema()
Parameters:	None
Returns:	TRUE or FALSE 
Description:	Is user rif40 or does the user have the rif_user or rif_manager role?
		The user postgres is never a RIF_USER]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<definition><![CDATA[
/*

Function: 	is_rif40_user_manager_or_schema()
Parameters:	None
Returns:	TRUE or FALSE 
Description:	Is user rif40 or does the user have the rif_user or rif_manager role?
		The user postgres is never a RIF_USER
 */
DECLARE
BEGIN
	IF USER = 'rif40' THEN
		RETURN TRUE;
	ELSIF USER = 'postgres' THEN
		RETURN FALSE;
	ELSIF pg_has_role(USER, 'rif_user', 'USAGE') THEN
		RETURN TRUE;
	ELSIF pg_has_role(USER, 'rif_manager', 'USAGE') THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
]]></definition>
</function>

<function name="rif40_auto_indirect_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_auto_indirect_checks()
Parameters:	table name
Returns: 	NULL if not found or not an indirect denominator, geography and counts
Description:	Automatic (Able to be used in automatic RIF40_NUM_DENOM (0/1, default 0). 
		A user specific T_RIF40_NUM_DENOM is supplied for other combinations. 
		Cannot be applied to direct standardisation denominator) is restricted to 1 denominator per geography.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="character varying"/>
	</return-type>
	<parameter name="l_table_name" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[

/*

Function: 	rif40_auto_indirect_checks()
Parameters:	table name
Returns: 	NULL if not found or not an indirect denominator, geography and counts
Description:	Automatic (Able to be used in automatic RIF40_NUM_DENOM (0/1, default 0). 
		A user specific T_RIF40_NUM_DENOM is supplied for other combinations. 
		Cannot be applied to direct standardisation denominator) is restricted to 1 denominator per geography.
 */
DECLARE
	c1 CURSOR(l_table VARCHAR) IS
		SELECT isindirectdenominator, isnumerator, automatic
		  FROM rif40_tables
		 WHERE l_table = table_name;
	c2 CURSOR(l_table VARCHAR) IS
		WITH valid_geog AS (
			SELECT g.geography
			  FROM rif40_geographies g
			 WHERE rif40_sql_pkg.rif40_num_denom_validate(g.geography, l_table) = 1
		)
		SELECT valid_geog.geography geography, COUNT(t.table_name) total_denominators
		  FROM rif40_tables t, valid_geog 
		 WHERE t.table_name            != l_table
		   AND t.isindirectdenominator = 1
   		   AND t.automatic             = 1
		   AND rif40_sql_pkg.rif40_num_denom_validate(valid_geog.geography, t.table_name) = 1
		 GROUP BY valid_geog.geography
		 ORDER BY 1;
	c3 CURSOR(l_geography VARCHAR, l_table VARCHAR) IS
		SELECT t.table_name 
		  FROM rif40_tables t 
		 WHERE t.table_name != l_table
		   AND t.isindirectdenominator = 1
   		   AND t.automatic             = 1
		   AND rif40_sql_pkg.rif40_num_denom_validate(l_geography, t.table_name) = 1
		 ORDER BY 1;
--
	c1_rec RECORD;
	c2_rec RECORD;
	c3_rec RECORD;
--
	msg 		VARCHAR:=NULL;
	dmsg 		VARCHAR:=NULL;
	i		INTEGER:=0;
	j		INTEGER:=0;
BEGIN
--
-- Must be rif40 or have rif_user or rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_auto_indirect_checks', 'User % must be rif40 or have rif_user or rif_manager role', 
			USER::VARCHAR);
	END IF;
--
-- If inputs are NULL return NULL 
--
	IF l_table_name IS NULL THEN
		RETURN NULL;
	END IF;
--
-- automatic indirect denominator checks
--
	OPEN c1(l_table_name);
	FETCH c1 INTO c1_rec;
	CLOSE c1;
	IF c1_rec.automatic = 0 OR c1_rec.isindirectdenominator != 1 OR c1_rec.isnumerator = 1 THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_auto_indirect_checks', 'table: % is not an automatic indirect denominator', 
			l_table_name::VARCHAR);
		RETURN NULL;
	END IF;
--
-- Check object is resolvable
--
	IF rif40_sql_pkg.rif40_is_object_resolvable(l_table_name) = 0 THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_auto_indirect_checks', 'table: % not resolvable', 
			l_table_name::VARCHAR);
		RETURN NULL;
	END IF;
--
	IF c1_rec.isindirectdenominator = 1 THEN
		FOR c2_rec IN c2(l_table_name) LOOP
			j:=j+1;
			IF c2_rec.total_denominators > 0 THEN
				IF msg IS NULL THEN
					msg:=E'\n'||c2_rec.geography||' '||c2_rec.total_denominators;
				ELSE
					msg:=msg||', '||c2_rec.geography||' '||c2_rec.total_denominators;
				END IF;
--
				i:=0;
				FOR c3_rec IN c3(c2_rec.geography, l_table_name) LOOP
					i:=i+1;
					IF i = 1 THEN
						dmsg:=' ('||c3_rec.table_name;
					ELSE
						dmsg:=dmsg||', '||c3_rec.table_name;
					END IF;
				END LOOP;
				dmsg:=dmsg||')';
				PERFORM rif40_log_pkg.rif40_log('DEBUG2', 'rif40_auto_indirect_checks', 'table[%]: %, geography: %; total_denominators = %; %', 
					j::VARCHAR, l_table_name::VARCHAR, c2_rec.geography::VARCHAR, c2_rec.total_denominators::VARCHAR, dmsg::VARCHAR);
			ELSE
				PERFORM rif40_log_pkg.rif40_log('DEBUG2', 'rif40_auto_indirect_checks', 'table[%]: %, geography: %; total_denominators = 0', 
					j::VARCHAR, l_table_name::VARCHAR, c2_rec.geography::VARCHAR);
			END IF;	
		END LOOP;
	END IF;	
	RETURN msg;
END;
]]></definition>
</function>

<function name="rif40_create_fdw_table"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_create_fdw_table()
Parameters: 	numerator_table, total_geographies, drop objects (boolean), FDW server name, FDW server type
Returns: 	Nothing
Description:	Attmept if needed to create FDW tables for potential FDW tables i.e. those numerators in RIF40_NUM_DENOM_ERRORS with no local table of the same name 

		ONLY SUPPORTS NUMERATORS - DENOMINATORS ARE EXPECTED TO ALWAYS BE LOCAL
		ONLY SUPPORTS TABLES AT PRESENT - MAY SUPPORT VIEWS AND MATERIALIZED VIEWS IN FUTURE]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="numerator_table" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="total_geographies" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="drop_objects" in="true">
		<type name="boolean"/>
	</parameter>
	<parameter name="fdwservername" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="fdwservertype" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	rif40_create_fdw_table()
Parameters: 	numerator_table, total_geographies, drop objects (boolean), FDW server name, FDW server type
Returns: 	Nothing
Description:	Attmept if needed to create FDW tables for potential FDW tables i.e. those numerators in RIF40_NUM_DENOM_ERRORS with no local table of the same name 

		ONLY SUPPORTS NUMERATORS - DENOMINATORS ARE EXPECTED TO ALWAYS BE LOCAL
		ONLY SUPPORTS TABLES AT PRESENT - MAY SUPPORT VIEWS AND MATERIALIZED VIEWS IN FUTURE
 */
DECLARE
	c2cfdwt CURSOR(l_table_or_view VARCHAR) FOR 	
		SELECT a.relname AS table_or_view				/* FDW tables */
		  FROM pg_foreign_table b, pg_roles r, pg_class a, pg_namespace n 
		 WHERE b.ftrelid  = a.oid
		   AND a.relowner = (SELECT oid FROM pg_roles WHERE rolname = USER)
		   AND a.relowner = r.oid
		   AND n.nspname  = USER
		   AND n.oid      = a.relnamespace
		   AND a.relname  = LOWER(l_table_or_view);
	c3cfdwt CURSOR(l_table_or_view VARCHAR) FOR 	
		SELECT *
		  FROM fdw_all_tables
		 WHERE table_name = UPPER(l_table_or_view);
	c4cfdwt CURSOR(l_table_or_view VARCHAR) FOR
		SELECT table_name, column_name,
		       CASE
				WHEN data_type = 'VARCHAR2'		 		THEN 'varchar('||data_length||')'
				WHEN data_type = 'CHAR' 				THEN 'char('||data_length||')'
				WHEN data_type = 'NUMBER' AND data_scale = 0 		THEN 'integer'
				WHEN data_type = 'NUMBER' AND data_scale != 0 		THEN 'numeric('||data_precision||','||data_scale||')'
				WHEN data_type = 'NUMBER' AND data_scale IS NULL 	THEN 'double precision'
				WHEN data_type = 'DATE' 				THEN 'timestamp'
				WHEN data_type LIKE 'TIMESTAMP(%) WITH TIME ZONE' 	THEN 'timestamp'
				WHEN data_type LIKE 'TIMESTAMP(%)' 			THEN 'timestamp'
				ELSE NULL	/* NEED TO RAISE AN ERROR HERE - IT WILL CAUSE ONE LATER */
		       END data_defn, data_type, data_length, data_scale, data_precision, column_id, comments
		  FROM fdw_all_tab_columns
		 WHERE table_name  = UPPER(l_table_or_view)
		 ORDER BY column_id;
	c5cfdwt CURSOR(l_table_or_view VARCHAR) FOR 	
		SELECT *
		  FROM rif40_fdw_tables
		 WHERE table_name = UPPER(l_table_or_view);
--
	c2cfdwt_rec RECORD;
	c3cfdwt_rec RECORD;
	c4cfdwt_rec RECORD;
	c5cfdwt_rec RECORD;
--
	create_fdw BOOLEAN:=FALSE;
	sql_stmt VARCHAR[];
	l_sql_stmt VARCHAR;
	column_list VARCHAR[];
	column_defn VARCHAR[];
	column_comment VARCHAR[];
	test_column VARCHAR;
	test VARCHAR;
--
	c_idx INTEGER:=0;
	j INTEGER:=0;
--
	error_message VARCHAR;
	v_detail VARCHAR:='(Not supported until 9.2; type SQL statement into psql to see remote error)';
BEGIN
--
-- Check if table exists
--
	OPEN c2cfdwt(numerator_table);
	FETCH c2cfdwt INTO c2cfdwt_rec;
	CLOSE c2cfdwt;
--
-- Get records from FDW_ALL_TABLES
--
	OPEN c3cfdwt(numerator_table);
	FETCH c3cfdwt INTO c3cfdwt_rec;
	CLOSE c3cfdwt;
--
-- Get records from RIF40_FDW_TABLES
--
	OPEN c5cfdwt(numerator_table);
	FETCH c5cfdwt INTO c5cfdwt_rec;
	CLOSE c5cfdwt;
--
	IF c2cfdwt_rec.table_or_view IS NOT NULL /* Already exists */ AND drop_objects THEN
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_create_fdw_table', 'Re-creating foreign data wrapper table: %', 
			c2cfdwt_rec.table_or_view::VARCHAR);
		create_fdw:=TRUE;
		sql_stmt[1]:='DROP FOREIGN TABLE '||USER||'.'||LOWER(numerator_table);
	ELSIF c2cfdwt_rec.table_or_view IS NOT NULL /* Already exists */ AND NOT drop_objects AND c5cfdwt_rec.table_name IS NULL THEN
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_create_fdw_table', 'Re-creating foreign data wrapper table: %; no entry in RIF40_FDW_TABLES', 
			c2cfdwt_rec.table_or_view::VARCHAR);
		create_fdw:=TRUE;
		sql_stmt[1]:='DROP FOREIGN TABLE '||USER||'.'||LOWER(numerator_table);
	ELSIF c2cfdwt_rec.table_or_view IS NOT NULL /* Already exists */ AND NOT drop_objects THEN
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_create_fdw_table', 'Foreign data wrapper table: % exists; create status: %, date: %', 
			c2cfdwt_rec.table_or_view::VARCHAR, c5cfdwt_rec.create_status::VARCHAR, c5cfdwt_rec.date_created::VARCHAR);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_create_fdw_table', 'Creating foreign data wrapper table: %', 
			LOWER(numerator_table)::VARCHAR);
		create_fdw:=TRUE;
	END IF;
--
-- If the table needs to be created, check it is accessible remotely
--
	IF create_fdw THEN
--
		IF c3cfdwt_rec.table_name IS NULL THEN
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_create_fdw_table', 'Cannot find numerator table % in remote FDW_ALL_TABLES on % server %', 
				LOWER(numerator_table)::VARCHAR, fdwservertype::VARCHAR, fdwservername::VARCHAR);
			create_fdw:=FALSE;
		ELSIF STRPOS(c3cfdwt_rec.owner, '@') > 1 /* Kerberos user */ THEN
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_create_fdw_table', 'Found numerator table "%".% in remote FDW_ALL_TABLES on % server %', 
				c3cfdwt_rec.owner::VARCHAR, c3cfdwt_rec.table_name::VARCHAR, fdwservertype::VARCHAR, fdwservername::VARCHAR);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_create_fdw_table', 'Found numerator table %.% in remote FDW_ALL_TABLES on % server %', 
				c3cfdwt_rec.owner::VARCHAR, c3cfdwt_rec.table_name::VARCHAR, fdwservertype::VARCHAR, fdwservername::VARCHAR);
		END IF;
	END IF;
--
-- OK, so get list of columns
--
	IF create_fdw THEN
		l_sql_stmt:='CREATE FOREIGN TABLE '||USER||'.'||LOWER(numerator_table)||' ('||E'\n';
		FOR c4cfdwt_rec IN c4cfdwt(numerator_table) LOOP
			column_list[c4cfdwt_rec.column_id]:=c4cfdwt_rec.column_name;
			column_defn[c4cfdwt_rec.column_id]:=LOWER(c4cfdwt_rec.column_name)||E'\t'||c4cfdwt_rec.data_defn;
			column_comment[c4cfdwt_rec.column_id]:=c4cfdwt_rec.comments;
		END LOOP;
		FOR i IN array_lower(column_list, 1) .. array_upper(column_list, 1) LOOP
			IF column_defn[i] IS NOT NULL THEN
				c_idx:=c_idx+1;
				IF c_idx = 1 THEN
					test_column:=column_list[i];
					l_sql_stmt:=l_sql_stmt||E'\t'||column_defn[i];
				ELSE
					l_sql_stmt:=l_sql_stmt||','||E'\n'||E'\t'||column_defn[i];
				END IF;
			END IF;
		END LOOP;
		IF STRPOS(c3cfdwt_rec.owner, '@') > 1 /* Kerberos user */ THEN
			l_sql_stmt:=l_sql_stmt||E'\n'||') SERVER '||fdwservername||' OPTIONS (SCHEMA ''"'||c3cfdwt_rec.owner||'"'', TABLE '''||c3cfdwt_rec.table_name||''')';
		ELSE
			l_sql_stmt:=l_sql_stmt||E'\n'||') SERVER '||fdwservername||' OPTIONS (SCHEMA '''||c3cfdwt_rec.owner||''', TABLE '''||c3cfdwt_rec.table_name||''')';
		END IF;
		sql_stmt[2]:=l_sql_stmt;
		FOR i IN array_lower(column_list, 1) .. array_upper(column_list, 1) LOOP
			sql_stmt[array_upper(sql_stmt, 1)+1]:='COMMENT ON FOREIGN TABLE '||USER||'.'||LOWER(numerator_table)||' IS '''||
				REPLACE(column_comment[i], '''', ''''||'''' /* Escape comments */)||'''';
		END LOOP;
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		j:=1;
	END IF;

--
-- Test
--
	IF test_column IS NULL THEN /* Guess year */
		test:=rif40_sql_pkg.rif40_fdw_table_select_test(LOWER(numerator_table), 'YEAR', fdwservername, fdwservertype);
	ELSE
		test:=rif40_sql_pkg.rif40_fdw_table_select_test(LOWER(numerator_table), test_column, fdwservername, fdwservertype);
	END IF;
	IF test IS NULL THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_create_fdw_table', 'Foreign data wrapper numerator table: % tested OK', 
			LOWER(numerator_table)::VARCHAR);
		PERFORM rif40_sql_pkg.rif40_update_fdw_tables(
			UPPER(numerator_table) /* table name */, 'C' /* Create status */, NULL::varchar /* Error message */, 1 /* Rowtest passed */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_create_fdw_table', 'returned: %', 
			test::VARCHAR);
		l_sql_stmt:='DROP FOREIGN TABLE '||USER||'.'||LOWER(numerator_table);
		PERFORM rif40_sql_pkg.rif40_ddl(l_sql_stmt);
		PERFORM rif40_sql_pkg.rif40_update_fdw_tables(
			UPPER(numerator_table) /* table name */, 'E' /* Create status */, test /* Error message */, 0 /* Rowtest NOT passed */);
--
		PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_create_fdw_table', 'Foreign data wrapper numerator table: % test SELECT returned error', 
			LOWER(numerator_table)::VARCHAR);
	END IF;
--
	RETURN j;
EXCEPTION
	WHEN others THEN
-- 
-- Not supported until 9.2
--
--		GET STACKED DIAGNOTICS v_detail = PG_EXCETION_DETAIL;
		error_message:='rif40_create_fdw_table() caught: '||E'\n'||SQLERRM::VARCHAR||' in SQL (see previous trapped error)'||E'\n'||'for FDW '||
			LOWER(numerator_table)::VARCHAR||' on '||fdwservertype::VARCHAR||' server '||fdwservername::VARCHAR||E'\n'||'Detail: '||v_detail::VARCHAR;
		RAISE INFO '1: %', error_message;
		PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_create_fdw_table', 'Caught exception: % [IGNORED]', 
			error_message::VARCHAR);
		RAISE INFO '2: %', error_message;
		PERFORM rif40_sql_pkg.rif40_update_fdw_tables(
			UPPER(numerator_table) /* table name */, 'N' /* Create status */, error_message /* Error message */, 0 /* Rowtest NOT passed */);
		BEGIN
			l_sql_stmt:='DROP FOREIGN TABLE '||USER||'.'||LOWER(numerator_table);
			PERFORM rif40_sql_pkg.rif40_ddl(l_sql_stmt);
		EXCEPTION
			WHEN others THEN NULL;
		END;
--		RAISE /* the original error */;
--
-- Or you could just return (which is what we will do in the long run)
--
		RETURN 0;
END;
]]></definition>
</function>

<function name="rif40_create_fdw_view"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_create_fdw_view()
Parameters: 	Drop objects (boolean), FDW server name, FDW server type, FDW name for remote view, remote column to be tested, arrays of SQL statements
Returns: 	Nothing
Description:	Create support view if needed (FDW_ALL_TABLES, FDW_ALL_TAB_COLUMNS)

Sse rif40_create_fdw_views() for SQL exmaples

This contains Oracle specific code (i.e. data dictionary items ALL_TABLES, ALL_TAB_COLUMNS owned by SYS)

Test user can select from FDW table name using rif40_sql_pkg.rif40_fdw_table_select_test()]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="drop_objects" in="true">
		<type name="boolean"/>
	</parameter>
	<parameter name="fdwservername" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="fdwservertype" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_view" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_column" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="sql_stmt" in="true">
		<type name="character varying" dimension="1"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	rif40_create_fdw_view()
Parameters: 	Drop objects (boolean), FDW server name, FDW server type, FDW name for remote view, remote column to be tested, arrays of SQL statements
Returns: 	Nothing
Description:	Create support view if needed (FDW_ALL_TABLES, FDW_ALL_TAB_COLUMNS)

Sse rif40_create_fdw_views() for SQL exmaples

This contains Oracle specific code (i.e. data dictionary items ALL_TABLES, ALL_TAB_COLUMNS owned by SYS)

Test user can select from FDW table name using rif40_sql_pkg.rif40_fdw_table_select_test()

 */
DECLARE
	c2cfdwv CURSOR(l_table_or_view VARCHAR) FOR 	
		SELECT a.relname AS table_or_view				/* FDW tables */
		  FROM pg_foreign_table b, pg_roles r, pg_class a, pg_namespace n 
		 WHERE b.ftrelid  = a.oid
		   AND a.relowner = (SELECT oid FROM pg_roles WHERE rolname = USER)
		   AND a.relowner = r.oid
		   AND n.nspname  = USER
		   AND n.oid      = a.relnamespace
		   AND a.relname  = LOWER(l_table_or_view);
--
	c2cfdwv_rec RECORD;
--
	test VARCHAR;
	i INTEGER:=0;
	l_sql_stmt VARCHAR[]:=sql_stmt;
BEGIN
	OPEN c2cfdwv(l_view);
	FETCH c2cfdwv INTO c2cfdwv_rec;
	CLOSE c2cfdwv;
	IF c2cfdwv_rec.table_or_view IS NOT NULL /* Already exists */ AND drop_objects THEN
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_create_fdw_view', 'Re-creating foreign data wrapper view: %', 
			c2cfdwv_rec.table_or_view::VARCHAR);
		l_sql_stmt[1]:='DROP FOREIGN TABLE '||USER||'.'||l_view;
		PERFORM rif40_sql_pkg.rif40_ddl(l_sql_stmt);
		i:=1;
	ELSIF c2cfdwv_rec.table_or_view IS NOT NULL /* Already exists */ AND NOT drop_objects THEN
		NULL;
	ELSE
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_create_fdw_view', 'Creating foreign data wrapper view: %', 
			l_view::VARCHAR);
		PERFORM rif40_sql_pkg.rif40_ddl(l_sql_stmt);
		i:=i+1;
	END IF;
--
-- Test
--
	test:=rif40_sql_pkg.rif40_fdw_table_select_test(l_view, l_column, fdwservername, fdwservertype);
	IF test IS NULL THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_create_fdw_view', 'Foreign data wrapper view: % tested OK', 
			l_view::VARCHAR);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_create_fdw_view', 'returned: %', 
			test::VARCHAR);
		l_sql_stmt:=NULL;
		l_sql_stmt[1]:='DROP FOREIGN TABLE '||USER||'.'||l_view;
		PERFORM rif40_sql_pkg.rif40_ddl(l_sql_stmt);
		PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_create_fdw_view', 'Foreign data wrapper view: % test SELECT returned error', 
			l_view::VARCHAR);
	END IF;
--
	RETURN i;
END;
]]></definition>
</function>

<function name="rif40_create_fdw_views"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_create_fdw_views()
Parameters: 	Drop objects (boolean), FDW server name, FDW server type
Returns: 	Nothing
Description:	Create support views if needed (FDW_ALL_TABLES, FDW_ALL_TAB_COLUMNS) using rif40_sql_pkg.rif40_create_fdw_view()

CREATE FOREIGN TABLE fdw_all_tables (
	owner		VARCHAR(30),
	table_name	VARCHAR(30),
	comments	VARCHAR(4000)
) SERVER eph1 OPTIONS (SCHEMA 'SAHSU', TABLE 'RIF_ALL_TABLES');

CREATE FOREIGN TABLE fdw_all_tab_columns (
	owner		VARCHAR(30),
	table_name	VARCHAR(30),
	column_name	VARCHAR(30),
	data_type       VARCHAR(106),
 	data_length     NUMERIC(22,0), 
 	data_precision  NUMERIC(22,0),
 	data_scale      NUMERIC(22,0),
 	column_id       NUMERIC(22,0),
	comments	VARCHAR(4000)
) SERVER eph1 OPTIONS (SCHEMA 'SAHSU', TABLE 'RIF_ALL_TAB_COLUMNS');

This contains Oracle specific code (i.e. data dictionary items ALL_TABLES, ALL_TAB_COLUMNS owned by SYS)

Test user can select from FDW table name

RIF_ALL_TAB_COLUMNS is defined (as user SAHSU) as:

CREATE OR REPLACE VIEW rif_all_tab_columns AS
SELECT t.owner, t.table_name, t.column_name, 
       data_type,
       CAST(data_length AS NUMBER(22,0)) AS data_length,  
       CAST(data_precision AS NUMBER(22,0)) AS data_precision, 
       CAST(data_scale AS NUMBER(22,0)) AS data_scale,
       CAST(column_id AS NUMBER(22,0)) AS column_id, 
       c.comments
  FROM all_tab_columns t
	LEFT OUTER JOIN all_col_comments c ON (c.owner = t.owner AND c.table_name = t.table_name AND c.column_name = t.column_name);
GRANT SELECT ON rif_all_tab_columns TO PUBLIC;
EXECUTE recreate_public_synonym('rif_all_tab_columns');
DESC rif_all_tab_columns
COLUMN data_type FORMAT a20
SELECT  * from rif_all_tab_columns where table_name = 'RIF_CANC_EW_74_ON_ED91';

CREATE OR REPLACE VIEW rif40_all_tables AS
SELECT t.owner, t.table_name, c.comments
  FROM all_tab_columns t
	LEFT OUTER JOIN all_col_comments c ON (c.owner = t.owner AND c.table_name = t.table_name);
GRANT SELECT ON rif40_all_tables TO PUBLIC;
EXECUTE recreate_public_synonym('rif40_all_tables');
DESC rif40_all_tables
SELECT  * from rif40_all_tables where table_name = 'RIF_CANC_EW_74_ON_ED91';

This has been create to define the NUMBER data type exactly (the is a bug in Oracle FDW); and to include the column comments

The ordering of column in Oracle FDW must be the same as in Oracle
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="drop_objects" in="true">
		<type name="boolean"/>
	</parameter>
	<parameter name="fdwservername" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="fdwservertype" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	rif40_create_fdw_views()
Parameters: 	Drop objects (boolean), FDW server name, FDW server type
Returns: 	Nothing
Description:	Create support views if needed (FDW_ALL_TABLES, FDW_ALL_TAB_COLUMNS) using rif40_sql_pkg.rif40_create_fdw_view()

CREATE FOREIGN TABLE fdw_all_tables (
	owner		VARCHAR(30),
	table_name	VARCHAR(30),
	comments	VARCHAR(4000)
) SERVER eph1 OPTIONS (SCHEMA 'SAHSU', TABLE 'RIF_ALL_TABLES');

CREATE FOREIGN TABLE fdw_all_tab_columns (
	owner		VARCHAR(30),
	table_name	VARCHAR(30),
	column_name	VARCHAR(30),
	data_type       VARCHAR(106),
 	data_length     NUMERIC(22,0), 
 	data_precision  NUMERIC(22,0),
 	data_scale      NUMERIC(22,0),
 	column_id       NUMERIC(22,0),
	comments	VARCHAR(4000)
) SERVER eph1 OPTIONS (SCHEMA 'SAHSU', TABLE 'RIF_ALL_TAB_COLUMNS');

This contains Oracle specific code (i.e. data dictionary items ALL_TABLES, ALL_TAB_COLUMNS owned by SYS)

Test user can select from FDW table name

RIF_ALL_TAB_COLUMNS is defined (as user SAHSU) as:

CREATE OR REPLACE VIEW rif_all_tab_columns AS
SELECT t.owner, t.table_name, t.column_name, 
       data_type,
       CAST(data_length AS NUMBER(22,0)) AS data_length,  
       CAST(data_precision AS NUMBER(22,0)) AS data_precision, 
       CAST(data_scale AS NUMBER(22,0)) AS data_scale,
       CAST(column_id AS NUMBER(22,0)) AS column_id, 
       c.comments
  FROM all_tab_columns t
	LEFT OUTER JOIN all_col_comments c ON (c.owner = t.owner AND c.table_name = t.table_name AND c.column_name = t.column_name);
GRANT SELECT ON rif_all_tab_columns TO PUBLIC;
EXECUTE recreate_public_synonym('rif_all_tab_columns');
DESC rif_all_tab_columns
COLUMN data_type FORMAT a20
SELECT  * from rif_all_tab_columns where table_name = 'RIF_CANC_EW_74_ON_ED91';

CREATE OR REPLACE VIEW rif40_all_tables AS
SELECT t.owner, t.table_name, c.comments
  FROM all_tab_columns t
	LEFT OUTER JOIN all_col_comments c ON (c.owner = t.owner AND c.table_name = t.table_name);
GRANT SELECT ON rif40_all_tables TO PUBLIC;
EXECUTE recreate_public_synonym('rif40_all_tables');
DESC rif40_all_tables
SELECT  * from rif40_all_tables where table_name = 'RIF_CANC_EW_74_ON_ED91';

This has been create to define the NUMBER data type exactly (the is a bug in Oracle FDW); and to include the column comments

The ordering of column in Oracle FDW must be the same as in Oracle

 */
DECLARE
	l_view	VARCHAR;
	l_column VARCHAR;
	sql_stmt VARCHAR[];
	i INTEGER:=0;
BEGIN
	l_view:='fdw_all_tables';
	l_column:='table_name';
	sql_stmt[2]:='CREATE FOREIGN TABLE '||USER||'.fdw_all_tables ('||E'\n'||
		E'\t'||'owner		VARCHAR(30),'||E'\n'||
		E'\t'||'table_name	VARCHAR(30),'||E'\n'||
		E'\t'||'comments	VARCHAR(4000)'||E'\n'||
		') SERVER '||fdwservername||' OPTIONS (SCHEMA ''SAHSU'', TABLE ''RIF40_ALL_TABLES'')';
	sql_stmt[3]:='COMMENT ON FOREIGN TABLE '||USER||'.fdw_all_tables IS ''List of remote tables/views/materialized views accessible via foreign data wrapper '||
		fdwservertype||' server '||fdwservername||'. Used to check table exists''';
	sql_stmt[4]:='COMMENT ON COLUMN '||USER||'.fdw_all_tables.owner IS ''Owner of remote table/view/materialized view''';
	sql_stmt[5]:='COMMENT ON COLUMN '||USER||'.fdw_all_tables.table_name IS ''Name of remote table/view/materialized view''';
	sql_stmt[6]:='COMMENT ON COLUMN '||USER||'.fdw_all_tables.comments IS ''Comments''';
--
	i:=i+rif40_sql_pkg.rif40_create_fdw_view(drop_objects, fdwservername, fdwservertype, l_view, l_column, sql_stmt);
--
	l_view:='fdw_all_tab_columns';
	l_column:='table_name';
	sql_stmt:=NULL;
	sql_stmt[2]:='CREATE FOREIGN TABLE '||USER||'.fdw_all_tab_columns ('||E'\n'||
		E'\t'||'owner		VARCHAR(30),'||E'\n'||
		E'\t'||'table_name	VARCHAR(30),'||E'\n'||
		E'\t'||'column_name	VARCHAR(30),'||E'\n'||
		E'\t'||'data_type	VARCHAR(30),'||E'\n'||
		E'\t'||'data_length	NUMERIC(22,0),'||E'\n'||
		E'\t'||'data_precision	NUMERIC(22,0),'||E'\n'||
		E'\t'||'data_scale	NUMERIC(22,0),'||E'\n'||
		E'\t'||'column_id	NUMERIC(22,0),'||E'\n'||
		E'\t'||'comments	VARCHAR(4000)'||E'\n'||
		') SERVER '||fdwservername||' OPTIONS (SCHEMA ''SAHSU'', TABLE ''RIF_ALL_TAB_COLUMNS'')';
	sql_stmt[3]:='COMMENT ON FOREIGN TABLE '||USER||'.fdw_all_tab_columns IS ''List of remote table/view/materialized view columns accessible via foreign data wrapper '||
		fdwservertype||' server '||fdwservername||'. Used to check table exists''';
	sql_stmt[4]:='COMMENT ON COLUMN '||USER||'.fdw_all_tab_columns.owner IS ''Owner of remote table/view/materialized view''';
	sql_stmt[5]:='COMMENT ON COLUMN '||USER||'.fdw_all_tab_columns.table_name IS ''Name of remote table/view/materialized view''';
	sql_stmt[6]:='COMMENT ON COLUMN '||USER||'.fdw_all_tab_columns.column_name IS ''Column name''';
	sql_stmt[7]:='COMMENT ON COLUMN '||USER||'.fdw_all_tab_columns.data_type IS ''Data type''';
	sql_stmt[8]:='COMMENT ON COLUMN '||USER||'.fdw_all_tab_columns.data_length IS ''Data length''';
	sql_stmt[9]:='COMMENT ON COLUMN '||USER||'.fdw_all_tab_columns.data_precision IS ''Data precision''';
	sql_stmt[10]:='COMMENT ON COLUMN '||USER||'.fdw_all_tab_columns.data_scale IS ''Data scale''';
	sql_stmt[11]:='COMMENT ON COLUMN '||USER||'.fdw_all_tab_columns.column_id IS ''Column id (order)''';
	sql_stmt[12]:='COMMENT ON COLUMN '||USER||'.fdw_all_tab_columns.comments IS ''Comments''';
--
	i:=i+rif40_sql_pkg.rif40_create_fdw_view(drop_objects, fdwservername, fdwservertype, l_view, l_column, sql_stmt);
--
	RETURN i;
END;
]]></definition>
</function>

<function name="rif40_ddl"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_ddl()
Parameters:	SQL statement
Returns:	Rows
Description:	Log and execute SQL (rif40 schema create version)
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="sql_stmt" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[

/*

Function: 	rif40_ddl()
Parameters:	SQL statement
Returns:	Rows
Description:	Log and execute SQL (rif40 schema create version)
		If NULL SQL raises no data exception (02000) with message "ERROR:  rif40_ddl() Null SQL statement"
		Supports EXPLAIN and EXPLAIN ANALYZE as text ONLY

 */
DECLARE
	stp TIMESTAMP WITH TIME ZONE;
	etp TIMESTAMP WITH TIME ZONE;
	took INTERVAL;
	l_rows INTEGER:=NULL;
	l_pos INTEGER:=NULL;
--
	explain_rec	RECORD;
	explain_text	VARCHAR;
BEGIN
--
-- Must be rifupg34, rif40 or have rif_user or rif_manager role
--
	IF USER != 'rifupg34' AND NOT rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_ddl', 'User % must be rif40 or have rif_user or rif_manager role', 
			USER::VARCHAR);
	END IF;
--
	IF sql_stmt IS NULL THEN
		PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_ddl', 'Null SQL statement');
		RAISE SQLSTATE '02000' /* No data found */ USING MESSAGE='rif40_ddl() Null SQL statement';
	END IF;
--
	stp:=clock_timestamp();
	l_pos:=position('EXPLAIN' IN UPPER(sql_stmt));
	IF l_pos = 1 THEN /* EXPLAIN ANALYZE statement */
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_ddl', 'EXPLAIN SQL> %;', sql_stmt::VARCHAR);
		sql_stmt:='SELECT explain_line FROM rif40_sql_pkg._rif40_explain_ddl('||quote_literal(sql_stmt)||')';
		FOR explain_rec IN EXECUTE sql_stmt LOOP
			IF explain_text IS NULL THEN
				explain_text:=explain_rec.explain_line::VARCHAR;
			ELSE
				explain_text:=explain_text||E'\n'||explain_rec.explain_line::VARCHAR;
			END IF;
		END LOOP;
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_ddl', '%', explain_text::VARCHAR);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_ddl', 'SQL> %;', sql_stmt::VARCHAR);
		EXECUTE sql_stmt;
	END IF;
	GET DIAGNOSTICS l_rows = ROW_COUNT;
	etp:=clock_timestamp();
	took:=age(etp, stp);
--	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_ddl', 'Statement took: % (%)', 
--			took::VARCHAR, EXTRACT ('epoch' FROM took)::VARCHAR);
	if (EXTRACT ('epoch' FROM took) > 1) THEN
		IF l_rows IS NULL THEN
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_ddl', 'Statement took: %', 
				took::VARCHAR);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_ddl', 'Statement took: %, proccessed % rows', 
				took::VARCHAR, l_rows::VARCHAR);
		END IF;
	ELSE
		IF l_rows IS NULL THEN
			PERFORM rif40_log_pkg.rif40_log('DEBUG2', 'rif40_ddl', 'Statement took: %', 
				took::VARCHAR);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG2', 'rif40_ddl', 'Statement took: %, proccessed % rows', 
				took::VARCHAR, l_rows::VARCHAR);
		END IF;
	END IF;
--
	RETURN l_rows;
EXCEPTION
	WHEN SQLSTATE '02000' /* No data found */ THEN
		RAISE;
	WHEN others THEN
		PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_ddl', 'SQL in error> %;', 
			sql_stmt::VARCHAR); 
		RAISE;
END;
]]></definition>
</function>

<function name="rif40_ddl"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_ddl()
Parameters:	SQL statement array (0+ statements; not multiline statements)
Returns:	Rows
Description:	Log and execute SQL (rif40 schema create version) - ARRAY VERSION
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="sql_stmt" in="true">
		<type name="character varying" dimension="1"/>
	</parameter>
	<definition><![CDATA[

/*

Function: 	rif40_ddl()
Parameters:	SQL statement array (0+ statements; not multiline statements)
Returns:	Rows
Description:	Log and execute SQL (rif40 schema create version) - ARRAY VERSION

 */
DECLARE
	l_rows INTEGER:=NULL;
	l2_rows INTEGER:=0;
--
	l_sql_stmt VARCHAR;
	l_idx INTEGER;
BEGIN
--
	IF sql_stmt IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-20997, 'rif40_ddl', 'Null SQL statement array');
	END IF;
--
	FOR i IN array_lower(sql_stmt, 1) .. array_upper(sql_stmt, 1) LOOP
		l_idx:=i;
		l_sql_stmt:=sql_stmt[l_idx];
		l_rows:=rif40_sql_pkg.rif40_ddl(l_sql_stmt);
		IF l_rows IS NOT NULL THEN
			l2_rows:=l2_rows+l_rows;
		END IF;
	END LOOP;
--
	RETURN l2_rows;
END;
]]></definition>
</function>

<function name="rif40_ddl_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_ddl_checks()
Parameters: 	None
Returns: 	Nothing
Description:	Validate RIF DDL

Check for:

a) Missing tables and views
b) Missing table/view comment
c) Missing table/view columns
d) Missing table/view column comments
e) Missing triggers
f) Extra tables and views
g) Missing sequences
h) All tables, views and sequences GRANT SELECT to rif_user and rif_manager
i) All functions in rif40_sql_pkg, rif40_geo_pkg GRANT EXECUTE to rif40, rif_user and rif_manager
j) Extra columns

Will work as any RIF user, not just RIF40]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<definition><![CDATA[
/*

Function: 	rif40_ddl_checks()
Parameters: 	None
Returns: 	Nothing
Description:	Validate RIF DDL

Check for:

a) Missing tables and views
b) Missing table/view comment
c) Missing table/view columns
d) Missing table/view column comments
e) Missing triggers
f) Extra tables and views
g) Missing sequences
h) All tables, views and sequences GRANT SELECT to rif_user and rif_manager
i) All functions in rif40_sql_pkg, rif40_geo_pkg GRANT EXECUTE to rif40, rif_user and rif_manager
j) Extra columns

Will work as any RIF user, not just RIF40

 */
DECLARE
	c1 CURSOR(l_schema VARCHAR) FOR /* Missing tables and views */
		SELECT LOWER(table_or_view_name_hide) table_or_view	/* RIF40 list of tables and views */
		  FROM rif40_tables_and_views
		EXCEPT 
		SELECT a.relname table_or_view 				/* Temporary tables */
 		 FROM pg_roles r, pg_class a
			LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
		 WHERE a.relowner       = (SELECT oid FROM pg_roles WHERE rolname = USER)
		   AND a.relkind        = 'r' 				/* Relational table */
		   AND a.relpersistence = 't' 				/* Persistence: temporary */
		   AND a.relowner = r.oid
		   AND n.nspname        LIKE 'pg_temp%'
		EXCEPT					
		SELECT a.relname table_or_view				/* FDW tables */
		  FROM pg_foreign_table b, pg_roles r, pg_class a
			LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
		 WHERE b.ftrelid = a.oid
		   AND a.relowner = (SELECT oid FROM pg_roles WHERE rolname = USER)
		   AND a.relowner = r.oid
		   AND COALESCE(n.nspname, r.rolname) IN (USER, 'public')
		EXCEPT
		SELECT t.tablename table_or_view			/* Local tables */
		  FROM pg_tables t, pg_class c
		 WHERE t.tableowner IN (USER, l_schema)
		   AND t.schemaname IN (USER, l_schema)
		   AND c.relowner   IN (SELECT oid FROM pg_roles WHERE rolname IN (USER, l_schema))
		   AND c.relname    = t.tablename
		   AND c.relkind    = 'r' 				/* Relational table */
		   AND c.relpersistence IN ('p', 'u') 			/* Persistence: permanent/unlogged */
		EXCEPT
		SELECT viewname	table_or_view 				/* Local views */
		  FROM pg_views
		 WHERE viewowner  IN (USER, l_schema)
		   AND schemaname IN (USER, l_schema)
		 ORDER BY 1;
	c2 CURSOR(l_schema VARCHAR) FOR /* Missing table/view comment */	
		SELECT DISTINCT relname table_or_view, n.nspname AS schema_owner, b.description, comments
		  FROM rif40_tables_and_views c, pg_class a
			LEFT OUTER JOIN pg_description b ON (b.objoid = a.oid AND b.objsubid = 0)
			LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
		 WHERE a.relowner IN (SELECT oid FROM pg_roles WHERE rolname IN (USER, l_schema))
		   AND b.description IS NULL
		   AND LOWER(table_or_view_name_hide) = a.relname
		 ORDER BY 1;
	c3 CURSOR(l_schema VARCHAR) FOR /* Missing table/view columns */
		SELECT LOWER(table_or_view_name_hide) table_or_view, LOWER(column_name_hide) column_name
		  FROM rif40_columns
                 WHERE LOWER(table_or_view_name_hide) NOT IN ( /* Exclude missing tables/views (i.e. cursor c1) */
			SELECT LOWER(table_or_view_name_hide) table_or_view	/* RIF40 list of tables and views */
			  FROM rif40_tables_and_views
			EXCEPT 
			SELECT a.relname table_or_view 				/* Temporary tables */
 			 FROM pg_roles r, pg_class a
				LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
			 WHERE a.relowner       = (SELECT oid FROM pg_roles WHERE rolname = USER)
			   AND a.relkind        = 'r' 				/* Relational table */
			   AND a.relpersistence = 't' 				/* Persistence: temporary */
			   AND a.relowner = r.oid
			   AND n.nspname        LIKE 'pg_temp%'
			EXCEPT					
			SELECT a.relname table_or_view				/* FDW tables */
			  FROM pg_foreign_table b, pg_roles r, pg_class a
				LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
			 WHERE b.ftrelid = a.oid
			   AND a.relowner = (SELECT oid FROM pg_roles WHERE rolname = USER)
			   AND a.relowner = r.oid
				   AND COALESCE(n.nspname, r.rolname) IN (USER, 'public')
			EXCEPT
			SELECT t.tablename table_or_view			/* Local tables */
			  FROM pg_tables t, pg_class c
			 WHERE t.tableowner IN (USER, l_schema)
			   AND t.schemaname IN (USER, l_schema)
			   AND c.relowner   IN (SELECT oid FROM pg_roles WHERE rolname IN (USER, l_schema))
			   AND c.relname    = t.tablename
			   AND c.relkind    = 'r' 				/* Relational table */
			   AND c.relpersistence IN ('p', 'u') 			/* Persistence: permanent/unlogged */
			EXCEPT
			SELECT viewname	table_or_view				/* Local views */
			  FROM pg_views
			 WHERE viewowner  IN (USER, l_schema)
			   AND schemaname IN (USER, l_schema)
		)
		   AND table_or_view_name_hide NOT LIKE 'G%'
		EXCEPT
		SELECT table_name table_or_view, column_name
		  FROM information_schema.columns a
			LEFT OUTER JOIN pg_tables b1 ON (b1.schemaname = a.table_schema AND a.table_name = b1.tablename) 
			LEFT OUTER JOIN pg_views b2 ON (b2.schemaname = a.table_schema AND a.table_name = b2.viewname) 
			LEFT OUTER JOIN (
				SELECT c.relname fdw_table, r.rolname fdw_tableowner
				  FROM pg_class c, pg_foreign_table t, pg_roles r
				 WHERE t.ftrelid  = c.oid 
				   AND c.relowner = (SELECT oid FROM pg_roles WHERE rolname = USER)) b3 ON
				(b3.fdw_table = a.table_name)
		 WHERE tableowner IN (USER, l_schema) OR viewowner IN (USER, l_schema) OR fdw_tableowner = USER
		 ORDER BY 1, 2;
	c4 CURSOR(l_schema VARCHAR) FOR /* Missing table/view column comments */ 		
		WITH a AS (
	 		SELECT table_name table_or_view, column_name, ordinal_position
			  FROM information_schema.columns a
					LEFT OUTER JOIN pg_views b2  ON 
						(b2.schemaname = a.table_schema AND a.table_name = b2.viewname) 
					LEFT OUTER JOIN pg_tables b1 ON 
						(b1.schemaname = a.table_schema AND a.table_name = b1.tablename) 
			 WHERE (viewowner IN (USER, l_schema) OR tableowner IN (USER, l_schema))
			   AND table_schema = 'rif40' 
		), b AS (
			SELECT table_or_view, column_name, ordinal_position, b.oid
  			  FROM a, pg_class b
			 WHERE b.relowner IN (SELECT oid FROM pg_roles WHERE rolname IN (USER, l_schema)) 
			   AND b.relname  = a.table_or_view
		)
		SELECT table_or_view, column_name, ordinal_position, c.description
		  FROM b
			LEFT OUTER JOIN pg_description c ON (c.objoid = b.oid AND c.objsubid = b.ordinal_position)
		 WHERE c.description IS NULL
		 ORDER BY 1, 2;
	c5 CURSOR(l_schema VARCHAR) FOR  /* Missing triggers */
		SELECT LOWER(trigger_name) trigger_name, LOWER(table_name) table_name
		  FROM rif40_triggers
		 WHERE LOWER(table_name) NOT IN (
			SELECT a.relname object_name	/* FDW tables */
			  FROM pg_foreign_table b, pg_roles r, pg_class a
				LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
			 WHERE b.ftrelid = a.oid
			   AND a.relowner IN (SELECT oid FROM pg_roles WHERE rolname = l_schema)
			   AND a.relowner = r.oid
			   AND COALESCE(n.nspname, r.rolname) = l_schema)
		EXCEPT
		SELECT tgname trigger_name, relname table_name
		  FROM pg_class a, pg_trigger b
			 WHERE tgrelid = a.oid
			   AND relowner IN (SELECT oid FROM pg_roles WHERE rolname = l_schema)
		 ORDER BY 1, 2;
	c6 CURSOR(l_schema VARCHAR) FOR /* Extra tables and views */
		SELECT a.relname table_or_view 				/* Temporary tables */
 		 FROM pg_roles r, pg_class a
			LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
		 WHERE a.relowner       = (SELECT oid FROM pg_roles WHERE rolname = USER)
		   AND a.relkind        = 'r' 				/* Relational table */
		   AND a.relpersistence = 't' 				/* Persistence: temporary */
		   AND a.relowner = r.oid
		   AND n.nspname        LIKE 'pg_temp%'
		 UNION
		SELECT a.relname table_or_view				/* FDW tables */
		  FROM pg_foreign_table b, pg_roles r, pg_class a
			LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
		 WHERE b.ftrelid = a.oid
		   AND a.relowner IN (SELECT oid FROM pg_roles WHERE rolname IN (USER, l_schema))
		   AND a.relowner = r.oid
		   AND COALESCE(n.nspname, r.rolname) IN (USER, l_schema)
		 UNION
		SELECT t.tablename table_or_view			/* Local tables */
		  FROM pg_tables t, pg_class c
		 WHERE t.tableowner IN (USER, l_schema)
		   AND t.schemaname IN (USER, l_schema)
		   AND c.relowner   IN (SELECT oid FROM pg_roles WHERE rolname IN (USER, l_schema))
		   AND c.relname    = t.tablename
		   AND c.relkind    = 'r' 				/* Relational table */
		   AND c.relpersistence IN ('p', 'u') 			/* Persistence: permanent/unlogged */
		 UNION
		SELECT viewname	table_or_view 				/* Local views */
		  FROM pg_views
		 WHERE viewowner  IN (USER, l_schema)
		   AND schemaname IN (USER, l_schema)
		EXCEPT  
		SELECT table_or_view
		  FROM (
			SELECT LOWER(table_or_view_name_hide) table_or_view	/* RIF40 list of tables and views */
			  FROM rif40_tables_and_views
			 UNION
			SELECT tablename table_or_view		 		/* Geospatial tables created by rif40_geo_pkg functions */
			  FROM pg_tables
			 WHERE tablename IN (
				SELECT DISTINCT LOWER(lookup_table) tablename	/* Geolevel lookup tables */
			        FROM t_rif40_geolevels WHERE lookup_table IS NOT NULL
			       UNION 
			      SELECT DISTINCT LOWER(hierarchytable) tablename	/* Hierarchy table */
			        FROM rif40_geographies
			       UNION 
			      SELECT DISTINCT 't_rif40_'||LOWER(geography)||'_geometry' tablename
										/* Geometry tables */
			        FROM rif40_geographies
			       UNION 
			      SELECT DISTINCT 't_rif40_geolevels_geometry_'||	/* Geometry table partitions */
					LOWER(geography)||'_'||LOWER(geolevel_name) tablename
			        FROM t_rif40_geolevels
			       UNION 
			      SELECT DISTINCT LOWER(table_name) tablename	/* Numerator and denominators */
			        FROM rif40_tables WHERE table_name IS NOT NULL
			       UNION 
			      SELECT DISTINCT LOWER(covariate_table) tablename	/* Covariate tables */
			        FROM t_rif40_geolevels WHERE covariate_table IS NOT NULL
			       UNION 
			      SELECT DISTINCT LOWER(shapefile_table) tablename	/* Loaded shapefile tables */
			        FROM t_rif40_geolevels WHERE shapefile_table IS NOT NULL
			       UNION 
			      SELECT DISTINCT LOWER(centroids_table) tablename	/* Centroids tables */
			        FROM t_rif40_geolevels WHERE centroids_table IS NOT NULL
				/* rif40_outcomes lookup tables not inluded in this list as supplied as part of the initial setup 
			      UNION
			     SELECT tablename 
			       FROM (
				   SELECT LOWER(current_lookup_table) AS tablename
				     FROM rif40_outcomes
				    UNION
				   SELECT LOWER(previous_lookup_table) AS tablename
				     FROM rif40_outcomes) AS a
		  	      WHERE tablename IS NOT NULL
				*/ 
				)
			 UNION
			SELECT a.relname AS table_or_view		 		/* FDW tables created by  rif40_sql_pkg.rif40_startup() */
			  FROM pg_foreign_table b, pg_roles r, pg_class a
				LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
			 WHERE b.ftrelid = a.oid
			   AND a.relowner IN (SELECT oid FROM pg_roles WHERE rolname = USER)
			   AND a.relowner = r.oid
			   AND n.nspname = USER
			   AND a.relname IN (
			      SELECT LOWER(table_name) AS tablename			/* FDW interconnect tables to Oracle */
				FROM rif40_fdw_tables
			       WHERE create_status IN ('C', 'E')
				)
			 UNION
			SELECT a.relname AS table_or_view		 		/* FDW Geospatial tables created by rif40_geo_pkg functions (rifupg34 only) */
			  FROM pg_foreign_table b, pg_roles r, pg_class a
				LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
			 WHERE b.ftrelid = a.oid
			   AND a.relowner IN (SELECT oid FROM pg_roles WHERE rolname = 'rifupg34')
			   AND a.relowner = r.oid
			   AND COALESCE(n.nspname, r.rolname) = l_schema
			   AND a.relname IN (
				SELECT DISTINCT LOWER(lookup_table) tablename	/* Geolevel lookup tables */
			        FROM t_rif40_geolevels WHERE lookup_table IS NOT NULL
			       UNION 
			      SELECT DISTINCT LOWER(hierarchytable) tablename	/* Hierarchy table */
			        FROM rif40_geographies
			       UNION 
			      SELECT DISTINCT 't_rif40_'||LOWER(geography)||'_geometry' tablename
										/* Geometry tables */
			        FROM rif40_geographies
			       UNION 
			      SELECT DISTINCT 't_rif40_geolevels_geometry_'||	/* Geometry table partitions */
					LOWER(geography)||'_'||LOWER(geolevel_name) tablename
			        FROM t_rif40_geolevels
			       UNION 
			      SELECT DISTINCT LOWER(table_name) tablename	/* Numerator and denominators */
			        FROM rif40_tables WHERE table_name IS NOT NULL
			       UNION 
			      SELECT DISTINCT LOWER(covariate_table) tablename	/* Covariate tables */
			        FROM t_rif40_geolevels WHERE covariate_table IS NOT NULL
			       UNION 
			      SELECT DISTINCT LOWER(shapefile_table) tablename	/* Loaded shapefile tables */
			        FROM t_rif40_geolevels WHERE shapefile_table IS NOT NULL
			       UNION 
			      SELECT DISTINCT LOWER(centroids_table) tablename	/* Centroids tables */
			        FROM t_rif40_geolevels WHERE centroids_table IS NOT NULL
				/* rif40_outcomes lookup tables not inluded in this list as supplied as part of the initial setup 
			      UNION
			     SELECT tablename 
			       FROM (
				   SELECT LOWER(current_lookup_table) AS tablename
				     FROM rif40_outcomes
				    UNION
				   SELECT LOWER(previous_lookup_table) AS tablename
				     FROM rif40_outcomes) AS a
		  	      WHERE tablename IS NOT NULL
				*/ 
				)
			) AS a
		 ORDER BY 1;
	c7 CURSOR(l_schema VARCHAR) FOR /* Missing sequences */
		SELECT 'rif40_study_id_seq' AS sequences
		 UNION
		SELECT 'rif40_inv_id_seq' AS sequences
		EXCEPT
		SELECT c.relname AS sequences
		  FROM pg_class c
		 WHERE relkind = 'S'
		   AND c.relowner   = (SELECT oid FROM pg_roles WHERE rolname = l_schema)
		 ORDER BY 1;
	c8 CURSOR(l_schema VARCHAR) FOR /* All tables, views and sequences GRANT SELECT to rif_user and rif_manager */
		SELECT LOWER(table_or_view_name_hide) table_or_view, /* rif40_tables_and_views */
  		       has_table_privilege(USER, LOWER(table_or_view_name_hide), 'select') has_user_select,
  		       has_table_privilege('rif_user', LOWER(table_or_view_name_hide), 'select') has_rif_user_select,
  		       has_table_privilege('rif_manager', LOWER(table_or_view_name_hide), 'select') has_rif_manager_select,
  		       has_table_privilege('public', LOWER(table_or_view_name_hide), 'select') has_public_select
		  FROM rif40_tables_and_views
                 WHERE LOWER(table_or_view_name_hide) NOT IN ( /* Exclude missing tables/views (i.e. cursor c1) */
			SELECT LOWER(table_or_view_name_hide) table_or_view	/* RIF40 list of tables and views */
			  FROM rif40_tables_and_views
			EXCEPT 
			SELECT a.relname table_or_view 				/* Temporary tables */
 			 FROM pg_roles r, pg_class a
				LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
			 WHERE a.relowner       = (SELECT oid FROM pg_roles WHERE rolname = USER)
			   AND a.relkind        = 'r' 				/* Relational table */
			   AND a.relpersistence = 't' 				/* Persistence: temporary */
			   AND a.relowner = r.oid
			   AND n.nspname        LIKE 'pg_temp%'
			EXCEPT					
			SELECT a.relname table_or_view				/* FDW tables */
			  FROM pg_foreign_table b, pg_roles r, pg_class a
				LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
			 WHERE b.ftrelid = a.oid
			   AND a.relowner = (SELECT oid FROM pg_roles WHERE rolname = USER)
			   AND a.relowner = r.oid
			   AND COALESCE(n.nspname, r.rolname) = USER
			EXCEPT
			SELECT t.tablename table_or_view			/* Local tables */
			  FROM pg_tables t, pg_class c
			 WHERE t.tableowner IN (USER, l_schema)
			   AND t.schemaname IN (USER, l_schema)
			   AND c.relowner   IN (SELECT oid FROM pg_roles WHERE rolname IN (USER, l_schema))
			   AND c.relname    = t.tablename
			   AND c.relkind    = 'r' 				/* Relational table */
			   AND c.relpersistence IN ('p', 'u') 			/* Persistence: permanent/unlogged */
			EXCEPT
			SELECT viewname AS table_or_view			/* Local views */
			  FROM pg_views
			 WHERE viewowner  IN (USER, l_schema)
			   AND schemaname IN (USER, l_schema)
		)
		   AND table_or_view_name_hide NOT LIKE 'G%'			/* Temporary tables */
		   AND LOWER(table_or_view_name_hide) NOT IN ('rif40_num_denom', 'rif40_num_denom_errors', 't_rif40_num_denom', 'rif40_user_version') /* Local user tables/views */
		 UNION
		SELECT rif40_sql_pkg.rif40_object_resolve(tablename::VARCHAR)||'.'||tablename table_or_view,	/* Geospatial tables created by rif40_geo_pkg functions */
  		       has_table_privilege(USER, rif40_sql_pkg.rif40_object_resolve(tablename::VARCHAR)||'.'||LOWER(tablename), 'select') has_user_select,
  		       has_table_privilege('rif_user', rif40_sql_pkg.rif40_object_resolve(tablename::VARCHAR)||'.'||LOWER(tablename), 'select') has_rif_user_select,
  		       has_table_privilege('rif_manager', rif40_sql_pkg.rif40_object_resolve(tablename::VARCHAR)||'.'||LOWER(tablename), 'select') has_rif_manager_select,
  		       has_table_privilege('public', rif40_sql_pkg.rif40_object_resolve(tablename::VARCHAR)||'.'||LOWER(tablename), 'select') has_public_select
		  FROM pg_tables
		 WHERE tablename IN (
			SELECT DISTINCT LOWER(lookup_table) tablename	/* Geolevel lookup tables */
		        FROM t_rif40_geolevels WHERE lookup_table IS NOT NULL
		       UNION 
		      SELECT DISTINCT LOWER(hierarchytable) tablename	/* Hierarchy table */
		        FROM rif40_geographies
		       UNION 
		      SELECT DISTINCT 't_rif40_'||LOWER(geography)||'_geometry' tablename
									/* Geometry tables */
		        FROM rif40_geographies
		       UNION 
		      SELECT DISTINCT LOWER(covariate_table) tablename	/* Covariate tables */
		        FROM t_rif40_geolevels WHERE covariate_table IS NOT NULL
		       UNION 
		      SELECT DISTINCT LOWER(shapefile_table) tablename	/* Loaded shapefile tables */
		        FROM t_rif40_geolevels WHERE shapefile_table IS NOT NULL
		       UNION 
		      SELECT DISTINCT LOWER(centroids_table) tablename	/* Centroids tables */
		        FROM t_rif40_geolevels WHERE centroids_table IS NOT NULL)
		   AND rif40_sql_pkg.rif40_object_resolve(tablename::VARCHAR) IS NOT NULL	/* Object exists in the search path */
		UNION
		SELECT rif40_sql_pkg.rif40_object_resolve(tablename::VARCHAR)||'.'||tablename table_or_view,	/* Numerator and denominators */
  		       has_table_privilege(USER, rif40_sql_pkg.rif40_object_resolve(tablename::VARCHAR)||'.'||LOWER(tablename), 'select') has_user_select,
  		       has_table_privilege('rif_user', rif40_sql_pkg.rif40_object_resolve(tablename::VARCHAR)||'.'||LOWER(tablename), 'select') has_rif_user_select,
  		       has_table_privilege('rif_manager', rif40_sql_pkg.rif40_object_resolve(tablename::VARCHAR)||'.'||LOWER(tablename), 'select') has_rif_manager_select,
  		       has_table_privilege('public', rif40_sql_pkg.rif40_object_resolve(tablename::VARCHAR)||'.'||LOWER(tablename), 'select') has_public_select
		  FROM pg_tables
		 WHERE tablename IN (
		      SELECT DISTINCT LOWER(table_name) tablename	/* Numerator and denominators */
		        FROM rif40_tables WHERE table_name IS NOT NULL)
		   AND rif40_sql_pkg.rif40_object_resolve(tablename::VARCHAR) IS NOT NULL	/* Object exists in the search path */
		 UNION
		SELECT table_or_view,					/* Sequences */
  		       has_table_privilege(USER, LOWER(table_or_view), 'select') has_user_select,
  		       has_table_privilege('rif_user', LOWER(table_or_view), 'select') has_rif_user_select,
  		       has_table_privilege('rif_manager', LOWER(table_or_view), 'select') has_rif_manager_select,
  		       has_table_privilege('public', LOWER(table_or_view), 'select') has_public_select
		  FROM (
			SELECT 'rif40_study_id_seq' AS table_or_view
			 UNION
			SELECT 'rif40_inv_id_seq' AS table_or_view
			) b, pg_class a
		 WHERE has_schema_privilege('rif40', 'USAGE') 
	  	  AND a.relkind  = 'S' 
		  AND a.relowner = (SELECT oid FROM pg_roles WHERE rolname = l_schema)
		  AND a.relname  = b.table_or_view
	        ORDER BY 1;
	c9 CURSOR(l_schema VARCHAR) FOR /* All functions in rif40_sql_pkg, rif40_geo_pkg GRANT EXECUTE to rif40, rif_user and rif_manager */
		SELECT object_type, 
                       schemaname||'.'||function_name AS function_name,
  		       has_function_privilege(USER, schemaname||'.'||function_name, 'execute') AS  has_user_select,
  		       has_function_privilege('rif40', schemaname||'.'||function_name, 'execute') AS has_rif40_select,
  		       has_function_privilege('rif_user', schemaname||'.'||function_name, 'execute') AS has_rif_user_select,
  		       has_function_privilege('rif_manager', schemaname||'.'||function_name, 'execute') AS has_rif_manager_select
		  FROM (
			SELECT l.lanname||' function' AS object_type, 
			       COALESCE(n.nspname, r.rolname) AS schemaname,
			       p.proname||rif40_sql_pkg.rif40_get_function_arg_types(p.proargtypes) AS function_name	
			  FROM pg_language l, pg_type t, pg_roles r, pg_proc p
				LEFT OUTER JOIN pg_namespace n ON (n.oid = p.pronamespace)			
			 WHERE p.prolang    = l.oid
			   AND p.prorettype = t.oid
			   AND p.proowner   = (SELECT oid FROM pg_roles WHERE rolname = l_schema)
			   AND p.proowner   = r.oid
			) AS a
		 WHERE has_schema_privilege('rif40', 'USAGE') 
		 ORDER BY 1, 2;
	c10 CURSOR(l_schema VARCHAR) FOR /* Extra table/view columns */
		WITH a AS (
		SELECT table_name table_or_view, column_name
		  FROM information_schema.columns a
			LEFT OUTER JOIN pg_tables b1 ON (b1.schemaname = a.table_schema AND a.table_name = b1.tablename) 
			LEFT OUTER JOIN pg_views b2 ON (b2.schemaname = a.table_schema AND a.table_name = b2.viewname) 
			LEFT OUTER JOIN (
				SELECT c.relname fdw_table, r.rolname fdw_tableowner
				  FROM pg_foreign_table t, pg_roles r, pg_class c
					LEFT OUTER JOIN pg_namespace n ON (n.oid = c.relnamespace)			
				 WHERE t.ftrelid  = c.oid 
  				   AND n.nspname IN (USER, l_schema)
				   AND c.relowner = (SELECT oid FROM pg_roles WHERE rolname = USER)
				) b3 ON (b3.fdw_table = a.table_name)
		 WHERE (tableowner IN (USER, l_schema) OR viewowner IN (USER, l_schema) OR fdw_tableowner = USER)
                   AND a.table_schema  != 'rif_studies'			/* Exclude map/extract tables */
		   AND NOT (a.table_name IN ('g_rif40_comparison_areas', 'g_rif40_study_areas', 'user_role_privs', 'sahsuland_geography_test')
    		       OR   a.table_name IN (
			SELECT tablename table_or_view		 		/* Geospatial tables created by rif40_geo_pkg functions */
			  FROM pg_tables
			 WHERE tablename IN (
		    	      SELECT DISTINCT LOWER(lookup_table) tablename	/* Geolevel lookup tables */
			        FROM t_rif40_geolevels WHERE lookup_table IS NOT NULL
			       UNION 
			      SELECT DISTINCT LOWER(hierarchytable) tablename	/* Hierarchy table */
			        FROM rif40_geographies
			       UNION 
			      SELECT DISTINCT 't_rif40_'||LOWER(geography)||'_geometry' tablename
										/* Geometry tables */
			        FROM rif40_geographies
			       UNION 
			      SELECT DISTINCT 't_rif40_geolevels_geometry_'||	/* Geometry table partitions */
					LOWER(geography)||'_'||LOWER(geolevel_name) tablename
			        FROM t_rif40_geolevels
			       UNION 
			      SELECT DISTINCT LOWER(table_name) tablename	/* Numerator and denominators */
			        FROM rif40_tables WHERE table_name IS NOT NULL
			       UNION 
			      SELECT DISTINCT LOWER(covariate_table) tablename	/* Covariate tables */
			        FROM t_rif40_geolevels WHERE covariate_table IS NOT NULL
			       UNION 
			      SELECT DISTINCT LOWER(shapefile_table) tablename	/* Loaded shapefile tables */
			        FROM t_rif40_geolevels WHERE shapefile_table IS NOT NULL
			       UNION 
			      SELECT DISTINCT LOWER(centroids_table) tablename	/* Centroids tables */
			        FROM t_rif40_geolevels WHERE centroids_table IS NOT NULL
				/* rif40_outcomes lookup tables not inluded in this list as supplied as part of the initial setup 
			      UNION
			     SELECT tablename 
			       FROM (
				   SELECT LOWER(current_lookup_table) AS tablename
				     FROM rif40_outcomes
				    UNION
				   SELECT LOWER(previous_lookup_table) AS tablename
				     FROM rif40_outcomes) AS a
		  	      WHERE tablename IS NOT NULL
				*/ 
				)
			 UNION
			SELECT a.relname AS table_or_view		 		/* FDW tables created by  rif40_sql_pkg.rif40_startup() */
			  FROM pg_foreign_table b, pg_roles r, pg_class a
				LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
			 WHERE b.ftrelid = a.oid
			   AND a.relowner IN (SELECT oid FROM pg_roles WHERE rolname = USER)
			   AND a.relowner = r.oid
			   AND n.nspname = USER
			   AND a.relname IN (
			      SELECT LOWER(table_name) AS tablename			/* FDW interconnect tables to Oracle */
				FROM rif40_fdw_tables
			       WHERE create_status IN ('C', 'E')
				) 
			))
		EXCEPT
		SELECT LOWER(table_or_view_name_hide) table_or_view, LOWER(column_name_hide) column_name
		  FROM rif40_columns
                 WHERE LOWER(table_or_view_name_hide) NOT IN ( /* Exclude missing tables/views (i.e. cursor c1) */
			SELECT LOWER(table_or_view_name_hide) table_or_view	/* RIF40 list of tables and views */
			  FROM rif40_tables_and_views
			EXCEPT 
			SELECT a.relname table_or_view 				/* Temporary tables */
 			 FROM pg_roles r, pg_class a
				LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
			 WHERE a.relowner       = (SELECT oid FROM pg_roles WHERE rolname = USER)
			   AND a.relkind        = 'r' 				/* Relational table */
			   AND a.relpersistence = 't' 				/* Persistence: temporary */
			   AND a.relowner = r.oid
			   AND n.nspname        LIKE 'pg_temp%'
			EXCEPT					
			SELECT a.relname table_or_view				/* FDW tables */
			  FROM pg_foreign_table b, pg_roles r, pg_class a
				LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
			 WHERE b.ftrelid = a.oid
			   AND a.relowner = (SELECT oid FROM pg_roles WHERE rolname = USER)
			   AND a.relowner = r.oid
			   AND COALESCE(n.nspname, r.rolname) = USER
			EXCEPT
			SELECT t.tablename table_or_view			/* Local tables */
			  FROM pg_tables t, pg_class c
			 WHERE t.tableowner IN (USER, l_schema)
			   AND t.schemaname IN (USER, l_schema)
			   AND c.relowner   IN (SELECT oid FROM pg_roles WHERE rolname IN (USER, l_schema))
			   AND c.relname    = t.tablename
			   AND c.relkind    = 'r' 				/* Relational table */
			   AND c.relpersistence IN ('p', 'u') 			/* Persistence: permanent/unlogged */
			EXCEPT
			SELECT viewname table_or_view				/* Local views */
			  FROM pg_views
			 WHERE viewowner  IN (USER, l_schema)
			   AND schemaname IN (USER, l_schema)
		)
		   AND table_or_view_name_hide NOT LIKE 'G%'
		)
		SELECT table_schema, a.table_or_view, a.column_name
		  FROM a, information_schema.columns b
		 WHERE a.table_or_view = b.table_name
		   AND a.column_name   = b.column_name
		 ORDER BY 1, 2;
	c11 CURSOR FOR /* All rif40_objects and comments */
		WITH a AS (
			SELECT c.relname AS object_name, 
			       n.nspname AS object_schema, 
			       CASE 
					WHEN c.relkind        = 'r' AND			/* Relational table */
					     c.relpersistence = 'p' 			/* Persistence: unlogged */	 THEN 'TABLE'
					WHEN c.relkind        = 'r' AND			/* Relational table */
					     c.relpersistence = 'u' 			/* Persistence: unlogged */ 	THEN 'UNLOGGED TABLE'
					WHEN c.relkind        = 'r' AND			/* Relational table */
					     c.relpersistence = 't' 			/* Persistence: temporary */ 	THEN 'TEMPORARY TABLE'
					WHEN c.relkind        = 'i'			/* Index */			THEN 'INDEX'
					WHEN c.relkind        = 'v'			/* View */			THEN 'VIEW'
					WHEN c.relkind        = 'S'			/* Sequence */			THEN 'SEQUENCE'
					WHEN c.relkind        = 't'			/* TOAST Table */		THEN 'TOAST TABLE'
					WHEN c.relkind        = 'f'			/* Foreign Table */		THEN 'FOREIGN TABLE'
					WHEN c.relkind        = 'c'			/* Composite type */		THEN 'COMPOSITE TYPE'
					ELSE 										     'Unknown relkind: '||c.relkind
			       END AS object_type,
			       d.description
			  FROM pg_class c
				LEFT OUTER JOIN pg_namespace n ON (n.oid = c.relnamespace)			
				LEFT OUTER JOIN pg_description d ON (d.objoid = c.oid AND (d.objsubid IS NULL OR d.objsubid = 0))
			 WHERE c.relowner IN (SELECT oid FROM pg_roles WHERE rolname IN ('rif40', USER))
			UNION
			SELECT p.proname AS object_name, 
			       n.nspname AS object_schema,
			       'FUNCTION'  AS object_type,
			       d.description
			  FROM pg_proc p
				LEFT OUTER JOIN pg_namespace n ON (n.oid = p.pronamespace)			
				LEFT OUTER JOIN pg_description d ON (d.objoid = p.oid AND d.objsubid = 0)
			 WHERE p.proowner IN (SELECT oid FROM pg_roles WHERE rolname IN ('rif40', USER))
			UNION
			SELECT t.tgname AS object_name, 
			       n.nspname AS object_schema,
			       'TRIGGER'  AS object_type,
			       d.description
			  FROM pg_trigger t, pg_class c
				LEFT OUTER JOIN pg_namespace n ON (n.oid = c.relnamespace)			
				LEFT OUTER JOIN pg_description d ON (d.objoid = c.oid AND d.objsubid = 0)
			 WHERE c.relowner IN (SELECT oid FROM pg_roles WHERE rolname IN ('rif40', USER))
			   AND c.oid = t.tgrelid
			   AND t.tgisinternal = FALSE /* trigger function */
			UNION
			SELECT DISTINCT relname||'.'||column_name AS object_name, 
			       n.nspname AS object_schema,
			       'COLUMN'  AS object_type,
			       b.description
			  FROM (
				SELECT table_name table_or_view, column_name, ordinal_position
				  FROM information_schema.columns a
					LEFT OUTER JOIN pg_tables b1 ON 
						(b1.schemaname = a.table_schema AND a.table_name = b1.tablename) 
					LEFT OUTER JOIN pg_views b2  ON 
						(b2.schemaname = a.table_schema AND a.table_name = b2.viewname) 
				 WHERE tableowner IN (USER, 'rif40') OR viewowner IN (USER, 'rif40')) c, 
				pg_class a
				LEFT OUTER JOIN pg_description b ON (b.objoid = a.oid)
				LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
			 WHERE a.relowner IN (SELECT oid FROM pg_roles WHERE rolname IN (USER, 'rif40')) 
			   AND b.objsubid = c.ordinal_position
			   AND a.relname  = c.table_or_view
		), b AS (
			SELECT object_type, object_schema, COUNT(object_name) AS total_objects, 
			       CASE
					WHEN object_schema = 'pg_toast' OR
					     object_type IN ('INDEX', 'COMPOSITE TYPE') THEN NULL
					ELSE 					     	     COUNT(object_name)-COUNT(description) 
			       END AS missing_comments
			  FROM a
			 GROUP BY object_type, object_schema
		)
		SELECT object_type, object_schema, total_objects, missing_comments
		  FROM b
		 ORDER BY 1, 2;
	c12 CURSOR(l_object_type VARCHAR, l_object_schema VARCHAR) FOR /* All rif40_objects and comments */
		WITH a AS (
			SELECT c.relname AS object_name, 
			       n.nspname AS object_schema, 
			       CASE 
					WHEN c.relkind        = 'r' AND			/* Relational table */
					     c.relpersistence = 'p' 			/* Persistence: unlogged */	 THEN 'TABLE'
					WHEN c.relkind        = 'r' AND			/* Relational table */
					     c.relpersistence = 'u' 			/* Persistence: unlogged */ 	THEN 'UNLOGGED TABLE'
					WHEN c.relkind        = 'r' AND			/* Relational table */
					     c.relpersistence = 't' 			/* Persistence: temporary */ 	THEN 'TEMPORARY TABLE'
					WHEN c.relkind        = 'i'			/* Index */			THEN 'INDEX'
					WHEN c.relkind        = 'v'			/* View */			THEN 'VIEW'
					WHEN c.relkind        = 'S'			/* Sequence */			THEN 'SEQUENCE'
					WHEN c.relkind        = 't'			/* TOAST Table */		THEN 'TOAST TABLE'
					WHEN c.relkind        = 'f'			/* Foreign Table */		THEN 'FOREIGN TABLE'
					WHEN c.relkind        = 'c'			/* Composite type */		THEN 'COMPOSITE TYPE'
					ELSE 										     'Unknown relkind: '||c.relkind
			       END AS object_type,
			       d.description
			  FROM pg_class c
				LEFT OUTER JOIN pg_namespace n ON (n.oid = c.relnamespace)			
				LEFT OUTER JOIN pg_description d ON (d.objoid = c.oid AND (d.objsubid IS NULL OR d.objsubid = 0))
			 WHERE c.relowner IN (SELECT oid FROM pg_roles WHERE rolname IN ('rif40', USER))
			UNION
			SELECT p.proname AS object_name, 
			       n.nspname AS object_schema,
			       'FUNCTION'  AS object_type,
			       d.description
			  FROM pg_proc p
				LEFT OUTER JOIN pg_namespace n ON (n.oid = p.pronamespace)			
				LEFT OUTER JOIN pg_description d ON (d.objoid = p.oid AND d.objsubid = 0)
			 WHERE p.proowner IN (SELECT oid FROM pg_roles WHERE rolname IN ('rif40', USER))
			UNION
			SELECT t.tgname AS object_name, 
			       n.nspname AS object_schema,
			       'TRIGGER'  AS object_type,
			       d.description
			  FROM pg_trigger t, pg_class c
				LEFT OUTER JOIN pg_namespace n ON (n.oid = c.relnamespace)			
				LEFT OUTER JOIN pg_description d ON (d.objoid = c.oid AND d.objsubid = 0)
			 WHERE c.relowner IN (SELECT oid FROM pg_roles WHERE rolname IN ('rif40', USER))
			   AND c.oid = t.tgrelid
			   AND t.tgisinternal = FALSE /* trigger function */
			UNION
			SELECT DISTINCT relname||'.'||column_name AS object_name, 
			       n.nspname AS object_schema,
			       'COLUMN'  AS object_type,
			       b.description
			  FROM (
				SELECT table_name table_or_view, column_name, ordinal_position
				  FROM information_schema.columns a
					LEFT OUTER JOIN pg_tables b1 ON 
						(b1.schemaname = a.table_schema AND a.table_name = b1.tablename) 
					LEFT OUTER JOIN pg_views b2  ON 
						(b2.schemaname = a.table_schema AND a.table_name = b2.viewname) 
				 WHERE tableowner IN (USER, 'rif40') OR viewowner IN (USER, 'rif40')
                   		   AND a.table_schema  != 'rif_studies'			/* Exclude map/extract tables */
				) c, 
				pg_class a
				LEFT OUTER JOIN pg_description b ON (b.objoid = a.oid)
				LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
			 WHERE a.relowner IN (SELECT oid FROM pg_roles WHERE rolname IN (USER, 'rif40')) 
			   AND b.objsubid = c.ordinal_position
			   AND a.relname  = c.table_or_view
		)
		SELECT object_type, object_schema, object_name
		  FROM a
		 WHERE NOT (object_schema = 'pg_toast' OR object_type IN ('INDEX'))
		   AND description IS NULL
		   AND l_object_schema = object_schema
		   AND l_object_type   = object_type
		 ORDER BY 1, 2, 3;
--
	c1_rec RECORD;
	c2_rec RECORD;
	c3_rec RECORD;
	c4_rec RECORD;
	c5_rec RECORD;
	c6_rec RECORD;
	c7_rec RECORD;
	c8_rec RECORD;
	c9_rec RECORD;
	c10_rec RECORD;
	c11_rec RECORD;
	c12_rec RECORD;
--
	i INTEGER:=0;
	j INTEGER:=0;
	k INTEGER:=0;
--
	schema_owner VARCHAR:='rif40';
	tag VARCHAR;
BEGIN
--
-- Must be rifupg34, rif40 or have rif_user or rif_manager rol
--
	IF USER != 'rifupg34' AND NOT rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_ddl_checks', 'User % must be rif40 or have rif_user or rif_manager role',
			USER::VARCHAR);
	END IF;
--
-- Schema owner is RIF40 unless we are RIFUPG34 and then it is public
--
	IF USER = 'rifupg34' THEN
		schema_owner:='public';
	END IF;
--
	PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_ddl_checks', 'Checking for missing table/view column comments');
	FOR c4_rec IN c4(schema_owner) LOOP
		PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_ddl_checks', 'Missing table/view column comment: %.%', 
			c4_rec.table_or_view::VARCHAR, c4_rec.column_name::VARCHAR);
		i:=i+1;
	END LOOP;
--
	PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_ddl_checks', 'Checking for missing table/view columns');
	FOR c3_rec IN c3(schema_owner) LOOP
		PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_ddl_checks', 'Missing table/view column: %.%', 
			c3_rec.table_or_view::VARCHAR, c3_rec.column_name::VARCHAR);
		i:=i+1;
	END LOOP;
--
	PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_ddl_checks', 'Checking for missing table/view comments');
	FOR c2_rec IN c2(schema_owner) LOOP
		IF c2_rec.description IS NULL THEN
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_ddl_checks', 'Missing table/view comment: %', 
				c2_rec.table_or_view::VARCHAR);
			i:=i+1;
		END IF;
	END LOOP;
--
	PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_ddl_checks', 'Checking for extra table/views');
	FOR c6_rec IN c6(schema_owner) LOOP
		IF USER NOT IN ('rif40', 'rifupg34') AND c6_rec.table_or_view IN ( /* Ordinary users - ignore  */
			'fdw_all_tab_columns', 'fdw_all_tables') THEN
			NULL;
		ELSIF USER IN ('peterh') THEN
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_ddl_checks', 'Extra table/view: %.% [IGNORED]', 
				USER::VARCHAR,
				c6_rec.table_or_view::VARCHAR);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_ddl_checks', 'Extra table/view: %', 
				c6_rec.table_or_view::VARCHAR);
			j:=j+1;
		END IF;
	END LOOP;
--
	IF USER != 'rifupg34' THEN
--
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_ddl_checks', 'Checking for missing table triggers');
		FOR c5_rec IN c5(schema_owner) LOOP
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_ddl_checks', 'Missing table trigger: (%) % [TRIGGER NEEDS TO BE ADDED]', 
				c5_rec.table_name::VARCHAR, c5_rec.trigger_name::VARCHAR);
			k:=k+1;
		END LOOP;
		IF k > 0 THEN
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_ddl_checks', '% missing table triggers', 
				k::VARCHAR);
			i:=i+k; /* This is now an error */
		END IF;
--
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_ddl_checks', 'Checking for missing sequences');
		FOR c7_rec IN c7(schema_owner) LOOP
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_ddl_checks', 'Missing sequences: %', 
				c7_rec.sequences::VARCHAR);
			i:=i+1;
		END LOOP;
--
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_ddl_checks', 'Checking for missing tables, views and sequences GRANT SELECT to rif_user and rif_manager');
		FOR c8_rec IN c8(schema_owner) LOOP
			IF (c8_rec.has_user_select = FALSE OR c8_rec.has_rif_user_select = FALSE OR c8_rec.has_rif_manager_select = FALSE) AND c8_rec.has_public_select = FALSE THEN
				PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_ddl_checks', 'Missing grant SELECT on % to rif_user(%) and rif_manager(%); user(%); public(%)', 
					c8_rec.table_or_view::VARCHAR, c8_rec.has_rif_user_select::VARCHAR, c8_rec.has_rif_manager_select::VARCHAR, 
					c8_rec.has_user_select::VARCHAR, c8_rec.has_public_select);
				IF c8_rec.has_rif_user_select = FALSE THEN
					PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_ddl_checks', 'Required SQL> GRANT SELECT ON % TO rif_user;', 
					c8_rec.table_or_view::VARCHAR);
				END IF;
				IF c8_rec.has_rif_manager_select = FALSE THEN
					PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_ddl_checks', 'Required SQL> GRANT SELECT ON % TO rif_manager;', c8_rec.table_or_view);
				END IF;
				i:=i+1;
			ELSE
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_ddl_checks', 'SELECT grant OK on % to rif_user(%) and rif_manager(%); user(%); public(%)', 
					c8_rec.table_or_view::VARCHAR, c8_rec.has_rif_user_select::VARCHAR, c8_rec.has_rif_manager_select::VARCHAR, 
					c8_rec.has_user_select::VARCHAR, c8_rec.has_public_select::VARCHAR);
			END IF;
		END LOOP;
--
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_ddl_checks', 'Checking all functions in rif40_sql_pkg, rif40_geo_pkg for GRANT EXECUTE to rif40, rif_user and rif_manager');
		FOR c9_rec IN c9(schema_owner) LOOP
			IF c9_rec.has_rif40_select = FALSE OR c9_rec.has_rif_user_select = FALSE OR c9_rec.has_rif_manager_select = FALSE THEN
				PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_ddl_checks', 'Missing grant EXECUTE on % % to rif40(%), rif_user(%) and rif_manager(%)', 
					c9_rec.object_type::VARCHAR, c9_rec.function_name::VARCHAR, c9_rec.has_rif40_select::VARCHAR, 
					c9_rec.has_rif_user_select::VARCHAR, c9_rec.has_rif_manager_select::VARCHAR);
				i:=i+1;
			ELSE
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_ddl_checks', 'EXECUTE grant OK on % % to rif40(%), rif_user(%) and rif_manager(%)', 
					c9_rec.object_type::VARCHAR, c9_rec.function_name::VARCHAR, c9_rec.has_rif40_select::VARCHAR, 
					c9_rec.has_rif_user_select::VARCHAR, c9_rec.has_rif_manager_select::VARCHAR);
			END IF;
		END LOOP;
--
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_ddl_checks', 'Checking for extra table/view columns');
		FOR c10_rec IN c10(schema_owner) LOOP
			IF USER NOT IN ('rif40', 'rifupg34') AND c10_rec.table_or_view IN ( /* Ordinary users - ignore  */
				'fdw_all_tab_columns', 'fdw_all_tables') THEN
				NULL;
			ELSIF c10_rec.table_schema IN ('gis', 'peterh') THEN
				PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_ddl_checks', 'Extra table/view column: %.%.% [IGNORED]', 
					c10_rec.table_schema::VARCHAR, c10_rec.table_or_view::VARCHAR, c10_rec.column_name::VARCHAR);
			ELSE
				PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_ddl_checks', 'Extra table/view column: %.%.%', 
					c10_rec.table_schema::VARCHAR, c10_rec.table_or_view::VARCHAR, c10_rec.column_name::VARCHAR);
				j:=j+1;
			END IF;
		END LOOP;
--
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_ddl_checks', 'Checking for missing comments');
		FOR c11_rec IN c11 LOOP
		 	IF c11_rec.missing_comments > 0 THEN
				IF c11_rec.object_schema LIKE 'rif40%' THEN
					tag:='WARNING';
				ELSE
					tag:='INFO';
				END IF;
				PERFORM rif40_log_pkg.rif40_log(tag::rif40_log_pkg.rif40_log_debug_level, 'rif40_ddl_checks', 'Missing %/% comments for schema % %s', 
					c11_rec.missing_comments::VARCHAR, 
					c11_rec.total_objects::VARCHAR,
					c11_rec.object_schema::VARCHAR, 
					c11_rec.object_type::VARCHAR); 
				FOR c12_rec IN c12(c11_rec.object_type, c11_rec.object_schema) LOOP
					IF c11_rec.object_schema LIKE 'rif40%' THEN
						i:=i+1;
				END IF;
					PERFORM rif40_log_pkg.rif40_log(tag::rif40_log_pkg.rif40_log_debug_level, 'rif40_ddl_checks', 'Missing comment for % %.%', 
						c12_rec.object_type::VARCHAR,
						c12_rec.object_schema::VARCHAR, 
						c12_rec.object_name::VARCHAR);
				END LOOP;
			ELSE
				PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_ddl_checks', 'No missing comments for schema % %s (%)', 
					c11_rec.object_schema::VARCHAR, 
					c11_rec.object_type::VARCHAR,
					c11_rec.total_objects::VARCHAR);
			END IF;
		END LOOP;
	END IF;
--
	PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_ddl_checks', 'Checking for missing table/views');
	FOR c1_rec IN c1(schema_owner) LOOP
		IF USER = 'rifupg34' AND c1_rec.table_or_view IN ( /* Not created in the upgrade schema */
				'g_rif40_comparison_areas', 'g_rif40_study_areas', 'rif40_user_version') THEN
			NULL;
		ELSIF USER = 'rifupg34' THEN
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_ddl_checks', 'Missing foreign data wrapper table/table/view: %', 
				c1_rec.table_or_view::VARCHAR);
			i:=i+1;
		ELSE
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_ddl_checks', 'Missing table/view: %', 
				c1_rec.table_or_view::VARCHAR);
			i:=i+1;
		END IF;
	END LOOP;
--
	IF i > 0 OR j > 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_ddl_checks', 
			'Schema: % % missing tables/triggers/views/columns/comments/sequences/grants; % extra; % warnings', 
			schema_owner::VARCHAR, i::VARCHAR, j::VARCHAR, k::VARCHAR);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_ddl_checks', 
			'Schema: % All tables/triggers/views/columns/comments/sequences/grants present; % warnings', 
			schema_owner::VARCHAR, k::VARCHAR);
	END IF;
END;
]]></definition>
</function>

<function name="rif40_does_role_exist"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_does_role_exist()
Parameters:	Database role
Returns:	TRUE or FALSE
Description:	Check if database role exists.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="role" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*
Function: 	rif40_does_role_exist()
Parameters:	Database role
Returns:	TRUE or FALSE
Description:	Check if database role exists
 */
DECLARE
	c1dre CURSOR(l_role VARCHAR) FOR /* Extra table/view columns */
		SELECT rolname
		  FROM pg_roles
		 WHERE rolname = l_role;
	c1dre_rec RECORD;
BEGIN
	IF role IS NULL THEN 
		RETURN FALSE;
	END IF;
--
	OPEN c1dre(role);
	FETCH c1dre INTO c1dre_rec;
	IF NOT FOUND THEN /* Does not exist, ignore */
		CLOSE c1dre;
		RETURN FALSE; 
	END IF;
	CLOSE c1dre;
--
	RETURN TRUE;
END;
]]></definition>
</function>

<function name="rif40_drop_user_table_or_view"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_drop_user_table_or_view()
Parameters:	Table or view name
Returns:	Nothing
Description:	Drops users table, view or temporary table if it exists. Trucates table first.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="table_or_view" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*
Function: 	rif40_drop_user_table_or_view()
Parameters:	Table or view name
Returns:	Nothing
Description:	Drops users table, view or temporary table if it exists. Trucates table first.
 */
DECLARE
	c1dut CURSOR(l_table_or_view VARCHAR) FOR 		/* User objects */
		SELECT TRUE AS truncate_table, TRUE AS is_table, tablename AS table_or_view		/* Local tables */
		  FROM pg_tables
		 WHERE tableowner = USER
		   AND schemaname = USER
		   AND tablename  = l_table_or_view
		 UNION
		SELECT FALSE AS truncate_table, FALSE AS is_table, viewname AS table_or_view 		/* Local views */
		  FROM pg_views
		 WHERE viewowner  = USER
		   AND schemaname = USER
		   AND viewname   = l_table_or_view
		 UNION
		SELECT FALSE AS truncate_table, TRUE AS is_table, a.relname AS table_or_view 		/* Temporary tables */
 		 FROM pg_roles r, pg_class a
			LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
		 WHERE a.relowner       = (SELECT oid FROM pg_roles WHERE rolname = USER)
		   AND a.relkind        = 'r' 				/* Relational table */
		   AND a.relpersistence = 't' 				/* Persistence: temporary */
		   AND a.relowner       = r.oid
		   AND n.nspname        LIKE 'pg_temp%'
		   AND a.relname        = l_table_or_view
		ORDER BY 1;
	c1dut_rec  RECORD;
--
	sql_stmt 	VARCHAR;
--
	error_message VARCHAR;
	v_detail VARCHAR:='(Not supported until 9.2; type SQL statement into psql to see remote error)';
--	v_version BOOLEAN:=(string_to_array(version()::Text, ' '::Text))[2] >= '9.2'; /* Check Postgres server version */
BEGIN
	IF table_or_view IS NULL THEN 
		RETURN;
	END IF;
--
	OPEN c1dut(table_or_view);
	FETCH c1dut INTO c1dut_rec;
	IF NOT FOUND THEN /* Does not exist, ignore */
		CLOSE c1dut;
		RETURN; 
	END IF;
	CLOSE c1dut;
--
--  Bin object
--
	IF c1dut.truncate_table THEN
		sql_stmt:='TRUNCATE TABLE '||table_or_view;
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_drop_user_table_or_view', 'SQL> %;', 
			sql_stmt::VARCHAR);
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	END IF;
	IF c1dut.is_table THEN
		sql_stmt:='DROP TABLE '||table_or_view;
	ELSE
		sql_stmt:='DROP VIEW '||table_or_view;
	END IF;
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_drop_user_table_or_view', 'SQL> %;', 
		sql_stmt::VARCHAR);
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
EXCEPTION
	WHEN others THEN
-- 
-- Not supported until 9.2
--
--		IF v_version THEN
--			GET STACKED DIAGNOTICS v_detail = PG_EXCETION_DETAIL;
--		END IF;
		error_message:='rif40_drop_user_table_or_view() caught: '||E'\n'||SQLERRM::VARCHAR||' in SQL (see previous trapped error)'||E'\n'||'Detail: '||v_detail::VARCHAR;
		RAISE INFO '1: %', error_message;
--
		RAISE;
END;
]]></definition>
</function>

<function name="rif40_fdw_table_select_test"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_fdw_table_select_test()
Parameters: 	Table name, column name, FDW server name, FDW server type
Returns: 	Text of error or NULL if all OK
Description:	Test user can select from FDW table name
		
		SQL> SELECT <column name> AS test FROM <table name> LIMIT 1;

		IF 1 row returned, RETURN NULL
		IF any of the inputs are NULL RETURN custom error message
		IF FDW server name is invalid/not accessible RETURN custom error message
		IF SQL error RETURN SQL error message
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="l_table_name" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_column_name" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="fdwservername" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="fdwservertype" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	rif40_fdw_table_select_test()
Parameters: 	Table name, column name, FDW server name, FDW server type
Returns: 	Text of error or NULL if all OK
Description:	Test user can select from FDW table name
		
		SQL> SELECT <column name> AS test FROM <table name> LIMIT 1;

		IF 1 row returned, RETURN NULL
		IF any of the inputs are NULL RETURN custom error message
		IF FDW server name is invalid/not accessible RETURN custom error message
		IF SQL error RETURN SQL error message

 */
DECLARE
	c1_st REFCURSOR;
	c6_st CURSOR(l_fdwservername VARCHAR) FOR 		/* FDW server name check */
		SELECT r.rolname AS srvowner, s.srvname
		  FROM pg_foreign_server s, pg_roles r
		 WHERE s.srvname  = l_fdwservername
		   AND s.srvowner = r.oid;
--
	c6_st_rec RECORD;
--
	test VARCHAR;
	sql_stmt VARCHAR;
	error_message VARCHAR:=NULL;
	l_rows INTEGER:=NULL;
--
	v_detail VARCHAR:='(Not supported until 9.2; type SQL statement into psql to see remote error)';
BEGIN
--
-- IF any of the inputs are NULL RETURN custom error message
--
	IF l_table_name IS NULL OR l_column_name IS NULL OR fdwservername IS NULL OR fdwservertype IS NULL THEN
		error_message:='rif40_fdw_table_select_test() C209xx: NULL Table name, column name, FDW server name or FDW server type';
	END IF;
	sql_stmt:='SELECT '||l_column_name||'::VARCHAR AS test FROM '||USER||'.'||l_table_name||' LIMIT 1';
--
-- Check access to FDWServerName
--
	IF error_message IS NULL THEN
		OPEN c6_st(fdwservername);
		FETCH c6_st INTO c6_st_rec;
		CLOSE c6_st;
		IF c6_st_rec.srvowner IS NULL THEN
			error_message:='rif40_fdw_table_select_test() FDW functionality disabled - FDWServerName: '||fdwservername::VARCHAR||' not found';
		ELSIF has_server_privilege(c6_st_rec.srvowner, c6_st_rec.srvname, 'USAGE') THEN
			NULL;
		ELSE
			error_message:='rif40_fdw_table_select_test() FDW functionality disabled - no access to FDWServerName: '||c6_st_rec.srvowner::VARCHAR||'.'||c6_st_rec.srvname::VARCHAR;
		END IF;
	END IF;
--
-- Run SELECT test
--
	IF error_message IS NULL THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'rif40_fdw_table_select_test', 'SQL> %;', 
			sql_stmt::VARCHAR);
		OPEN c1_st FOR EXECUTE sql_stmt;
		FETCH c1_st INTO test;
		GET DIAGNOSTICS l_rows = ROW_COUNT;
		CLOSE c1_st;
--
		IF l_rows IS NULL THEN
			error_message:='rif40_fdw_table_select_test() C209xx: NULL ROW_COUNT in: '||E'\n'||'SQL> '||sql_stmt||E'\n'||'for FDW '||
				l_table_name::VARCHAR||'.'||l_column_name::VARCHAR||' on '||fdwservertype::VARCHAR||' server '||fdwservername::VARCHAR;
		ELSIF l_rows = 0 THEN
			error_message:='rif40_fdw_table_select_test() C209xx: 0 ROW_COUNT in: '||E'\n'||'SQL> '||sql_stmt||E'\n'||'for FDW '||
				l_table_name::VARCHAR||'.'||l_column_name::VARCHAR||' on '||fdwservertype::VARCHAR||' server '||fdwservername::VARCHAR;
		ELSIF l_rows > 1 THEN
			error_message:='rif40_fdw_table_select_test() C209xx: Non zero ('||l_rows||') ROW_COUNT in: '||E'\n'||'SQL> '||sql_stmt||E'\n'||'for FDW '||
				l_table_name::VARCHAR||'.'||l_column_name::VARCHAR||' on '||fdwservertype::VARCHAR||' server '||fdwservername::VARCHAR;
		END IF;
	END IF;
--
	IF error_message IS NOT NULL THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'rif40_fdw_table_select_test', 'SQL> %; %', 
			sql_stmt::VARCHAR, error_message::VARCHAR);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'rif40_fdw_table_select_test', 'OK SQL> %;', 
			sql_stmt::VARCHAR);
	END IF;
--
	RETURN error_message;
EXCEPTION
	WHEN others THEN
-- 
-- Not supported until 9.2
--
--		GET STACKED DIAGNOTICS v_detail = PG_EXCETION_DETAIL;
		error_message:='rif40_fdw_table_select_test() caught: '||E'\n'||SQLERRM::VARCHAR||' in: '||E'\n'||'SQL> '||sql_stmt::VARCHAR||E'\n'||'for FDW '||
			l_table_name::VARCHAR||'.'||l_column_name::VARCHAR||' on '||fdwservertype::VARCHAR||' server '||fdwservername::VARCHAR||E'\n'||'Detail: '||v_detail::VARCHAR;
		PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_fdw_table_select_test', 'Caught exception: % [IGNORED]', 
			error_message::VARCHAR);
		RETURN error_message;
END;
]]></definition>
</function>

<function name="rif40_get_function_arg_types"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_get_function_arg_types()
Parameters: 	arg_type_list (pg_types.oid)
Returns: 	Text
Description:	Returns function signature e.g (character varying, character varying)

		Similar to pg_get_function_identity_arguments() without the function names
		For use with pg_proc]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="arg_type_list" in="true">
		<type name="oid" dimension="1"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	rif40_get_function_arg_types()
Parameters: 	arg_type_list (pg_types.oid)
Returns: 	Text
Description:	Returns function signature e.g (character varying, character varying)

		Similar to pg_get_function_identity_arguments() without the function names
		For use with pg_proc
 */
DECLARE
	ret TEXT;
	j INTEGER:=0;
BEGIN
	ret:='(';
--
	IF arg_type_list IS NOT NULL THEN
		FOR i IN array_lower(arg_type_list, 1) .. array_upper(arg_type_list, 1) LOOP
			IF i = array_lower(arg_type_list, 1) THEN
				ret:=ret||format_type(arg_type_list[i], NULL);
			ELSE
				ret:=ret||', '||format_type(arg_type_list[i], NULL);
			END IF;
			j:=j+1;
		END LOOP;
	END IF;
--
	ret:=ret||')';
	PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'rif40_get_function_arg_types', 'args: %, signature: %', 
		j::VARCHAR, ret::VARCHAR);
	RETURN ret;
END;
]]></definition>
</function>

<function name="rif40_hash_partition"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_method4()
Parameters:	Schema, table, column
Returns:	Nothing
Description:	Hash partition schema.table on column
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="l_schema" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="t_table" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_ciolumn" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*
Function: 	rif40_hash_partition()
Parameters:	Schema, table, column
Returns:	Nothing
Description:	Hash partition schema.table on column

 */
DECLARE
BEGIN
--
-- Must be rif40 or have rif_user or rif_manager role
--
	IF USER != 'rif40' AND NOT rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_hash_partition', 'User % must be rif40 or have rif_user or rif_manager role', 
			USER::VARCHAR);
	END IF;
END;
]]></definition>
</function>

<function name="rif40_is_object_resolvable"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_is_object_resolvable()
Parameters:	Table/view name
Returns: 	1 - resolvable and accessible, 0 - NOT
Description:	Is object resolvable?

Search search path for table/view/foreign table; check resolvable

Will need OracleFDW objects to check remote access]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="l_table_name" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[

/*

Function: 	rif40_is_object_resolvable()
Parameters:	Table/view name
Returns: 	1 - resolvable and accessible, 0 - NOT
Description:	Is object resolvable?

Search search path for table/view/foreign table; check resolvable

Will need OracleFDW objects to check remote access

 */
DECLARE
	c1 CURSOR FOR
		SELECT REPLACE(regexp_split_to_table(setting, E'\\s+'), ',', '') AS schemaname
	 	  FROM pg_settings
		 WHERE name = 'search_path';
	c2 CURSOR(l_schema VARCHAR, l_table VARCHAR) FOR
		SELECT schemaname, tablename
		  FROM pg_tables
		 WHERE schemaname = l_schema
		   AND tablename  = LOWER(l_table)
		 UNION
		SELECT schemaname, viewname AS tablename
		  FROM pg_views
		 WHERE schemaname = l_schema
		   AND viewname   = LOWER(l_table)
	 	 UNION
		SELECT n.nspname schemaname, a.relname tablename				/* FDW tables */
		  FROM pg_foreign_table b, pg_roles r, pg_class a
			LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
		 WHERE b.ftrelid = a.oid
		   AND a.relowner = (SELECT oid FROM pg_roles WHERE rolname = USER)
		   AND a.relowner = r.oid
		   AND n.nspname  = USER
		   AND n.nspname  = l_schema
		   AND a.relname  = LOWER(l_table);
--
	c1_rec RECORD;
	c2_rec RECORD;
BEGIN
--
-- Must be rif40 or have rif_user or rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_is_object_resolvable', 'User % must be rif40 or have rif_user or rif_manager role', 
			USER::VARCHAR);
	END IF;
--
-- If inputs are NULL return 0
--
	IF l_table_name IS NULL THEN
		RETURN 0;
	END IF;
--
	FOR c1_rec IN c1 LOOP
		OPEN c2(c1_rec.schemaname, l_table_name);
		FETCH c2 INTO c2_rec;
--
		IF c2_rec.tablename IS NOT NULL AND has_schema_privilege(USER, c1_rec.schemaname, 'USAGE') AND 
		   has_table_privilege(USER, c1_rec.schemaname||'.'||c2_rec.tablename, 'SELECT') /* or view or foreign table */ THEN
			CLOSE c2;
			RETURN 1;
		ELSIF c2_rec.tablename IS NULL THEN
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_is_object_resolvable', 'No table/view/foreign table: %.%', 
				c1_rec.schemaname::VARCHAR, LOWER(l_table_name)::VARCHAR);
		ELSIF c2_rec.tablename IS NOT NULL AND NOT has_schema_privilege(USER, c1_rec.schemaname, 'USAGE') THEN
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_is_object_resolvable', 'No access to schema % for table/view/foreign table: %.%', 
				c1_rec.schemaname::VARCHAR, c1_rec.schemaname::VARCHAR, LOWER(l_table_name)::VARCHAR);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_is_object_resolvable', 'No access to: %.%', 
				c1_rec.schemaname::VARCHAR, LOWER(l_table_name)::VARCHAR);
		END IF;
		CLOSE c2;
	END LOOP;
--
	RETURN 0;
END;
]]></definition>
</function>

<function name="rif40_method4"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_method4()
Parameters:	SQL SELECT statement
Returns:	Nothing
Description:	Log and execute SQL Dynamic SQL method 4 (Oracle name) SELECT statement
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="select_stmt" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="title" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*
Function: 	rif40_method4()
Parameters:	SQL SELECT statement, title
Returns:	Nothing
Description:	Log and execute SQL Dynamic SQL method 4 (Oracle name) SELECT statement

SELECT column_name, data_type, character_maximum_length, character_octet_length, numeric_precision, numeric_precision_radix, numeric_scale, datetime_precision
  FROM information_schema.columns a, pg_tables b 
		 WHERE b.schemaname = a.table_schema
		   AND a.table_name = b.tablename
		   AND b.tablename  = 'rif40_geographies';
 */
DECLARE
	sql_stmt 	VARCHAR;
	drop_stmt 	VARCHAR;
	select_text	VARCHAR:=NULL;
	temp_table 	VARCHAR:=NULL;
--
	c1m4 CURSOR(l_table VARCHAR) FOR /* Extra table/view columns */
		SELECT table_name, column_name,
		       CASE 													/* Work out column length */
				WHEN numeric_precision IS NOT NULL /* bits */ AND
				     LENGTH((2^numeric_precision)::Text) > LENGTH(column_name) AND 
				     LENGTH((2^numeric_precision)::Text) <= 40							THEN LENGTH((2^numeric_precision)::Text)
				WHEN numeric_precision IS NOT NULL /* bits */ AND
				     LENGTH((2^numeric_precision)::Text) > LENGTH(column_name) AND 
				     LENGTH((2^numeric_precision)::Text) > 40							THEN 40 /* Truncate at 40 characters */
				WHEN datetime_precision IS NOT NULL /* bits */  AND
				     LENGTH((2^datetime_precision)::Text) > LENGTH(column_name) AND 
				     LENGTH((2^datetime_precision)::Text) <= 40							THEN LENGTH((2^datetime_precision)::Text)
				WHEN datetime_precision IS NOT NULL /* bits */  AND
				     LENGTH((2^datetime_precision)::Text) > LENGTH(column_name) AND 
				     LENGTH((2^datetime_precision)::Text) > 40							THEN 40 /* Truncate at 40 characters */
				WHEN character_maximum_length > LENGTH(column_name) AND 
				     character_maximum_length <= 40 								THEN character_maximum_length
				WHEN character_maximum_length > LENGTH(column_name) AND 
				     character_maximum_length > 40 								THEN 40 /* Truncate at 40 characters */
				ELSE LENGTH(column_name)
		       END column_length
		  FROM information_schema.columns a, pg_tables b 
		 WHERE b.schemaname = a.table_schema
		   AND a.table_name = b.tablename
		   AND b.tableowner = USER
		   AND b.tablename  = l_table; 
	c2m4 REFCURSOR;
	c1m4_rec RECORD;
	c2m4_result_row	VARCHAR[];
--
	stp 		TIMESTAMP WITH TIME ZONE;
	etp 		TIMESTAMP WITH TIME ZONE;
	took 		INTERVAL;
	l_rows 		INTEGER:=0;
	j 		INTEGER:=0;
	display_len	INTEGER:=0;
	column_len	INTEGER[];
--
	error_message VARCHAR;
	v_detail VARCHAR:='(Not supported until 9.2; type SQL statement into psql to see remote error)';
BEGIN
--
-- Must be rifupg34, rif40 or have rif_user or rif_manager role
--
	IF USER != 'rifupg34' AND NOT rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_method4', 'User % must be rif40 or have rif_user or rif_manager role', 
			USER::VARCHAR);
	END IF;
--
	IF select_stmt IS NULL THEN
		RETURN;
	END IF;
	stp:=clock_timestamp();
--
-- Create results temporary table
--
	temp_table:='l_'||REPLACE(rif40_sql_pkg.sys_context(NULL, 'AUDSID'), '.', '_');
--
-- This could do with checking first to remove the notice:
-- psql:v4_0_rif40_sql_pkg.sql:3601: NOTICE:  table "l_7388_2456528_62637_130282_7388" does not exist, skipping
-- CONTEXT:  SQL statement "DROP TABLE IF EXISTS l_7388_2456528_62637_130282"
-- PL/pgSQL function "rif40_ddl" line 32 at EXECUTE statement
--
	drop_stmt:='DROP TABLE IF EXISTS '||temp_table;
	PERFORM rif40_sql_pkg.rif40_drop_user_table_or_view(temp_table);
--
-- SQL injection check
--
-- ADD

--
	sql_stmt:='EXPLAIN ANALYZE VERBOSE CREATE TEMPORARY TABLE '||temp_table||' AS '||E'\n'||select_stmt;
	PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Process table header
--
	FOR c1m4_rec IN c1m4(temp_table) LOOP
		j:=j+1;
		PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'rif40_method4', 'Column[%] %.%, length: %', 
			j::Text, 
			c1m4_rec.table_name, 
			c1m4_rec.column_name, 
			c1m4_rec.column_length::Text);
		display_len:=display_len+c1m4_rec.column_length+3;
		column_len[j]:=c1m4_rec.column_length;
		IF select_text IS NULL THEN
			select_text:=E'\n'||RPAD(c1m4_rec.column_name, c1m4_rec.column_length);
		ELSE
			select_text:=select_text||' | '||RPAD(c1m4_rec.column_name, c1m4_rec.column_length);
		END IF;
	END LOOP;
	select_text:=select_text||E'\n'||RPAD('-', display_len, '-');
--
-- Title
--
	IF title IS NOT NULL THEN
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_method4', E'\n'||title||E'\n'||RPAD('-', LENGTH(title), '-'));
	END IF;
--
-- FETCH from temporary table as an array
--
	sql_stmt:='SELECT TRANSLATE(string_to_array(x.*::Text, '','')::Text, ''()'', '''')::text[] FROM '||temp_table||' AS x';
	PERFORM rif40_log_pkg.rif40_log('DEBUG2', 'rif40_method4', 'SQL> %;', 
		select_stmt::VARCHAR);
	OPEN c2m4 FOR EXECUTE sql_stmt;
	LOOP
		FETCH c2m4 INTO c2m4_result_row;
		IF NOT FOUND THEN EXIT; END IF;
--  
		l_rows:=l_rows+1;
		select_text:=select_text||E'\n';
--
-- Process row array
--
		FOR i IN 1 .. j LOOP
			IF i = 1 THEN
				select_text:=select_text||RPAD(c2m4_result_row[i], column_len[i]);
			ELSE
				select_text:=select_text||' | '||RPAD(c2m4_result_row[i], column_len[i]);
			END IF;
		END LOOP;
	END LOOP;
	CLOSE c2m4;
--
	IF l_rows = 0 THEN
		select_text:=select_text||E'\n'||'(no rows)';
	ELSIF l_rows = 1 THEN
		select_text:=select_text||E'\n'||'('||l_rows::Text||' row)';
	ELSE
		select_text:=select_text||E'\n'||'('||l_rows::Text||' rows)';
	END IF;
--
-- Print SELECT
--
	PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_method4', select_text);
--
	etp:=clock_timestamp();
	took:=age(etp, stp);
	IF l_rows IS NULL THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG2', 'rif40_method4', 'Statement took: %', 
			took::VARCHAR);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG2', 'rif40_method4', 'Statement took: %, proccessed % rows', 
			took::VARCHAR, l_rows::VARCHAR);
	END IF;
--
	PERFORM rif40_sql_pkg.rif40_ddl(drop_stmt);
--
	RETURN;
EXCEPTION
	WHEN others THEN
-- 
-- Not supported until 9.2
--
--		GET STACKED DIAGNOTICS v_detail = PG_EXCEPTION_DETAIL;
		error_message:='rif40_method4('''||coalesce(title::VARCHAR, '')||''') caught: '||E'\n'||SQLERRM::VARCHAR||' in SQL (see previous trapped error)'||E'\n'||'Detail: '||v_detail::VARCHAR;
		RAISE INFO '1: %', error_message;
--
-- This will not work if the cursor is open, but as it is a temporary table it will be deleted on session end
--
		PERFORM rif40_sql_pkg.rif40_ddl(drop_stmt);
		RAISE;
END;
]]></definition>
</function>

<function name="rif40_num_denom_validate"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_num_denom_validate()
Parameters: 	geography, table/view/foreign table name
Returns: 	1 - table/view/foreign table has all geolevels present in geography, 0 - table/view/foreign table has some/all geolevels missing in geography
Description:	Validate numerator or denominator geolevels]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="l_geography" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_table_name" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[

/*

Function: 	rif40_num_denom_validate()
Parameters: 	geography, table/view/foreign table name
Returns: 	1 - table/view/foreign table has all geolevels present in geography, 0 - table/view/foreign table has some/all geolevels missing in geography
Description:	Validate numerator or denominator geolevels

 */
DECLARE
	c1ndv CURSOR(l_geography VARCHAR, l_owner VARCHAR, l_table VARCHAR) FOR
		WITH all_tab_columns AS (
			SELECT UPPER(a.tablename) AS tablename, UPPER(b.attname) AS columnname, UPPER(schemaname) AS schemaname	/* Tables */
			  FROM pg_tables a, pg_attribute b, pg_class c
			 WHERE c.oid        = b.attrelid
			   AND c.relname    = a.tablename
			   AND c.relkind    = 'r' /* Relational table */
			   AND c.relpersistence IN ('p', 'u') /* Persistence: permanent/unlogged */ 
			 UNION
			SELECT UPPER(a.viewname) AS tablename, UPPER(b.attname) AS columnname, UPPER(schemaname) AS schemaname	/* Views */
			  FROM pg_views a, pg_attribute b, pg_class c
			 WHERE c.oid        = b.attrelid
			   AND c.relname    = a.viewname
			   AND c.relkind    = 'v' /* View */
			 UNION
			SELECT UPPER(a.relname) AS tablename, UPPER(d.attname) AS columnname, UPPER(n.nspname) AS schemaname				/* User FDW foreign tables */
			  FROM pg_foreign_table b, pg_roles r, pg_attribute d, pg_class a
				LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
			 WHERE b.ftrelid  = a.oid
			   AND a.relowner = (SELECT oid FROM pg_roles WHERE rolname = USER)
			   AND a.relowner = r.oid
			   AND n.nspname  = USER
			   AND a.oid      = d.attrelid
		)
		SELECT COUNT(l.geolevel_name) total_geolevels,
    		       COUNT(c.columnname) total_columns 
		  FROM t_rif40_geolevels l
			LEFT OUTER JOIN all_tab_columns c ON (c.schemaname = l_owner AND 
				c.tablename = l_table   AND c.columnname = l.geolevel_name)
		 WHERE geography  = l_geography
   		   AND resolution = 1;
	c1_rec RECORD;
--
	l_owner	VARCHAR:=NULL;
	l_table	VARCHAR:=NULL;
BEGIN
--
-- Must be rif40 or have rif_user or rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_num_denom_validate', 'User % must be rif40 or have rif_user or rif_manager role', 
			USER::VARCHAR);
	END IF;
--
-- If inputs are NULL return 0
--
	IF l_geography IS NULL OR l_table_name IS NULL THEN
		RETURN 0;
	END IF;
--
-- Resolve schema owner of table (oracle version of this has to deal with synonyms as well)
--
	l_owner:=UPPER(rif40_sql_pkg.rif40_object_resolve(l_table_name));
--
-- Check geolevels
--
	IF l_owner IS NOT NULL THEN
		OPEN c1ndv(l_geography, l_owner, l_table_name);
		FETCH c1ndv INTO c1_rec;
		CLOSE c1ndv;
		PERFORM rif40_log_pkg.rif40_log('DEBUG2', 'rif40_num_denom_validate', '[%,%.%] total_geolevels (in geography): %; total_columns (in table/view/foreign table; matching geolevels columns): %', 
			l_geography::VARCHAR, l_owner::VARCHAR, l_table_name::VARCHAR, c1_rec.total_geolevels::VARCHAR, c1_rec.total_columns::VARCHAR);
		IF c1_rec.total_geolevels = c1_rec.total_columns THEN 
			RETURN 1;		/* Validated */
		END IF;
	END IF;
--
	RETURN 0;
END;
]]></definition>
</function>

<function name="rif40_object_resolve"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_object_resolve()
Parameters:	Table/view name
Returns: 	Schema owner for first object found with name in search path
Description:	Is object resolvable?

Search search path for table/view/foreign table
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="character varying"/>
	</return-type>
	<parameter name="l_table_name" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[

/*

Function: 	rif40_object_resolve()
Parameters:	Table/view name (forced into lower case)
Returns: 	Schema owner for first object found with name in search path
Description:	Is object resolvable?

Search search path for table/view/foreign table

 */
DECLARE
	c1or CURSOR FOR
		SELECT REPLACE(regexp_split_to_table(setting, E'\\s+'), ',', '') AS schemaname
	 	  FROM pg_settings
		 WHERE name = 'search_path';
	c2or CURSOR(l_schema VARCHAR, l_table VARCHAR) FOR
		SELECT schemaname, tablename
		  FROM pg_tables
		 WHERE schemaname = l_schema
		   AND tablename  = LOWER(l_table)
		 UNION
		SELECT schemaname, viewname AS tablename
		  FROM pg_views
		 WHERE schemaname = l_schema
		   AND viewname   = LOWER(l_table)
	 	 UNION
		SELECT n.nspname schemaname, a.relname tablename				/* FDW tables */
		  FROM pg_foreign_table b, pg_roles r, pg_class a
			LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
		 WHERE b.ftrelid = a.oid
		   AND a.relowner = (SELECT oid FROM pg_roles WHERE rolname = USER)
		   AND a.relowner = r.oid
		   AND n.nspname  = l_schema
		   AND a.relname  = LOWER(l_table);
--
	c1_rec RECORD;
	c2_rec RECORD;
BEGIN
--
-- Must be rif40 or have rif_user or rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_object_resolve', 'User % must be rif40 or have rif_user or rif_manager role', 
			USER::VARCHAR);
	END IF;
--
-- If inputs are NULL return 0
--
	IF l_table_name IS NULL THEN
		RETURN NULL;
	END IF;
--
	FOR c1_rec IN c1or LOOP
		OPEN c2or(c1_rec.schemaname, l_table_name);
		FETCH c2or INTO c2_rec;
--
		IF c2_rec.tablename IS NOT NULL AND has_schema_privilege(USER, c1_rec.schemaname, 'USAGE') /* or view or foreign table */ THEN
			CLOSE c2or;
			RETURN c1_rec.schemaname;
		ELSIF c2_rec.tablename IS NULL THEN
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_object_resolve', 'No table/view/foreign table: %.%', 
				c1_rec.schemaname::VARCHAR, LOWER(l_table_name)::VARCHAR);
		ELSIF c2_rec.tablename IS NOT NULL AND NOT has_schema_privilege(USER, c1_rec.schemaname, 'USAGE') THEN
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_object_resolve', 'No access to schema % for table/view/foreign table: %.%', 
				c1_rec.schemaname::VARCHAR, c1_rec.schemaname::VARCHAR, LOWER(l_table_name)::VARCHAR);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_object_resolve', 'No access to: %.%', 
				c1_rec.schemaname::VARCHAR, LOWER(l_table_name)::VARCHAR);
		END IF;
		CLOSE c2or;
	END LOOP;
--
	RETURN NULL;
END;
]]></definition>
</function>

<function name="rif40_range_partition"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_method4()
Parameters:	Schema, table, column
Returns:	Nothing
Description:	Range partition schema.table on column
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="l_schema" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="t_table" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_ciolumn" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*
Function: 	rif40_range_partition()
Parameters:	Schema, table, column
Returns:	Nothing
Description:	Range partition schema.table on column

 */
DECLARE
BEGIN
--
-- Must be rif40 or have rif_user or rif_manager role
--
	IF USER != 'rif40' AND NOT rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_range_partition', 'User % must be rif40 or have rif_user or rif_manager role', 
			USER::VARCHAR);
	END IF;
END;
]]></definition>
</function>

<function name="rif40_startup"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_startup()
Parameters:	None
Returns:	1 
Description:	Startup functions - for calling from /usr/local/pgsql/etc/psqlrc
		Postgres has no ON-LOGON trigger
		Java users will need to run this first
		Check 1FDW functionality enabled (RIF40_PARAMETER FDWServerName), settings, FOREIGN SERVER setup OK 
		Create if required FDW tables i.e. those numerators in RIF40_NUM_DENOM_ERRORS with no local table of the same name

Create:	 	TABLE t_rif40_num_denom [if required]
		VIEWS rif40_user_version, rif40_num_denom, rif40_num_denom_errors [if required]
		TEMPORARY TABLE g_rif40_study_areas, g_rif40_comparison_areas

		Only creates objects if rif40_geographies, rif40_tables, rif40_health_study_themes exist
		The VIEW rif40_user_version contains the revision string from this file. If it does not match or the view does not exist the objects are rebuilt.
		To force a rebuild:

DROP VIEW rif40_user_version;

Check access to RIF40 tables

SQL generated:

a) User local numerator and denominator pairs

CREATE TABLE peterh.t_rif40_num_denom (
        geography              VARCHAR(50)     NOT NULL,
        numerator_table        VARCHAR(30)     NOT NULL,
        denominator_table      VARCHAR(30)     NOT NULL);

b) Errors in rif40_num_denom VIEW of valid numerator and denominator pairs

CREATE OR REPLACE VIEW peterh.rif40_num_denom_errors
AS
WITH n AS (
        SELECT geography, numerator_table, numerator_description, automatic, is_object_resolvable, n_num_denom_validated, numerator_owner
          FROM (
                SELECT g.geography, n.table_name numerator_table, n.description numerator_description, n.automatic,
                       rif40_sql_pkg.rif40_is_object_resolvable(n.table_name) AS is_object_resolvable,
		       rif40_sql_pkg.rif40_num_denom_validate(g.geography, n.table_name) AS n_num_denom_validated,
		       rif40_sql_pkg.rif40_object_resolve(n.table_name) AS numerator_owner
                  FROM rif40_geographies g, rif40_tables n
                 WHERE n.isnumerator = 1
                   AND n.automatic   = 1) AS n1 -* Automatic numerators *-
), d AS (
        SELECT geography, denominator_table, denominator_description, is_object_resolvable, d_num_denom_validated, denominator_owner,
               rif40_sql_pkg.rif40_auto_indirect_checks(denominator_table)::text AS auto_indirect_error
          FROM (
	        SELECT g.geography, d.table_name denominator_table, d.description denominator_description,
	               rif40_sql_pkg.rif40_is_object_resolvable(d.table_name) is_object_resolvable,
		       rif40_sql_pkg.rif40_num_denom_validate(g.geography, d.table_name) AS d_num_denom_validated,
		       rif40_sql_pkg.rif40_object_resolve(d.table_name) AS denominator_owner
	          FROM rif40_geographies g, rif40_tables d
	         WHERE d.isindirectdenominator = 1
	           AND d.automatic             = 1) AS d1 -* Automatic denominators *-
)
SELECT n.geography,
       n.numerator_owner,
       n.numerator_table,
       n.is_object_resolvable AS is_numerator_resolvable,
       n.n_num_denom_validated,
       n.numerator_description,
       d.denominator_owner,
       d.denominator_table,
       d.is_object_resolvable AS is_denominator_resolvable,
       d.d_num_denom_validated,
       d.denominator_description,
       n.automatic,
       CASE
                WHEN d.auto_indirect_error IS NULL THEN 0 ELSE 1 END AS auto_indirect_error_flag,
       d.auto_indirect_error AS auto_indirect_error,
       f.create_status AS n_fdw_create_status,
       f.error_message AS n_fdw_error_message,
       f.date_created AS n_fdw_date_created,
       f.rowtest_passed AS n_fdw_rowtest_passed
  FROM d, n
	LEFT OUTER JOIN rif40_fdw_tables f ON (n.numerator_table = f.table_name)
 WHERE n.geography = d.geography
UNION
SELECT g.geography,
       rif40_sql_pkg.rif40_object_resolve(g.numerator_table) AS numerator_owner,
       g.numerator_table,
       rif40_sql_pkg.rif40_is_object_resolvable(g.numerator_table) AS is_numerator_resolvable,
       rif40_sql_pkg.rif40_num_denom_validate(g.geography, g.numerator_table) AS n_num_denom_validated, 
       n.description AS numerator_description,
       rif40_sql_pkg.rif40_object_resolve(g.denominator_table) AS denominator_owner,
       g.denominator_table,
       rif40_sql_pkg.rif40_is_object_resolvable(g.denominator_table) AS is_denominator_resolvable,
       rif40_sql_pkg.rif40_num_denom_validate(g.geography, g.denominator_table) AS d_num_denom_validated, 
       d.description AS denominator_description,
       0 AS automatic,
       0 AS auto_indirect_error_flag,
       NULL::text AS auto_indirect_error,
       f.create_status AS n_fdw_create_status,
       f.error_message AS n_fdw_error_message,
       f.date_created AS n_fdw_date_created,
       f.rowtest_passed AS n_fdw_rowtest_passed
  FROM t_rif40_num_denom g
        LEFT OUTER JOIN rif40_tables n ON (n.table_name = g.numerator_table)
        LEFT OUTER JOIN rif40_tables d ON (d.table_name = g.denominator_table)
	LEFT OUTER JOIN rif40_fdw_tables f ON (n.table_name = f.table_name)
 ORDER BY 1, 2, 5;

Query to display RIF40_NUM_DENOM_ERRORS:

SELECT geography AS geog, 
       numerator_owner AS n_owner, numerator_table, is_numerator_resolvable AS n_resolv, n_num_denom_validated AS n_nd_valid, 
       denominator_owner AS d_owner, denominator_table, is_denominator_resolvable AS d_resolv, d_num_denom_validated AS d_nd_valid, 
       automatic AS auto, n_fdw_date_created,
       CASE WHEN n_num_denom_validated = 1 AND d_num_denom_validated = 1 THEN 1 ELSE 0 END AS ok
 FROM rif40_num_denom_errors
 ORDER BY n_num_denom_validated DESC, d_num_denom_validated DESC, is_numerator_resolvable DESC, is_denominator_resolvable DESC, denominator_table, numerator_table;

c) rif40_num_denom VIEW of valid numerator and denominator pairs

CREATE OR REPLACE VIEW peterh.rif40_num_denom
AS
WITH n AS (
        SELECT geography, numerator_table, numerator_description, automatic, theme_description
          FROM (
                SELECT g.geography, n.table_name AS numerator_table, n.description AS numerator_description, n.automatic,
                       t.description AS theme_description
                  FROM rif40_geographies g, rif40_tables n, rif40_health_study_themes t
                 WHERE n.isnumerator = 1
                   AND n.automatic   = 1
                   AND rif40_sql_pkg.rif40_is_object_resolvable(n.table_name) = 1
                   AND n.theme       = t.theme) n1
         WHERE rif40_sql_pkg.rif40_num_denom_validate(n1.geography, n1.numerator_table) = 1
), d AS (
        SELECT geography, denominator_table, denominator_description
          FROM (
                        SELECT g.geography, d.table_name AS denominator_table, d.description AS denominator_description
                          FROM rif40_geographies g, rif40_tables d
                         WHERE d.isindirectdenominator = 1
                           AND d.automatic             = 1
                           AND rif40_sql_pkg.rif40_is_object_resolvable(d.table_name) = 1) d1
        WHERE rif40_sql_pkg.rif40_num_denom_validate(d1.geography, d1.denominator_table) = 1
          AND rif40_sql_pkg.rif40_auto_indirect_checks(d1.denominator_table) IS NULL
)
SELECT n.geography,
       n.numerator_table,
       n.numerator_description,
       n.theme_description,
       d.denominator_table,
       d.denominator_description,
       n.automatic
  FROM d, n
 WHERE n.geography = d.geography
UNION
SELECT g.geography,
       g.numerator_table,
       n.description AS numerator_description,
       'Local user theme' AS theme_description,
       g.denominator_table,
       d.description AS denominator_description,
       0 automatic
  FROM t_rif40_num_denom g
        LEFT OUTER JOIN rif40_tables n ON (n.table_name = g.numerator_table)
        LEFT OUTER JOIN rif40_tables d ON (d.table_name = g.denominator_table)
 ORDER BY 1, 2, 4;

d) Temporary study and comparision area tables.  Used to speed up extracts. On Postgres they are not global and need to be created for each session

CREATE GLOBAL TEMPORARY TABLE g_rif40_study_areas (
        study_id                INTEGER         NOT NULL,
        area_id                 VARCHAR(300)    NOT NULL,
        band_id                 INTEGER) ON COMMIT PRESERVE ROWS;

CREATE GLOBAL TEMPORARY TABLE g_rif40_comparison_areas (
        study_id                INTEGER         NOT NULL,
        area_id                 VARCHAR(300)    NOT NULL) ON COMMIT PRESERVE ROWS;

e) Revision control view

CREATE OR REPLACE VIEW peterh.rif40_user_version AS SELECT CAST('1.10' AS numeric) AS user_schema_revision;
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<definition><![CDATA[
/*

Function: 	rif40_startup()
Parameters:	None
Returns:	1 
Description:	Startup functions - for calling from /usr/local/pgsql/etc/psqlrc
		Postgres has no ON-LOGON trigger
		Java users will need to run this first
		Check 1FDW functionality enabled (RIF40_PARAMETER FDWServerName), settings, FOREIGN SERVER setup OK 
		Create if required FDW tables i.e. those numerators in RIF40_NUM_DENOM_ERRORS with no local table of the same name

Create:	 	TABLE t_rif40_num_denom [if required]
		VIEWS rif40_user_version, rif40_num_denom, rif40_num_denom_errors [if required]
		TEMPORARY TABLE g_rif40_study_areas, g_rif40_comparison_areas

		Only creates objects if rif40_geographies, rif40_tables, rif40_health_study_themes exist
		The VIEW rif40_user_version contains the revision string from this file. If it does not match or the view does not exist the objects are rebuilt.
		To force a rebuild:

DROP VIEW rif40_user_version;

Check access to RIF40 tables

SQL generated:

a) User local numerator and denominator pairs

CREATE TABLE peterh.t_rif40_num_denom (
        geography              VARCHAR(50)     NOT NULL,
        numerator_table        VARCHAR(30)     NOT NULL,
        denominator_table      VARCHAR(30)     NOT NULL);

b) Errors in rif40_num_denom VIEW of valid numerator and denominator pairs

CREATE OR REPLACE VIEW peterh.rif40_num_denom_errors
AS
WITH n AS (
        SELECT geography, numerator_table, numerator_description, automatic, is_object_resolvable, n_num_denom_validated, numerator_owner
          FROM (
                SELECT g.geography, n.table_name numerator_table, n.description numerator_description, n.automatic,
                       rif40_sql_pkg.rif40_is_object_resolvable(n.table_name) AS is_object_resolvable,
		       rif40_sql_pkg.rif40_num_denom_validate(g.geography, n.table_name) AS n_num_denom_validated,
		       rif40_sql_pkg.rif40_object_resolve(n.table_name) AS numerator_owner
                  FROM rif40_geographies g, rif40_tables n
                 WHERE n.isnumerator = 1
                   AND n.automatic   = 1) AS n1 -* Automatic numerators *-
), d AS (
        SELECT geography, denominator_table, denominator_description, is_object_resolvable, d_num_denom_validated, denominator_owner,
               rif40_sql_pkg.rif40_auto_indirect_checks(denominator_table)::text AS auto_indirect_error
          FROM (
	        SELECT g.geography, d.table_name denominator_table, d.description denominator_description,
	               rif40_sql_pkg.rif40_is_object_resolvable(d.table_name) is_object_resolvable,
		       rif40_sql_pkg.rif40_num_denom_validate(g.geography, d.table_name) AS d_num_denom_validated,
		       rif40_sql_pkg.rif40_object_resolve(d.table_name) AS denominator_owner
	          FROM rif40_geographies g, rif40_tables d
	         WHERE d.isindirectdenominator = 1
	           AND d.automatic             = 1) AS d1 -* Automatic denominators *-
)
SELECT n.geography,
       n.numerator_owner,
       n.numerator_table,
       n.is_object_resolvable AS is_numerator_resolvable,
       n.n_num_denom_validated,
       n.numerator_description,
       d.denominator_owner,
       d.denominator_table,
       d.is_object_resolvable AS is_denominator_resolvable,
       d.d_num_denom_validated,
       d.denominator_description,
       n.automatic,
       CASE
                WHEN d.auto_indirect_error IS NULL THEN 0 ELSE 1 END AS auto_indirect_error_flag,
       d.auto_indirect_error AS auto_indirect_error,
       f.create_status AS n_fdw_create_status,
       f.error_message AS n_fdw_error_message,
       f.date_created AS n_fdw_date_created,
       f.rowtest_passed AS n_fdw_rowtest_passed
  FROM d, n
	LEFT OUTER JOIN rif40_fdw_tables f ON (n.numerator_table = f.table_name)
 WHERE n.geography = d.geography
UNION
SELECT g.geography,
       rif40_sql_pkg.rif40_object_resolve(g.numerator_table) AS numerator_owner,
       g.numerator_table,
       rif40_sql_pkg.rif40_is_object_resolvable(g.numerator_table) AS is_numerator_resolvable,
       rif40_sql_pkg.rif40_num_denom_validate(g.geography, g.numerator_table) AS n_num_denom_validated, 
       n.description AS numerator_description,
       rif40_sql_pkg.rif40_object_resolve(g.denominator_table) AS denominator_owner,
       g.denominator_table,
       rif40_sql_pkg.rif40_is_object_resolvable(g.denominator_table) AS is_denominator_resolvable,
       rif40_sql_pkg.rif40_num_denom_validate(g.geography, g.denominator_table) AS d_num_denom_validated, 
       d.description AS denominator_description,
       0 AS automatic,
       0 AS auto_indirect_error_flag,
       NULL::text AS auto_indirect_error,
       f.create_status AS n_fdw_create_status,
       f.error_message AS n_fdw_error_message,
       f.date_created AS n_fdw_date_created,
       f.rowtest_passed AS n_fdw_rowtest_passed
  FROM t_rif40_num_denom g
        LEFT OUTER JOIN rif40_tables n ON (n.table_name = g.numerator_table)
        LEFT OUTER JOIN rif40_tables d ON (d.table_name = g.denominator_table)
	LEFT OUTER JOIN rif40_fdw_tables f ON (n.table_name = f.table_name)
 ORDER BY 1, 2, 5;

Query to display RIF40_NUM_DENOM_ERRORS:

SELECT geography AS geog, 
       numerator_owner AS n_owner, numerator_table, is_numerator_resolvable AS n_resolv, n_num_denom_validated AS n_nd_valid, 
       denominator_owner AS d_owner, denominator_table, is_denominator_resolvable AS d_resolv, d_num_denom_validated AS d_nd_valid, 
       automatic AS auto, n_fdw_date_created,
       CASE WHEN n_num_denom_validated = 1 AND d_num_denom_validated = 1 THEN 1 ELSE 0 END AS ok
 FROM rif40_num_denom_errors
 ORDER BY n_num_denom_validated DESC, d_num_denom_validated DESC, is_numerator_resolvable DESC, is_denominator_resolvable DESC, denominator_table, numerator_table;

c) rif40_num_denom VIEW of valid numerator and denominator pairs

CREATE OR REPLACE VIEW peterh.rif40_num_denom
AS
WITH n AS (
        SELECT geography, numerator_table, numerator_description, automatic, theme_description
          FROM (
                SELECT g.geography, n.table_name AS numerator_table, n.description AS numerator_description, n.automatic,
                       t.description AS theme_description
                  FROM rif40_geographies g, rif40_tables n, rif40_health_study_themes t
                 WHERE n.isnumerator = 1
                   AND n.automatic   = 1
                   AND rif40_sql_pkg.rif40_is_object_resolvable(n.table_name) = 1
                   AND n.theme       = t.theme) n1
         WHERE rif40_sql_pkg.rif40_num_denom_validate(n1.geography, n1.numerator_table) = 1
), d AS (
        SELECT geography, denominator_table, denominator_description
          FROM (
                        SELECT g.geography, d.table_name AS denominator_table, d.description AS denominator_description
                          FROM rif40_geographies g, rif40_tables d
                         WHERE d.isindirectdenominator = 1
                           AND d.automatic             = 1
                           AND rif40_sql_pkg.rif40_is_object_resolvable(d.table_name) = 1) d1
        WHERE rif40_sql_pkg.rif40_num_denom_validate(d1.geography, d1.denominator_table) = 1
          AND rif40_sql_pkg.rif40_auto_indirect_checks(d1.denominator_table) IS NULL
)
SELECT n.geography,
       n.numerator_table,
       n.numerator_description,
       n.theme_description,
       d.denominator_table,
       d.denominator_description,
       n.automatic
  FROM d, n
 WHERE n.geography = d.geography
UNION
SELECT g.geography,
       g.numerator_table,
       n.description AS numerator_description,
       'Local user theme' AS theme_description,
       g.denominator_table,
       d.description AS denominator_description,
       0 automatic
  FROM t_rif40_num_denom g
        LEFT OUTER JOIN rif40_tables n ON (n.table_name = g.numerator_table)
        LEFT OUTER JOIN rif40_tables d ON (d.table_name = g.denominator_table)
 ORDER BY 1, 2, 4;

d) Temporary study and comparision area tables.  Used to speed up extracts. On Postgres they are not global and need to be created for each session

CREATE GLOBAL TEMPORARY TABLE g_rif40_study_areas (
        study_id                INTEGER         NOT NULL,
        area_id                 VARCHAR(300)    NOT NULL,
        band_id                 INTEGER) ON COMMIT PRESERVE ROWS;

CREATE GLOBAL TEMPORARY TABLE g_rif40_comparison_areas (
        study_id                INTEGER         NOT NULL,
        area_id                 VARCHAR(300)    NOT NULL) ON COMMIT PRESERVE ROWS;

e) Revision control view

CREATE OR REPLACE VIEW peterh.rif40_user_version AS SELECT CAST('1.10' AS numeric) AS user_schema_revision;

 */
DECLARE
	c1 CURSOR FOR
		SELECT COUNT(tablename) AS total
		  FROM pg_tables
		 WHERE tablename IN ('rif40_geographies', 'rif40_tables', 'rif40_health_study_themes');
	c2 CURSOR(l_table_or_view VARCHAR) FOR 		/* User objects */
		SELECT tablename AS table_or_view			/* Local tables */
		  FROM pg_tables
		 WHERE tableowner = USER
		   AND schemaname = USER
		   AND tablename  = l_table_or_view
		 UNION
		SELECT viewname	AS table_or_view 			/* Local views */
		  FROM pg_views
		 WHERE viewowner  = USER
		   AND schemaname = USER
		   AND viewname   = l_table_or_view
		 UNION
		SELECT a.relname table_or_view 				/* Temporary tables */
 		 FROM pg_roles r, pg_class a
			LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
		 WHERE a.relowner       = (SELECT oid FROM pg_roles WHERE rolname = USER)
		   AND a.relkind        = 'r' 				/* Relational table */
		   AND a.relpersistence = 't' 				/* Persistence: temporary */
		   AND a.relowner       = r.oid
		   AND n.nspname        LIKE 'pg_temp%'
		   AND pg_table_is_visible(a.oid)		/* Table is visible in users current schema */
		   AND a.relname        = l_table_or_view
		ORDER BY 1;
	c3 CURSOR FOR					/* Current revision of user schema */
		SELECT user_schema_revision::VARCHAR
		  FROM rif40_user_version;
	c4 CURSOR FOR					/* Schema search path */
		SELECT name, REPLACE(setting, USER||', ', '') AS setting, reset_val
	 	  FROM pg_settings
		 WHERE name = 'search_path';
	c5 CURSOR FOR					/* FDW Settings in RIF40_PARAMETERS */
		SELECT a.param_value AS fdwservername,
		       b.param_value AS fdwservertype,
		       c.param_value AS fdwdbserver
		  FROM rif40_parameters a, rif40_parameters b, rif40_parameters c
		 WHERE a.param_name = 'FDWServerName'
		   AND b.param_name = 'FDWServerType'
		   AND c.param_name = 'FDWDBServer';
	c6 CURSOR(l_fdwservername VARCHAR) FOR 		/* FDW server name check */
		SELECT r.rolname AS srvowner, s.srvname
		  FROM pg_foreign_server s, pg_roles r
		 WHERE s.srvname  = l_fdwservername
		   AND s.srvowner = r.oid;
	c7 CURSOR FOR					/* Potential FDW tables i.e. those numerators in RIF40_NUM_DENOM_ERRORS with no local table of the same name */
		WITH a AS (
			SELECT numerator_table, numerator_owner, is_numerator_resolvable, COUNT(DISTINCT(geography))::INTEGER AS total_geographies
			  FROM rif40_num_denom_errors
			 GROUP BY numerator_table, numerator_owner, is_numerator_resolvable
		), b AS (
			SELECT a.relname AS foreign_table				/* FDW tables */
			  FROM pg_foreign_table b, pg_roles r, pg_class a, pg_namespace n
			 WHERE b.ftrelid  = a.oid
			   AND a.relowner = (SELECT oid FROM pg_roles WHERE rolname = USER)
			   AND a.relowner = r.oid
			   AND n.nspname  = USER
			   AND n.oid      = a.relnamespace
			   AND a.relname NOT LIKE 'fdw%'
		), c AS (
			SELECT LOWER(a.numerator_table) AS table_or_view
			  FROM a
			 UNION
			SELECT LOWER(b.foreign_table) AS table_or_view
			  FROM b
		)
		SELECT c.table_or_view AS foreign_table,
 		       CASE WHEN b.foreign_table = c.table_or_view THEN 1 ELSE 0 END AS foreign_table_exists,
                       CASE WHEN a.numerator_owner IS NOT NULL AND a.is_numerator_resolvable = 1 THEN 1 ELSE 0 END AS table_ok,
		       a.total_geographies,
                       f.create_status, f.error_message, f.date_created, f.rowtest_passed
		  FROM c
			LEFT OUTER JOIN rif40_fdw_tables f ON (c.table_or_view = LOWER(f.table_name))
			LEFT OUTER JOIN b ON (b.foreign_table = c.table_or_view)
			LEFT OUTER JOIN a ON (c.table_or_view = LOWER(a.numerator_table))
		 ORDER BY 1;
	c8 CURSOR FOR					/* Obsolete FDW tables i.e. those no longer in RIF40_NUM_DENOM_ERRORS */
		WITH a AS (
			SELECT numerator_table, denominator_table
			  FROM rif40_num_denom_errors
		), b AS (
			SELECT a.relname AS foreign_table				/* FDW tables */
			  FROM pg_foreign_table b, pg_roles r, pg_class a, pg_namespace n, rif40_fdw_tables t
			 WHERE b.ftrelid  = a.oid
			   AND a.relowner = (SELECT oid FROM pg_roles WHERE rolname = USER)
			   AND a.relowner = r.oid
			   AND n.nspname  = USER
			   AND n.oid      = a.relnamespace
			   AND a.relname NOT LIKE 'fdw%'
			   AND a.relname  = LOWER(t.table_name)
		), c AS (
			SELECT b.foreign_table
			  FROM b 
			EXCEPT 
			SELECT b1.table_or_view
			  FROM (
				SELECT LOWER(a.numerator_table) AS table_or_view
				  FROM a
				 UNION
				SELECT LOWER(a.denominator_table) AS table_or_view
				  FROM a) AS b1
		)
		SELECT c.foreign_table, b.create_status, b.error_message, b.date_created, b.rowtest_passed
		  FROM c, rif40_fdw_tables b
		 WHERE c.foreign_table = LOWER(b.table_name)
		 ORDER BY 1;
--
	c9 CURSOR FOR
		SELECT PostGIS_Version() AS PostGIS_Version /* Expecting "2.0 USE_GEOS=1 USE_PROJ=1 USE_STATS=1" */, 
		       PostGIS_geos_version() AS PostGIS_geos_version,
		       PostGIS_lib_version() AS PostGIS_lib_version,  
		       PostGIS_libXML_version() AS PostGIS_libXML_version,  
		       PostGIS_PROJ_version() AS PostGIS_PROJ_version,  
		       PostGIS_GDAL_version() AS PostGIS_GDAL_version, 
		       PostGIS_raster_lib_version() AS PostGIS_raster_lib_version,
		       PostGIS_Full_Version() AS PostGIS_Full_Version;
	c10 CURSOR(l_extension VARCHAR) FOR
		SELECT extname, extversion /* Required: postgis plpgsql; optional: adminpack, plperl, oracle_fdw, postgis_topology, dblink */
		  FROM pg_extension
		 WHERE extname = l_extension;
--
	c1_rec RECORD;
	c2_rec RECORD;
	c3_rec RECORD;
	c4_rec RECORD;
	c5_rec RECORD;
	c6_rec RECORD;
	c7_rec RECORD;
	c8_rec RECORD;
	c9_rec RECORD;
	c10_rec RECORD;
--
	rif40_num_denom BOOLEAN:=FALSE;	
	rif40_num_denom_errors BOOLEAN:=FALSE;	
	t_rif40_num_denom BOOLEAN:=FALSE;	
	g_rif40_study_areas BOOLEAN:=FALSE;	
	g_rif40_comparison_areas BOOLEAN:=FALSE;	
	rif40_user_version BOOLEAN:=FALSE;	
--
	fdw_enabled BOOLEAN:=FALSE;	
--
	drop_objects BOOLEAN:=FALSE; 			/* To force a rebuild */
--
	sql_stmt VARCHAR;
	i INTEGER:=0;					/* CREATE count */
	j INTEGER:=0;					/* DROP count */
--
-- Revision control rebuild will blow up if you branch...
--
	cvs_revision VARCHAR:='$Revision: 1.11 $';	/* DO NOT EDIT THIS - IT IS FOR CVSs benefit */
BEGIN
--
-- Must be rif40 or have rif_user or rif_manager role
--
	IF NOT rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'disabled - user % is not or has rif_user or rif_manager role', USER::VARCHAR);
		RETURN;
	END IF;
--
-- Setup logging
--
	PERFORM rif40_log_pkg.rif40_log_setup();
--
-- Prepend user to search path if not RIF40 (otherwise the function will try and create the objects in the rif40 schema, 
-- and you will use the rif40 t_rif40_num_denom). Add rif_studies (schema for study extracts/maps)
--
	OPEN c4;
	FETCH c4 INTO c4_rec;
	CLOSE c4;
	IF c4_rec.name IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_startup', 'search_path NOT found');
	ELSIF USER NOT IN ('rif40', 'postgres') THEN
		sql_stmt:='SET search_path TO '||USER||','||c4_rec.setting||',rif_studies';
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'SQL> %;', sql_stmt);
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		OPEN c4;
		FETCH c4 INTO c4_rec;
		CLOSE c4;
	ELSE
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'search_path not set for: %', USER::VARCHAR);
	END IF;	
--
-- Check extensions Required: postgis plpgsql; optional: adminpack, plperl, oracle_fdw, postgis_topology, dblink
-- 
	OPEN c10('postgis');
	FETCH c10 INTO c10_rec;
	CLOSE c10;
	IF c10_rec.extname IS NULL THEN
		PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_startup', 'PostGIS extension is not loaded');
	ELSE
		OPEN c9;
		FETCH c9 INTO c9_rec;
		CLOSE c9;
		IF c9_rec.postgis_geos_version IS NULL THEN
			PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_startup', 'PostGIS extension was not compiled with GEOS');
		ELSIF c9_rec.postgis_libxml_version IS NULL THEN
			PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_startup', 'PostGIS extension was not compiled with XML');
		ELSIF c9_rec.postgis_proj_version IS NULL THEN
			PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_startup', 'PostGIS extension was not compiled with PROJ');
		ELSIF c9_rec.postgis_gdal_version IS NULL THEN
			PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_startup', 'PostGIS extension was not compiled with GDAL');
		ELSIF c9_rec.postgis_raster_lib_version IS NULL THEN
			PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_startup', 'PostGIS extension was not compiled with RASTER');
		ELSE
			PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'PostGIS extension V% (%)',
				c10_rec.extversion::VARCHAR, c9_rec.PostGIS_Full_Version::VARCHAR);
		END IF;
	END IF;

--
-- Get FDWServerName, FDWServerType, FDWDBServer from RIF40_PARAMETERS
--
	OPEN c5;
	FETCH c5 INTO c5_rec;
	CLOSE c5;
	IF c5_rec.fdwservername IS NULL OR c5_rec.fdwservertype IS NULL OR c5_rec.fdwdbserver IS NULL OR 
	   c5_rec.fdwservername = ''    OR c5_rec.fdwservertype = ''    OR c5_rec.fdwdbserver = '' THEN
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'FDW functionality disabled - FDWServerName, FDWServerType, FDWDBServer RIF parameters not set.');
	ELSE
--
-- Check FDW server is installed
--
		OPEN c10(c5_rec.fdwservertype);
		FETCH c10 INTO c10_rec;
		CLOSE c10;
		IF c10_rec.extname IS NULL THEN
			PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_startup', 'Foreign data wrapper server extension: % not loaded', 
				c5_rec.fdwservertype::VARCHAR);
		END IF;
--
-- Check access to FDWServerName
--
		OPEN c6(c5_rec.fdwservername);
		FETCH c6 INTO c6_rec;
		CLOSE c6;
		IF c6_rec.srvowner IS NULL THEN
			PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'FDW functionality disabled - FDWServerName: % not found', 
				c5_rec.fdwservername::VARCHAR);
		ELSIF has_server_privilege(c6_rec.srvowner, c6_rec.srvname, 'USAGE') THEN
			fdw_enabled:=TRUE;
			PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'FDW functionality enabled to FDWServerName: %.% using % V%', 
				c6_rec.srvowner::VARCHAR, c6_rec.srvname::VARCHAR, c5_rec.fdwservertype::VARCHAR, c10_rec.extversion::VARCHAR);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'FDW functionality disabled - no access to FDWServerName: %.%', 
				c6_rec.srvowner::VARCHAR, c6_rec.srvname::VARCHAR);
		END IF;
--
-- DB link is required
--
		OPEN c10('dblink');
		FETCH c10 INTO c10_rec;
		CLOSE c10;
		IF c10_rec.extname IS NULL THEN
			PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_startup', 'Dblink extension is not loaded');
		END IF;
	END IF;
--
-- Check rif40_geographies, rif40_tables, rif40_health_study_themes exist
--
	OPEN c1;
	FETCH c1 INTO c1_rec;
	CLOSE c1;
--
-- Check user objects exist
--
	OPEN c2('rif40_num_denom');
	FETCH c2 INTO c2_rec;
	IF c2_rec.table_or_view = 'rif40_num_denom' THEN
		rif40_num_denom:=TRUE;
	END IF;
	CLOSE c2;
	OPEN c2('rif40_num_denom_errors');
	FETCH c2 INTO c2_rec;
	IF c2_rec.table_or_view = 'rif40_num_denom_errors' THEN
		rif40_num_denom_errors:=TRUE;
	END IF;
	CLOSE c2;
	OPEN c2('t_rif40_num_denom');
	FETCH c2 INTO c2_rec;
	IF c2_rec.table_or_view = 't_rif40_num_denom' THEN
		t_rif40_num_denom:=TRUE;
	END IF;
	CLOSE c2;
	OPEN c2('g_rif40_study_areas');
	FETCH c2 INTO c2_rec;
--
-- Fixed - for multiple logons 
--
	IF c2_rec.table_or_view = 'g_rif40_study_areas' THEN
		g_rif40_study_areas:=TRUE;
	END IF;
	CLOSE c2;
	OPEN c2('g_rif40_comparison_areas');
	FETCH c2 INTO c2_rec;
	IF c2_rec.table_or_view = 'g_rif40_comparison_areas' THEN		
		g_rif40_comparison_areas:=TRUE;
	END IF;
	CLOSE c2;
	OPEN c2('rif40_user_version');
	FETCH c2 INTO c2_rec;
	IF c2_rec.table_or_view = 'rif40_user_version' THEN
		rif40_user_version:=TRUE;
	END IF;
	CLOSE c2;
--
-- Get rif40_user_version revision
--
	IF rif40_user_version THEN
		OPEN c3;
		FETCH c3 INTO c3_rec;
		CLOSE c3;
		IF cvs_revision = c3_rec.user_schema_revision THEN
			PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'V% DB version % matches', 
				cvs_revision::VARCHAR, c3_rec.user_schema_revision::VARCHAR);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'V% DB version % mismatch; object; rebuild forced', 
				cvs_revision::VARCHAR, c3_rec.user_schema_revision::VARCHAR);
			drop_objects:=TRUE;
		END IF;
	END IF;
--
-- Check for the presence of dependent tables
--
	IF c1_rec.total != 3 THEN
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 
			'V% rif40_geographies, rif40_tables, rif40_health_study_themes do not [YET] exist; rebuild forced when they do', 
			cvs_revision::VARCHAR);
		drop_objects:=TRUE;
	ELSE
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'V% rif40_geographies, rif40_tables, rif40_health_study_themes exist for user: %', 
			cvs_revision::VARCHAR, USER::VARCHAR);
	END IF;
--
-- If rif40_user_version does not exist - force a rebuild
--
	IF NOT rif40_user_version THEN
		drop_objects:=TRUE;
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'VIEW rif40_user_version not found; rebuild forced');
	END IF;
--
-- Display search path
--
	PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'search_path: %, reset: %', 
		c4_rec.setting::VARCHAR, c4_rec.reset_val::VARCHAR);
--
	IF drop_objects THEN
--
-- If user objects exist - then delete them
--
		IF rif40_user_version THEN
			sql_stmt:='DROP VIEW rif40_user_version';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			rif40_user_version:=FALSE;
			j:=j+1;
		END IF;
		IF rif40_num_denom THEN
			sql_stmt:='DROP VIEW rif40_num_denom';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			rif40_num_denom:=FALSE;
			j:=j+1;
		END IF;
		IF rif40_num_denom_errors THEN
			sql_stmt:='DROP VIEW rif40_num_denom_errors';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			rif40_num_denom_errors:=FALSE;
			j:=j+1;
		END IF;
		IF t_rif40_num_denom THEN
			sql_stmt:='DROP TABLE t_rif40_num_denom';
			PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
			t_rif40_num_denom:=FALSE;
			j:=j+1;
		END IF;
	END IF;
--
-- Check for the presence of dependent tables - only continue of they do
--
	IF c1_rec.total != 3 THEN
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 
			'Check for the presence of dependent tables - only continue of they do, c1_rec.total: %', 
			c1_rec.total::VARCHAR);
		RETURN;
	END IF;
--
-- If user objects do not exist them create them
--
	IF NOT t_rif40_num_denom THEN
		sql_stmt:='CREATE TABLE '||USER||'.t_rif40_num_denom ('||E'\n';
		sql_stmt:=sql_stmt||E'\t'||'geography              VARCHAR(50)     NOT NULL,'||E'\n';
		sql_stmt:=sql_stmt||E'\t'||'numerator_table        VARCHAR(30)     NOT NULL,'||E'\n';
		sql_stmt:=sql_stmt||E'\t'||'denominator_table      VARCHAR(30)     NOT NULL)';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='CREATE UNIQUE INDEX rif40_num_denom_pk ON '||USER||'.t_rif40_num_denom(geography, numerator_table, denominator_table)';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='ANALYZE VERBOSE '||USER||'.t_rif40_num_denom';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON TABLE '||USER||'.t_rif40_num_denom IS ''Private copy of extra numerator and denominator pairs not added automatically.''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.t_rif40_num_denom.denominator_table IS ''Denominator table''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.t_rif40_num_denom.geography IS ''Geography (e.g EW2001)''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.t_rif40_num_denom.numerator_table IS ''Numerator table''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
-- Add triggers
--
		sql_stmt:='CREATE TRIGGER t_rif40_num_denom_checks'||E'\n';
		sql_stmt:=sql_stmt||E'\t'||'BEFORE INSERT OR UPDATE OF geography, numerator_table, denominator_table ON t_rif40_num_denom'||E'\n';
		sql_stmt:=sql_stmt||E'\t'||'FOR EACH ROW'||E'\n';	
		sql_stmt:=sql_stmt||E'\t'||'WHEN ((NEW.geography IS NOT NULL AND NEW.geography::text <> '''') OR (NEW.numerator_table IS NOT NULL AND NEW.numerator_table::text <> '''') OR (NEW.denominator_table IS NOT NULL AND NEW.denominator_table::text <> ''''))'||E'\n';
		sql_stmt:=sql_stmt||E'\t'||'EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks()';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='CREATE TRIGGER t_rif40_num_denom_checks_del'||E'\n';
		sql_stmt:=sql_stmt||E'\t'||'BEFORE DELETE ON t_rif40_num_denom'||E'\n';
		sql_stmt:=sql_stmt||E'\t'||'FOR EACH ROW'||E'\n';	
		sql_stmt:=sql_stmt||E'\t'||'EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks()';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON TRIGGER t_rif40_num_denom_checks ON t_rif40_num_denom IS ''INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks()''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON TRIGGER t_rif40_num_denom_checks_del ON t_rif40_num_denom IS ''DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks()''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
--
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'Created table: t_rif40_num_denom');
		i:=i+1;
	END IF;
	IF NOT rif40_num_denom_errors THEN
		sql_stmt:='CREATE OR REPLACE VIEW '||USER||'.rif40_num_denom_errors'||E'\n'||
			'AS'||E'\n'||
			'WITH n AS ('||E'\n'||
			E'\t'||'SELECT geography, numerator_table, numerator_description, automatic, is_object_resolvable, n_num_denom_validated, numerator_owner'||E'\n'||
			E'\t'||'  FROM ('||E'\n'||
			E'\t'||E'\t'||'SELECT g.geography, n.table_name numerator_table, n.description numerator_description, n.automatic,'||E'\n'||
			E'\t'||E'\t'||'       rif40_sql_pkg.rif40_is_object_resolvable(n.table_name) AS is_object_resolvable,'||E'\n'||
		        E'\t'||E'\t'||'       rif40_sql_pkg.rif40_num_denom_validate(g.geography, n.table_name) AS n_num_denom_validated,'||E'\n'||
		        E'\t'||E'\t'||'       rif40_sql_pkg.rif40_object_resolve(n.table_name) AS numerator_owner'||E'\n'||
			E'\t'||E'\t'||'  FROM rif40_geographies g, rif40_tables n'||E'\n'||
			E'\t'||E'\t'||' WHERE n.isnumerator = 1'||E'\n'||
			E'\t'||E'\t'||'   AND n.automatic   = 1) AS n1 /* Automatic numerators */'||E'\n'||
			'), d AS ('||E'\n'||
			E'\t'||'SELECT geography, denominator_table, denominator_description, is_object_resolvable, d_num_denom_validated, denominator_owner,'||E'\n'||
			E'\t'||'       rif40_sql_pkg.rif40_auto_indirect_checks(denominator_table)::text AS auto_indirect_error'||E'\n'||
			E'\t'||'  FROM ('||E'\n'||
			E'\t'||E'\t'||'SELECT g.geography, d.table_name denominator_table, d.description denominator_description,'||E'\n'||
			E'\t'||E'\t'||'       rif40_sql_pkg.rif40_is_object_resolvable(d.table_name) is_object_resolvable,'||E'\n'||
		        E'\t'||E'\t'||'       rif40_sql_pkg.rif40_num_denom_validate(g.geography, d.table_name) AS d_num_denom_validated,'||E'\n'||
		        E'\t'||E'\t'||'       rif40_sql_pkg.rif40_object_resolve(d.table_name) AS denominator_owner'||E'\n'||
			E'\t'||E'\t'||'  FROM rif40_geographies g, rif40_tables d'||E'\n'||
			E'\t'||E'\t'||' WHERE d.isindirectdenominator = 1'||E'\n'||
			E'\t'||E'\t'||'   AND d.automatic             = 1) AS d1 /* Automatic denominators */'||E'\n'||
			')'||E'\n'||
			'SELECT n.geography,'||E'\n'|| 
			'       n.numerator_owner,'||E'\n'|| 
			'       n.numerator_table,'||E'\n'|| 
			'       n.is_object_resolvable AS is_numerator_resolvable,'||E'\n'|| 
			'       n.n_num_denom_validated,'||E'\n'|| 
			'       n.numerator_description,'||E'\n'|| 
			'       d.denominator_owner,'||E'\n'|| 
			'       d.denominator_table,'||E'\n'|| 
			'       d.is_object_resolvable AS is_denominator_resolvable,'||E'\n'|| 
			'       d.d_num_denom_validated,'||E'\n'|| 
			'       d.denominator_description,'||E'\n'|| 
			'       n.automatic,'||E'\n'|| 
			'       CASE'||E'\n'||
			E'\t'||'	WHEN d.auto_indirect_error IS NULL THEN 0 ELSE 1 END AS auto_indirect_error_flag,'||E'\n'||
			'       d.auto_indirect_error AS auto_indirect_error,'||E'\n'||
			'       f.create_status AS n_fdw_create_status,'||E'\n'||
			'       f.error_message AS n_fdw_error_message,'||E'\n'||
			'       f.date_created AS n_fdw_date_created,'||E'\n'||
			'       f.rowtest_passed AS n_fdw_rowtest_passed'||E'\n'||
			'  FROM d, n'||E'\n'||
			E'\t'||'LEFT OUTER JOIN rif40_fdw_tables f ON (n.numerator_table = f.table_name)'||E'\n'||
			' WHERE n.geography = d.geography'||E'\n';
		IF  USER != 'rif40' THEN
			sql_stmt:=sql_stmt||'UNION'||E'\n'||
				'SELECT g.geography,'||E'\n'|| 
			'       rif40_sql_pkg.rif40_object_resolve(g.numerator_table) AS numerator_owner,'||E'\n'|| 
			'       g.numerator_table,'||E'\n'|| 
			'       rif40_sql_pkg.rif40_is_object_resolvable(g.numerator_table) AS is_numerator_resolvable,'||E'\n'|| 
			'       rif40_sql_pkg.rif40_num_denom_validate(g.geography, g.numerator_table) AS num_denom_validated,'||E'\n'|| 
			'       n.description AS numerator_description,'||E'\n'||
			'       rif40_sql_pkg.rif40_object_resolve(g.denominator_table) AS denominator_owner,'||E'\n'|| 
			'       g.denominator_table,'||E'\n'|| 
			'       rif40_sql_pkg.rif40_is_object_resolvable(g.denominator_table) AS is_denominator_resolvable,'||E'\n'|| 
			'       rif40_sql_pkg.rif40_num_denom_validate(g.geography, g.denominator_table) AS num_denom_validated,'||E'\n'|| 
			'       d.description AS denominator_description,'||E'\n'||
			'       0 AS automatic,'||E'\n'|| 
			'       0 AS auto_indirect_error_flag,'||E'\n'|| 
			'       NULL::text AS auto_indirect_error,'||E'\n'||
			'       f.create_status AS n_fdw_create_status,'||E'\n'||
			'       f.error_message AS n_fdw_error_message,'||E'\n'||
			'       f.date_created AS n_fdw_date_created,'||E'\n'||
			'       f.rowtest_passed AS n_fdw_rowtest_passed'||E'\n'||
			'  FROM t_rif40_num_denom g'||E'\n'||
			E'\t'||'LEFT OUTER JOIN rif40_tables n ON (n.table_name = g.numerator_table)'||E'\n'||
			E'\t'||'LEFT OUTER JOIN rif40_tables d ON (d.table_name = g.denominator_table)'||E'\n'||
			E'\t'||'LEFT OUTER JOIN rif40_fdw_tables f ON (n.table_name = f.table_name)'||E'\n';
		END IF;
		sql_stmt:=sql_stmt||' ORDER BY 1, 2, 5';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON VIEW '||USER||'.rif40_num_denom_errors 				IS ''All possible numerator and indirect standardisation denominator pairs with error diagnostic fields. As this is a CROSS JOIN the will be a lot of output as tables are not rejected on the basis of user access or containing the correct geography geolevel fields.'''; 
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom_errors.geography 		IS ''Geography''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom_errors.numerator_owner 		IS ''Numerator table owner''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom_errors.numerator_table 		IS ''Numerator table''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom_errors.denominator_owner 	IS ''Denominator table owner''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom_errors.denominator_table 	IS ''Denominator table''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom_errors.is_numerator_resolvable 	IS ''Is the numerator table resolvable and accessible (0/1)''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom_errors.n_num_denom_validated      IS ''Is the numerator valid for this geography (0/1). If N_NUM_DENOM_VALIDATED and D_NUM_DENOM_VALIDATED are both 1 then the pair will appear in RIF40_NUM_DENOM.''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom_errors.is_denominator_resolvable IS ''Is the denominator table resolvable and accessible (0/1)''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom_errors.numerator_description	IS ''Numerator table description''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom_errors.d_num_denom_validated      IS ''Is the denominator valid for this geography (0/1). If N_NUM_DENOM_VALIDATED and D_NUM_DENOM_VALIDATED are both 1 then the pair will appear in RIF40_NUM_DENOM.''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom_errors.denominator_description 	IS ''Denominator table description''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom_errors.automatic 		IS ''Is the pair automatic (0/1). Cannot be applied to direct standardisation denominator. Restricted to 1 denominator per geography. The default in RIF40_TABLES is 0 because of the restrictions.''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom_errors.auto_indirect_error_flag IS ''Error flag 0/1. Denominator table with automatic set to "1" that fails the RIF40_CHECKS.RIF40_AUTO_INDIRECT_CHECKS test. Restricted to 1 denominator per geography to prevent the automatic RIF40_NUM_DENOM having >1 pair per numerator.''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom_errors.auto_indirect_error 	IS ''Denominator table with automatic set to "1" that fails the RIF40_CHECKS.RIF40_AUTO_INDIRECT_CHECKS test. Restricted to 1 denominator per geography to prevent the automatic RIF40_NUM_DENOM having >1 pair per numerator. List of geographies and tables in error.''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom_errors.n_fdw_create_status 	IS ''RIF numerator foreign data wrappers table create status: C (Created, no errors), E(Created, errors in test SELECT), N(Not created, errors).''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom_errors.n_fdw_error_message 	IS ''RIF numerator foreign data wrappers table error message when create status is: E(Created, errors in test SELECT, N(Not created, errors).''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom_errors.n_fdw_date_created 	IS ''RIF numerator foreign data wrappers table date FDW table created (or attempted to be).''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom_errors.n_fdw_rowtest_passed 	IS ''RIF numerator foreign data wrappers table SELECT rowtest passed (0/1).''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'Created view: rif40_num_denom_errors');
		i:=i+1;
	END IF;
	IF NOT rif40_num_denom THEN
		sql_stmt:='CREATE OR REPLACE VIEW '||USER||'.rif40_num_denom'||E'\n';
		sql_stmt:=sql_stmt||'AS'||E'\n'||
			'WITH n AS ('||E'\n'||
			E'\t'||'SELECT geography, numerator_table, numerator_description, automatic, theme_description'||E'\n'||
			E'\t'||'  FROM ('||E'\n'||
			E'\t'||E'\t'||'SELECT g.geography, n.table_name AS numerator_table, n.description AS numerator_description, n.automatic,'||E'\n'||
       			E'\t'||E'\t'||'       t.description AS theme_description'||E'\n'||
			E'\t'||E'\t'||'  FROM rif40_geographies g, rif40_tables n, rif40_health_study_themes t'||E'\n'||
			E'\t'||E'\t'||' WHERE n.isnumerator = 1'||E'\n'||
			E'\t'||E'\t'||'   AND n.automatic   = 1'||E'\n'||
			E'\t'||E'\t'||'   AND rif40_sql_pkg.rif40_is_object_resolvable(n.table_name) = 1'||E'\n'||
			E'\t'||E'\t'||'   AND n.theme       = t.theme) AS n1'||E'\n'||
			E'\t'||' WHERE rif40_sql_pkg.rif40_num_denom_validate(n1.geography, n1.numerator_table) = 1'||E'\n'||
			'), d AS ('||E'\n'||
			E'\t'||'SELECT geography, denominator_table, denominator_description'||E'\n'||
			E'\t'||'  FROM ('||E'\n'||
			E'\t'||E'\t'||'	SELECT g.geography, d.table_name AS denominator_table, d.description AS denominator_description'||E'\n'||
			E'\t'||E'\t'||'	  FROM rif40_geographies g, rif40_tables d'||E'\n'||
			E'\t'||E'\t'||'	 WHERE d.isindirectdenominator = 1'||E'\n'||
			E'\t'||E'\t'||'	   AND d.automatic             = 1'||E'\n'||
			E'\t'||E'\t'||'	   AND rif40_sql_pkg.rif40_is_object_resolvable(d.table_name) = 1) AS d1'||E'\n'||
			E'\t'||'WHERE rif40_sql_pkg.rif40_num_denom_validate(d1.geography, d1.denominator_table) = 1'||E'\n'||
		   	E'\t'||'  AND rif40_sql_pkg.rif40_auto_indirect_checks(d1.denominator_table) IS NULL'||E'\n'||
			')'||E'\n'||
			'SELECT n.geography,'||E'\n'||
			'       n.numerator_table,'||E'\n'||
			'       n.numerator_description,'||E'\n'||
			'       n.theme_description,'||E'\n'||
			'       d.denominator_table,'||E'\n'||
			'       d.denominator_description,'||E'\n'||
			'       n.automatic'||E'\n'||
			'  FROM n, d'||E'\n'||
			' WHERE n.geography = d.geography'||E'\n';
--
-- Add t_rif40_num_denom for non rif40 users
--
		IF  USER != 'rif40' THEN
			sql_stmt:=sql_stmt||'UNION'||E'\n'||
				'SELECT g.geography,'||E'\n'||
				'       g.numerator_table,'||E'\n'||
				'       n.description AS numerator_description,'||E'\n'||
				'       ''Local user theme'' AS theme_description,'||E'\n'||
				'       g.denominator_table,'||E'\n'||
				'       d.description AS denominator_description,'||E'\n'||
				'       0 automatic'||E'\n'||
				'  FROM t_rif40_num_denom g'||E'\n'||
				'	LEFT OUTER JOIN rif40_tables n ON (n.table_name = g.numerator_table)'||E'\n'||
				'	LEFT OUTER JOIN rif40_tables d ON (d.table_name = g.denominator_table)'||E'\n';
 		END IF;
		sql_stmt:=sql_stmt||' ORDER BY 1, 2, 4';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON VIEW '||USER||'.rif40_num_denom 				IS ''Numerator and indirect standardisation denominator pairs. Use RIF40_NUM_DENOM_ERROR if your numerator and denominator table pair is missing. You must have your own copy of RIF40_NUM_DENOM or you will only see the tables RIF40 has access to. Tables not rejected if the user does not have access or the table does not contain the correct geography geolevel fields.''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom.geography 		IS ''Geography''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom.numerator_table 	IS ''Numerator table''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom.denominator_table 	IS ''Denominator table''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom.numerator_description	IS ''Numerator table description''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom.denominator_description	IS ''Denominator table description''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom.automatic 		IS ''Is the pair automatic (0/1). Cannot be applied to direct standardisation denominator. Restricted to 1 denominator per geography. The default in RIF40_TABLES is 0 because of the restrictions.''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_num_denom.theme_description 	IS ''Numerator table health study theme description''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'Created view: rif40_num_denom');
		i:=i+1;
	END IF;
	IF NOT g_rif40_study_areas THEN
--		sql_stmt:='DROP TABLE IF EXISTS g_rif40_study_areas';
--		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='CREATE GLOBAL TEMPORARY TABLE g_rif40_study_areas ('||E'\n'||
			E'\t'||'study_id		INTEGER 	NOT NULL,'||E'\n'||
			E'\t'||'area_id			VARCHAR(300) 	NOT NULL,'||E'\n'||
			E'\t'||'band_id			INTEGER) ON COMMIT PRESERVE ROWS';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON TABLE g_rif40_study_areas 		IS ''Local session cache of links study areas and bands for a given study. Created for high performance in extracts.''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN g_rif40_study_areas.study_id 	IS ''Unique study index: study_id. Created by SEQUENCE rif40_study_id_seq''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN g_rif40_study_areas.area_id 	IS ''An area id, the value of a geolevel; i.e. the value of the column T_RIF40_GEOLEVELS.GEOLEVEL_NAME in table T_RIF40_GEOLEVELS.LOOKUP_TABLE''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN g_rif40_study_areas.band_id 	IS ''A band allocated to the area''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'Created temporary table: g_rif40_study_areas');
		i:=i+1;
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'rif40_startup', 'Temporary table: g_rif40_study_areas exists');
	END IF;
	IF NOT g_rif40_comparison_areas THEN
--		sql_stmt:='DROP TABLE IF EXISTS g_rif40_comparison_areas';
--		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='CREATE GLOBAL TEMPORARY TABLE g_rif40_comparison_areas ('||E'\n'||
			E'\t'||'study_id		INTEGER 	NOT NULL,'||E'\n'||
			E'\t'||'area_id			VARCHAR(300) 	NOT NULL) ON COMMIT PRESERVE ROWS';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON TABLE g_rif40_comparison_areas 		IS ''Local session cache of links comparison areas and bands for a given study. Created for high performance in extracts.''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN g_rif40_comparison_areas.study_id 	IS ''Unique study index: study_id. Created by SEQUENCE rif40_study_id_seq''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN g_rif40_comparison_areas.area_id 	IS ''An area id, the value of a geolevel; i.e. the value of the column T_RIF40_GEOLEVELS.GEOLEVEL_NAME in table T_RIF40_GEOLEVELS.LOOKUP_TABLE''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'Created temporary table: g_rif40_comparison_areas');
		i:=i+1;
	ELSE
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'Temporary table: g_rif40_comparison_areas exists');
	END IF;
--
-- FDW  support
--
	IF fdw_enabled AND USER != 'rif40' THEN
--
-- Create support views if needed (FDW_USER_TABLES, FDW_USER_TAB_COLUMNS)
--
		i:=i+rif40_sql_pkg.rif40_create_fdw_views(drop_objects, c5_rec.fdwservername, c5_rec.fdwservertype);
		FOR c7_rec IN c7 LOOP
--
-- Attmept to create FDW tables for potential FDW tables i.e. those numerators in RIF40_NUM_DENOM_ERRORS with no local table of the same name 
--
			IF c7_rec.foreign_table_exists = 0 AND c7_rec.table_ok = 1 THEN /* Local table - DO NOT TOUCH */
				PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'Local numerator: %', 
					c7_rec.foreign_table::VARCHAR);
			ELSE
				i:=i+rif40_sql_pkg.rif40_create_fdw_table(c7_rec.foreign_table, c7_rec.total_geographies, drop_objects, c5_rec.fdwservername, c5_rec.fdwservertype);
			END IF;
		END LOOP;
--
-- It would also be desirable to clean up FDW tables no longer in use
--
		FOR c8_rec IN c8 LOOP
			PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_startup', 'Remote foreign data wrapper health table % is obsolete and needs to be removed', 
				c8_rec.foreign_table::VARCHAR);
		END LOOP;
	END IF;
--
-- RIF40 doesn't have a version view
--
	IF NOT rif40_user_version THEN
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'V% Creating view: rif40_user_version', 
			cvs_revision::VARCHAR);
		sql_stmt:='CREATE OR REPLACE VIEW '||USER||'.rif40_user_version AS SELECT CAST('''||cvs_revision||''' AS VARCHAR) AS user_schema_revision';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON VIEW '||USER||'.rif40_user_version 				IS ''User schema revision control view.''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		sql_stmt:='COMMENT ON COLUMN '||USER||'.rif40_user_version.user_schema_revision 	IS ''Revision (derived from CVS).''';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
		i:=i+1;
	END IF;
--
	IF i > 0 OR j > 0 THEN
		PERFORM rif40_log_pkg.rif40_log('INFO', 'rif40_startup', 'Deleted %, created % tables/views/foreign data wrapper tables', 
			j::VARCHAR, i::VARCHAR);
	END IF;
--
END;
]]></definition>
</function>

<function name="rif40_update_fdw_tables"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_update_fdw_tables()
Parameters: 	Table name, Create status: C (Created, no errors), E(Created, errors in test SELECT), N(Not created, errors), error message, rowtest passed (0/1)
Returns: 	Nothing
Description:	MERGE rif40_fdw_tables
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="l_table_name" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="create_status" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="error_message" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="rowtest_passed" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	rif40_update_fdw_tables()
Parameters: 	Table name, Create status: C (Created, no errors), E(Created, errors in test SELECT), N(Not created, errors), error message, rowtest passed (0/1)
Returns: 	Nothing
Description:	MERGE rif40_fdw_tables

 */
DECLARE
	c1ufdw CURSOR(l_table_name VARCHAR) FOR
		SELECT * 
		  FROM rif40_fdw_tables
		 WHERE table_name = UPPER(l_table_name);
--
	c1ufdw_rec RECORD;
--
	sql_stmt VARCHAR;
--
	error_message VARCHAR;
	v_detail VARCHAR:='(Not supported until 9.2; type SQL statement into psql to see remote error)';
BEGIN
	OPEN c1ufdw(l_table_name);
	FETCH c1ufdw INTO c1ufdw_rec;
	CLOSE c1ufdw;
--
	IF c1ufdw_rec.table_name IS NULL THEN
		sql_stmt:='INSERT INTO t_rif40_fdw_tables (create_status, error_message, rowtest_passed, table_name, username) VALUES ($1, $2, $3, $4, $5)';
	ELSE
		sql_stmt:='UPDATE t_rif40_fdw_tables SET create_status=$1, error_message=$2, rowtest_passed=$3 WHERE table_name=$4 AND username = $5';
	END IF;
	EXECUTE sql_stmt USING create_status, error_message, rowtest_passed, UPPER(l_table_name), USER;
EXCEPTION
	WHEN others THEN
-- 
-- Not supported until 9.2
--
--		GET STACKED DIAGNOTICS v_detail = PG_EXCETION_DETAIL;
		IF sql_stmt IS NULL THEN
			error_message:='rif40_update_fdw_tables() caught: '||E'\n'||SQLERRM::VARCHAR||' in SQL> (Not known, probably CURSOR c1ufdw)'||E'\n'||'Detail: '||v_detail::VARCHAR;
		ELSE
			error_message:='rif40_update_fdw_tables() caught: '||E'\n'||SQLERRM::VARCHAR||' in SQL>'||sql_stmt::VARCHAR||E'\n'||'Detail: '||v_detail::VARCHAR;
		END IF;
		PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_update_fdw_tables', 'Caught exception: % [IGNORED]', 
			error_message::VARCHAR);
END;

]]></definition>
</function>

<function name="sys_context"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Replacement for Oracle SYS_CONTEXT(namespace, parameter). Only limited parameters are supported, namespace is ignored.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="character varying"/>
	</return-type>
	<parameter name="namespace" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="parameter" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	sys_context()
Parameters:	Namespace, parameter
Returns:	TIMESTAMP
Description:	Oracle compatability function SYS_CONTEXT
		Namespace is ignored unless it is SAHSU_CONTEXT when the role is checked to see if it was GRANTED the ROLE
		Parameter must be one of: DB_NAME, CURRENT_SCHEMA, AUDSID

		Used to support auditing

		Could be extended to use FDW to get the real AUDSID
 */
DECLARE
	ret	VARCHAR;
	c1 CURSOR FOR
		SELECT procpid||'.'||TO_CHAR(backend_start, 'J.SSSS.US') audsid 
			/* Backend PID.Julian day.Seconds from midnight.uSeconds (backend start) */
		  FROM pg_stat_activity
		 WHERE datname     = current_database()
		   AND usename     = session_user
		   AND client_addr = inet_client_addr()
		   AND client_port = inet_client_port();		
	c2c CURSOR(l_granted_role VARCHAR) FOR
		SELECT * 
		  FROM user_role_privs
		 WHERE l_granted_role = granted_role;
	c2c_rec user_role_privs%ROWTYPE;
BEGIN
--
-- Emulate Oracle security contexts by returning YES if the user has the role of the same name
--
	IF namespace = 'SAHSU_CONTEXT' THEN 
		OPEN c2c(LOWER(parameter));
		FETCH c2c INTO c2c_rec;
		CLOSE c2c;
		IF c2c_rec.granted_role IS NULL THEN
			RETURN 'NO';
		ELSE
			RETURN 'YES';
		END IF;
	ELSE
		IF parameter = 'DB_NAME' THEN 
			ret:=current_database();
		ELSIF parameter = 'CURRENT_SCHEMA' THEN 
			ret:=current_schema();
		ELSIF parameter = 'AUDSID' OR parameter = 'SESSIONID' THEN 
			OPEN c1;
			FETCH c1 INTO ret;
			CLOSE c1;
		ELSIF namespace IS NULL THEN
			PERFORM rif40_log_pkg.rif40_error(-20999, 'sys_context', 'namespace: NULL invalid parameter: %', 
				parameter::VARCHAR);

		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'sys_context', 'namespace: % invalid parameter: %', 
				namespace::VARCHAR, parameter::VARCHAR);
		END IF;
	END IF;
--
	RETURN ret;
END;
]]></definition>
</function>

<function name="systimestamp"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Replacement for Oracle SYSTIMESTAMP. Precision is not used]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="timestamp"/>
	</return-type>
	<parameter name="tprecision" in="true">
		<type name="bigint"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	systimestamp()
Parameters:	Precision
Returns:	TIMESTAMP
Description:	Oracle compatability function SYSTIMESTAMP

 */
DECLARE
BEGIN
	RETURN current_time;
END;
]]></definition>
</function>

<function name="create_instead_of_triggers"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	create_instead_of_triggers()
Parameters:	NONE
Returns:	NONE
Description:	Create (or re-create) INSTEAD OF functions and triggers for all views of T_ tables where username as a column
	 	INSERT/UPDATE/DELETE of another users data in NOT permitted
Generates SQL:

CREATE OR REPLACE FUNCTION rif40_trg_pkg.trgf_rif40_user_projects()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $trigger_function$
BEGIN
        IF TG_OP = 'INSERT' THEN
--
-- Check (USER = NEW.username OR NULL) and USER is a RIF user; if OK INSERT
--
                IF (USER = NEW.username OR NEW.username IS NULL /* Will be defaulted */) AND rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
                        INSERT INTO t_rif40_user_projects (
                                project,
                                username,
                                grant_date,
                                revoke_date,
                                description,
                                date_started,
                                date_ended)
                        VALUES(
                                NEW.project,
                                NEW.username,
                                NEW.grant_date,
                                NEW.revoke_date,
                                NEW.description,
                                NEW.date_started,
                                NEW.date_ended);
                ELSE
                        PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_user_projects',
                                'Cannot INSERT: User % must have rif_user or rif_manager role, NEW.username (%) must be USER or NULL', USER::VARCHAR, NEW.username::VARCHAR);
                END IF;
                RETURN NEW;
        ELSIF TG_OP = 'UPDATE' THEN
--
-- Check USER = OLD.username and NEW.username = OLD.username; if OK UPDATE
--
                IF USER = OLD.username AND NEW.username = OLD.username THEN
                        UPDATE t_rif40_user_projects
                           SET project=NEW.project,
                               username=NEW.username,
                               grant_date=NEW.grant_date,
                               revoke_date=NEW.revoke_date,
                               description=NEW.description,
                               date_started=NEW.date_started,
                               date_ended=NEW.date_ended
                         WHERE project=OLD.project
                           AND username=OLD.username;
                ELSE
                        PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_user_projects',
                                'Cannot UPDATE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
                END IF;
                RETURN NEW;
        ELSIF TG_OP = 'DELETE' THEN
--
-- Check USER = OLD.username; if OK DELETE
--
                IF USER = OLD.username THEN
                        DELETE FROM t_rif40_user_projects
                         WHERE project=OLD.project
                           AND username=OLD.username;
                ELSE
                        PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_user_projects',
                                'Cannot DELETE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
                END IF;
                RETURN NULL;
        END IF;
        RETURN NEW;
END;
$trigger_function$;

CREATE TRIGGER trg_rif40_user_projects INSTEAD OF INSERT OR UPDATE OR DELETE ON rif40_user_projects FOR EACH ROW EXECUTE PROCEDURE rif40_trg_pkg.trgf_rif40_user_projects();

COMMENT ON TRIGGER trg_rif40_user_projects ON rif40_user_projects IS 'INSTEAD OF trigger for view T_RIF40_USER_PROJECTS to allow INSERT/UPDATE/DELETE. INSERT/UPDATE/DELETE of another users data is NOT permitted. 
 [NO TABLE/VIEW comments available]';

COMMENT ON FUNCTION rif40_trg_pkg.trgf_rif40_user_projects() IS 'INSTEAD OF trigger for view T_RIF40_USER_PROJECTS to allow INSERT/UPDATE/DELETE. INSERT/UPDATE/DELETE of another users data is NOT permitted. 
 [NO TABLE/VIEW comments available]';

GRANT INSERT ON rif40_user_projects TO rif_manager
GRANT UPDATE ON rif40_user_projects TO rif_manager
GRANT DELETE ON rif40_user_projects TO rif_manager
]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<definition><![CDATA[
/*

Function: 	create_instead_of_triggers()
Parameters:	NONE
Returns:	NONE
Description:	Create (or re-create) INSTEAD OF functions and triggers for all views of T_ tables where username as a column
	 	INSERT/UPDATE/DELETE of another users data is NOT permitted	
 */
DECLARE
	c1ciot CURSOR FOR
		WITH t AS (
			SELECT a.relname AS tablename, b.description,
			       'INSTEAD OF trigger for view '||UPPER(a.relname)||
					' to allow INSERT/UPDATE/DELETE. INSERT/UPDATE/DELETE of another users data is NOT permitted. '||E'\n'||
					COALESCE(b.description, '') AS comments 				
 			 FROM pg_roles r, pg_namespace n, pg_attribute c, pg_class a		
				LEFT OUTER JOIN pg_description b ON (b.objoid = a.oid AND b.objsubid IS NULL)
			 WHERE a.relowner       = (SELECT oid FROM pg_roles WHERE rolname = USER)
			   AND a.relkind        = 'r' 				/* Relational table */
			   AND a.relpersistence IN ('p', 'u') 			/* Persistent */
			   AND a.relowner       = r.oid
			   AND n.oid 		= a.relnamespace
			   AND n.nspname  	= USER    
			   AND c.attrelid       = a.oid
			   AND c.attname  	= 'username'
		), v AS (
			SELECT a.relname AS viewname, b.description,
			       'INSTEAD OF trigger for view '||UPPER(a.relname)||
					' to allow INSERT/UPDATE/DELETE. INSERT/UPDATE/DELETE of another users data is NOT permitted. '||E'\n'||
					COALESCE(b.description, '') AS comments 				
 			 FROM pg_roles r, pg_namespace n, pg_attribute c, pg_class a		
				LEFT OUTER JOIN pg_description b ON (b.objoid = a.oid AND b.objsubid IS NULL)
			 WHERE a.relowner       = (SELECT oid FROM pg_roles WHERE rolname = USER)
			   AND a.relkind        = 'v' 				/* Views */
			   AND a.relowner       = r.oid
			   AND n.oid 		= a.relnamespace
			   AND n.nspname  	= USER    
			   AND c.attrelid       = a.oid
			   AND c.attname  	= 'username'
		)
		SELECT t.tablename, v.viewname, 
		       CASE 
				WHEN v.description IS NOT NULL THEN v.comments /* Use view comments in preference */
				WHEN t.description IS NOT NULL THEN t.comments /* Use view comments in preference */
				ELSE t.comments||' [NO TABLE/VIEW comments available]'
		       END AS comments
		  FROM t, v
		 WHERE t.tablename  = 't_'||v.viewname
		 ORDER BY 1;
	c2ciot CURSOR(l_view VARCHAR) FOR
		WITH pk AS (
			SELECT c.attname
			  FROM pg_index i, pg_class a, pg_attribute c
			 WHERE a.oid    = i.indrelid
			   AND a.oid    = c.attrelid
			   AND c.attnum = ANY(i.indkey)
		   	   AND a.relname 	= 't_'||l_view
			   AND i.indisprimary
		), d AS (
			SELECT c.attname, coalesce(e.adsrc::text, '') AS default_value
			  FROM pg_class a, pg_attribute c 
				LEFT OUTER JOIN pg_attrdef e ON (c.attrelid = e.adrelid AND c.attnum = e.adnum)
			 WHERE a.oid   	        = c.attrelid
		   	   AND a.relname 	= 't_'||l_view
                   	   AND NOT (c.attname 	= 'partition_parallelisation'
                           AND      a.relname 	= 'rif40_studies')
		), k AS (
			SELECT l.relname, j.column_name, m.description
  			  FROM information_schema.columns j, pg_class l, pg_description m
			 WHERE m.objoid = l.oid AND m.objsubid = j.ordinal_position
			   AND l.relname =  't_'||l_view
			   AND l.relname = j.table_name
		)
		SELECT c.attname AS columnname,
                       CASE WHEN pk.attname IS NOT NULL THEN TRUE ELSE FALSE END::BOOLEAN AS is_pk,
		       CASE WHEN d.attname IS NOT NULL THEN TRUE ELSE FALSE END::BOOLEAN AS is_table_column,
		       d.default_value,
                       k.description
 		 FROM pg_roles r, pg_class a, pg_namespace n, pg_attribute c
			LEFT OUTER JOIN pk ON (c.attname = pk.attname)		
			LEFT OUTER JOIN d ON (c.attname = d.attname)
			LEFT OUTER JOIN k ON (c.attname = k.column_name)			
		 WHERE a.relowner       = (SELECT oid FROM pg_roles WHERE rolname = USER)
		   AND a.relkind        = 'v' 				/* Views */
		   AND a.relowner       = r.oid
		   AND n.oid 		= a.relnamespace
		   AND n.nspname  	= USER    
		   AND c.attrelid       = a.oid
		   AND a.relname 	= l_view
		 ORDER BY c.attnum;
--
	c1ciot_rec RECORD;
	c2ciot_rec RECORD;
--
	sql_stmt VARCHAR[];
	comment_sql VARCHAR[];
	column_list VARCHAR;
	insert_stmt VARCHAR;
	update_stmt VARCHAR;
	delete_stmt VARCHAR;
	where_stmt VARCHAR;
--
	i INTEGER:=0;
	j INTEGER:=1;
--
	role_list VARCHAR[]:=ARRAY['rif_user', 'rif_manager'];
	priv_list VARCHAR[]:=ARRAY['INSERT', 'UPDATE', 'DELETE'];
BEGIN
--
-- Must be RIF40
--
	IF USER != 'rif40' THEN
		PERFORM rif40_log_pkg.rif40_error(-20999, 'create_instead_of_triggers',
                	'Cannot create INSTEAD OF triggers; user % must must be RIF40', USER::VARCHAR);
	END IF;
--
	FOR c1ciot_rec IN c1ciot LOOP
--
-- Create  INSERT/UPDATE/DELETE statements
--
		sql_stmt:=NULL;
		j:=1;
		where_stmt:=NULL;
		update_stmt:='UPDATE '||c1ciot_rec.tablename||E'\n'; 
		delete_stmt:='DELETE FROM '||c1ciot_rec.tablename; 
		i:=0;
		comment_sql:=NULL;
		FOR c2ciot_rec IN c2ciot(c1ciot_rec.viewname) LOOP /* Column bits */
--
-- Create PK WHERE clause
--
			IF c2ciot_rec.is_pk THEN
				IF where_stmt IS NULL THEN
					where_stmt:='WHERE '||c2ciot_rec.columnname||'=OLD.'||c2ciot_rec.columnname;
				ELSE
					where_stmt:=where_stmt||E'\n'||E'\t'||E'\t'||E'\t'||'   AND '||c2ciot_rec.columnname||'=OLD.'||c2ciot_rec.columnname;
				END IF;
			END IF;
--
			i:=i+1;
			IF i = 1 THEN
				IF c2ciot_rec.is_table_column THEN
					IF c2ciot_rec.default_value = '' THEN
						insert_stmt:=E'\t'||E'\t'||E'\t'||E'\t'||
							'NEW.'||c2ciot_rec.columnname||' /* no default value */';
					ELSE
						insert_stmt:=E'\t'||E'\t'||E'\t'||E'\t'||
							'coalesce(NEW.'||c2ciot_rec.columnname||', '||c2ciot_rec.default_value||')';
					END IF;
				ELSE
					insert_stmt:='';
				END IF;
				column_list:=E'\t'||E'\t'||c2ciot_rec.columnname;
				update_stmt:=update_stmt||E'\t'||E'\t'||E'\t'||'   SET '||c2ciot_rec.columnname||'=NEW.'||c2ciot_rec.columnname;
			ELSE
				IF c2ciot_rec.is_table_column THEN
					IF c2ciot_rec.default_value = '' THEN
						insert_stmt:=insert_stmt||','||E'\n'||E'\t'||E'\t'||E'\t'||E'\t'||'NEW.'||
							c2ciot_rec.columnname||' /* no default value */';
					ELSE
						insert_stmt:=insert_stmt||','||E'\n'||E'\t'||E'\t'||E'\t'||E'\t'||'coalesce(NEW.'||
							c2ciot_rec.columnname||', '||c2ciot_rec.default_value||')';
					END IF;
					column_list:=column_list||','||E'\n'||E'\t'||E'\t'||E'\t'||E'\t'||c2ciot_rec.columnname;
					update_stmt:=update_stmt||','||E'\n'||E'\t'||E'\t'||E'\t'||'       '||
						c2ciot_rec.columnname||'=NEW.'||c2ciot_rec.columnname;
				END IF;
			END IF;
			IF c2ciot_rec.description IS NOT NULL THEN
				comment_sql[i]:='COMMENT ON COLUMN '||c1ciot_rec.viewname||'.'||c2ciot_rec.columnname||
					' IS '''||c2ciot_rec.description||'''';
			ELSE
				PERFORM rif40_log_pkg.rif40_log('WARNING', 'create_instead_of_triggers', 
					'No comment for column: %.%', 
					c1ciot_rec.viewname::VARCHAR,
					c2ciot_rec.columnname::VARCHAR);
				comment_sql[i]:='COMMENT ON COLUMN '||c1ciot_rec.viewname||'.'||c2ciot_rec.columnname||
					' IS ''N/A''';
			END If;
		END LOOP;
		insert_stmt:='INSERT INTO '||c1ciot_rec.tablename||' ('||E'\n'||E'\t'||E'\t'||column_list||')'||E'\n'||E'\t'||E'\t'||E'\t'||'VALUES('||E'\n'||insert_stmt||');';
		update_stmt:=update_stmt||E'\n'||E'\t'||E'\t'||E'\t'||' '||where_stmt||';';
		delete_stmt:=delete_stmt||E'\n'||E'\t'||E'\t'||E'\t'||' '||where_stmt||';';
		IF where_stmt IS NULL THEN
			PERFORM rif40_log_pkg.rif40_error(-20999, 'create_instead_of_triggers',
                		'Cannot create INSTEAD OF triggers; no primary key columns indexed for table: %', c1ciot_rec.tablename::VARCHAR);
		END IF;
--
-- Funcion code
--
		sql_stmt[j]:='CREATE OR REPLACE FUNCTION rif40_trg_pkg.trgf_'||c1ciot_rec.viewname||'()'||E'\n'||
			'RETURNS TRIGGER'||E'\n'||
			'LANGUAGE plpgsql'||E'\n'||
			'AS $trigger_function$'||E'\n'||
			'BEGIN'||E'\n'||
			E'\t'||'IF TG_OP = ''INSERT'' THEN'||E'\n'||
			'--'||E'\n'||
			'-- Check (USER = NEW.username OR NULL) and USER is a RIF user; if OK INSERT'||E'\n'||
			'--'||E'\n'||
			E'\t'||E'\t'||'IF (USER = NEW.username OR NEW.username IS NULL /* Will be defaulted */) AND rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN'||E'\n'||
			E'\t'||E'\t'||E'\t'||insert_stmt||E'\n'||
			E'\t'||E'\t'||'ELSE'||E'\n'||
			E'\t'||E'\t'||E'\t'||'PERFORM rif40_log_pkg.rif40_error(-20999, ''trg_'||c1ciot_rec.viewname||''','||E'\n'
			||E'\t'||E'\t'||E'\t'||E'\t'||'''Cannot INSERT: User % must have rif_user or rif_manager role, NEW.username (%) must be USER or NULL'', USER::VARCHAR, NEW.username::VARCHAR);'||E'\n'||
			E'\t'||E'\t'||'END IF;'||E'\n'||
			E'\t'||E'\t'||'RETURN NEW;'||E'\n'||
			E'\t'||'ELSIF TG_OP = ''UPDATE'' THEN'||E'\n'||
			'--'||E'\n'||
			'-- Check USER = OLD.username and NEW.username = OLD.username; if OK UPDATE'||E'\n'||
			'--'||E'\n'||
			E'\t'||E'\t'||'IF USER = OLD.username AND NEW.username = OLD.username THEN'||E'\n'||
			E'\t'||E'\t'||E'\t'||update_stmt||E'\n'||
			E'\t'||E'\t'||'ELSE'||E'\n'||
			E'\t'||E'\t'||E'\t'||'PERFORM rif40_log_pkg.rif40_error(-20999, ''trg_'||c1ciot_rec.viewname||''','||E'\n'||
			E'\t'||E'\t'||E'\t'||E'\t'||'''Cannot UPDATE: User % is not the owner (%) of the record'', USER::VARCHAR, OLD.username::VARCHAR);'||E'\n'||
			E'\t'||E'\t'||'END IF;'||E'\n'||
			E'\t'||E'\t'||'RETURN NEW;'||E'\n'||
			E'\t'||'ELSIF TG_OP = ''DELETE'' THEN'||E'\n'||
			'--'||E'\n'||
			'-- Check USER = OLD.username; if OK DELETE'||E'\n'||
			'--'||E'\n'||
			E'\t'||E'\t'||'IF USER = OLD.username THEN'||E'\n'||
			E'\t'||E'\t'||E'\t'||delete_stmt||E'\n'||
			E'\t'||E'\t'||'ELSE'||E'\n'||
			E'\t'||E'\t'||E'\t'||'PERFORM rif40_log_pkg.rif40_error(-20999, ''trg_'||c1ciot_rec.viewname||''','||E'\n'||
			E'\t'||E'\t'||E'\t'||E'\t'||'''Cannot DELETE: User % is not the owner (%) of the record'', USER::VARCHAR, OLD.username::VARCHAR);'||E'\n'||
			E'\t'||E'\t'||'END IF;'||E'\n'||
			E'\t'||E'\t'||'RETURN NULL;'||E'\n'||
			E'\t'||'END IF;'||E'\n'||
			E'\t'||'RETURN NEW;'||E'\n'||
			'END;'||E'\n'||
			'$trigger_function$;';
--
-- Trigger code
--
		j:=j+1;
		sql_stmt[j]:='CREATE TRIGGER trg_'||c1ciot_rec.viewname||' INSTEAD OF INSERT OR UPDATE OR DELETE ON '||
			c1ciot_rec.viewname||' FOR EACH ROW EXECUTE PROCEDURE rif40_trg_pkg.trgf_'||c1ciot_rec.viewname||'()';
--
-- Comments
--
		j:=j+1;
		sql_stmt[j]:='COMMENT ON TRIGGER trg_'||c1ciot_rec.viewname||' ON '||c1ciot_rec.viewname||' IS '''||c1ciot_rec.comments||'''';
		j:=j+1;
		sql_stmt[j]:='COMMENT ON FUNCTION rif40_trg_pkg.trgf_'||c1ciot_rec.viewname||'() IS '''||c1ciot_rec.comments||'''';
--
-- Column comments
--
		FOR k IN array_lower(comment_sql, 1) .. array_upper(comment_sql, 1) LOOP
			j:=j+1;
			sql_stmt[j]:=comment_sql[k];
		END LOOP;
--
-- Grants
--
		FOR k IN array_lower(role_list, 1) .. array_upper(role_list, 1) LOOP
			FOR l IN array_lower(priv_list, 1) .. array_upper(priv_list, 1) LOOP
				IF has_table_privilege(role_list[k], c1ciot_rec.tablename, priv_list[l]) THEN
					j:=j+1;
					sql_stmt[j]:='GRANT '||priv_list[l]||' ON '||c1ciot_rec.viewname||' TO '||role_list[k];
				END IF;
			END LOOP;
		END LOOP;
--
		PERFORM rif40_log_pkg.rif40_log('INFO', 'create_instead_of_triggers', 'Creating INSTEAD OF function and trigger for: %', 
			c1ciot_rec.viewname::VARCHAR);
--
-- Execute SQL to create INSTEAD trigger for VIEW
--
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	END LOOP;
END;
]]></definition>
</function>

<function name="drop_instead_of_triggers"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	drop_instead_of_triggers()
Parameters:	NONE
Returns:	NONE
Description:	Drop INSTEAD OF functions and triggers for all views of T_ tables where username as a column
	 	INSERT/UPDATE/DELETE of another users data is NOT permitted]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<definition><![CDATA[
/*

Function: 	drop_instead_of_triggers()
Parameters:	NONE
Returns:	NONE
Description:	Drop INSTEAD OF functions and triggers for all views of T_ tables where username as a column
	 	INSERT/UPDATE/DELETE of another users data is NOT permitted	
 */
DECLARE
	c1diot CURSOR FOR
		WITH t AS (
			SELECT a.relname AS tablename 				
 			 FROM pg_roles r, pg_class a, pg_namespace n, pg_attribute c		
			 WHERE a.relowner       = (SELECT oid FROM pg_roles WHERE rolname = USER)
			   AND a.relkind        = 'r' 				/* Relational table */
			   AND a.relpersistence IN ('p', 'u') 			/* Persistent */
			   AND a.relowner       = r.oid
			   AND n.oid 		= a.relnamespace
			   AND n.nspname  	= USER    
			   AND c.attrelid       = a.oid
			   AND c.attname  	= 'username'
		), v AS (
			SELECT a.relname AS viewname 				
 			 FROM pg_roles r, pg_namespace n, pg_attribute c, pg_class a		
				LEFT OUTER JOIN pg_description b ON (b.objoid = a.oid)
			 WHERE a.relowner       = (SELECT oid FROM pg_roles WHERE rolname = USER)
			   AND a.relkind        = 'v' 				/* Views */
			   AND a.relowner       = r.oid
			   AND n.oid 		= a.relnamespace
			   AND n.nspname  	= USER    
			   AND c.attrelid       = a.oid
			   AND c.attname  	= 'username'
		)
		SELECT t.tablename, v.viewname
		  FROM t, v
		 WHERE t.tablename  = 't_'||v.viewname
		 ORDER BY 1;
--
	c1diot_rec RECORD;
	sql_stmt VARCHAR[];
BEGIN
--
-- Must be RIF40
--
	IF USER != 'rif40' THEN
		PERFORM rif40_log_pkg.rif40_error(-20999, 'drop_instead_of_triggers',
                	'Cannot drop INSTEAD OF triggers; user % must must be RIF40', USER::VARCHAR);
	END IF;
--
	FOR c1diot_rec IN c1diot LOOP
		sql_stmt[1]:='DROP TRIGGER IF EXISTS trg_'||c1diot_rec.viewname||' ON '||c1diot_rec.viewname||' CASCADE';
		sql_stmt[2]:='DROP FUNCTION IF EXISTS rif40_trg_pkg.trgf_'||c1diot_rec.viewname||'() CASCADE';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	END LOOP;
END;
]]></definition>
</function>

<function name="lp_outcomes_check_column"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	lp_outcomes_check_column()
Parameters:	Outcome type, Column name in RIF40_OUTCOMES, Column (value in above), table, column [both being checked]
Returns:	NONE
Description:	Check outcome type exists]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="l_outcome_type" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_rif40_column" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_schema" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_table_name" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="l_column" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	lp_outcomes_check_column()
Parameters:	Outcome type, Column name in RIF40_OUTCOMES, Column (value in above), table, column [both being checked]
Returns:	NONE
Description:	Check outcome type exists

*/
DECLARE
	c1outc CURSOR (l_schema VARCHAR, l_table VARCHAR, l_column VARCHAR) IS
		SELECT column_name
		  FROM information_schema.columns
		 WHERE table_schema = LOWER(l_schema)
		   AND table_name   = LOWER(l_table)
		   AND column_name  = LOWER(l_column);
--
	c1outc_rec RECORD;
BEGIN
	IF (l_column IS NOT NULL AND l_column::text <> '') THEN
		OPEN c1outc(l_schema, l_table_name, l_column);
		FETCH c1outc INTO c1outc_rec;
		IF c1outc_rec.column_name IS NULL THEN
			PERFORM rif40_log_pkg.rif40_error(-20401, 'lp_outcomes_check_column', 'RIF40_OUTCOMES outcome type: % % column (%) not found in table %.%',
				l_outcome_type::VARCHAR 	/* Outcome type */,
				l_rif40_column::VARCHAR 	/* Column name in RIF40_OUTCOMES */,
				l_column::VARCHAR  		/* Column (value in above) */,
				l_schema::VARCHAR  		/* Schema */,
				l_table_name::VARCHAR		/* Table */);
			CLOSE c1outc;
		END IF;
		CLOSE c1outc;
	END IF;
END;
]]></definition>
</function>

<function name="rif40_db_name_check"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_db_name_check()
Parameters:	Column name, value
Returns:	NONE
Description:	Check column name value obeys DB naming conventions; i.e. Oracle's. Value is assumed to be in upper case; even on Postgres where the convention is lower case]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="column_name" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="value" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*

Function: 	rif40_db_name_check()
Parameters:	Column name, value
Returns:	NONE
Description:	Check column name value obeys DB naming conventions; i.e. Oracles. Value is assumed to be in upper case; even on Postgres where the convention is lower case	

SELECT regexp_replace('1 AA_123a ()*+Cb', '[[:upper:]]{1,}[[:upper:]{0,}[:digit:]{0,}_{0,}]{0,}', '', 'g');
 regexp_replace 
----------------
 1 a ()*+b
(1 row)


 */
DECLARE
--
-- Check for valid Oracle name
--
	c3dbnc CURSOR(l_value VARCHAR) FOR
		SELECT REGEXP_REPLACE(l_value, '[[:upper:]]{1,}[[:upper:]{0,}[:digit:]{0,}_{0,}]{0,}', '', 'g') AS invalid_characters,
		       CASE
				WHEN LENGTH(REGEXP_REPLACE(l_value, '[[:upper:]]{1,}[[:upper:]{0,}[:digit:]{0,}_{0,}]{0,}', '', 'g')) > 0 THEN TRUE
				ELSE FALSE END::BOOLEAN AS is_invalid;
--
	c3dbnc_rec 		RECORD;
	maxlen 			INTEGER:=30;
BEGIN
--
-- Check for valid Oracle name
--
	OPEN c3dbnc(value);
	FETCH c3dbnc INTO c3dbnc_rec;
--
-- Invalid Oracle name
--
	IF c3dbnc_rec.is_invalid THEN
		CLOSE c3dbnc;
		PERFORM rif40_log_pkg.rif40_error(-20098, 'rif40_db_name_check', 'Invalid Oracle/Postgres name %: "%"; contains NON alphanumeric characters: %',
			UPPER(column_name)::VARCHAR/* Oracle name */, 
			value::VARCHAR		/* Value */,
			c3dbnc_rec.invalid_characters::VARCHAR	/* Invalid characters */);
	END IF;
	CLOSE c3dbnc;
--
-- Length must <= 30
--
	IF LENGTH(value) > maxlen THEN
		PERFORM rif40_log_pkg.rif40_error(-20097, 'rif40_db_name_check', 'Invalid Oracle name %: "%"; length (%) > %',
			UPPER(column_name)::VARCHAR	/* Oracle name */, 
			value::VARCHAR		/* Value */,
			LENGTH(value)::VARCHAR	/* Length */, 
			maxlen::VARCHAR		/* Maximum permitted length */);
	END IF;
--
-- First character must be a letter
--
	IF SUBSTR(value, 1, 1) NOT BETWEEN 'A' AND 'Z' THEN
		PERFORM rif40_log_pkg.rif40_error(-20096, 'rif40_db_name_check', 'Invalid Oracle/Postgres name s: "%"; First character (%) must be a letter', 
			UPPER(column_name)::VARCHAR	/* Oracle name */, 
			value::VARCHAR		/* Value */, 
			SUBSTR(value, 1, 1)::VARCHAR	/* First character */);
	END IF;
--
	IF value IS NOT NULL THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'rif40_db_name_check', 'rif40_db_name_check(%, %) Ok',
			UPPER(column_name)::VARCHAR	/* Oracle name */, 
			value::VARCHAR		/* Value */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'rif40_db_name_check', 'rif40_db_name_check(%, %) Ok',
			UPPER(column_name)::VARCHAR	/* Oracle name */, 
			'NULL'::VARCHAR		/* Value */);
	END IF;
END;
]]></definition>
</function>

<function name="rif40_drop_table_triggers"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Function: 	rif40_drop_table_triggers()
Parameters:	NONE
Returns:	NONE
Description:	Drop triggers and trigger functions on all standard RIF tables (Used as part of the build ONLY)
		rfi40 table trigger in schema rif40_trg_pkg]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<definition><![CDATA[
/*

Function: 	rif40_drop_table_triggers()
Parameters:	NONE
Returns:	NONE
Description:	Drop triggers and trigger functions on all standard RIF tables (Used as part of the build ONLY)
		rfi40 table trigger in schema rif40_trg_pkg

*/
DECLARE
	c1dtt CURSOR FOR
		SELECT tgname AS trigger_name, 
		       relname AS table_name,
		       n.nspname AS table_schema,
		       n2.nspname||'.'||p.proname||rif40_sql_pkg.rif40_get_function_arg_types(p.proargtypes) AS function_name
		  FROM pg_tables t, pg_class c, pg_trigger b, pg_namespace n, pg_namespace n2, pg_proc p
		 WHERE b.tgrelid        = c.oid				
                   AND NOT b.tgisinternal				/* Ignore constraints */
		   AND n.oid            = c.relnamespace		/* Table schema */
		   AND b.tgfoid         = p.oid				/* Trigger function */
		   AND n2.oid            = p.pronamespace		/* Fu8nction schema */
		   AND c.relowner       IN (SELECT oid FROM pg_roles WHERE rolname = USER)	/* RIF40 tables */
		   AND n2.nspname        = 'rif40_trg_pkg' 		/* Function schema: rif40_trg_pkg */
		   AND c.relname        = t.tablename			/* Tables only */
		   AND c.relkind        = 'r' 				/* Relational table */
		   AND c.relpersistence IN ('p', 'u') 			/* Persistence: permanent/unlogged */
		 ORDER BY 1, 2;
--
	c1dtt_rec RECORD;
--
	sql_stmt VARCHAR[];
BEGIN
--
-- Must be RIF40
--
	IF USER != 'rif40' THEN
		PERFORM rif40_log_pkg.rif40_error(-20999, 'rif40_drop_table_triggers',
                	'Cannot drop INSTEAD OF triggers; user % must must be RIF40', USER::VARCHAR);
	END IF;
--
	FOR c1dtt_rec IN c1dtt LOOP
		sql_stmt[1]:='DROP TRIGGER IF EXISTS '||c1dtt_rec.trigger_name||' ON '||c1dtt_rec.table_schema||'.'||c1dtt_rec.table_name||' CASCADE';
		sql_stmt[2]:='DROP FUNCTION IF EXISTS '||c1dtt_rec.function_name||' CASCADE';
		PERFORM rif40_sql_pkg.rif40_ddl(sql_stmt);
	END LOOP;
END;
]]></definition>
</function>

<function name="rif40_sql_injection_check"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Parameters: 	Table nmame, study_id, inv_id, line_number, name, value
Description:	Check value for SQL injection]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="table_name" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="study_id" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="inv_id" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="line_number" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="name" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="value" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
/*
Parameters: 	Table nmame, study_id, inv_id, line_number, name, value
Description:	Check value for SQL injection	
 */
DECLARE
BEGIN
	PERFORM rif40_log_pkg.rif40_log('WARNING', 'rif40_sql_injection_check', 'SQL injection check not yet implemented for table: %, study: %', 
		table_name::VARCHAR, study_id::VARCHAR);
END;
]]></definition>
</function>

<function name="trgf_rif40_comparison_areas"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[INSTEAD OF trigger for view T_RIF40_COMPARISON_AREAS to allow INSERT/UPDATE/DELETE. INSERT/UPDATE/DELETE of another users data is NOT permitted. 
 [NO TABLE/VIEW comments available]]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
	IF TG_OP = 'INSERT' THEN
--
-- Check (USER = NEW.username OR NULL) and USER is a RIF user; if OK INSERT
--
		IF (USER = NEW.username OR NEW.username IS NULL /* Will be defaulted */) AND rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
			INSERT INTO t_rif40_comparison_areas (
				username,
				study_id,
				area_id)
			VALUES(
				coalesce(NEW.username, "current_user"()),
				coalesce(NEW.study_id, (currval('rif40_study_id_seq'::regclass))::integer),
				NEW.area_id /* no default value */);
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_comparison_areas',
				'Cannot INSERT: User % must have rif_user or rif_manager role, NEW.username (%) must be USER or NULL', USER::VARCHAR, NEW.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'UPDATE' THEN
--
-- Check USER = OLD.username and NEW.username = OLD.username; if OK UPDATE
--
		IF USER = OLD.username AND NEW.username = OLD.username THEN
			UPDATE t_rif40_comparison_areas
			   SET username=NEW.username,
			       study_id=NEW.study_id,
			       area_id=NEW.area_id
			 WHERE study_id=OLD.study_id
			   AND area_id=OLD.area_id;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_comparison_areas',
				'Cannot UPDATE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'DELETE' THEN
--
-- Check USER = OLD.username; if OK DELETE
--
		IF USER = OLD.username THEN
			DELETE FROM t_rif40_comparison_areas
			 WHERE study_id=OLD.study_id
			   AND area_id=OLD.area_id;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_comparison_areas',
				'Cannot DELETE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NULL;
	END IF;
	RETURN NEW;
END;
]]></definition>
</function>

<function name="trgf_rif40_contextual_stats"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[INSTEAD OF trigger for view T_RIF40_CONTEXTUAL_STATS to allow INSERT/UPDATE/DELETE. INSERT/UPDATE/DELETE of another users data is NOT permitted. 
 [NO TABLE/VIEW comments available]]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
	IF TG_OP = 'INSERT' THEN
--
-- Check (USER = NEW.username OR NULL) and USER is a RIF user; if OK INSERT
--
		IF (USER = NEW.username OR NEW.username IS NULL /* Will be defaulted */) AND rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
			INSERT INTO t_rif40_contextual_stats (
				username,
				study_id,
				inv_id,
				area_id,
				area_population,
				area_observed,
				total_comparision_population,
				variance_high,
				variance_low)
			VALUES(
				coalesce(NEW.username, "current_user"()),
				coalesce(NEW.study_id, (currval('rif40_study_id_seq'::regclass))::integer),
				coalesce(NEW.inv_id, (currval('rif40_inv_id_seq'::regclass))::integer),
				NEW.area_id /* no default value */,
				NEW.area_population /* no default value */,
				NEW.area_observed /* no default value */,
				NEW.total_comparision_population /* no default value */,
				NEW.variance_high /* no default value */,
				NEW.variance_low /* no default value */);
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_contextual_stats',
				'Cannot INSERT: User % must have rif_user or rif_manager role, NEW.username (%) must be USER or NULL', USER::VARCHAR, NEW.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'UPDATE' THEN
--
-- Check USER = OLD.username and NEW.username = OLD.username; if OK UPDATE
--
		IF USER = OLD.username AND NEW.username = OLD.username THEN
			UPDATE t_rif40_contextual_stats
			   SET username=NEW.username,
			       study_id=NEW.study_id,
			       inv_id=NEW.inv_id,
			       area_id=NEW.area_id,
			       area_population=NEW.area_population,
			       area_observed=NEW.area_observed,
			       total_comparision_population=NEW.total_comparision_population,
			       variance_high=NEW.variance_high,
			       variance_low=NEW.variance_low
			 WHERE study_id=OLD.study_id
			   AND inv_id=OLD.inv_id
			   AND area_id=OLD.area_id;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_contextual_stats',
				'Cannot UPDATE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'DELETE' THEN
--
-- Check USER = OLD.username; if OK DELETE
--
		IF USER = OLD.username THEN
			DELETE FROM t_rif40_contextual_stats
			 WHERE study_id=OLD.study_id
			   AND inv_id=OLD.inv_id
			   AND area_id=OLD.area_id;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_contextual_stats',
				'Cannot DELETE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NULL;
	END IF;
	RETURN NEW;
END;
]]></definition>
</function>

<function name="trgf_rif40_fdw_tables"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[INSTEAD OF trigger for view T_RIF40_FDW_TABLES to allow INSERT/UPDATE/DELETE. INSERT/UPDATE/DELETE of another users data is NOT permitted. 
 [NO TABLE/VIEW comments available]]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
	IF TG_OP = 'INSERT' THEN
--
-- Check (USER = NEW.username OR NULL) and USER is a RIF user; if OK INSERT
--
		IF (USER = NEW.username OR NEW.username IS NULL /* Will be defaulted */) AND rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
			INSERT INTO t_rif40_fdw_tables (
				username,
				table_name,
				create_status,
				error_message,
				date_created,
				rowtest_passed)
			VALUES(
				coalesce(NEW.username, "current_user"()),
				NEW.table_name /* no default value */,
				NEW.create_status /* no default value */,
				NEW.error_message /* no default value */,
				coalesce(NEW.date_created, ('now'::text)::timestamp without time zone),
				coalesce(NEW.rowtest_passed, 0));
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_fdw_tables',
				'Cannot INSERT: User % must have rif_user or rif_manager role, NEW.username (%) must be USER or NULL', USER::VARCHAR, NEW.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'UPDATE' THEN
--
-- Check USER = OLD.username and NEW.username = OLD.username; if OK UPDATE
--
		IF USER = OLD.username AND NEW.username = OLD.username THEN
			UPDATE t_rif40_fdw_tables
			   SET username=NEW.username,
			       table_name=NEW.table_name,
			       create_status=NEW.create_status,
			       error_message=NEW.error_message,
			       date_created=NEW.date_created,
			       rowtest_passed=NEW.rowtest_passed
			 WHERE table_name=OLD.table_name;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_fdw_tables',
				'Cannot UPDATE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'DELETE' THEN
--
-- Check USER = OLD.username; if OK DELETE
--
		IF USER = OLD.username THEN
			DELETE FROM t_rif40_fdw_tables
			 WHERE table_name=OLD.table_name;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_fdw_tables',
				'Cannot DELETE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NULL;
	END IF;
	RETURN NEW;
END;
]]></definition>
</function>

<function name="trgf_rif40_inv_conditions"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[INSTEAD OF trigger for view T_RIF40_INV_CONDITIONS to allow INSERT/UPDATE/DELETE. INSERT/UPDATE/DELETE of another users data is NOT permitted. 
 [NO TABLE/VIEW comments available]]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
	IF TG_OP = 'INSERT' THEN
--
-- Check (USER = NEW.username OR NULL) and USER is a RIF user; if OK INSERT
--
		IF (USER = NEW.username OR NEW.username IS NULL /* Will be defaulted */) AND rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
			INSERT INTO t_rif40_inv_conditions (
				username,
				study_id,
				inv_id,
				line_number,
				condition)
			VALUES(
				coalesce(NEW.username, "current_user"()),
				coalesce(NEW.study_id, (currval('rif40_study_id_seq'::regclass))::integer),
				coalesce(NEW.inv_id, (currval('rif40_inv_id_seq'::regclass))::integer),
				coalesce(NEW.line_number, 1),
				coalesce(NEW.condition, '1=1'::character varying));
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_inv_conditions',
				'Cannot INSERT: User % must have rif_user or rif_manager role, NEW.username (%) must be USER or NULL', USER::VARCHAR, NEW.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'UPDATE' THEN
--
-- Check USER = OLD.username and NEW.username = OLD.username; if OK UPDATE
--
		IF USER = OLD.username AND NEW.username = OLD.username THEN
			UPDATE t_rif40_inv_conditions
			   SET username=NEW.username,
			       study_id=NEW.study_id,
			       inv_id=NEW.inv_id,
			       line_number=NEW.line_number,
			       condition=NEW.condition
			 WHERE study_id=OLD.study_id
			   AND inv_id=OLD.inv_id
			   AND line_number=OLD.line_number;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_inv_conditions',
				'Cannot UPDATE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'DELETE' THEN
--
-- Check USER = OLD.username; if OK DELETE
--
		IF USER = OLD.username THEN
			DELETE FROM t_rif40_inv_conditions
			 WHERE study_id=OLD.study_id
			   AND inv_id=OLD.inv_id
			   AND line_number=OLD.line_number;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_inv_conditions',
				'Cannot DELETE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NULL;
	END IF;
	RETURN NEW;
END;
]]></definition>
</function>

<function name="trgf_rif40_inv_covariates"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[INSTEAD OF trigger for view T_RIF40_INV_COVARIATES to allow INSERT/UPDATE/DELETE. INSERT/UPDATE/DELETE of another users data is NOT permitted. 
 [NO TABLE/VIEW comments available]]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
	IF TG_OP = 'INSERT' THEN
--
-- Check (USER = NEW.username OR NULL) and USER is a RIF user; if OK INSERT
--
		IF (USER = NEW.username OR NEW.username IS NULL /* Will be defaulted */) AND rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
			INSERT INTO t_rif40_inv_covariates (
				username,
				study_id,
				inv_id,
				covariate_name,
				min,
				max,
				geography,
				study_geolevel_name)
			VALUES(
				coalesce(NEW.username, "current_user"()),
				coalesce(NEW.study_id, (currval('rif40_study_id_seq'::regclass))::integer),
				coalesce(NEW.inv_id, (currval('rif40_inv_id_seq'::regclass))::integer),
				NEW.covariate_name /* no default value */,
				NEW.min /* no default value */,
				NEW.max /* no default value */,
				NEW.geography /* no default value */,
				NEW.study_geolevel_name /* no default value */);
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_inv_covariates',
				'Cannot INSERT: User % must have rif_user or rif_manager role, NEW.username (%) must be USER or NULL', USER::VARCHAR, NEW.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'UPDATE' THEN
--
-- Check USER = OLD.username and NEW.username = OLD.username; if OK UPDATE
--
		IF USER = OLD.username AND NEW.username = OLD.username THEN
			UPDATE t_rif40_inv_covariates
			   SET username=NEW.username,
			       study_id=NEW.study_id,
			       inv_id=NEW.inv_id,
			       covariate_name=NEW.covariate_name,
			       min=NEW.min,
			       max=NEW.max,
			       geography=NEW.geography,
			       study_geolevel_name=NEW.study_geolevel_name
			 WHERE study_id=OLD.study_id
			   AND inv_id=OLD.inv_id
			   AND covariate_name=OLD.covariate_name;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_inv_covariates',
				'Cannot UPDATE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'DELETE' THEN
--
-- Check USER = OLD.username; if OK DELETE
--
		IF USER = OLD.username THEN
			DELETE FROM t_rif40_inv_covariates
			 WHERE study_id=OLD.study_id
			   AND inv_id=OLD.inv_id
			   AND covariate_name=OLD.covariate_name;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_inv_covariates',
				'Cannot DELETE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NULL;
	END IF;
	RETURN NEW;
END;
]]></definition>
</function>

<function name="trgf_rif40_investigations"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[INSTEAD OF trigger for view T_RIF40_INVESTIGATIONS to allow INSERT/UPDATE/DELETE. INSERT/UPDATE/DELETE of another users data is NOT permitted. 
 [NO TABLE/VIEW comments available]]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
	IF TG_OP = 'INSERT' THEN
--
-- Check (USER = NEW.username OR NULL) and USER is a RIF user; if OK INSERT
--
		IF (USER = NEW.username OR NEW.username IS NULL /* Will be defaulted */) AND rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
			INSERT INTO t_rif40_investigations (
				username,
				inv_id,
				study_id,
				inv_name,
				year_start,
				year_stop,
				max_age_group,
				min_age_group,
				genders,
				numer_tab,
				mh_test_type,
				geography,
				inv_description,
				classifier,
				classifier_bands,
				investigation_state)
			VALUES(
				coalesce(NEW.username, "current_user"()),
				coalesce(NEW.inv_id, (nextval('rif40_inv_id_seq'::regclass))::integer),
				coalesce(NEW.study_id, (currval('rif40_study_id_seq'::regclass))::integer),
				NEW.inv_name /* no default value */,
				NEW.year_start /* no default value */,
				NEW.year_stop /* no default value */,
				NEW.max_age_group /* no default value */,
				NEW.min_age_group /* no default value */,
				NEW.genders /* no default value */,
				NEW.numer_tab /* no default value */,
				coalesce(NEW.mh_test_type, 'No Test'::character varying),
				NEW.geography /* no default value */,
				NEW.inv_description /* no default value */,
				coalesce(NEW.classifier, 'QUANTILE'::character varying),
				coalesce(NEW.classifier_bands, 5),
				coalesce(NEW.investigation_state, 'C'::character varying));
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_investigations',
				'Cannot INSERT: User % must have rif_user or rif_manager role, NEW.username (%) must be USER or NULL', USER::VARCHAR, NEW.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'UPDATE' THEN
--
-- Check USER = OLD.username and NEW.username = OLD.username; if OK UPDATE
--
		IF USER = OLD.username AND NEW.username = OLD.username THEN
			UPDATE t_rif40_investigations
			   SET username=NEW.username,
			       inv_id=NEW.inv_id,
			       study_id=NEW.study_id,
			       inv_name=NEW.inv_name,
			       year_start=NEW.year_start,
			       year_stop=NEW.year_stop,
			       max_age_group=NEW.max_age_group,
			       min_age_group=NEW.min_age_group,
			       genders=NEW.genders,
			       numer_tab=NEW.numer_tab,
			       mh_test_type=NEW.mh_test_type,
			       geography=NEW.geography,
			       inv_description=NEW.inv_description,
			       classifier=NEW.classifier,
			       classifier_bands=NEW.classifier_bands,
			       investigation_state=NEW.investigation_state
			 WHERE inv_id=OLD.inv_id
			   AND study_id=OLD.study_id;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_investigations',
				'Cannot UPDATE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'DELETE' THEN
--
-- Check USER = OLD.username; if OK DELETE
--
		IF USER = OLD.username THEN
			DELETE FROM t_rif40_investigations
			 WHERE inv_id=OLD.inv_id
			   AND study_id=OLD.study_id;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_investigations',
				'Cannot DELETE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NULL;
	END IF;
	RETURN NEW;
END;
]]></definition>
</function>

<function name="trgf_rif40_parameters"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[INSTEAD OF trigger for view T_RIF40_PARAMETERS to allow INSERT/UPDATE by the RIF manager. Update not allowed on parameters: SuppressionValue or RifParametersTable]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
        IF TG_OP = 'INSERT' THEN
--
-- Check (USER = NEW.username OR NULL) and USER is a RIF user; if OK INSERT
--
                IF (USER = NEW.username OR NEW.username IS NULL /* Will be defaulted */) AND rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
                        INSERT INTO t_rif40_parameters (
                                param_name,
                                param_value,
                                param_description)
                        VALUES(
                                NEW.param_name,
                                NEW.param_value,
                                NEW.param_description);
                ELSE
                        PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_parameters',
                                'Cannot INSERT: User % must have rif_user or rif_manager role, NEW.username (%) must be USER or NULL', USER::VARCHAR, NEW.username::VARCHAR);
                END IF;
                RETURN NEW;
        ELSIF TG_OP = 'UPDATE' THEN
--
-- Cannot update SuppressionValue or RifParametersTable
--
                IF NEW.param_name NOT IN ('SuppressionValue', 'RifParametersTable') THEN
                        UPDATE t_rif40_parameters
                           SET param_value=NEW.param_value,
                               param_description=NEW.param_description;
                ELSE
                        PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_parameters',
                                'Cannot UPDATE: RIF40_PARAMETERS param_name  % (=%)', NEW.param_name::VARCHAR, NEW.param_value::VARCHAR);
                END IF;
                RETURN NEW;
        ELSIF TG_OP = 'DELETE' THEN
--
-- Check USER = OLD.username; if OK DELETE
--
                PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_parameters',
                    	'Cannot DELETE RIF40_PARAMETERS records');
                RETURN NULL;
        END IF;
        RETURN NEW;
END;
]]></definition>
</function>

<function name="trgf_rif40_results"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[INSTEAD OF trigger for view T_RIF40_RESULTS to allow INSERT/UPDATE/DELETE. INSERT/UPDATE/DELETE of another users data is NOT permitted. 
 [NO TABLE/VIEW comments available]]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
	IF TG_OP = 'INSERT' THEN
--
-- Check (USER = NEW.username OR NULL) and USER is a RIF user; if OK INSERT
--
		IF (USER = NEW.username OR NEW.username IS NULL /* Will be defaulted */) AND rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
			INSERT INTO t_rif40_results (
				username,
				study_id,
				inv_id,
				band_id,
				genders,
				direct_standardisation,
				adjusted,
				observed,
				expected,
				lower95,
				upper95,
				relative_risk,
				smoothed_relative_risk,
				posterior_probability,
				posterior_probability_upper95,
				posterior_probability_lower95,
				residual_relative_risk,
				residual_rr_lower95,
				residual_rr_upper95,
				smoothed_smr,
				smoothed_smr_lower95,
				smoothed_smr_upper95)
			VALUES(
				coalesce(NEW.username, "current_user"()),
				coalesce(NEW.study_id, (currval('rif40_study_id_seq'::regclass))::integer),
				coalesce(NEW.inv_id, (currval('rif40_inv_id_seq'::regclass))::integer),
				NEW.band_id /* no default value */,
				NEW.genders /* no default value */,
				NEW.direct_standardisation /* no default value */,
				NEW.adjusted /* no default value */,
				NEW.observed /* no default value */,
				NEW.expected /* no default value */,
				NEW.lower95 /* no default value */,
				NEW.upper95 /* no default value */,
				NEW.relative_risk /* no default value */,
				NEW.smoothed_relative_risk /* no default value */,
				NEW.posterior_probability /* no default value */,
				NEW.posterior_probability_upper95 /* no default value */,
				NEW.posterior_probability_lower95 /* no default value */,
				NEW.residual_relative_risk /* no default value */,
				NEW.residual_rr_lower95 /* no default value */,
				NEW.residual_rr_upper95 /* no default value */,
				NEW.smoothed_smr /* no default value */,
				NEW.smoothed_smr_lower95 /* no default value */,
				NEW.smoothed_smr_upper95 /* no default value */);
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_results',
				'Cannot INSERT: User % must have rif_user or rif_manager role, NEW.username (%) must be USER or NULL', USER::VARCHAR, NEW.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'UPDATE' THEN
--
-- Check USER = OLD.username and NEW.username = OLD.username; if OK UPDATE
--
		IF USER = OLD.username AND NEW.username = OLD.username THEN
			UPDATE t_rif40_results
			   SET username=NEW.username,
			       study_id=NEW.study_id,
			       inv_id=NEW.inv_id,
			       band_id=NEW.band_id,
			       genders=NEW.genders,
			       direct_standardisation=NEW.direct_standardisation,
			       adjusted=NEW.adjusted,
			       observed=NEW.observed,
			       expected=NEW.expected,
			       lower95=NEW.lower95,
			       upper95=NEW.upper95,
			       relative_risk=NEW.relative_risk,
			       smoothed_relative_risk=NEW.smoothed_relative_risk,
			       posterior_probability=NEW.posterior_probability,
			       posterior_probability_upper95=NEW.posterior_probability_upper95,
			       posterior_probability_lower95=NEW.posterior_probability_lower95,
			       residual_relative_risk=NEW.residual_relative_risk,
			       residual_rr_lower95=NEW.residual_rr_lower95,
			       residual_rr_upper95=NEW.residual_rr_upper95,
			       smoothed_smr=NEW.smoothed_smr,
			       smoothed_smr_lower95=NEW.smoothed_smr_lower95,
			       smoothed_smr_upper95=NEW.smoothed_smr_upper95
			 WHERE study_id=OLD.study_id
			   AND inv_id=OLD.inv_id
			   AND band_id=OLD.band_id
			   AND genders=OLD.genders
			   AND direct_standardisation=OLD.direct_standardisation
			   AND adjusted=OLD.adjusted;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_results',
				'Cannot UPDATE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'DELETE' THEN
--
-- Check USER = OLD.username; if OK DELETE
--
		IF USER = OLD.username THEN
			DELETE FROM t_rif40_results
			 WHERE study_id=OLD.study_id
			   AND inv_id=OLD.inv_id
			   AND band_id=OLD.band_id
			   AND genders=OLD.genders
			   AND direct_standardisation=OLD.direct_standardisation
			   AND adjusted=OLD.adjusted;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_results',
				'Cannot DELETE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NULL;
	END IF;
	RETURN NEW;
END;
]]></definition>
</function>

<function name="trgf_rif40_studies"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[INSTEAD OF trigger for view T_RIF40_STUDIES to allow INSERT/UPDATE/DELETE. INSERT/UPDATE/DELETE of another users data is NOT permitted. 
 [NO TABLE/VIEW comments available]]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
	IF TG_OP = 'INSERT' THEN
--
-- Check (USER = NEW.username OR NULL) and USER is a RIF user; if OK INSERT
--
		IF (USER = NEW.username OR NEW.username IS NULL /* Will be defaulted */) AND rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
			INSERT INTO t_rif40_studies (
				username,
				study_id,
				extract_table,
				study_name,
				summary,
				description,
				other_notes,
				study_date,
				geography,
				study_type,
				study_state,
				comparison_geolevel_name,
				denom_tab,
				direct_stand_tab,
				study_geolevel_name,
				map_table,
				suppression_value,
				extract_permitted,
				transfer_permitted,
				authorised_by,
				authorised_on,
				authorised_notes,
				audsid,
				project)
			VALUES(
				coalesce(NEW.username, "current_user"()),
				coalesce(NEW.study_id, (nextval('rif40_study_id_seq'::regclass))::integer),
				NEW.extract_table /* no default value */,
				NEW.study_name /* no default value */,
				NEW.summary /* no default value */,
				NEW.description /* no default value */,
				NEW.other_notes /* no default value */,
				coalesce(NEW.study_date, ('now'::text)::timestamp without time zone),
				NEW.geography /* no default value */,
				NEW.study_type /* no default value */,
				coalesce(NEW.study_state, 'C'::character varying),
				NEW.comparison_geolevel_name /* no default value */,
				NEW.denom_tab /* no default value */,
				NEW.direct_stand_tab /* no default value */,
				NEW.study_geolevel_name /* no default value */,
				NEW.map_table /* no default value */,
				NEW.suppression_value /* no default value */,
				coalesce(NEW.extract_permitted, 0),
				coalesce(NEW.transfer_permitted, 0),
				NEW.authorised_by /* no default value */,
				NEW.authorised_on /* no default value */,
				NEW.authorised_notes /* no default value */,
				coalesce(NEW.audsid, sys_context('USERENV'::character varying, 'SESSIONID'::character varying)),
				NEW.project /* no default value */);
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_studies',
				'Cannot INSERT: User % must have rif_user or rif_manager role, NEW.username (%) must be USER or NULL', USER::VARCHAR, NEW.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'UPDATE' THEN
--
-- Check USER = OLD.username and NEW.username = OLD.username; if OK UPDATE
--
		IF USER = OLD.username AND NEW.username = OLD.username THEN
			UPDATE t_rif40_studies
			   SET username=NEW.username,
			       study_id=NEW.study_id,
			       extract_table=NEW.extract_table,
			       study_name=NEW.study_name,
			       summary=NEW.summary,
			       description=NEW.description,
			       other_notes=NEW.other_notes,
			       study_date=NEW.study_date,
			       geography=NEW.geography,
			       study_type=NEW.study_type,
			       study_state=NEW.study_state,
			       comparison_geolevel_name=NEW.comparison_geolevel_name,
			       denom_tab=NEW.denom_tab,
			       direct_stand_tab=NEW.direct_stand_tab,
			       study_geolevel_name=NEW.study_geolevel_name,
			       map_table=NEW.map_table,
			       suppression_value=NEW.suppression_value,
			       extract_permitted=NEW.extract_permitted,
			       transfer_permitted=NEW.transfer_permitted,
			       authorised_by=NEW.authorised_by,
			       authorised_on=NEW.authorised_on,
			       authorised_notes=NEW.authorised_notes,
			       audsid=NEW.audsid,
			       project=NEW.project
			 WHERE study_id=OLD.study_id;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_studies',
				'Cannot UPDATE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'DELETE' THEN
--
-- Check USER = OLD.username; if OK DELETE
--
		IF USER = OLD.username THEN
			DELETE FROM t_rif40_studies
			 WHERE study_id=OLD.study_id;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_studies',
				'Cannot DELETE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NULL;
	END IF;
	RETURN NEW;
END;
]]></definition>
</function>

<function name="trgf_rif40_study_areas"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[INSTEAD OF trigger for view T_RIF40_STUDY_AREAS to allow INSERT/UPDATE/DELETE. INSERT/UPDATE/DELETE of another users data is NOT permitted. 
 [NO TABLE/VIEW comments available]]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
	IF TG_OP = 'INSERT' THEN
--
-- Check (USER = NEW.username OR NULL) and USER is a RIF user; if OK INSERT
--
		IF (USER = NEW.username OR NEW.username IS NULL /* Will be defaulted */) AND rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
			INSERT INTO t_rif40_study_areas (
				username,
				study_id,
				area_id,
				band_id)
			VALUES(
				coalesce(NEW.username, "current_user"()),
				coalesce(NEW.study_id, (currval('rif40_study_id_seq'::regclass))::integer),
				NEW.area_id /* no default value */,
				NEW.band_id /* no default value */);
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_study_areas',
				'Cannot INSERT: User % must have rif_user or rif_manager role, NEW.username (%) must be USER or NULL', USER::VARCHAR, NEW.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'UPDATE' THEN
--
-- Check USER = OLD.username and NEW.username = OLD.username; if OK UPDATE
--
		IF USER = OLD.username AND NEW.username = OLD.username THEN
			UPDATE t_rif40_study_areas
			   SET username=NEW.username,
			       study_id=NEW.study_id,
			       area_id=NEW.area_id,
			       band_id=NEW.band_id
			 WHERE study_id=OLD.study_id
			   AND area_id=OLD.area_id;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_study_areas',
				'Cannot UPDATE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'DELETE' THEN
--
-- Check USER = OLD.username; if OK DELETE
--
		IF USER = OLD.username THEN
			DELETE FROM t_rif40_study_areas
			 WHERE study_id=OLD.study_id
			   AND area_id=OLD.area_id;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_study_areas',
				'Cannot DELETE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NULL;
	END IF;
	RETURN NEW;
END;
]]></definition>
</function>

<function name="trgf_rif40_study_sql"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[INSTEAD OF trigger for view T_RIF40_STUDY_SQL to allow INSERT/UPDATE/DELETE. INSERT/UPDATE/DELETE of another users data is NOT permitted. 
 [NO TABLE/VIEW comments available]]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
	IF TG_OP = 'INSERT' THEN
--
-- Check (USER = NEW.username OR NULL) and USER is a RIF user; if OK INSERT
--
		IF (USER = NEW.username OR NEW.username IS NULL /* Will be defaulted */) AND rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
			INSERT INTO t_rif40_study_sql (
				username,
				study_id,
				statement_type,
				statement_number,
				sql_text,
				line_number,
				status)
			VALUES(
				coalesce(NEW.username, "current_user"()),
				coalesce(NEW.study_id, (currval('rif40_study_id_seq'::regclass))::integer),
				NEW.statement_type /* no default value */,
				NEW.statement_number /* no default value */,
				NEW.sql_text /* no default value */,
				NEW.line_number /* no default value */,
				NEW.status /* no default value */);
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_study_sql',
				'Cannot INSERT: User % must have rif_user or rif_manager role, NEW.username (%) must be USER or NULL', USER::VARCHAR, NEW.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'UPDATE' THEN
--
-- Check USER = OLD.username and NEW.username = OLD.username; if OK UPDATE
--
		IF USER = OLD.username AND NEW.username = OLD.username THEN
			UPDATE t_rif40_study_sql
			   SET username=NEW.username,
			       study_id=NEW.study_id,
			       statement_type=NEW.statement_type,
			       statement_number=NEW.statement_number,
			       sql_text=NEW.sql_text,
			       line_number=NEW.line_number,
			       status=NEW.status
			 WHERE study_id=OLD.study_id
			   AND statement_number=OLD.statement_number
			   AND line_number=OLD.line_number;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_study_sql',
				'Cannot UPDATE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'DELETE' THEN
--
-- Check USER = OLD.username; if OK DELETE
--
		IF USER = OLD.username THEN
			DELETE FROM t_rif40_study_sql
			 WHERE study_id=OLD.study_id
			   AND statement_number=OLD.statement_number
			   AND line_number=OLD.line_number;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_study_sql',
				'Cannot DELETE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NULL;
	END IF;
	RETURN NEW;
END;
]]></definition>
</function>

<function name="trgf_rif40_study_sql_log"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[INSTEAD OF trigger for view T_RIF40_STUDY_SQL_LOG to allow INSERT/UPDATE/DELETE. INSERT/UPDATE/DELETE of another users data is NOT permitted. 
 [NO TABLE/VIEW comments available]]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
	IF TG_OP = 'INSERT' THEN
--
-- Check (USER = NEW.username OR NULL) and USER is a RIF user; if OK INSERT
--
		IF (USER = NEW.username OR NEW.username IS NULL /* Will be defaulted */) AND rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
			INSERT INTO t_rif40_study_sql_log (
				username,
				study_id,
				statement_type,
				statement_number,
				log_message,
				audsid,
				log_sqlcode,
				rowcount,
				start_time,
				elapsed_time)
			VALUES(
				coalesce(NEW.username, "current_user"()),
				coalesce(NEW.study_id, (currval('rif40_study_id_seq'::regclass))::integer),
				NEW.statement_type /* no default value */,
				NEW.statement_number /* no default value */,
				NEW.log_message /* no default value */,
				coalesce(NEW.audsid, sys_context('USERENV'::character varying, 'SESSIONID'::character varying)),
				NEW.log_sqlcode /* no default value */,
				NEW.rowcount /* no default value */,
				coalesce(NEW.start_time, systimestamp((9)::bigint)),
				NEW.elapsed_time /* no default value */);
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_study_sql_log',
				'Cannot INSERT: User % must have rif_user or rif_manager role, NEW.username (%) must be USER or NULL', USER::VARCHAR, NEW.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'UPDATE' THEN
--
-- Check USER = OLD.username and NEW.username = OLD.username; if OK UPDATE
--
		IF USER = OLD.username AND NEW.username = OLD.username THEN
			UPDATE t_rif40_study_sql_log
			   SET username=NEW.username,
			       study_id=NEW.study_id,
			       statement_type=NEW.statement_type,
			       statement_number=NEW.statement_number,
			       log_message=NEW.log_message,
			       audsid=NEW.audsid,
			       log_sqlcode=NEW.log_sqlcode,
			       rowcount=NEW.rowcount,
			       start_time=NEW.start_time,
			       elapsed_time=NEW.elapsed_time
			 WHERE study_id=OLD.study_id
			   AND statement_number=OLD.statement_number;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_study_sql_log',
				'Cannot UPDATE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'DELETE' THEN
--
-- Check USER = OLD.username; if OK DELETE
--
		IF USER = OLD.username THEN
			DELETE FROM t_rif40_study_sql_log
			 WHERE study_id=OLD.study_id
			   AND statement_number=OLD.statement_number;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_study_sql_log',
				'Cannot DELETE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NULL;
	END IF;
	RETURN NEW;
END;
]]></definition>
</function>

<function name="trgf_rif40_user_projects"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[INSTEAD OF trigger for view T_RIF40_USER_PROJECTS to allow INSERT/UPDATE/DELETE. INSERT/UPDATE/DELETE of another users data is NOT permitted. 
 [NO TABLE/VIEW comments available]]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
	IF TG_OP = 'INSERT' THEN
--
-- Check (USER = NEW.username OR NULL) and USER is a RIF user; if OK INSERT
--
		IF (USER = NEW.username OR NEW.username IS NULL /* Will be defaulted */) AND rif40_sql_pkg.is_rif40_user_manager_or_schema() THEN
			INSERT INTO t_rif40_user_projects (
				project,
				username,
				grant_date,
				revoke_date)
			VALUES(
				NEW.project /* no default value */,
				coalesce(NEW.username, "current_user"()),
				coalesce(NEW.grant_date, ('now'::text)::timestamp without time zone),
				NEW.revoke_date /* no default value */);
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_user_projects',
				'Cannot INSERT: User % must have rif_user or rif_manager role, NEW.username (%) must be USER or NULL', USER::VARCHAR, NEW.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'UPDATE' THEN
--
-- Check USER = OLD.username and NEW.username = OLD.username; if OK UPDATE
--
		IF USER = OLD.username AND NEW.username = OLD.username THEN
			UPDATE t_rif40_user_projects
			   SET project=NEW.project,
			       username=NEW.username,
			       grant_date=NEW.grant_date,
			       revoke_date=NEW.revoke_date
			 WHERE project=OLD.project
			   AND username=OLD.username;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_user_projects',
				'Cannot UPDATE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NEW;
	ELSIF TG_OP = 'DELETE' THEN
--
-- Check USER = OLD.username; if OK DELETE
--
		IF USER = OLD.username THEN
			DELETE FROM t_rif40_user_projects
			 WHERE project=OLD.project
			   AND username=OLD.username;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20999, 'trg_rif40_user_projects',
				'Cannot DELETE: User % is not the owner (%) of the record', USER::VARCHAR, OLD.username::VARCHAR);
		END IF;
		RETURN NULL;
	END IF;
	RETURN NEW;
END;
]]></definition>
</function>

<function name="trigger_fct_rif40_covariates_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check <T_RIF40_GEOLEVELS.COVARIATE_TABLE>.<COVARIATE_NAME> column exists.
Check - min < max, max/min precison is appropriate to type.
Error range:  -20140 to -20159 - RIF40_COVARIATES]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_rif40_covariates_checks_description>
<para>
Check <T_RIF40_GEOLEVELS.COVARIATE_TABLE>.<COVARIATE_NAME> column exists.
Check - min < max, max/min precison is appropriate to type
</para>
</trigger_rif40_covariates_checks_description>
 */
--
-- Error range:  -20140 to -20159 - RIF40_COVARIATES
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c1tcov CURSOR (l_schema VARCHAR, l_table VARCHAR, l_column VARCHAR) IS
		SELECT column_name
		  FROM information_schema.columns
		 WHERE table_schema = LOWER(l_schema)
		   AND table_name   = LOWER(l_table)
		   AND column_name  = LOWER(l_column);
	c2tcov CURSOR (l_geolevel_name VARCHAR) IS
		SELECT covariate_table
		  FROM t_rif40_geolevels
		 WHERE geolevel_name = l_geolevel_name;
	c1tcov_rec RECORD;
	c2tcov_rec RECORD;
--
	schema 		VARCHAR;
BEGIN
	IF TG_OP = 'DELETE' THEN
		RETURN NULL;
	END IF;
--
-- Check <T_RIF40_GEOLEVELS.COVARIATE_TABLE>.<COVARIATE_NAME> column exists
--
	OPEN c2tcov(NEW.geolevel_name);
	FETCH c2tcov INTO c2tcov_rec;
	CLOSE c2tcov;
	IF (c2tcov_rec.covariate_table IS NOT NULL AND c2tcov_rec.covariate_table::text <> '') THEN
		schema:=rif40_sql_pkg.rif40_object_resolve(c2tcov_rec.covariate_table::VARCHAR);
		IF coalesce(schema::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20140, 'trigger_fct_rif40_covariates_checks', 
				'Error: T_RIF40_GEOLEVELS COVARIATE_TABLE (%) not found for geolevel_name: %, covariate: %',
				LOWER(c2tcov_rec.covariate_table)::VARCHAR	/* Covariate table */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */,
				NEW.covariate_name::VARCHAR		/* Covariate name */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_covariates_checks', 
				'[20140] T_RIF40_GEOLEVELS COVARIATE_TABLE (%) found for geolevel_name: %, covariate: %',
				LOWER(c2tcov_rec.covariate_table)::VARCHAR	/* Covariate table */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */,
				NEW.covariate_name::VARCHAR		/* Covariate name */);
		END IF;
		OPEN c1tcov(schema, c2tcov_rec.covariate_table, NEW.covariate_name);
		FETCH c1tcov INTO c1tcov_rec;
		CLOSE c1tcov;
		IF (NEW.covariate_name IS NOT NULL AND NEW.covariate_name::text <> '') AND coalesce(c1tcov_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20141, 
				'trigger_fct_rif40_covariates_checks', 'Error: RIF40_COVARIATES % column not found in: % for geolevel_name: %',
				NEW.covariate_name::VARCHAR		/* Covariate name */,
				UPPER(c2tcov_rec.covariate_table)::VARCHAR		/* Covariate table */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		ELSIF (NEW.covariate_name IS NOT NULL AND NEW.covariate_name::text <> '') AND (c1tcov_rec.column_name IS NOT NULL AND c1tcov_rec.column_name::text <> '') THEN
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_covariates_checks', 
				'[20141] RIF40_COVARIATES % column found in: % for geolevel_name: %',
				NEW.covariate_name::VARCHAR		/* Covariate name */,
				UPPER(c2tcov_rec.covariate_table)::VARCHAR		/* Covariate table */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		END IF;
	END IF;
--
-- 	Check - min < max, max/min precison is appropriate to type
--
	IF NEW.min >= NEW.max THEN
		PERFORM rif40_log_pkg.rif40_error(-20142, 'trigger_fct_rif40_covariates_checks', 
			'Error: RIF40_COVARIATES min >= max: % >= % for geolevel_name: % covariate: %',
			TO_CHAR(NEW.min)::VARCHAR		/* New min */,
			TO_CHAR(NEW.max)::VARCHAR		/* New max */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	ELSIF NEW.type = 1 AND ROUND(NEW.max) != NEW.max THEN /* integer score */
		PERFORM rif40_log_pkg.rif40_error(-20143, 'trigger_fct_rif40_covariates_checks', 
			'Error: RIF40_COVARIATES type = 1 (integer score) and max is not an integer: % for geolevel_name: % covariate: % for geolevel_name: % covariate: %',
			TO_CHAR(NEW.max)::VARCHAR		/* New max */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	ELSIF NEW.type = 1 AND ROUND(NEW.min) != NEW.min THEN /* integer score */
		PERFORM rif40_log_pkg.rif40_error(-20144, 'trigger_fct_rif40_covariates_checks', 
			'Error: RIF40_COVARIATES type = 1 (integer score) and min is not an integer: % for geolevel_name: % covariate: % for geolevel_name: % covariate: %',
			TO_CHAR(NEW.min)::VARCHAR		/* New min */,
			NEW.geolevel_name::VARCHAR	/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	ELSIF NEW.type = 1 AND NEW.min < 0 THEN /* integer score */
		PERFORM rif40_log_pkg.rif40_error(-20145, 'trigger_fct_rif40_covariates_checks', 
			'Error: RIF40_COVARIATES type = 1 (integer score) and min <0: % for geolevel_name: % covariate: % for geolevel_name: % covariate: %',
			TO_CHAR(NEW.min)::VARCHAR		/* New min */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_covariates_checks', 
			'[20142-5] RIF40_COVARIATES Checked OK for geolevel_name: % covariate: %',
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	END IF;
--
-- Check covariate_name
--
	PERFORM rif40_trg_pkg.rif40_db_name_check('COVARIATE_NAME', NEW.covariate_name);
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
]]></definition>
</function>

<function name="trigger_fct_rif40_error_messages_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check - table_name exists.
-20480 to -20499 - RIF40_ERROR_MESSAGES]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_rif40_error_messages_checks>
<para>
Check - table_name exists.
</para>
</trigger_rif40_error_messages_checks>
 */
--
-- -20480 to -20499 - RIF40_ERROR_MESSAGES
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	schema	VARCHAR;
BEGIN
	IF TG_OP = 'DELETE' THEN
		RETURN NULL;
	END IF;
--
	schema:=rif40_sql_pkg.rif40_object_resolve(NEW.table_name::VARCHAR);
--
-- Check HIERARCHYTABLE
--
	IF (NEW.table_name IS NOT NULL AND NEW.table_name::text <> '') AND coalesce(schema::text, '') = '' THEN
--
-- This really should be an error - wait until auto generated on PostGres
--
		PERFORM rif40_log_pkg.rif40_log('WARNING', 'trigger_fct_rif40_error_messages_checks', '[20480] RIF40_ERROR_MESSAGES table_name (%) not found',
			LOWER(NEW.table_name)::VARCHAR /* table_name referenced in RIF40_ERROR_MESSAGES */);
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
]]></definition>
</function>

<function name="trigger_fct_rif40_geog_hierarchytable"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check HIERARCHYTABLE exists.
Check postal_population_table if set and expected columns
Error range: -20100 to -20119 - RIF40_GEOG_HIERARCHYTABLE]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_rif40_geog_hierarchytable_description>
<para>
Check HIERARCHYTABLE exists.
Check postal_population_table if set and expected columns
</para>
</trigger_rif40_geog_hierarchytable_description>
 */
--
-- Error range: -20100 to -20119 - RIF40_GEOG_HIERARCHYTABLE
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c1geog CURSOR (l_schema VARCHAR, l_table VARCHAR, l_column VARCHAR) FOR
		SELECT column_name
		  FROM information_schema.columns
		 WHERE table_schema = LOWER(l_schema)
		   AND table_name   = LOWER(l_table)
		   AND column_name  = LOWER(l_column);
	c2geog CURSOR (l_geolevel VARCHAR) FOR
		SELECT *
		  FROM t_rif40_geolevels
		 WHERE geolevel_name = l_geolevel;
	c3geog CURSOR (l_geography VARCHAR) FOR
		SELECT COUNT(geolevel_name) AS total_geolevels
		  FROM t_rif40_geolevels
		 WHERE l_geography = geography;
--
	c1geog_rec 	RECORD;
	c2ageog_rec 	RECORD;
	c2bgeog_rec 	RECORD;
	c3geog_rec 	RECORD;
--
	schema		VARCHAR;
BEGIN
	IF TG_OP = 'DELETE' THEN
		RETURN NULL;
	END IF;
--
-- Check HIERARCHYTABLE
--
	schema:=rif40_sql_pkg.rif40_object_resolve(NEW.hierarchytable::VARCHAR);
	IF (NEW.hierarchytable IS NOT NULL AND NEW.hierarchytable::text <> '') AND coalesce(schema::text, '') = '' THEN
--
-- A date_built column needs to be added so the HIERARCHYTABLE can be NULL when trhe RIF builds the hierarchy table
--
--		PERFORM rif40_log_pkg.rif40_error(-20100, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES HIERARCHYTABLE (%) not found',
--			LOWER(NEW.hierarchytable)::VARCHAR /* hierarchy table */);
		NULL;
	ELSIF (NEW.hierarchytable IS NOT NULL AND NEW.hierarchytable::text <> '') AND coalesce(schema::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20100] RIF40_GEOGRAPHIES HIERARCHYTABLE (%) found',
			LOWER(NEW.hierarchytable)::VARCHAR /* hierarchy table */);
	END IF;
--
-- Check postal_population_table and postal_point_column
--
	IF (NEW.postal_population_table IS NOT NULL AND NEW.postal_population_table::text <> '') THEN
		schema:=rif40_sql_pkg.rif40_object_resolve(NEW.postal_population_table::VARCHAR);
		IF coalesce(schema::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20101, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES POSTAL_POPULATION_TABLE (%) not found',
				LOWER(NEW.postal_population_table)::VARCHAR /* hierarchy table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20101] RIF40_GEOGRAPHIES POSTAL_POPULATION_TABLE (%) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		END IF;
		OPEN c1geog(schema, NEW.postal_population_table, NEW.postal_point_column);
		FETCH c1geog INTO c1geog_rec;
		CLOSE c1geog;
		IF coalesce(c1geog_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20102, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES POSTAL_POINT_COLUMN column (%.%) not found',
				NEW.postal_population_table::VARCHAR	/* postal population table */,
				NEW.postal_point_column::VARCHAR	/* postal point column */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20102] RIF40_GEOGRAPHIES POSTAL_POINT_COLUMN column (%.%) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */,
				NEW.postal_point_column::VARCHAR	/* postal point column */);
		END IF;
		c1geog_rec.column_name:=NULL;
		OPEN c1geog(schema, NEW.postal_population_table, 'MALES');
		FETCH c1geog INTO c1geog_rec;
		CLOSE c1geog;
		IF coalesce(c1geog_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20103, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES column (%.MALES) not found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20103] RIF40_GEOGRAPHIES column (%.MALES) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		END IF;
		c1geog_rec.column_name:=NULL;
		OPEN c1geog(schema, NEW.postal_population_table, 'FEMALES');
		FETCH c1geog INTO c1geog_rec;
		CLOSE c1geog;
		IF coalesce(c1geog_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20104, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES column (%.FEMALES) not found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20104] RIF40_GEOGRAPHIES column (%.FEMALES) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		END IF;
		c1geog_rec.column_name:=NULL;
		OPEN c1geog(schema, NEW.postal_population_table, 'TOTAL');
		FETCH c1geog INTO c1geog_rec;
		CLOSE c1geog;
		IF coalesce(c1geog_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20105, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES column (%.TOTAL) not found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20105] RIF40_GEOGRAPHIES column (%.TOTAL) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		END IF;
		c1geog_rec.column_name:=NULL;
		OPEN c1geog(schema, NEW.postal_population_table, 'XCOORDINATE');
		FETCH c1geog INTO c1geog_rec;
		CLOSE c1geog;
		IF coalesce(c1geog_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20106, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES column (%.XCOORDINATE) not found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20106] RIF40_GEOGRAPHIES column (%.XCOORDINATE) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		END IF;
		c1geog_rec.column_name:=NULL;
		OPEN c1geog(schema, NEW.postal_population_table, 'YCOORDINATE');
		FETCH c1geog INTO c1geog_rec;
		CLOSE c1geog;
		IF coalesce(c1geog_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20107, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES column (%.YCOORDINATE) not found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20107] RIF40_GEOGRAPHIES column (%.YCOORDINATE) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		END IF;
	END IF;
--
--  Also check defaultcomparea, defaultstudyarea as FK is now removed
--
	OPEN c3geog(NEW.geography);
	FETCH c3geog INTO c3geog_rec;
	CLOSE c3geog;
--
	IF (c3geog_rec.total_geolevels > 0 AND NEW.defaultcomparea IS NOT NULL AND NEW.defaultcomparea::text <> '') THEN
		OPEN c2geog(NEW.defaultcomparea);
		FETCH c2geog INTO c2ageog_rec;
		CLOSE c2geog;
		IF c2ageog_rec.geolevel_name IS NULL THEN
			PERFORM rif40_log_pkg.rif40_error(-20108, 'trigger_fct_rif40_geog_hierarchytable', 
				'Error: Default comparision area column % not found in T_RIF40_GEOLEVELS for geography: %',
				NEW.defaultcomparea::VARCHAR	/* Default comparision area */,
				NEW.geography::VARCHAR		/* Geography */);
		ELSIF (NEW.defaultstudyarea IS NOT NULL AND NEW.defaultstudyarea::text <> '')  THEN
			OPEN c2geog(NEW.defaultstudyarea);
			FETCH c2geog INTO c2bgeog_rec;
			CLOSE c2geog;
			IF c2bgeog_rec.geolevel_name IS NULL THEN
				PERFORM rif40_log_pkg.rif40_error(-20108, 'trigger_fct_rif40_geog_hierarchytable', 
					'Error: Default study area column % not found in T_RIF40_GEOLEVELS for geography: %',
					NEW.defaultstudyarea::VARCHAR	/* Default study area */,
					NEW.geography::VARCHAR		/* Geography */);
			END IF;
		END IF;
	END IF;

--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END; 
]]></definition>
</function>

<function name="trigger_fct_rif40_outcomes_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check current_lookup table exists
Check current_value_Nchar AND current_description_Nchar columns exists if NOT NULL
Check previous lookup table exists if NOT NULL
Check previous_value_Nchar AND previous_description_Nchar if NOT NULL AND (previous_lookup_table IS NOT NULL)

-20400 to -20419 - RIF40_OUTCOMES]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_rif40_outcomes_checks_description>
<para>
Check current_lookup table exists
Check current_value_Nchar AND current_description_Nchar columns exists if NOT NULL
Check previous lookup table exists if NOT NULL
Check previous_value_Nchar AND previous_description_Nchar if NOT NULL AND (previous_lookup_table IS NOT NULL AND previous_lookup_table::text <> '')
</para>
</trigger_rif40_outcomes_checks_description>
 */
--
-- -20400 to -20419 - RIF40_OUTCOMES
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	schema VARCHAR(30);
BEGIN
	IF TG_OP = 'DELETE' THEN
		RETURN NULL;
	END IF;
--
-- Check current_lookup table exists
--
	schema:=rif40_sql_pkg.rif40_object_resolve(NEW.current_lookup_table::VARCHAR);
	IF (NEW.current_lookup_table IS NOT NULL AND NEW.current_lookup_table::text <> '') AND coalesce(schema::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20400, 'trigger_fct_rif40_outcomes_checks', 'RIF40_OUTCOMES outcome type: % current_lookup_table (%) not found',
			NEW.outcome_type::VARCHAR		/* Outcome type */,
			NEW.current_lookup_table::VARCHAR	/* Current lookup table */);
	END IF;

--
-- Check current_value_Nchar AND current_description_Nchar columns exists if NOT NULL
--
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_value_1char',  schema, NEW.current_lookup_table, NEW.current_value_1char);
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_value_2char',  schema, NEW.current_lookup_table, NEW.current_value_2char);
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_value_3char',  schema, NEW.current_lookup_table, NEW.current_value_3char);
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_value_4char',  schema, NEW.current_lookup_table, NEW.current_value_4char);
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_value_5char',  schema, NEW.current_lookup_table, NEW.current_value_5char);
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_description_1char',  schema, NEW.current_lookup_table, NEW.current_description_1char);
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_description_2char',  schema, NEW.current_lookup_table, NEW.current_description_2char);
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_description_3char',  schema, NEW.current_lookup_table, NEW.current_description_3char);
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_description_4char',  schema, NEW.current_lookup_table, NEW.current_description_4char);
	PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'current_description_5char',  schema, NEW.current_lookup_table, NEW.current_description_5char);

--
-- Check previous lookup table exists if NOT NULL
--
	schema:=rif40_sql_pkg.rif40_object_resolve(NEW.previous_lookup_table::VARCHAR);
	IF (NEW.previous_lookup_table IS NOT NULL AND NEW.previous_lookup_table::text <> '') AND coalesce(schema::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20402, 'trigger_fct_rif40_outcomes_checks', 'RIF40_OUTCOMES outcome type: % previous_lookup_table (%) not found',
			NEW.outcome_type::VARCHAR		/* Outcome type */,
			NEW.previous_lookup_table::VARCHAR	/* Previous lookup table */);
	END IF;

--
-- Check previous_value_Nchar AND previous_description_Nchar if NOT NULL AND (previous_lookup_table IS NOT NULL AND previous_lookup_table::text <> '')
--
	IF (NEW.previous_lookup_table IS NOT NULL AND NEW.previous_lookup_table::text <> '') THEN
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_value_1char',  schema, NEW.previous_lookup_table, NEW.previous_value_1char);
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_value_2char',  schema, NEW.previous_lookup_table, NEW.previous_value_2char);
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_value_3char',  schema, NEW.previous_lookup_table, NEW.previous_value_3char);
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_value_4char',  schema, NEW.previous_lookup_table, NEW.previous_value_4char);
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_value_5char',  schema, NEW.previous_lookup_table, NEW.previous_value_5char);
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_description_1char',  schema, NEW.previous_lookup_table, NEW.previous_description_1char);
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_description_2char',  schema, NEW.previous_lookup_table, NEW.previous_description_2char);
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_description_3char',  schema, NEW.previous_lookup_table, NEW.previous_description_3char);
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_description_4char',  schema, NEW.previous_lookup_table, NEW.previous_description_4char);
		PERFORM rif40_trg_pkg.lp_outcomes_check_column(NEW.outcome_type, 'previous_description_5char',  schema, NEW.previous_lookup_table, NEW.previous_description_5char);
	END IF;
--
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_outcomes_checks', '[20400-2] RIF40_OUTCOMES outcome type: % OK',
		NEW.outcome_type::VARCHAR	/* Outcome type */);
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
]]></definition>
</function>

<function name="trigger_fct_rif40_predefined_groups_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check condition for SQL injection
-20460 to -20479 - RIF40_PREDEFINED_GROUPS]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_rif40_predefined_groups_checks_description>
<para>
Check condition for SQL injection
</para>
</trigger_rif40_predefined_groups_checks_description>
 */
--
-- -20460 to -20479 - RIF40_PREDEFINED_GROUPS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
BEGIN
	IF TG_OP = 'DELETE' THEN
		RETURN NULL;
	END IF;
--
-- Check condition for SQL injection
--
	PERFORM rif40_trg_pkg.rif40_sql_injection_check(
		'RIF40_PREDEFINED_GROUPS',
		NEW.predefined_group_name		/* Predefined group name */,
		NEW.predefined_group_description	/* Description */,
		NEW.outcome_type 			/* Outcome type */,
		'CONDITION', NEW.condition);
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END; 
]]></definition>
</function>

<function name="trigger_fct_rif40_study_shares_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check - Username is NOT a RIF user - i.e. username is NOT rif40 and has either or both RIF_USER and RIF_MANAGER.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
Check - Grantor is owner of the study OR has RIF_MANAGER role.
Check - grantee username.
Check - grantee username has RIF_USER or RIF_MANAGER role.

 -20320 to -20339 - RIF40_STUDY_SHARES]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_rif40_study_shares_checks_description>
<para>
Check - Username is NOT a RIF user - i.e. username is NOT rif40 and has either or both RIF_USER and RIF_MANAGER.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
Check - Grantor is owner of the study OR has RIF_MANAGER role.
Check - grantee username.
Check - grantee username has RIF_USER or RIF_MANAGER role.
</para>
</trigger_rif40_study_shares_checks_description>
 */
--
-- -20320 to -20339 - RIF40_STUDY_SHARES
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
-- $Log: v4_0_postgres_triggers.sql,v $
-- Revision 1.6  2014/02/24 10:50:28  peterh
-- Full build from Oracle, including default study area and removal of year_start/stop min/max_age_group from T_RIF40_STUDIES
--
-- Still present in view
--
-- Revision 1.5  2013/09/25 12:12:22  peterh
-- Baseline after 2x full clean builds at Postgres level
-- TODO.txt uptodate
--
-- Revision 1.4  2013/09/18 15:20:32  peterh
-- Checkin at end of 6 week RIF focus. Got as far as SAHSULAND run study to completion for observed only
--
-- Revision 1.3  2013/09/02 14:08:33  peterh
--
-- Baseline after full trigger implmentation
--
-- Revision 1.2  2013/03/14 17:35:38  peterh
-- Baseline for TX to laptop
--
-- Revision 1.4  2013/02/14 10:48:39  peterh
-- Baseline aftyer clean build with screen mockup changes
--
-- Revision 1.12  2012/10/23 09:05:57  peterh
--
-- Baseline after full build of SAHSUland RIF schema including data
-- No triggers, Geo data and system error/logon triggers to be done
--
-- Revision 1.11  2012/09/14 15:44:53  peterh
-- Baseline after full review of check code and error messages
-- IG functionality added
--
-- Revision 1.10  2012/09/05 15:16:37  peterh
--
-- RIF update after initial build of postgres DB
--
-- Revision 1.9  2012/07/03 12:28:55  peterh
--
-- RIF schema as at 3/6/2012. All entities complete
--
-- Revision 1.8  2012/06/15 11:05:26  peterh
-- Check with working SQL generator (CREATE stmt only); bones of XML generator
-- Numerous lookup tables added.
-- Prepare for documentation
--
-- Revision 1.7  2012/05/22 15:29:41  peterh
--
-- Added RIF40_RESULTS, contextual_stats; more verification
--
-- Revision 1.6  2012/05/21 11:11:28  peterh
--
-- RIF investigattion, inv_covariates, study shares checks + SAHSU land example data
--
-- Revision 1.5  2012/04/26 15:49:48  peterh
-- Fixed view security problems
--
-- Revision 1.4  2012/04/13 15:05:02  peterh
--
-- Added RIF studies, investigations etc
--
-- Revision 1.3  2012/04/04 15:22:51  peterh
-- Easter baseline
--
-- Revision 1.2  2012/03/30 11:45:40  peterh
--
-- Baseline with working RIF40_NUM_DENOM
--
-- Revision 1.1  2012/03/28 15:39:19  peterh
--
-- Added check constraints and basic object table+column existance checks
--
-- Revision 1.2  2012/03/27 15:54:33  peterh
--
-- Added more V4 tables
--
-- Revision 1.1  2012/03/23 15:21:18  peterh
--
-- Moved from old RIF directory
--
-- Revision 1.2  2011/07/12 13:18:40  peterh
-- RIF baseline after Kerberosisation, re-doc and N_POP add
--
-- Revision 1.1  2011/05/27 10:31:21  peterh
--
-- Start of user level suppression support in RIF
--
	c1stsh CURSOR(l_study_id  integer) IS
		SELECT username, study_id
		  FROM t_rif40_studies
		 WHERE study_id = l_study_id;
	c2stsh CURSOR(l_grantee  varchar) IS
		SELECT rolname
		  FROM pg_roles
		 WHERE rolname = LOWER(l_grantee);
	c4stsh CURSOR IS
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c4stsh_rec RECORD;
	c1stsh_rec RECORD;
	c2stsh_rec RECORD;
BEGIN
	OPEN c4stsh;
	FETCH c4stsh INTO c4stsh_rec;
	CLOSE c4stsh;
--
-- RIF40_STUDY_SHARES:	Check - Username is NOT a RIF user - i.e. username is NOT rif40 and has either or both RIF_USER and RIF_MANAGER
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records

	IF NOT TG_OP = 'DELETE' AND USER = 'rif40' AND c4stsh_rec.total = 0 THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_study_shares_checks', 
			'[20320] RIF40_STUDY_SHARES study % username: %: allowed duing build before first result is added to system',
			NEW.study_id::VARCHAR	/* Study id */,
			USER::VARCHAR 		/* User */);
	ELSIF NOT TG_OP = 'DELETE' AND NEW.grantor != USER AND NOT pg_has_role(USER, 'rif_manager', 'USAGE') /* Not granted RIF_MANAGER */ THEN
		PERFORM rif40_log_pkg.rif40_error(-20320, 'trigger_fct_rif40_study_shares_checks', 
			'RIF40_STUDY_SHARES study_id: % grantor username: % is not USER: % or a RIF40_MANAGER',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.grantor::VARCHAR		/* Grantor */,
			USER::VARCHAR			/* User */);
	ELSIF USER = 'rif40' OR NOT (pg_has_role(USER, 'rif_user', 'USAGE') AND pg_has_role(USER, 'rif_manager', 'USAGE')) THEN
		PERFORM rif40_log_pkg.rif40_error(-20321, 'trigger_fct_rif40_study_shares_checks', 
			'RIF40_STUDY_SHARES study_id: % username: % is not a RIF USER',
			OLD.study_id::VARCHAR		/* Study id */,
			USER::VARCHAR			/* User */);
/* Kerberos checks no longer possible 
		PERFORM rif40_log_pkg.rif40_error(-20321, 'rif40_study_shares_checks', 
			'RIF40_STUDY_SHARES study_id: % grantor username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR		-* Study id *-,
			NEW.grantor::VARCHAR		-* Grantor *-,
			USER::VARCHAR			-* User *-);  */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20322, 'trigger_fct_rif40_study_shares_checks', 
			'RIF40_STUDY_SHARES study_id: % UPDATE not allowed on RIF40_STUDY_SHARES',
			NEW.study_id		/* Study id */);
	ELSIF TG_OP = 'DELETE' AND OLD.grantor != USER AND NOT pg_has_role(USER, 'rif_manager', 'USAGE') /* Not granted RIF_MANAGER */ THEN
		PERFORM rif40_log_pkg.rif40_error(-20323, 'trigger_fct_rif40_study_shares_checks', 
			'RIF40_STUDY_SHARES study_id: % DELETE only allowed on own records or by RIF40_MANAGER in RIF40_STUDY_SHARES, record owned by: %',
			OLD.study_id::VARCHAR		/* Study id */,
			OLD.grantor::VARCHAR		/* INSERTER */);
	END IF;

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
     
--
-- Grantor is owner of the study OR has RIF_MANAGER role
--
	OPEN c1stsh(NEW.study_id);
	FETCH c1stsh INTO c1stsh_rec;
	IF c1stsh_rec.study_id IS NULL THEN
		CLOSE c1stsh;
		PERFORM rif40_log_pkg.rif40_error(-20324, 'trigger_fct_rif40_study_shares_checks', 
			'RIF40_STUDY_SHARES study_id: % not found',
			NEW.study_id::VARCHAR			/* Study id */);
	END IF;
	CLOSE c1stsh;
	IF pg_has_role(USER, 'rif_manager', 'USAGE') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_study_shares_checks', 
			'[20325] RIF40_STUDY_SHARES study_id: % not owned by grantor: %; owned by: %; but grantor is a RIF_MANAGER',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.grantor::VARCHAR		/* Grantor */,
			c1stsh_rec.username::VARCHAR	/* Study user */);
	ELSIF c1stsh_rec.username != NEW.grantor THEN
		PERFORM rif40_log_pkg.rif40_error(-20325, 'trigger_fct_rif40_study_shares_checks', 
			'RIF40_STUDY_SHARES study_id: % not owned by grantor: %; owned by: %',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.grantor::VARCHAR		/* Grantor */,
			c1stsh_rec.username::VARCHAR	/* Study user */);
	END IF;
--
-- Check - grantee username.
--
	OPEN c2stsh(NEW.grantee_username);
	FETCH c2stsh INTO c2stsh_rec;
	IF c2stsh_rec.rolname IS NULL THEN
		CLOSE c2stsh;
		PERFORM rif40_log_pkg.rif40_error(-20326, 'trigger_fct_rif40_study_shares_checks', 
			'RIF40_STUDY_SHARES study_id: % grantee username: % not a valid database user',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.grantee_username::VARCHAR	/* Grantee username */);
	END IF;
	CLOSE c2stsh;
--
-- Check grantee_username has RIF_USER or RIF_MANAGER role.
--
	IF pg_has_role(NEW.grantee_username, 'rif_user', 'USAGE') OR pg_has_role(NEW.grantee_username, 'rif_manager', 'USAGE') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_study_shares_checks', 
			'[20327] RIF40_STUDY_SHARES study_id: % grantee username: % is a RIF_USER/RIF_MANAGER',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.grantee_username::VARCHAR	/* Study user */);
	ELSE
		PERFORM rif40_log_pkg.rif40_error(-20327, 'trigger_fct_rif40_study_shares_checks', 
			'[20327] RIF40_STUDY_SHARES study_id: % grantee username: % is NOT a RIF_USER/RIF_MANAGER',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.grantee_username::VARCHAR	/* Study user */);
	END IF;
--
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_study_shares_checks', 
		'[20320-7] RIF40_STUDY_SHARES study: % CRUD checks OK',
		NEW.study_id::VARCHAR			/* Study id */);
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
]]></definition>
</function>

<function name="trigger_fct_rif40_table_outcomes_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check current_version_start_year (if not NULL) BETWEEN rif40_tables.year_start AND rif40_tables.year_stop
Check numer_tab is a numerator
 
-20440 to -20459 - RIF40_TABLE_OUTCOMES]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_rif40_table_outcomes_checks_description>
<para>
Check current_version_start_year (if not NULL) BETWEEN rif40_tables.year_start AND rif40_tables.year_stop
Check numer_tab is a numerator
</para>
</trigger_rif40_table_outcomes_checks_description>
 */
--
-- -20440 to -20459 - RIF40_TABLE_OUTCOMES
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
        c1rto CURSOR(l_table VARCHAR) FOR
		SELECT *
		  FROM rif40_tables
		 WHERE table_name = l_table;
	c1_rec RECORD;
BEGIN
--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
--
	OPEN c1rto(NEW.numer_tab);
	FETCH c1rto INTO c1_rec;
	IF c1_rec.table_name IS NULL THEN
		CLOSE c1rto;
		PERFORM rif40_log_pkg.rif40_error(-20440, 'trigger_fct_rif40_table_outcomes_checks', '[20440] RIF40_TABLE_OUTCOMES outcome group name % numerator (%) not found in RIF tables',
			NEW.outcome_group_name::VARCHAR	/* Outcome group */,
			NEW.numer_tab::VARCHAR 		/* Numerator table */);
	END IF;
	CLOSE c1rto;
--
-- Check current_version_start_year (if not NULL) BETWEEN rif40_tables.year_start AND rif40_tables.year_stop
--
	IF NOT NEW.current_version_start_year BETWEEN c1_rec.year_start AND c1_rec.year_stop THEN
		PERFORM rif40_log_pkg.rif40_error(-20441, 'trigger_fct_rif40_table_outcomes_checks', '[20441] RIF40_TABLE_OUTCOMES outcome group name % current_version_start_year (%) not NOT between % and %',
			NEW.outcome_group_name::VARCHAR		/* Outcome group */,
			NEW.current_version_start_year::VARCHAR	/* Current version start year */,
			c1_rec.year_start::VARCHAR		/* Year start */,
			c1_rec.year_stop::VARCHAR		/* Year stop */);
	END IF;

--
-- Check numer_tab is a numerator
--
	IF c1_rec.isnumerator != 1 THEN
		PERFORM rif40_log_pkg.rif40_error(-20442, 'trigger_fct_rif40_table_outcomes_checks', '[20442] RIF40_TABLE_OUTCOMES outcome group name % numerator (%) is not a numerator',
			NEW.outcome_group_name::VARCHAR	/* Outcome group */,
			NEW.numer_tab::VARCHAR 		/* Numerator table */);
	END IF;
--
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_table_outcomes_checks', '[20440-2] RIF40_TABLE_OUTCOMES outcome group name % numerator (%) OK',
		NEW.outcome_group_name::VARCHAR	/* Outcome group */,
		NEW.numer_tab::VARCHAR 		/* Numerator table */);
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
]]></definition>
</function>

<function name="trigger_fct_rif40_tables_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check TABLE_NAME exists. DO NOT RAISE AN ERROR IF IT DOES; otherwise check, column <TABLE_NAME>.TOTAL_FIELD,  column <TABLE_NAME>.ICD_FIELD_NAME exists. This allows the RIF40 schema owner to not have access to the tables. Access is checked in RIF40_NUM_DENOM. Automatic (Able to be used in automatic RIF40_NUM_DENOM (0/1, default 0). A user specific T_RIF40_NUM_DENOM is supplied for other combinations. Cannot be applied to direct standardisation denominator) is restricted to 1 denominator per geography.
Check table_name, total_field, sex_field_name, age_group_field_name, age_sex_group_field_name Oracle names.

Error range: -20180 to -20199 - RIF40_TABLES]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_rif40_tables_checks_description>
<para>
Check TABLE_NAME exists. DO NOT RAISE AN ERROR IF IT DOES; otherwise check, column <TABLE_NAME>.TOTAL_FIELD,  column <TABLE_NAME>.ICD_FIELD_NAME exists. This allows the RIF40 schema owner to not have access to the tables. Access is checked in RIF40_NUM_DENOM. Automatic (Able to be used in automatic RIF40_NUM_DENOM (0/1, default 0). A user specific T_RIF40_NUM_DENOM is supplied for other combinations. Cannot be applied to direct standardisation denominator) is restricted to 1 denominator per geography.
Check table_name, total_field, sex_field_name, age_group_field_name, age_sex_group_field_name Oracle names.
</para>
</trigger_rif40_tables_checks_description>
 */
--
-- Error range: -20180 to -20199 - RIF40_TABLES
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c1rt CURSOR (l_schema VARCHAR, l_table VARCHAR, l_column VARCHAR) FOR
		WITH all_tab_columns AS (
			SELECT UPPER(a.tablename) AS tablename, UPPER(b.attname) AS columnname, UPPER(schemaname) AS schemaname	/* Tables */
			  FROM pg_tables a, pg_attribute b, pg_class c
			 WHERE c.oid        = b.attrelid
			   AND c.relname    = a.tablename
			   AND c.relkind    = 'r' /* Relational table */
			   AND c.relpersistence IN ('p', 'u') /* Persistence: permanent/unlogged */ 
			 UNION
			SELECT UPPER(a.viewname) AS tablename, UPPER(b.attname) AS columnname, UPPER(schemaname) AS schemaname	/* Views */
			  FROM pg_views a, pg_attribute b, pg_class c
			 WHERE c.oid        = b.attrelid
			   AND c.relname    = a.viewname
			   AND c.relkind    = 'v' /* View */
			 UNION
			SELECT UPPER(a.relname) AS tablename, UPPER(d.attname) AS columnname, UPPER(n.nspname) AS schemaname				/* User FDW foreign tables */
			  FROM pg_foreign_table b, pg_roles r, pg_attribute d, pg_class a
				LEFT OUTER JOIN pg_namespace n ON (n.oid = a.relnamespace)			
			 WHERE b.ftrelid  = a.oid
			   AND a.relowner = (SELECT oid FROM pg_roles WHERE rolname = USER)
			   AND a.relowner = r.oid
			   AND n.nspname  = USER
			   AND a.oid      = d.attrelid
		)
		SELECT columnname
		  FROM all_tab_columns
		 WHERE schemaname = UPPER(l_schema)
		   AND tablename  = UPPER(l_table)
		   AND columnname = UPPER(l_column);
	c1_rec RECORD;
--
	schema		varchar(30);
--	msg 		varchar(4000)	:= NULL;
BEGIN
--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
     
	schema:=rif40_sql_pkg.rif40_object_resolve(NEW.table_name::VARCHAR);
--
-- Normally the schema owner will not be able to see the data tables, so there is no error here
-- You must have access to automatic indirect standardisation denominators
--
	IF (schema IS NOT NULL) THEN
		IF (NEW.total_field IS NOT NULL AND NEW.total_field::text <> '') THEN
			OPEN c1rt(schema, NEW.table_name, NEW.total_field);
			FETCH c1rt INTO c1_rec;
			CLOSE c1rt;
			IF coalesce(c1_rec.columnname::text, '') = '' THEN
				PERFORM rif40_log_pkg.rif40_error(-20180, 'trigger_fct_rif40_tables_checks', '[20180] Error: RIF40_TABLES TOTAL_FIELD % column not found in table: %',
					NEW.total_field::VARCHAR	/* Total field */,
					NEW.table_name::VARCHAR		/* Table name */);
			ELSE
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_tables_checks', '[20180] RIF40_TABLES TOTAL_FIELD % column found in table: %',
					NEW.total_field::VARCHAR	/* Total field */,
					NEW.table_name::VARCHAR		/* Table name */);
			END IF;
		END IF;
	END IF;
--
-- Check direct standardised denominators exist system wide
--
	IF NEW.isdirectdenominator = 1 THEN
		IF coalesce(NEW.table_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20181, 'trigger_fct_rif40_tables_checks', '[20181] RIF40_TABLES direct standardised denominator TABLE_NAME (%) not found',
				NEW.table_name::VARCHAR		/* Table name */);
		END IF;
	END IF;
--
-- Automatic
--
--	IF NEW.automatic = 1 AND NEW.isindirectdenominator = 1 THEN
--		IF coalesce(table_or_view::text, '') = '' THEN
--			PERFORM rif40_log_pkg.rif40_error(-20182, 'RIF40_TABLES TABLE_NAME ('||NEW.table_name||') not found');
--		END IF;
--
-- This causes:
-- ORA-04091: table RIF40.RIF40_TABLES is mutating, trigger/function may not see it
--
-- Enforced in RIF40_NUM_DENOM
--
--		msg:=PERFORM rif40_log_pkg.rif40_auto_indirect_checks(table_or_view);
--		IF (msg IS NOT NULL AND msg::text <> '') THEN
--			PERFORM rif40_log_pkg.rif40_error(-20183, 'RIF40_TABLES table: '||UPPER(table_or_view)||
--				' (automatic indirect denominator) has >1 per geography: '||msg);
--		END IF;
--
--	END IF;
--
-- Check table_name, total_field, sex_field_name, age_group_field_name, age_sex_group_field_name Oracle names
--
	PERFORM rif40_trg_pkg.rif40_db_name_check('TABLE_NAME', NEW.table_name);
	PERFORM rif40_trg_pkg.rif40_db_name_check('TOTAL_FIELD', NEW.total_field);
	IF (NEW.sex_field_name IS NOT NULL AND NEW.sex_field_name::text <> '') THEN
		PERFORM rif40_trg_pkg.rif40_db_name_check('SEX_FIELD_NAME', NEW.sex_field_name);
	END IF;
	IF (NEW.age_group_field_name IS NOT NULL AND NEW.age_group_field_name::text <> '') THEN
		PERFORM rif40_trg_pkg.rif40_db_name_check('AGE_GROUP_FIELD_NAME', NEW.age_group_field_name);
	END IF;
	IF (NEW.age_sex_group_field_name IS NOT NULL AND NEW.age_sex_group_field_name::text <> '') THEN
		PERFORM rif40_trg_pkg.rif40_db_name_check('AGE_SEX_GROUP_FIELD_NAME', NEW.age_sex_group_field_name);
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END; 
]]></definition>
</function>

<function name="trigger_fct_rif40_version_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check - single column, populate schema_amended. Prevent DELETE or INSERT
Error range: -20160 to -20179 - RIF40_VERSION]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_rif40_version_checks_description>
<para>
Check - single column, populate schema_amended. Prevent DELETE or INSERT
</para>
</trigger_rif40_version_checks_description>
 */
--
-- Error range: -20160 to -20179 - RIF40_VERSION
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c1vc CURSOR FOR
		SELECT COUNT(*) AS total
		  FROM rif40_version;
	c1_rec RECORD;
BEGIN
	IF TG_OP = 'INSERT' THEN
		OPEN c1vc;
		FETCH c1vc INTO c1_rec;
		CLOSE c1vc;
--
		IF c1_rec.total > 0 THEN
			PERFORM rif40_log_pkg.rif40_error(-20160, 'trigger_fct_rif40_version_checks', '[20160] Error: RIF40_VERSION INSERT disallowed, rows: %',
				c1_rec.total::VARCHAR /* rows */);
		END IF;
	ELSIF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20161, 'trigger_fct_rif40_version_checks', '[20161] Error: RIF40_VERSION DELETE disallowed');
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
--
		NEW.schema_amended := LOCALTIMESTAMP;
		RETURN NEW;
	END IF;
END;
]]></definition>
</function>

<function name="trigger_fct_t_rif40_comp_areas_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_t_rif40_comp_areas_checks_description>
<para>
Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
</para>
</trigger_t_rif40_comp_areas_checks_description>
 */
--
-- -20300 to -20319 - T_RIF40_COMPARISON_AREAS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
-- $Log: v4_0_postgres_triggers.sql,v $
-- Revision 1.6  2014/02/24 10:50:28  peterh
-- Full build from Oracle, including default study area and removal of year_start/stop min/max_age_group from T_RIF40_STUDIES
--
-- Still present in view
--
-- Revision 1.5  2013/09/25 12:12:22  peterh
-- Baseline after 2x full clean builds at Postgres level
-- TODO.txt uptodate
--
-- Revision 1.4  2013/09/18 15:20:32  peterh
-- Checkin at end of 6 week RIF focus. Got as far as SAHSULAND run study to completion for observed only
--
-- Revision 1.3  2013/09/02 14:08:33  peterh
--
-- Baseline after full trigger implmentation
--
-- Revision 1.2  2013/03/14 17:35:38  peterh
-- Baseline for TX to laptop
--
-- Revision 1.4  2013/02/14 10:48:39  peterh
-- Baseline aftyer clean build with screen mockup changes
--
-- Revision 1.12  2012/10/23 09:05:57  peterh
--
-- Baseline after full build of SAHSUland RIF schema including data
-- No triggers, Geo data and system error/logon triggers to be done
--
-- Revision 1.11  2012/09/14 15:44:53  peterh
-- Baseline after full review of check code and error messages
-- IG functionality added
--
-- Revision 1.10  2012/09/05 15:16:37  peterh
--
-- RIF update after initial build of postgres DB
--
-- Revision 1.9  2012/07/03 12:28:55  peterh
--
-- RIF schema as at 3/6/2012. All entities complete
--
-- Revision 1.8  2012/06/15 11:05:26  peterh
-- Check with working SQL generator (CREATE stmt only); bones of XML generator
-- Numerous lookup tables added.
-- Prepare for documentation
--
-- Revision 1.7  2012/05/22 15:29:41  peterh
--
-- Added RIF40_RESULTS, contextual_stats; more verification
--
-- Revision 1.6  2012/05/21 11:11:28  peterh
--
-- RIF investigattion, inv_covariates, comparison shares checks + SAHSU land example data
--
-- Revision 1.5  2012/04/26 15:49:48  peterh
-- Fixed view security problems
--
-- Revision 1.4  2012/04/13 15:05:02  peterh
--
-- Added RIF studies, investigations etc
--
-- Revision 1.3  2012/04/04 15:22:51  peterh
-- Easter baseline
--
-- Revision 1.2  2012/03/30 11:45:40  peterh
--
-- Baseline with working RIF40_NUM_DENOM
--
-- Revision 1.1  2012/03/28 15:39:19  peterh
--
-- Added check constraints and basic object table+column existance checks
--
-- Revision 1.2  2012/03/27 15:54:33  peterh
--
-- Added more V4 tables
--
-- Revision 1.1  2012/03/23 15:21:18  peterh
--
-- Moved from old RIF directory
--
-- Revision 1.2  2011/07/12 13:18:40  peterh
-- RIF baseline after Kerberosisation, re-doc and N_POP add
--
-- Revision 1.1  2011/05/27 10:31:21  peterh
--
-- Start of user level suppression support in RIF
--
	c4cack CURSOR IS
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c4_rec RECORD;
BEGIN
--
-- T_RIF40_COMPARISON_AREAS: Check - USERNAME is Kerberos USER on INSERT
--			Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records
--
	OPEN c4cack;
	FETCH c4cack INTO c4_rec;
	CLOSE c4cack;
	IF TG_OP = 'INSERT' AND NEW.username != USER THEN
		IF USER = 'rif40' AND c4_rec.total = 0 THEN 
			/* Allowed during build before first result is added to system or before Kerberos update */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20300, 'trigger_fct_t_rif40_comp_areas_checks', 
				'T_RIF40_COMPARISON_AREAS study: % area_id: % username: % is not USER: %',
				NEW.study_id::VARCHAR		/* Study id */,
				NEW.area_id::VARCHAR		/* Area */,
				NEW.username::VARCHAR		/* New username */,
				USER::VARCHAR			/* Username */);
		END IF;
	ELSIF TG_OP = 'UPDATE' AND NEW.username != USER THEN
		IF (USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0)) THEN 
			/* Allowed during build before first result is added to system or before Kerberos update */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20300, 'trigger_fct_t_rif40_comp_areas_checks', 
				'T_RIF40_COMPARISON_AREAS study: % area_id: % new username: % is not USER: %; old: %',
				NEW.study_id::VARCHAR		/* Study id */,
				NEW.area_id::VARCHAR		/* Area */,
				NEW.username::VARCHAR		/* New username */,
				USER::VARCHAR			/* Username */,
				OLD.username::VARCHAR		/* Old username */);
		END IF;
/*
	ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20301, 'trigger_fct_t_rif40_comp_areas_checks', 
			'T_RIF40_COMPARISON_AREAS study: % area_id: % username: % is not a Kerberos USER: %',
			NEW.username::VARCHAR		/- Record username -/,
			NEW.study_id::VARCHAR		/- Study id -/,
			NEW.area_id::VARCHAR		/- Area -/,
			USER::VARCHAR			/- Username -/); */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20302, 'trigger_fct_t_rif40_comp_areas_checks', 
			'T_RIF40_COMPARISON_AREAS study: % area_id: % UPDATE not allowed on T_RIF40_COMPARISON_AREAS',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.area_id::VARCHAR		/* Area */);
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20303, 'trigger_fct_t_rif40_comp_areas_checks', 
			'T_RIF40_COMPARISON_AREAS study: % area_id: % DELETE only allowed on own records in T_RIF40_COMPARISON_AREAS, record owned by: %',
			OLD.username::VARCHAR		/* INSERT Username */,
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.area_id::VARCHAR		/* Area */);
	END IF;
--
	IF TG_OP = 'DELETE' THEN
--		PERFORM rif40_log_pkg.rif40_log('DEBUG4','trigger_fct_t_rif40_comp_areas_checks', 
--     	 		'[20300-3] T_RIF40_COMPARISON_AREAS study: % area_id: % CRUD checks OK',
--     	 		OLD.study_id::VARCHAR		/* Study id */,
--			OLD.area_id::VARCHAR		/* Area */);  
		RETURN OLD;
	ELSE  	
--
--		PERFORM rif40_log_pkg.rif40_log('DEBUG4','trigger_fct_t_rif40_comp_areas_checks', 
--     	 		'[20300-3] T_RIF40_COMPARISON_AREAS study: % area_id: % CRUD checks OK',
--     	 		NEW.study_id::VARCHAR		/* Study id */,
--			NEW.area_id::VARCHAR		/* Area */);
--
		RETURN NEW;
	END IF;
END; 
]]></definition>
</function>

<function name="trigger_fct_t_rif40_comp_areas_checks2"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check - area_id; once per statement (for performance reasons)]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_t_rif40_comp_areas_checks2_description>
<para>
Check - area_id; once per statement (for performance reasons)
</para>
</trigger_t_rif40_comp_areas_checks2_description>
 */
--
-- -20300 to -20319 - T_RIF40_COMPARISON_AREAS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c1_cack2 CURSOR (l_study_id  integer) FOR
		SELECT a.study_id, a.study_geolevel_name, a.comparison_geolevel_name, b.hierarchytable
		  FROM t_rif40_studies a, rif40_geographies b
		 WHERE a.geography = b.geography
		   AND a.study_id  = l_study_id;
	c3_cack2 CURSOR FOR
		SELECT currval('rif40_study_id_seq'::regclass) AS study_id;
	c1_rec RECORD;
	c3_rec RECORD;
	c4_cack2 CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c4_rec RECORD;
--
	c2_cack2 REFCURSOR;
	sql_stmt	varchar(2000);
	total		integer;
BEGIN
--
-- Efffectively disable check during initial syustem load
--
	IF NOT TG_OP = 'DELETE' AND USER = 'rif40' THEN
		OPEN c4_cack2;
		FETCH c4_cack2 INTO c4_rec;
		CLOSE c4_cack2;
		IF c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0 THEN  
			/* Allowed during build before first result is added to system or before Kerberos update */
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_comp_areas_checks2',
				'[20300] T_RIF40_COMPARISON_AREAS username: % allowed during build before first result is added to system [CHECK DISABLED]',
				USER::VARCHAR		/* User */);
			RETURN NEW;
		END IF;
	END IF;

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
  
--
-- Check - area_id
--
	OPEN c3_cack2;
	FETCH c3_cack2 INTO c3_rec;
	IF NOT FOUND OR coalesce(c3_rec.study_id::text, '') = '' THEN
		CLOSE c3_cack2;
		PERFORM rif40_log_pkg.rif40_error(-20304, 'trigger_fct_t_rif40_comp_areas_checks2', 'T_RIF40_COMPARISON_AREAS no study_id found');
	END IF;
	CLOSE c3_cack2;
	OPEN c1_cack2(c3_rec.study_id);
	FETCH c1_cack2 INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1_cack2;
		PERFORM rif40_log_pkg.rif40_error(-20305, 'trigger_fct_t_rif40_comp_areas_checks2', 
			'T_RIF40_COMPARISON_AREAS no comparison found for study_id: %',
			c3_rec.study_id::VARCHAR	/* rif40_study_id_seq.CURRVAL study_id sequence */);
	END IF;
	CLOSE c1_cack2;
	sql_stmt:='SELECT COUNT(area_id) AS total FROM ('||E'\n'||
			'SELECT area_id FROM t_rif40_comparison_areas WHERE study_id = $1'||E'\n'||
			'EXCEPT '||E'\n'||
			'SELECT '||LOWER(c1_rec.comparison_geolevel_name)||' FROM '||c1_rec.hierarchytable||') a';
	BEGIN
		OPEN c2_cack2 FOR EXECUTE sql_stmt USING c3_rec.study_id;
		FETCH c2_cack2 INTO total;
		CLOSE c2_cack2;
	EXCEPTION
		WHEN others THEN
			PERFORM rif40_log_pkg.rif40_error(-20306, 'trigger_fct_t_rif40_comp_areas_checks2',
				'T_RIF40_COMPARISON_AREAS study_id: % % raised by: %',
				c3_rec.study_id::VARCHAR	/* rif40_study_id_seq.CURRVAL study_id sequence */,
				sqlerrm::VARCHAR		/* Error */,
				sql_stmt::VARCHAR		/* SQL */);

	END;
	IF total > 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20307, 'trigger_fct_t_rif40_comp_areas_checks2', 
			'T_RIF40_COMPARISON_AREAS study_id: %; found % areas not in: %.%',
			c3_rec.study_id::VARCHAR			/* rif40_study_id_seq.CURRVAL study_id sequence */,
			total::VARCHAR					/* Total */,
			c1_rec.hierarchytable::VARCHAR			/* Hierarchy table */,
			c1_rec.comparison_geolevel_name::VARCHAR	/* Comparison geolevel column name */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG2', 'trigger_fct_t_rif40_comp_areas_checks2', 
			'[20307] T_RIF40_COMPARISON_AREAS study_id: %; found % areas in: %.%'||E'\n'||'SQL> %;',
			c3_rec.study_id::VARCHAR			/* rif40_study_id_seq.CURRVAL study_id sequence */,
			total::VARCHAR					/* Total */,
			c1_rec.hierarchytable::VARCHAR			/* Hierarchy table */,
			c1_rec.comparison_geolevel_name::VARCHAR	/* Comparison geolevel column name */,
			sql_stmt::VARCHAR	 		       /* SQL */);
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
]]></definition>
</function>

<function name="trigger_fct_t_rif40_contextualstats_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_t_rif40_contextual_stats_checks_description>
<para>
Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
</para>
</trigger_t_rif40_contextual_stats_checks_description>
 */
--
-- -20360 to -20379 - T_RIF40_CONTEXTUAL_STATS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--

	c4_cstck CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;    
	c4_rec RECORD;
BEGIN
	OPEN c4_cstck;
	FETCH c4_cstck INTO c4_rec;
	CLOSE c4_cstck; 
--
-- T_RIF40_CONTEXTUAL_STATS: Check - USERNAME is Kerberos USER on INSERT
--			Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records
--
	IF NOT TG_OP = 'DELETE' AND NEW.username != USER THEN
		IF USER = 'rif40' AND c4_rec.total = 0 THEN /* Allowed duing build before first result is added to system */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20360, 'trigger_fct_t_rif40_contextualstats_checks',
			 	'T_RIF40_CONTEXTUAL_STATS study: % investigation: % area id: % username: % is not USER: %',
				NEW.study_id::VARCHAR	/* Study */,
				NEW.inv_id::VARCHAR	/* Investigation */,
				NEW.area_id::VARCHAR	/* Area */,
				NEW.username::VARCHAR	/* New user */,
				USER::VARCHAR		/* Database user */);
		END IF;
 /*       ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20361, 'trigger_fct_t_rif40_contextualstats_checks',
		 	'T_RIF40_CONTEXTUAL_STATS study: % investigation: % area id: % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR	-* Study *-,
			NEW.inv_id::VARCHAR	-* Investigation *-,
			NEW.area_id::VARCHAR	-* Area *-,
			NEW.username::VARCHAR	-* New user *-,
			USER::VARCHAR		-* Database user *-);    */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20362, 'trigger_fct_t_rif40_contextualstats_checks',
		 	'T_RIF40_CONTEXTUAL_STATS study: % investigation: % area id: UPDATE not allowed on T_RIF40_CONTEXTUAL_STATS',
			NEW.study_id::VARCHAR	/* Study */,
			NEW.inv_id::VARCHAR	/* Investigation */,
			NEW.area_id::VARCHAR	/* Area */);
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20363, 'trigger_fct_t_rif40_contextualstats_checks',
			'T_RIF40_CONTEXTUAL_STATS study: % investigation: % area id: DELETE only allowed on own records in T_RIF40_CONTEXTUAL_STATS, record owned by: %',
			OLD.study_id::VARCHAR	/* Study */,
			OLD.inv_id::VARCHAR	/* Investigation */,
			OLD.area_id::VARCHAR	/* Area */,
			OLD.username::VARCHAR	/* INSERT username */);
	END IF;
--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_contextualstats_checks',
	       	 	'[20360-3] T_RIF40_CONTEXTUAL_STATS study: % investigation: % Band ID: % area ID: % CRUD checks OK',
			OLD.study_id::VARCHAR	/* Study id */,
			OLD.inv_id::VARCHAR	/* Investigation */,
			OLD.band_id::VARCHAR	/* Band ID */,
			OLD.area_id::VARCHAR	/* Area ID */);   
		RETURN OLD;
	ELSE  	
--	PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_contextualstats_checks',
--		  '[20340-3] T_RIF40_CONTEXTUAL_STATS study: % investigation: % Band ID: % area ID: % CRUD checks OK',
--		NEW.study_id::VARCHAR	/* Study id */,
--		NEW.inv_id::VARCHAR	/* Investigation */,
--		NEW.band_id::VARCHAR	/* Band ID */,
-- 		NEW.area_id::VARCHAR	/* Area ID */);   

		RETURN NEW;
	END IF;
END; 
]]></definition>
</function>

<function name="trigger_fct_t_rif40_geolevels_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[
Check LOOKUP_TABLE, COVARIATE_TABLE exist.
Check YEAR, <GEOLEVEL_NAME>; exist in COVARIATE_TABLE
Check LOOKUP_TABLE.<T_RIF40_GEOLEVELS.GEOLEVEL_NAME>, LOOKUP_TABLE.LOOKUP_DESC_COLUMN,
LOOKUP_TABLE.<CENTROIDXCOORDINATE_COLUMN>, LOOKUP_TABLE.<CENTROIDYCOORDINATE_COLUMN> columns exist
Check <RIF40_GEOGRAPHIES.HIERARCHYTABLE>.<GEOLEVEL_NAME> column exists
Check <postal_population_table>.<GEOLEVEL_NAME> column exists if POSTAL_POPULATION_TABLE set if RIF40_GEOGAPHIES]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_t_rif40_geolevels_checks_description>
<para>
Check LOOKUP_TABLE, COVARIATE_TABLE exist.
Check YEAR, &lt;GEOLEVEL_NAME&gt; exist in COVARIATE_TABLE
Check LOOKUP_TABLE.&lt;T_RIF40_GEOLEVELS.GEOLEVEL_NAME&gt;, LOOKUP_TABLE.LOOKUP_DESC_COLUMN,
LOOKUP_TABLE.<CENTROIDXCOORDINATE_COLUMN>, LOOKUP_TABLE.<CENTROIDYCOORDINATE_COLUMN> columns exist
Check &lt;RIF40_GEOGRAPHIES.HIERARCHYTABLE&gt;.&lt;GEOLEVEL_NAME&gt; column exists
Check &lt;postal_population_table&gt;.&lt;GEOLEVEL_NAME&gt; column exists if POSTAL_POPULATION_TABLE set if RIF40_GEOGAPHIES

TO be added:

Check
</para>
</trigger_t_rif40_geolevels_checks_description>
 */
--
-- Error range: -20120 to -20134 - T_RIF40_GEOLEVELS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c1_geock CURSOR (l_schema  varchar, l_table  varchar, l_column  varchar) IS
		SELECT column_name
		  FROM information_schema.columns
		 WHERE table_schema = LOWER(l_schema)
		   AND table_name   = LOWER(l_table)
		   AND column_name  = LOWER(l_column);
	c2_geock CURSOR (l_geography  varchar) IS
		SELECT hierarchytable, postal_population_table
		  FROM rif40_geographies
		 WHERE geography = l_geography;
	c4_geock CURSOR IS
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c1_rec RECORD;
	c2_rec RECORD;
	c4_rec RECORD;
--
	owner		varchar(30);
	table_or_view	varchar(30);
BEGIN
--
	OPEN c4_geock;
	FETCH c4_geock INTO c4_rec;
	CLOSE c4_geock;
--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSIF TG_OP = 'INSERT' AND c4_rec.total = 0 THEN /* Allowed during build before first result is added to system */
		RETURN NEW;
	END IF;
--
-- Check COVARIATE_TABLE
--
	owner:=rif40_sql_pkg.rif40_object_resolve(NEW.covariate_table);
	table_or_view:=NEW.covariate_table;
	IF (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') AND coalesce(table_or_view::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20120, 'trigger_fct_t_rif40_geolevels_checks',
			'Error: T_RIF40_GEOLEVELS COVARIATE_TABLE (%) not found',
			NEW.covariate_table::VARCHAR 		/* covariate_table */);
	ELSIF (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') AND (table_or_view IS NOT NULL AND table_or_view::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			'[20120] T_RIF40_GEOLEVELS COVARIATE_TABLE (%) found',
			NEW.covariate_table::VARCHAR 		/* covariate_table */);
	END IF;
--
-- Check YEAR, <GEOLEVEL_NAME> exist in COVARIATE_TABLE
--
	OPEN c1_geock(owner, table_or_view, 'YEAR');
	FETCH c1_geock INTO c1_rec;
	CLOSE c1_geock;
	IF (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20121, 'trigger_fct_t_rif40_geolevels_checks',
			'Error: T_RIF40_GEOLEVELS COVARIATE_TABLE column (%.%) not found for geolevel_name: ',
			NEW.covariate_table::VARCHAR		/* Covariate table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20121] T_RIF40_GEOLEVELS COVARIATE_TABLE column (%.%) found for geolevel_name: ',
			NEW.covariate_table::VARCHAR     	/* Covariate table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	END IF;
	c1_rec.column_name:=NULL;
	OPEN c1_geock(owner, table_or_view, NEW.geolevel_name);
	FETCH c1_geock INTO c1_rec;
	CLOSE c1_geock;
	IF (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20122, 'trigger_fct_t_rif40_geolevels_checks',
			 'Error: T_RIF40_GEOLEVELS COVARIATE_TABLE column (%.%) not found for geolevel_name: %',
			NEW.covariate_table::VARCHAR   	 	/* Covariate table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20122] T_RIF40_GEOLEVELS COVARIATE_TABLE column (%.%) not found for geolevel_name: %',
			NEW.covariate_table::VARCHAR		/* Covariate table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	END IF;
--
-- Check LOOKUP_TABLE
--
	owner:=rif40_sql_pkg.rif40_object_resolve(NEW.lookup_table);
	table_or_view:=NEW.lookup_table;
	IF (NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') AND coalesce(table_or_view::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20123, 'trigger_fct_t_rif40_geolevels_checks',
			 'Error: T_RIF40_GEOLEVELS LOOKUP_TABLE (%) not found for geolevel_name: %',
			NEW.lookup_table::VARCHAR  	     	/* Lookup table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') AND (table_or_view IS NOT NULL AND table_or_view::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20123] T_RIF40_GEOLEVELS LOOKUP_TABLE (%) found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	END IF;
--
-- Check LOOKUP_TABLE.<T_RIF40_GEOLEVELS.GEOLEVEL_NAME>, LOOKUP_TABLE.LOOKUP_DESC_COLUMN exists
--
	c1_rec.column_name:=NULL;
	OPEN c1_geock(owner, table_or_view, NEW.geolevel_name);
	FETCH c1_geock INTO c1_rec;
	CLOSE c1_geock;
	IF (NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20124, 'trigger_fct_t_rif40_geolevels_checks',
			 'Error: T_RIF40_GEOLEVELS LOOKUP_TABLE column (%.%) not found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20124] T_RIF40_GEOLEVELS LOOKUP_TABLE column (%.%) found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	END IF;
	c1_rec.column_name:=NULL;
	OPEN c1_geock(owner, table_or_view, NEW.lookup_desc_column);
	FETCH c1_geock INTO c1_rec;
	CLOSE c1_geock;
	IF (NEW.lookup_desc_column IS NOT NULL AND NEW.lookup_desc_column::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20125, 'trigger_fct_t_rif40_geolevels_checks',
			 'Error: T_RIF40_GEOLEVELS LOOKUP_TABLE column (%.%) not found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.lookup_desc_column::VARCHAR		/* LOOKUP_TABLE column */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.lookup_desc_column IS NOT NULL AND NEW.lookup_desc_column::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20125] T_RIF40_GEOLEVELS LOOKUP_TABLE column (%.%) found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.lookup_desc_column::VARCHAR		/* LOOKUP_TABLE column */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	END IF;
--
-- Check LOOKUP_TABLE.<CENTROIDXCOORDINATE_COLUMN>, LOOKUP_TABLE.<CENTROIDYCOORDINATE_COLUMN> column exist
--
	c1_rec.column_name:=NULL;
	OPEN c1_geock(owner, table_or_view, NEW.centroidxcoordinate_column);
	FETCH c1_geock INTO c1_rec;
	CLOSE c1_geock;
	IF (NEW.centroidxcoordinate_column IS NOT NULL AND NEW.centroidxcoordinate_column::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20126, 'trigger_fct_t_rif40_geolevels_checks',
			 'Error: T_RIF40_GEOLEVELS CENTROIDXCOORDINATE_COLUMN column (%.%) not found for geolevel_name: %',
			NEW.lookup_table::VARCHAR    	   	/* Lookup table */,
			NEW.centroidxcoordinate_column::VARCHAR	/* CENTROIDXCOORDINATE_COLUMN column */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.centroidxcoordinate_column IS NOT NULL AND NEW.centroidxcoordinate_column::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20126] T_RIF40_GEOLEVELS CENTROIDXCOORDINATE_COLUMN column (%.%) found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.centroidxcoordinate_column		/* CENTROIDXCOORDINATE_COLUMN column */,
			NEW.geolevel_name			/* Geolevel name */);
	END IF;
	c1_rec.column_name:=NULL;
	OPEN c1_geock(owner, table_or_view, NEW.centroidycoordinate_column);
	FETCH c1_geock INTO c1_rec;
	CLOSE c1_geock;
	IF (NEW.centroidycoordinate_column IS NOT NULL AND NEW.centroidycoordinate_column::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20127, 'trigger_fct_t_rif40_geolevels_checks',
			 'Error: T_RIF40_GEOLEVELS CENTROIDYCOORDINATE_COLUMN column (%.%) not found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.centroidxcoordinate_column::VARCHAR	/* CENTROIDXCOORDINATE_COLUMN column */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.centroidycoordinate_column IS NOT NULL AND NEW.centroidycoordinate_column::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20127] T_RIF40_GEOLEVELS CENTROIDYCOORDINATE_COLUMN column (%.%) found for geolevel_name: %',
			NEW.lookup_table::VARCHAR	/* Lookup table */,
			NEW.centroidxcoordinate_column::VARCHAR	/* CENTROIDXCOORDINATE_COLUMN column */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	END IF;
--
-- Check <RIF40_GEOGRAPHIES.HIERARCHYTABLE>.<GEOLEVEL_NAME> column exists
--
	OPEN c2_geock(NEW.geography);
	FETCH c2_geock INTO c2_rec;
	CLOSE c2_geock;
	IF (c2_rec.hierarchytable IS NOT NULL AND c2_rec.hierarchytable::text <> '') THEN
		owner:=rif40_sql_pkg.rif40_object_resolve(c2_rec.hierarchytable);
		table_or_view:=c2_rec.hierarchytable;
		IF coalesce(owner::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20128, 'trigger_fct_t_rif40_geolevels_checks',
			 	'Error: RIF40_GEOGRAPHIES HIERARCHYTABLE (%) not found for geolevel_name: %',
				c2_rec.hierarchytable::VARCHAR		/* HIERARCHYTABLE */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 	'[20128] RIF40_GEOGRAPHIES HIERARCHYTABLE (%) found for geolevel_name: %',
				c2_rec.hierarchytable::VARCHAR		/* HIERARCHYTABLE */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		END IF;
		c1_rec.column_name:=NULL;
		OPEN c1_geock(owner, c2_rec.hierarchytable, NEW.geolevel_name);
		FETCH c1_geock INTO c1_rec;
		CLOSE c1_geock;
		IF (NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20129, 'trigger_fct_t_rif40_geolevels_checks',
			 	'Error: RIF40_GEOGRAPHIES HIERARCHYTABLE geolevel column (%.%) not found for geolevel_name: %',
				c2_rec.hierarchytable::VARCHAR		/* HIERARCHYTABLE */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		ELSIF (NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 	'[20129] RIF40_GEOGRAPHIES HIERARCHYTABLE geolevel column (%.%) found for geolevel_name: %',
				c2_rec.hierarchytable::VARCHAR		/* HIERARCHYTABLE */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		END IF;
	END IF;
--
-- Check &lt;postal_population_table&gt;.&lt;GEOLEVEL_NAME&gt; column exists if POSTAL_POPULATION_TABLE set if RIF40_GEOGAPHIES
--
	IF (c2_rec.postal_population_table IS NOT NULL AND c2_rec.postal_population_table::text <> '') AND
		(
		 ((NEW.centroidxcoordinate_column IS NOT NULL AND NEW.centroidxcoordinate_column::text <> '') AND (NEW.centroidycoordinate_column IS NOT NULL AND NEW.centroidycoordinate_column::text <> '')) OR
		 ((NEW.centroidsfile IS NOT NULL AND NEW.centroidsfile::text <> ''))) THEN
		owner:=rif40_sql_pkg.rif40_object_resolve(c2_rec.postal_population_table);
		table_or_view:=c2_rec.postal_population_table;
		IF coalesce(table_or_view::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20130, 'trigger_fct_t_rif40_geolevels_checks',
			 	'Error: RIF40_GEOGRAPHIES POSTAL_POPULATION_TABLE (%) not found when set',
		   	     	c2_rec.postal_population_table::VARCHAR 	/* hierarchy table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 	'[20130] RIF40_GEOGRAPHIES POSTAL_POINT_COLUMN (%) found',
				c2_rec.postal_population_table::VARCHAR		/* postal population table */);
		END IF;
		c1_rec.column_name:=NULL;
		OPEN c1_geock(owner, table_or_view, NEW.geolevel_name);
		FETCH c1_geock INTO c1_rec;
		CLOSE c1_geock;
		IF coalesce(c1_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20131, 'trigger_fct_t_rif40_geolevels_checks',
				'Error: RIF40_GEOGRAPHIES geolevel column (%.%) not found',
				c2_rec.postal_population_table::VARCHAR	/* postal population table */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 	'[20131] RIF40_GEOGRAPHIES geolevel column (%.%) found',
				c2_rec.postal_population_table::VARCHAR	/* postal population table */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		END IF;
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
]]></definition>
</function>

<function name="trigger_fct_t_rif40_inv_conditions_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check - USERNAME exists.
Check - USERNAME is Kerberos USER on INSERT.
Check - DELETE only allowed on own records.
Check - CONDITION for SQL injection]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_t_rif40_inv_conditions_checks_description>
<para>
Check - USERNAME exists.
Check - USERNAME is Kerberos USER on INSERT.
Check - DELETE only allowed on own records.
Check - CONDITION for SQL injection
</para>
</trigger_t_rif40_inv_conditions_checks_description>
 */
--
-- Error range: -20500 to -20509 - T_RIF40_INV_CONDITIONS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
-- $Log: v4_0_postgres_triggers.sql,v $
-- Revision 1.6  2014/02/24 10:50:28  peterh
-- Full build from Oracle, including default study area and removal of year_start/stop min/max_age_group from T_RIF40_STUDIES
--
-- Still present in view
--
-- Revision 1.5  2013/09/25 12:12:22  peterh
-- Baseline after 2x full clean builds at Postgres level
-- TODO.txt uptodate
--
-- Revision 1.4  2013/09/18 15:20:32  peterh
-- Checkin at end of 6 week RIF focus. Got as far as SAHSULAND run study to completion for observed only
--
-- Revision 1.3  2013/09/02 14:08:33  peterh
--
-- Baseline after full trigger implmentation
--
-- Revision 1.2  2013/03/14 17:35:38  peterh
-- Baseline for TX to laptop
--
-- Revision 1.4  2013/02/14 10:48:39  peterh
-- Baseline aftyer clean build with screen mockup changes
--
-- Revision 1.12  2012/10/23 09:05:57  peterh
--
-- Baseline after full build of SAHSUland RIF schema including data
-- No triggers, Geo data and system error/logon triggers to be done
--
-- Revision 1.11  2012/09/14 15:44:53  peterh
-- Baseline after full review of check code and error messages
-- IG functionality added
--
-- Revision 1.10  2012/09/05 15:16:37  peterh
--
-- RIF update after initial build of postgres DB
--
-- Revision 1.9  2012/07/03 12:28:55  peterh
--
-- RIF schema as at 3/6/2012. All entities complete
--
--
-- Check - CONDITION for SQL injection
--
	c4_icck CURSOR IS
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c4_rec RECORD;
BEGIN
--
	OPEN c4_icck;
	FETCH c4_icck INTO c4_rec;
	CLOSE c4_icck;
	IF TG_OP = 'INSERT' AND NEW.username != USER THEN
		IF USER = 'rif40' AND c4_rec.total = 0 THEN 
			/* Allowed during build before first result is added to system or before Kerberos update */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20500, 'trigger_fct_t_rif40_inv_conditions_checks',
				'T_RIF40_INV_CONDITIONS  study: % investigation: % line: % new username: % is not USER: %',
				NEW.study_id::VARCHAR	/* Study */,
				NEW.inv_id::VARCHAR	/* Investigation */,
				NEW.username::VARCHAR 	/* Record username */,
				NEW.line_number::VARCHAR /* Line */,
				USER::VARCHAR		/* Username */,
				NEW.username::VARCHAR	/* New username */);
		END IF;
	ELSIF TG_OP = 'UPDATE' AND NEW.username != USER THEN
		IF (USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0)) THEN 
			/* Allowed during build before first result is added to system or before Kerberos update */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20500, 'trigger_fct_t_rif40_inv_conditions_checks',
				'T_RIF40_INV_CONDITIONS  study: % investigation: % line: % new username: % is not USER: %; old: %',
				NEW.study_id::VARCHAR	/* Study */,
				NEW.inv_id::VARCHAR	/* Investigation */,
				NEW.username::VARCHAR 	/* Record username */,
				NEW.line_number::VARCHAR /* Line */,
				USER::VARCHAR		/* Username */,
				NEW.username::VARCHAR	/* New username */,
				OLD.username::VARCHAR	/* Old username */);
		END IF;
/*	ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20501, 't_rif40_inv_conditions_checks',
			'T_RIF40_INV_CONDITIONS study: % investigation: % line: % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR	/- Study -/,
			NEW.inv_id::VARCHAR	/- Investigation -/,
			NEW.line_number::VARCHAR /- Line -/,
			NEW.username::VARCHAR 	/- Record username -/,
			USER::VARCHAR		/- Logon username -/); */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20502, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_CONDITIONS study: % investigation: % line: % UPDATE not allowed on T_RIF40_INV_CONDITIONS',
			NEW.study_id::VARCHAR		/* Study */,
			NEW.inv_id::VARCHAR		/* Investigation */,
			NNEW.line_number::VARCHAR 	/* Line */);    
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20503, 'trigger_fct_t_rif40_inv_conditions_checks',
			'T_RIF40_INV_CONDITIONS study: % investigation: % line: % DELETE only allowed on own records in T_RIF40_INV_CONDITIONS, record owned by: %',
			NEW.study_id::VARCHAR	/* Study */,
			NEW.inv_id::VARCHAR	/* Investigation */,
			NEW.line_number::VARCHAR /* Line */,
			OLD.username::VARCHAR	/* Record username */);
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_inv_conditions_checks',
       	 		'[20500-3] T_RIF40_INV_CONDITIONS study: % investigation: % line: % CRUD checks OK',
 	      	 	OLD.study_id::VARCHAR		/* Study id */,
       	 		OLD.inv_id::VARCHAR		/* Investigation */,
			OLD.line_number::VARCHAR 	/* Line */);
		RETURN OLD;
	ELSE  	
--
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_inv_conditions_checks',
       	 		'[20500-3] T_RIF40_INV_CONDITIONS study: % investigation: % line: % CRUD checks OK',
 	      	 	NEW.study_id::VARCHAR		/* Study id */,
       	 		NEW.inv_id::VARCHAR		/* Investigation */,
			NEW.line_number::VARCHAR 	/* Line */);
--
 	       PERFORM rif40_trg_pkg.rif40_sql_injection_check(
   		     	'T_RIF40_INV_CONDITIONS'::VARCHAR,
			NEW.study_id::VARCHAR			/* Study id */,
			NEW.inv_id::VARCHAR			/* Investigation */,
  		      	NEW.line_number::VARCHAR 		/* Line */,
   		     	'CONDITION'::VARCHAR, 
   		     	NEW.condition::VARCHAR);  
    	    	RETURN NEW;
	END IF;
END; 
]]></definition>
</function>

<function name="trigger_fct_t_rif40_inv_covariates_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check - USERNAME exists.
Check - USERNAME is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
Check - study_geolevel_name.
Check - Covariates a) MIN and MAX.  b) Limits c) Check access to covariate table, <covariate name> column exists d) Check score.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_t_rif40_inv_covariates_checks_description>
<para>
Check - USERNAME exists.
Check - USERNAME is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
Check - study_geolevel_name.
Check - Covariates a) MIN and MAX.  b) Limits c) Check access to covariate table, <covariate name> column exists d) Check score.
</para>
</trigger_t_rif40_inv_covariates_checks_description>
 */
--
-- Error range: -20260 to -20279 - T_RIF40_INV_COVARIATES
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c1_ckicov CURSOR (l_geography  varchar, l_geolevel_name  varchar, l_covariate_name  varchar) FOR
		SELECT *
		  FROM rif40_covariates
		 WHERE geography      = l_geography
		   AND geolevel_name  = l_geolevel_name
		   AND covariate_name = l_covariate_name;
	c2_ckicov CURSOR(l_geography  varchar, l_geolevel_name  varchar) FOR
		SELECT *
		  FROM t_rif40_geolevels
		 WHERE l_geography     = geography
		   AND l_geolevel_name = geolevel_name;
	c3_ckicov CURSOR (l_schema  varchar, l_table  varchar, l_covariate_name  varchar) FOR
		SELECT column_name
		  FROM information_schema.columns
		 WHERE table_schema = LOWER(l_schema)
		   AND table_name   = LOWER(l_table)
		   AND column_name  = LOWER(l_covariate_name);
	c4_ckicov CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c6_ckicov CURSOR FOR
		SELECT a.study_geolevel_name, b.geolevel_id, a.study_id
		  FROM t_rif40_studies a, t_rif40_geolevels b
		 WHERE currval('rif40_study_id_seq'::regclass) = study_id
		   AND b.geolevel_name = a.study_geolevel_name;
	c6_rec RECORD;
	c4_rec RECORD;
	c1_rec RECORD;
	c2b_rec RECORD;
	c3_rec RECORD;
--
	owner		varchar(30);
--
	c5_ckicov 	REFCURSOR;
	sql_stmt	varchar(2000);
	total		integer;
BEGIN
--
-- T_RIF40_INV_COVARIATES:	Check - USERNAME is Kerberos USER on INSERT
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records

	OPEN c4_ckicov;
	FETCH c4_ckicov INTO c4_rec;
	CLOSE c4_ckicov;
	IF TG_OP = 'INSERT' AND NEW.username != USER THEN
		IF USER = 'rif40' AND c4_rec.total = 0 THEN 
			/* Allowed during build before first result is added to system or before Kerberos update */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20260, 'trigger_fct_t_rif40_inv_covariates_checks',
				'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % username: % is not USER: %',
				NEW.study_id::VARCHAR		/* Study */,
				NEW.inv_id::VARCHAR		/* Investigation */,
				NEW.covariate_name::VARCHAR	/* Covariate */,
				NEW.username::VARCHAR		/* New username */,
				USER::VARCHAR			/* Username */);
		END IF;
	ELSIF TG_OP = 'UPDATE' AND NEW.username != USER THEN
		IF (USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0)) THEN 
			/* Allowed during build before first result is added to system or before Kerberos update */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20260, 'trigger_fct_t_rif40_inv_covariates_checks',
				'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % new username: % is not USER: %; old: %',
				NEW.study_id::VARCHAR		/* Study */,
				NEW.inv_id::VARCHAR		/* Investigation */,
				NEW.covariate_name::VARCHAR	/* Covariate */,
				NEW.username::VARCHAR 		/* Record username */,
				USER::VARCHAR			/* Username */,
				OLD.username::VARCHAR		/* Old username */);
		END IF;
/*
	ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20261, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR		/- Study -/,
			NEW.inv_id::VARCHAR		/- Investigation -/,
			NEW.covariate_name::VARCHAR	/- Covariate -/,
			NEW.username::VARCHAR 		/- Record username -/,
			USER::VARCHAR			/- Logon username -/); */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20262, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % UPDATE not allowed on T_RIF40_INV_COVARIATES',
			NEW.study_id::VARCHAR		/* Study */,
			NEW.inv_id::VARCHAR		/* Investigation */,
			NEW.covariate_name::VARCHAR	/* Covariate */);
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20263, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % DELETE only allowed on own records in T_RIF40_INV_COVARIATES, record owned by: ',
			OLD.study_id::VARCHAR		/* Study */,
			OLD.inv_id::VARCHAR		/* Investigation */,
			OLD.covariate_name::VARCHAR	/* Covariate */,
			OLD.username::VARCHAR		/* INSERT username */);
	END IF;

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
--
 	       PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_inv_covariates_checks',
       			'[20600-3] T_RIF40_INV_COVARIATES study: % investigation: % covariate: % CRUD checks OK',
			OLD.study_id::VARCHAR			/* Study id */,
			OLD.inv_id::VARCHAR			/* Investigation */,
			OLD.covariate_name::VARCHAR		/* Covariate */);
		RETURN OLD;
	END IF;

--
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_inv_covariates_checks',
		'[20600-3] T_RIF40_INV_COVARIATES study: % investigation: % covariate: % CRUD checks OK',
		NEW.study_id::VARCHAR			/* Study id */,
		NEW.inv_id::VARCHAR			/* Investigation */,
		NEW.covariate_name::VARCHAR		/* Covariate */);
--
-- Check - STUDY_GEOLEVEL_NAME. Must be a valid GEOLEVEL_NAME for the study GEOGRPAHY in T_RIF40_GEOLEVELS [this is now an FK and not really needed]
--
-- This inmplies that the geolevel can be different to the study
--
	IF (NEW.study_geolevel_name IS NOT NULL AND NEW.study_geolevel_name::text <> '') THEN
		OPEN c2_ckicov(NEW.geography, NEW.study_geolevel_name);
		FETCH c2_ckicov INTO c2b_rec;
		IF NOT FOUND THEN
			CLOSE c2_ckicov;
			PERFORM rif40_log_pkg.rif40_error(-20264, 'trigger_fct_t_rif40_inv_covariates_checks',
				'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % study area geolevel name: % not found in RIF40_GEOLEVELS',
				NEW.study_id::VARCHAR		/* Study */,
				NEW.inv_id::VARCHAR		/* Investigation */,
				NEW.covariate_name::VARCHAR	/* Covariate */,
				NEW.study_geolevel_name::VARCHAR /* Study geolevel */);
		END IF;
/*
 * Wrong - all areas are assummed to be mappable
 *
		IF c2b_rec.resolution != 1 THEN
			CLOSE c2_ckicov;
			PERFORM rif40_log_pkg.rif40_Xerror(-202xx, 'trigger_fct_t_rif40_inv_covariates_checks',
				'T_RIF40_INV_COVARIATES study area geolevel name: '||NEW.study_geolevel_name||
				' in RIF40_GEOLEVELS is not a mappable area');
		END IF;
*/
		CLOSE c2_ckicov;
--
-- Check study geolevel name is the same (or lower than) than study geolevel name in t_rif40_studies
--
		IF  TG_OP = 'INSERT' AND c4_rec.total = 0 THEN
			/* Allowed during build before first result is added to system */
			NULL;
		ELSIF TG_OP = 'UPDATE' AND strpos(OLD.username, '@PRIVATE.NET') > 0 THEN 
			/* Allowed Kerberos username update */
			NULL;
		ELSE
			OPEN c6_ckicov;
			FETCH c6_ckicov INTO c6_rec;
			IF NOT FOUND THEN
				CLOSE c6_ckicov;
				PERFORM rif40_log_pkg.rif40_error(-20364, 'trigger_fct_t_rif40_inv_covariates_checks',
					'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % study area geolevel name: % not found in T_RIF40_STUDIES for study %',
					NEW.study_id::VARCHAR		/* Study */,
					NEW.inv_id::VARCHAR		/* Investigation */,
					NEW.covariate_name::VARCHAR	/* Covariate */,
					NEW.study_geolevel_name::VARCHAR /* Study geolevel */,
					currval('rif40_study_id_seq'::regclass)::VARCHAR	/* Covariate geolevel_id */);
			ELSIF c2b_rec.geolevel_id = c6_rec.geolevel_id THEN
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_inv_covariates_checks',
					'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % study area geolevel name: % (id %) same as geolevel in T_RIF40_STUDIES for study %',
					NEW.study_id::VARCHAR		/* Study */,
					NEW.inv_id::VARCHAR		/* Investigation */,
					NEW.covariate_name::VARCHAR	/* Covariate */,
					NEW.study_geolevel_name::VARCHAR /* Study geolevel */,
					c2b_rec.geolevel_id::VARCHAR	/* Covariate geolevel_id */,
					currval('rif40_study_id_seq'::regclass)::VARCHAR);
			ELSIF c2b_rec.geolevel_id = c6_rec.geolevel_id THEN
				PERFORM rif40_log_pkg.rif40_log('WARNING', 'trigger_fct_t_rif40_inv_covariates_checks',
					'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % study area geolevel name: % (id %) higher resolution than geolevel in T_RIF40_STUDIES for study % geolevel (id %) [NOT CURRENTLY SUPPORTED]',
					NEW.study_id::VARCHAR		/* Study */,
					NEW.inv_id::VARCHAR		/* Investigation */,
					NEW.covariate_name::VARCHAR	/* Covariate */,
					NEW.study_geolevel_name::VARCHAR /* Study geolevel */,
					c2b_rec.geolevel_id::VARCHAR	/* Covariate geolevel_id */,
					currval('rif40_study_id_seq'::regclass)::VARCHAR,
					c6_rec.study_geolevel_name::VARCHAR	/* Study geolevel_name  */,
					c6_rec.geolevel_id::VARCHAR	/* Study geolevel_id */);
			ELSE
				PERFORM rif40_log_pkg.rif40_error(-20365, 'trigger_fct_t_rif40_inv_covariates_checks',
					'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % study area geolevel name: % (id %) lower resolution than geolevel in T_RIF40_STUDIES for study % geolevel (id %) [NOT CURRENTLY SUPPORTED]',
					NEW.study_id::VARCHAR		/* Study */,
					NEW.inv_id::VARCHAR		/* Investigation */,
					NEW.covariate_name::VARCHAR	/* Covariate */,
					NEW.study_geolevel_name::VARCHAR /* Study geolevel */,
					c2b_rec.geolevel_id::VARCHAR	/* Covariate geolevel_id */,
					currval('rif40_study_id_seq'::regclass)::VARCHAR,
					c6_rec.study_geolevel_name::VARCHAR	/* Study geolevel_name  */,
					c6_rec.geolevel_id::VARCHAR	/* Study geolevel_id */);
			END IF;
			CLOSE c6_ckicov;
		END IF;
	END IF;
--
-- Check - Covariates
--
-- a) MIN and MAX.
--
	OPEN c1_ckicov(NEW.geography, NEW.study_geolevel_name, NEW.covariate_name);
	FETCH c1_ckicov INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1_ckicov;
		PERFORM rif40_log_pkg.rif40_error(-20265, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % no % covariate: % found for study area geolevel name: %',
			NEW.study_id::VARCHAR		/* Study */,
			NEW.inv_id::VARCHAR		/* Investigation */,
			NEW.covariate_name::VARCHAR	/* Covariate */,
			NEW.study_geolevel_name::VARCHAR /* Study geolevel */);
	END IF;
	CLOSE c1_ckicov;
--
-- b) Limits
--
	IF NEW.min < c1_rec.min THEN
		PERFORM rif40_log_pkg.rif40_error(-20266, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate: min (%) < RIF40_COVARIATES min (%) for study area geolevel name: ',
			NEW.study_id::VARCHAR		/* Study */,
			NEW.inv_id::VARCHAR		/* Investigation */,
			NEW.covariate_name::VARCHAR	/* Covariate */,
			NEW.min::VARCHAR		/* T_RIF40_INV_COVARIATES min */,
			c1_rec.min::VARCHAR		/* RIF40_COVARIATES min */,
			NEW.study_geolevel_name::VARCHAR /* Study geolevel */);
	ELSIF NEW.max > c1_rec.max THEN
		PERFORM rif40_log_pkg.rif40_error(-20267, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate: max (%) > RIF40_COVARIATES max (%) for study area geolevel name: ',
			NEW.study_id::VARCHAR		/* Study */,
			NEW.inv_id::VARCHAR		/* Investigation */,
			NEW.covariate_name::VARCHAR	/* Covariate */,
			NEW.max::VARCHAR		/* T_RIF40_INV_COVARIATES max */,
			c1_rec.max::VARCHAR		/* RIF40_COVARIATES max */,
			NEW.study_geolevel_name::VARCHAR /* Study geolevel */);
--
-- Remove when supported
--
	ELSIF c1_rec.type = 2 THEN
		PERFORM rif40_log_pkg.rif40_error(-20268, 'trigger_fct_t_rif40_inv_covariates_checks',
			'Error: T_RIF40_INV_COVARIATES study: % type = 2 (continuous variable) is not currently supported for geolevel_name: % covariate: %',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.study_geolevel_name::VARCHAR	/* Study geolevel */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);

	ELSIF c1_rec.type = 1 AND ROUND(NEW.max) != NEW.max THEN /* integer score */
		PERFORM rif40_log_pkg.rif40_error(-20269, 'trigger_fct_t_rif40_inv_covariates_checks',
			'Error: T_RIF40_INV_COVARIATES study: % type = 1 (integer score) and max is not an integer: % for geolevel_name: % covariate: %',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.max::VARCHAR			/* New max */,
			NEW.study_geolevel_name::VARCHAR	/* Study geolevel */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	ELSIF c1_rec.type = 1 AND ROUND(NEW.min) != NEW.min THEN /* integer score */
		PERFORM rif40_log_pkg.rif40_error(-20270, 'trigger_fct_t_rif40_inv_covariates_checks',
			'Error: T_RIF40_INV_COVARIATES study: % type = 1 (integer score) and min is not an integer: % for geolevel_name: % covariate: %',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.min::VARCHAR			/* New min */,
			NEW.study_geolevel_name::VARCHAR	/*Study geolevel */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	ELSIF c1_rec.type = 1 AND NEW.min < 0 THEN /* integer score */
		PERFORM rif40_log_pkg.rif40_error(-20271, 'trigger_fct_t_rif40_inv_covariates_checks',
			'Error: T_RIF40_INV_COVARIATES study: % type = 1 (integer score) and min <0: % for geolevel_name: % covariate: %',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.min::VARCHAR			/* New min */,
			NEW.study_geolevel_name::VARCHAR	/* Study geolevel */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	END IF;
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_inv_covariates_checks',
			'[20266-71] T_RIF40_INV_COVARIATES study: % investigation: % covariate: % max/in checks OK',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.covariate_name::VARCHAR		/* Covariate */);

--
-- c) Check access to covariate table, <covariate name> column exists
--
	owner:=rif40_sql_pkg.rif40_object_resolve(c2b_rec.covariate_table::VARCHAR);
	IF coalesce(owner::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20272, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate table: % cannot be accessed',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.covariate_name::VARCHAR		/* Covariate */,
			c2b_rec.covariate_table::VARCHAR	/* Covariate table */);
	END IF;
	OPEN c3_ckicov(owner, c2b_rec.covariate_table, NEW.covariate_name);
	FETCH c3_ckicov INTO c3_rec;
	IF NOT FOUND THEN
		CLOSE c3_ckicov;
		PERFORM rif40_log_pkg.rif40_error(-20273, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate table column: %.%.% cannot be accessed',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.covariate_name::VARCHAR		/* Covariate */,
			owner::VARCHAR				/* Owner */,
			c2b_rec.covariate_table::VARCHAR	/* Covariate table */,
			NEW.covariate_name::VARCHAR		/* Covariate column */);
	ELSE	
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_inv_covariates_checks',
			'[20272-3] T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate table column: %.%.% can be accessed',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.covariate_name::VARCHAR		/* Covariate */,
			owner::VARCHAR				/* Owner */,
			c2b_rec.covariate_table::VARCHAR	/* Covariate table */,
			NEW.covariate_name::VARCHAR		/* Covariate column */);
	END IF;
--
	CLOSE c3_ckicov;
	OPEN c3_ckicov(owner, c2b_rec.covariate_table, 'YEAR');
	FETCH c3_ckicov INTO c3_rec;
	IF NOT FOUND THEN
		CLOSE c3_ckicov;
		PERFORM rif40_log_pkg.rif40_error(-20274, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate table column: %.%.YEAR cannot be accessed',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.covariate_name::VARCHAR		/* Covariate */,
			owner::VARCHAR				/* Owner */,
			c2b_rec.covariate_table::VARCHAR	/* Covariate table */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_inv_covariates_checks',
			'[20274] T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate table column: %.%.YEAR can be accessed',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.covariate_name::VARCHAR		/* Covariate */,
			owner::VARCHAR				/* Owner */,
			c2b_rec.covariate_table::VARCHAR	/* Covariate table */);
	END IF;
	CLOSE c3_ckicov;
	OPEN c3_ckicov(owner, c2b_rec.covariate_table, NEW.study_geolevel_name);
	FETCH c3_ckicov INTO c3_rec;
	IF NOT FOUND THEN
		CLOSE c3_ckicov;
		PERFORM rif40_log_pkg.rif40_error(-20275, 'trigger_fct_t_rif40_inv_covariates_checks',
			'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate table column: %.%.% cannot be accessed',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.covariate_name::VARCHAR		/* Covariate */,
			owner::VARCHAR				/* Owner */,
			c2b_rec.covariate_table::VARCHAR	/* Covariate table */,
			NEW.study_geolevel_name::VARCHAR 	/* Study geolevel column */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_inv_covariates_checks',
			'[20275] T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate table column: %.%.% can be accessed',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.covariate_name::VARCHAR		/* Covariate */,
			owner::VARCHAR				/* Owner */,
			c2b_rec.covariate_table::VARCHAR	/* Covariate table */,
			NEW.study_geolevel_name::VARCHAR 	/* Study geolevel column */);
	END IF;
	CLOSE c3_ckicov;

--
-- d) Check score
--
	IF TG_OP = 'INSERT' AND NEW.username != USER AND c4_rec.total = 0 THEN 
		/* Allowed during build before first result is added to system or before Kerberos update */
		NULL;
	ELSIF TG_OP = 'UPDATE' AND NEW.username != USER AND strpos(OLD.username, '@PRIVATE.NET') > 0  THEN 
		/* Allowed during build before first result is added to system or before Kerberos update */
		NULL;
	ELSIF c1_rec.type = 1 /* integer score */ THEN 
		/* Not during build before first result is added to system or before Kerberos update */
		BEGIN
			sql_stmt:='SELECT COUNT(*) AS total FROM "'||owner||'".'||c2b_rec.covariate_table||' WHERE '||NEW.covariate_name||' = $1';
			OPEN c5_ckicov FOR EXECUTE sql_stmt USING NEW.min::INTEGER;
			FETCH c5_ckicov INTO total;
			CLOSE c5_ckicov;
		EXCEPTION
			WHEN others THEN
				PERFORM rif40_log_pkg.rif40_error(-20276, 'trigger_fct_t_rif40_inv_covariates_checks',
					'T_RIF40_INV_COVARIATES Caught % for study: % investigation: % covariate: % covariate table column: %.%.% min value: %; SQL %',
					sqlerrm::VARCHAR			/* Error message */,
					NEW.study_id::VARCHAR			/* Study */,
					NEW.inv_id::VARCHAR			/* Investigation */,
					NEW.covariate_name::VARCHAR		/* Covariate */,
					owner::VARCHAR				/* Owner */,
					c2b_rec.covariate_table::VARCHAR	/* Covariate table */,
					NEW.covariate_name::VARCHAR		/* Covariate column */,
					NEW.min::VARCHAR			/* Min value */,
					sql_stmt::VARCHAR			/* SQL Statement */);
		END;
--
		IF total = 0 THEN
			PERFORM rif40_log_pkg.rif40_error(-20277, 'trigger_fct_t_rif40_inv_covariates_checks',
				'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate table column: %.%.% min value: % not found',
				NEW.study_id::VARCHAR			/* Study */,
				NEW.inv_id::VARCHAR			/* Investigation */,
				NEW.covariate_name::VARCHAR		/* Covariate */,
				owner::VARCHAR				/* Owner */,
				c2b_rec.covariate_table::VARCHAR	/* Covariate table */,
				NEW.covariate_name::VARCHAR		/* Covariate column */,
				NEW.min::VARCHAR			/* Min value */);
		END IF;
		BEGIN
			OPEN c5_ckicov FOR EXECUTE sql_stmt USING NEW.max::INTEGER;
			FETCH c5_ckicov INTO total;
			CLOSE c5_ckicov;
		EXCEPTION
			WHEN others THEN
				PERFORM rif40_log_pkg.rif40_error(-20278, 'trigger_fct_t_rif40_inv_covariates_checks',
					'T_RIF40_INV_COVARIATES Caught % for study: % investigation: % covariate: % covariate table column: %.%.% max value: %; SQL %',
					sqlerrm::VARCHAR			/* Error message */,
					NEW.study_id::VARCHAR			/* Study */,
					NEW.inv_id::VARCHAR			/* Investigation */,
					NEW.covariate_name::VARCHAR		/* Covariate */,
					owner::VARCHAR				/* Owner */,
					c2b_rec.covariate_table::VARCHAR	/* Covariate table */,
					NEW.covariate_name::VARCHAR		/* Covariate column */,
					NEW.max::VARCHAR			/* Min value */,
					sql_stmt::VARCHAR			/* SQL Statement */);
		END;
		IF total = 0 THEN
			PERFORM rif40_log_pkg.rif40_error(-20279, 'trigger_fct_t_rif40_inv_covariates_checks',
				'T_RIF40_INV_COVARIATES study: % investigation: % covariate: % covariate table column: %.%.% max value: % not found',
				NEW.study_id::VARCHAR			/* Study */,
				NEW.inv_id::VARCHAR			/* Investigation */,
				NEW.covariate_name::VARCHAR		/* Covariate */,
				owner::VARCHAR				/* Owner */,
				c2b_rec.covariate_table::VARCHAR	/* Covariate table */,
				NEW.covariate_name::VARCHAR		/* Covariate column */,
				NEW.max::VARCHAR			/* Max value */);
		END IF;
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END; 
]]></definition>
</function>

<function name="trigger_fct_t_rif40_investigations_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check - USERNAME exists.
Check - USERNAME is Kerberos USER on INSERT.
Check - UPDATE only allowed on own records for INVESTIGATION_STATE.
Check - DELETE only allowed on own records.
Check - NUMER_TAB is a valid Oracle name and a numerator, and user has access.
Check - YEAR_START, YEAR_STOP, MAX_AGE_GROUP, MIN_AGE_GROUP.
Check - INV_NAME is a valid Oracle name of 20 characters only.
Check - AGE_GROUP_ID, AGE_SEX_GROUP/AGE_GROUP/SEX_FIELD_NAMES are the same between numerator, denonminator and direct standardisation tables

Delayed RIF40_TABLES numerator checks: Column <TABLE_NAME>.TOTAL_FIELD, SEX_FIELD_NAME, AGE_GROUP_FIELD_NAME, AGE_SEX_GROUP_FIELD_NAME exists]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_t_rif40_investigations_checks_description>
<para>
Check - USERNAME exists.
Check - USERNAME is Kerberos USER on INSERT.
Check - UPDATE only allowed on own records for INVESTIGATION_STATE.
Check - DELETE only allowed on own records.
Check - NUMER_TAB is a valid Oracle name and a numerator, and user has access.
Check - YEAR_START, YEAR_STOP, MAX_AGE_GROUP, MIN_AGE_GROUP.
Check - INV_NAME is a valid Oracle name of 20 characters only.
Check - AGE_GROUP_ID, AGE_SEX_GROUP/AGE_GROUP/SEX_FIELD_NAMES are the same between numerator, denonminator and direct standardisation tables
</para>
<para>Delayed RIF40_TABLES numerator checks: Column <TABLE_NAME>.TOTAL_FIELD, SEX_FIELD_NAME, AGE_GROUP_FIELD_NAME, AGE_SEX_GROUP_FIELD_NAME exists
</para>
</trigger_t_rif40_investigations_checks_description>
 */
--
-- Error range: -20700 to -20759 - T_RIF40_INVESTIGATIONS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c1_ick CURSOR(l_table_name  varchar) FOR
		SELECT a.year_start, a.year_stop, a.isindirectdenominator, a.isdirectdenominator, a.isnumerator,
		       a.age_sex_group_field_name, a.sex_field_name, a.age_group_field_name, a.total_field, a.age_group_id,
                       MIN(g.offset) min_age_group, MAX(g.offset) max_age_group
		  FROM rif40_tables a
			LEFT OUTER JOIN rif40_age_groups g ON (g.age_group_id  = a.age_group_id)
		 WHERE table_name = l_table_name
		 GROUP BY a.year_start, a.year_stop, a.isindirectdenominator, a.isdirectdenominator, a.isnumerator,
		          a.age_sex_group_field_name, a.sex_field_name, a.age_group_field_name, a.total_field, a.age_group_id;
	c1a_rec RECORD; /* Numerator */
	c1b_rec RECORD; /* Denominator */
	c1c_rec RECORD; /* Direct standardisation table */
	c2_ick CURSOR(l_study_id  integer) FOR
		SELECT *
		  FROM t_rif40_studies
		 WHERE study_id = l_study_id;
	c2_rec RECORD;
	c3_ick CURSOR (l_schema  varchar, l_table  varchar, l_column  varchar) FOR
		SELECT column_name
		  FROM information_schema.columns
		 WHERE table_schema = LOWER(l_schema)
		   AND table_name   = LOWER(l_table)
		   AND column_name  = LOWER(l_column);
	c3_rec RECORD;
--
	c4_ick CURSOR IS
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c4_rec RECORD;
--
	table_or_view	varchar(30);
	owner		varchar(30);
--
	investigation_state_only_flag 	boolean:=FALSE;
BEGIN
--
-- T_RIF40_INVESTIGATIONS: Check - USERNAME is Kerberos USER on INSERT
--			Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT
-- 			Check - UPDATE only allowed on own records for INVESTIGATION_STATE
--			Check - DELETE only allowed on own records
	IF TG_OP = 'UPDATE' AND  NEW.username = OLD.username AND
 	   NEW.inv_name = OLD.inv_name AND
 	   NEW.inv_description = OLD.inv_description AND
 	   NEW.year_start = OLD.year_start AND
 	   NEW.year_stop = OLD.year_stop AND
 	   NEW.max_age_group = OLD.max_age_group AND
 	   NEW.min_age_group = OLD.min_age_group AND
 	   NEW.genders = OLD.genders AND
 	   NEW.numer_tab = OLD.numer_tab AND
 	   NEW.geography = OLD.geography AND
 	   NEW.study_id = OLD.study_id AND
 	   NEW.inv_id = OLD.inv_id AND
 	   NEW.classifier = OLD.classifier AND
 	   NEW.classifier_bands = OLD.classifier_bands AND
 	   NEW.mh_test_type = OLD.mh_test_type  AND
 	   NEW.investigation_state != OLD.investigation_state THEN
		investigation_state_only_flag:=TRUE;
	END IF;
--
	OPEN c4_ick;
	FETCH c4_ick INTO c4_rec;
	CLOSE c4_ick;
	IF TG_OP = 'INSERT' AND NEW.username != USER THEN
		IF USER = 'rif40' AND c4_rec.total = 0 THEN 
			/* Allowed during build before first result is added to system or before Kerberos update */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20700, 'trigger_fct_t_rif40_investigations_checks',
				'T_RIF40_INVESTIGATIONS study: % investigation: % username: % is not USER: %',
				NEW.study_id::VARCHAR	/* Study */,
				NEW.inv_id::VARCHAR	/* Investigation */,
				NEW.username::VARCHAR	/* Record username */,
				USER::VARCHAR		/* Username */);
		END IF;
	ELSIF TG_OP = 'UPDATE' AND NEW.username != USER THEN
		IF (USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0)) THEN 
			/* Allowed during build before first result is added to system or before Kerberos update */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20700, 'trigger_fct_t_rif40_investigations_checks',
				'T_RIF40_INVESTIGATIONS study: % investigation: % new username: % is not USER: %; Old: %',
				NEW.study_id::VARCHAR	/* Study */,
				NEW.inv_id::VARCHAR	/* Investigation */,
				NEW.username::VARCHAR	/* Record username */,
				USER::VARCHAR		/* Username */,
				OLD.username::VARCHAR	/* Old username */);
		END IF;
/*	ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20701, 'trigger_fct_t_rif40_investigations_checks',
			'T_RIF40_INVESTIGATIONS study: % investigation: % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR	/- Study -/,
			NEW.inv_id::VARCHAR	/- Investigation -/,
			NEW.username::VARCHAR	/- Record username -/,
			USER::VARCHAR		/- User -/); */
	ELSIF TG_OP = 'UPDATE'  AND OLD.username != USER  THEN
		PERFORM rif40_log_pkg.rif40_error(-20702, 'trigger_fct_t_rif40_investigations_checks',
			'T_RIF40_INVESTIGATIONS study: % investigation: % UPDATE only allowed on own records, record owned by: %, user: %',
			NEW.study_id::VARCHAR	/* Study */,
			NEW.inv_id::VARCHAR	/* Investigation */,
			OLD.username::VARCHAR	/* creator username */,
			USER::VARCHAR		/* User */);
	ELSIF TG_OP = 'UPDATE'  AND OLD.username = USER AND investigation_state_only_flag = FALSE THEN
		PERFORM rif40_log_pkg.rif40_error(-20703, 'trigger_fct_t_rif40_investigations_checks',
			'T_RIF40_INVESTIGATIONS study: % investigation: % UPDATE only allowed for T_RIF40_INVESTIGATIONS.INVESTIGATION_STATE',
			NEW.study_id::VARCHAR	/* Study */,
			NEW.inv_id::VARCHAR	/* Investigation */);
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20704, 'trigger_fct_t_rif40_investigations_checks',
			'T_RIF40_INVESTIGATIONS study: % investigation: % DELETE only allowed on own records in T_RIF40_INVESTIGATIONS, record owned by: %, user: %',
			OLD.study_id::VARCHAR	/* Study */,
			OLD.inv_id::VARCHAR	/* Investigation */,
			OLD.username::VARCHAR	/* creator username */,
			USER::VARCHAR		/* User */);
	END IF;

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_investigations_checks',
   	     		'[20700-4] T_RIF40_INVESTIGATIONS study: % investigation: % CRUD checks OK',
			OLD.study_id::VARCHAR	/* Study id */,
			OLD.inv_id::VARCHAR	/* Investigation */);
		RETURN OLD;
	END IF;
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_investigations_checks',
		'[20700-4] T_RIF40_INVESTIGATIONS study: % investigation: % CRUD checks OK',
		NEW.study_id::VARCHAR	/* Study id */,
		NEW.inv_id::VARCHAR	/* Investigation */);
 
--
-- Check - NUMER_TAB is a valid Oracle name and a numerator, and user has access.
--
	PERFORM rif40_trg_pkg.rif40_db_name_check('NUMER_TAB', NEW.numer_tab);
--
	OPEN c1_ick(NEW.numer_tab);
	FETCH c1_ick INTO c1a_rec; /* RIF40_TABLES numerator settings */
	CLOSE c1_ick;
	OPEN c2_ick(NEW.study_id);
	FETCH c2_ick INTO c2_rec;
	CLOSE c2_ick;
	IF c1a_rec.isnumerator != 1 THEN
		PERFORM rif40_log_pkg.rif40_error(-20705, 'trigger_fct_t_rif40_investigations_checks',
			'T_RIF40_INVESTIGATIONS study: % investigation: % numerator: % is not a numerator table',
			NEW.study_id::VARCHAR	/* Study */,
			NEW.inv_id::VARCHAR	/* Investigation */,
			NEW.numer_tab::VARCHAR	/* Numerator */);
	END IF;
	owner:=rif40_sql_pkg.rif40_object_resolve(NEW.numer_tab::VARCHAR);
	table_or_view:=NEW.numer_tab::VARCHAR;
	IF coalesce(owner::text, '') = '' THEN
		IF USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN 
			/* Allowed duing build before first result is added to system or when converting Kerberos users */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20706, 'trigger_fct_t_rif40_investigations_checks',
				'T_RIF40_INVESTIGATIONS study: % investigation: % numerator: % cannot be accessed',
				NEW.study_id::VARCHAR	/* Study */,
				NEW.inv_id::VARCHAR	/* Investigation */,
				NEW.numer_tab::VARCHAR	/* Numerator */);
		END IF;
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_investigations_checks',
			'[20706] T_RIF40_INVESTIGATIONS study: % investigation: % numerator: % accessible',
			NEW.study_id::VARCHAR	/* Study id */,
			NEW.inv_id::VARCHAR	/* Investigation */,
			NEW.numer_tab::VARCHAR 	/* map_table */);
	END IF;

--
-- Check - YEAR_START, YEAR_STOP, MAX_AGE_GROUP, MIN_AGE_GROUP.
--
	IF (c1a_rec.year_start IS NOT NULL AND c1a_rec.year_start::text <> '') AND NEW.YEAR_START < c1a_rec.year_start  THEN
		PERFORM rif40_log_pkg.rif40_error(-20707, 'trigger_fct_t_rif40_investigations_checks',
			'T_RIF40_INVESTIGATIONS study: % investigation: % numerator: % year start: % is before RIF40_TABLES year start: %',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.numer_tab::VARCHAR			/* Numerator */,
			NEW.year_start::VARCHAR			/* Investigation year start */,
			c1a_rec.year_start::VARCHAR		/* RIF40_TABLES year start */);
	END IF;
	IF (c1a_rec.year_stop IS NOT NULL AND c1a_rec.year_stop::text <> '') AND NEW.YEAR_START > c1a_rec.year_stop  THEN
		PERFORM rif40_log_pkg.rif40_error(-20708, 'trigger_fct_t_rif40_investigations_checks',
			'T_RIF40_INVESTIGATIONS study: % investigation: % numerator: % year stop: % is after RIF40_TABLES year stop: %',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.numer_tab::VARCHAR			/* Numerator */,
			NEW.year_stop::VARCHAR			/* Investigation year stop */,
			c1a_rec.year_stop::VARCHAR		/* RIF40_TABLES year stop */);
	END IF;
/*
Year_stop/start, min/max_age_group removed from t_rif40_studies. Still in view

	IF (c2_rec.year_start IS NOT NULL AND c2_rec.year_start::text <> '') AND NEW.YEAR_START < c2_rec.year_start  THEN
		PERFORM rif40_log_pkg.rif40_error(-20709, 'trigger_fct_t_rif40_investigations_checks',
			'T_RIF40_INVESTIGATIONS study: % investigation: % numerator: % year start: % is before T_RIF40_STUDIES year start: %',
			NEW.study_id::VARCHAR			/- Study -/,
			NEW.inv_id::VARCHAR			/- Investigation -/,
			NEW.numer_tab::VARCHAR			/- Numerator -/,
			NEW.year_start::VARCHAR			/- Investigation year start -/,
			c2_rec.year_start::VARCHAR		/- T_RIF40_STUDIES year start -/);
	END IF;
	IF (c2_rec.year_stop IS NOT NULL AND c2_rec.year_stop::text <> '') AND NEW.YEAR_START > c2_rec.year_stop  THEN
		PERFORM rif40_log_pkg.rif40_error(-20710, 'trigger_fct_t_rif40_investigations_checks',
			'T_RIF40_INVESTIGATIONS study: % investigation: % numerator: % year stop: % is after T_RIF40_STUDIES year stop: %',
			NEW.study_id::VARCHAR			/- Study -/,
			NEW.inv_id::VARCHAR			/- Investigation -/,
			NEW.numer_tab::VARCHAR			/- Numerator -/,
			NEW.year_stop::VARCHAR			/- Investigation year stop -/,
			c2_rec.year_stop::VARCHAR		/- T_RIF40_STUDIES year stop -/);
	END IF;
 */
	IF (c1a_rec.min_age_group IS NOT NULL AND c1a_rec.min_age_group::text <> '') AND NEW.min_age_group < c1a_rec.min_age_group  THEN
		PERFORM rif40_log_pkg.rif40_error(-20711, 'trigger_fct_t_rif40_investigations_checks',
			'T_RIF40_INVESTIGATIONS study: % investigation: % numerator: % min age group: % is before RIF40_TABLES min age group: %',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.numer_tab::VARCHAR			/* Numerator */,
			NEW.min_age_group::VARCHAR		/* Investigation min age group */,
			c1a_rec.min_age_group::VARCHAR		/* RIF40_TABLES min age group */);
	END IF;
/*
Year_stop/start, min/max_age_group removed from t_rif40_studies. Still in view

	IF (c2_rec.max_age_group IS NOT NULL AND c2_rec.max_age_group::text <> '') AND NEW.max_age_group > c2_rec.max_age_group  THEN
		PERFORM rif40_log_pkg.rif40_error(-20712, 'trigger_fct_t_rif40_investigations_checks',
			'T_RIF40_INVESTIGATIONS study: % investigation: % numerator:% max age group: % is after RIF40_TABLES max age group: %',
			NEW.study_id::VARCHAR			/- Study -/,
			NEW.inv_id::VARCHAR			/- Investigation -/,
			NEW.numer_tab::VARCHAR			/- Numerator -/,
			NEW.max_age_group::VARCHAR		/- Investigation max age group -/,
			c1a_rec.max_age_group::VARCHAR		/- RIF40_TABLES max age group -/);
	END IF;
	IF (c2_rec.min_age_group IS NOT NULL AND c2_rec.min_age_group::text <> '') AND NEW.min_age_group < c2_rec.min_age_group  THEN
		PERFORM rif40_log_pkg.rif40_error(-20713, 'trigger_fct_t_rif40_investigations_checks',
			'T_RIF40_INVESTIGATIONS study: % investigation: % numerator: % min age group: % is before T_RIF40_STUDIES min age group: %',
			NEW.study_id::VARCHAR			/- Study -/,
			NEW.inv_id::VARCHAR			/- Investigation -/,
			NEW.numer_tab::VARCHAR			/- Numerator -/,
			NEW.min_age_group::VARCHAR		/- Investigation min age group -/,
			c2_rec.min_age_group::VARCHAR		/- T_RIF40_STUDIES min age group -/);
	END IF;
 */
	IF (c1a_rec.max_age_group IS NOT NULL AND c1a_rec.max_age_group::text <> '') AND NEW.max_age_group > c1a_rec.max_age_group  THEN
		PERFORM rif40_log_pkg.rif40_error(-20714, 'trigger_fct_t_rif40_investigations_checks',
			'T_RIF40_INVESTIGATIONS study: % investigation: % numerator:% max age group: % is after T_RIF40_STUDIES max age group: %',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.numer_tab::VARCHAR			/* Numerator */,
			NEW.max_age_group::VARCHAR		/* Investigation max age group */,
			c2_rec.max_age_group::VARCHAR		/* T_RIF40_STUDIES max age group */);
	END IF;

	IF coalesce(c1a_rec.max_age_group::text, '') = '' OR coalesce(c1a_rec.min_age_group::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20715, 'trigger_fct_t_rif40_investigations_checks',
			'T_RIF40_INVESTIGATIONS study: % investigation: % numerator: % no age group linkage',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.numer_tab::VARCHAR			/* Numerator */);
	END IF;


	IF NEW.min_age_group > NEW.max_age_group THEN
		PERFORM rif40_log_pkg.rif40_error(-20716, 'trigger_fct_t_rif40_investigations_checks',
			'T_RIF40_INVESTIGATIONS study: % investigation: % min age group: % is after max age group: %',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.min_age_group::VARCHAR		/* min age group*/,
			NEW.max_age_group::VARCHAR		/* max age group */);
	END IF;
	IF NEW.year_start > NEW.year_stop THEN
		PERFORM rif40_log_pkg.rif40_error(-20717, 'trigger_fct_t_rif40_investigations_checks',
			'T_RIF40_INVESTIGATIONS study: % investigation: % year stop: % is after year stop: %',
			NEW.study_id::VARCHAR			/* Study */,
			NEW.inv_id::VARCHAR			/* Investigation */,
			NEW.year_start::VARCHAR			/* Year start */,
			NEW.year_stop::VARCHAR			/* Year stop */);
	END IF;

	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_investigations_checks',
		'[20707-17] T_RIF40_INVESTIGATIONS study: % investigation: % year/age checks OK',
		NEW.study_id::VARCHAR	/* Study id */,
		NEW.inv_id::VARCHAR	/* Investigation */);

--
-- Check - INV_NAME is a valid Oracle name (of 20 chaacters only - is an old ORacle restriction).
--
	PERFORM rif40_trg_pkg.rif40_db_name_check('INV_NAME', NEW.inv_name);
--	IF LENGTH(NEW.inv_name) > 20 THEN
--	END IF;

--
-- Delayed RIF40_TABLES numerator checks:
-- Check - Column <TABLE_NAME>.TOTAL_FIELD, SEX_FIELD_NAME, AGE_GROUP_FIELD_NAME, AGE_SEX_GROUP_FIELD_NAME exists
--
	IF c4_rec.total > 0 AND owner IS NOT NULL AND table_or_view IS NOT NULL THEN /* Not first insert */
		IF (c1a_rec.total_field IS NOT NULL AND c1a_rec.total_field::text <> '') THEN
			OPEN c3_ick(owner, table_or_view, c1a_rec.total_field);
			FETCH c3_ick INTO c3_rec;
			IF NOT FOUND THEN
				CLOSE c3_ick;
				PERFORM rif40_log_pkg.rif40_error(-20718, 'trigger_fct_t_rif40_investigations_checks',
					'T_RIF40_INVESTIGATIONS study: % investigation: % numerator RIF40_TABLES total field column: %.%.% NOT found',
					NEW.study_id::VARCHAR			/* Study */,
					NEW.inv_id::VARCHAR			/* Investigation */,
					owner::VARCHAR				/* Numerator owner */,
					table_or_view::VARCHAR			/* Numerator */,
					c1a_rec.total_field::VARCHAR		/* Total field name */);
			ELSE
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_investigations_checks',
					'[20718] T_RIF40_INVESTIGATIONS study: % investigation: % numerator RIF40_TABLES total field column: %.%.% found',
					NEW.study_id::VARCHAR			/* Study */,
					NEW.inv_id::VARCHAR			/* Investigation */,
					owner::VARCHAR				/* Numerator owner */,
					table_or_view::VARCHAR			/* Numerator */,
					c1a_rec.total_field::VARCHAR		/* Total field name */);
			END IF;
			CLOSE c3_ick;
		END IF;
		IF (c1a_rec.sex_field_name IS NOT NULL AND c1a_rec.sex_field_name::text <> '') THEN
			OPEN c3_ick(owner, table_or_view, c1a_rec.sex_field_name);
			FETCH c3_ick INTO c3_rec;
			IF NOT FOUND THEN
				CLOSE c3_ick;
				PERFORM rif40_log_pkg.rif40_error(-20719, 'trigger_fct_t_rif40_investigations_checks',
					'T_RIF40_INVESTIGATIONS study: % investigation: % numerator RIF40_TABLES sex field column: %.%.% NOT found',
					NEW.study_id::VARCHAR			/* Study */,
					NEW.inv_id::VARCHAR			/* Investigation */,
					owner::VARCHAR				/* Numerator owner */,
					table_or_view::VARCHAR			/* Numerator */,
					c1a_rec.sex_field_name::VARCHAR		/* Sex field name */);
			ELSE
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', '[20719] T_RIF40_INVESTIGATIONS study: % investigation: % numerator RIF40_TABLES sex field column: %.%.% found',
					NEW.study_id::VARCHAR			/* Study */,
					NEW.inv_id::VARCHAR			/* Investigation */,
					owner::VARCHAR				/* Numerator owner */,
					table_or_view::VARCHAR			/* Numerator */,
					c1a_rec.sex_field_name::VARCHAR		/* Sex field name */);
			END IF;
			CLOSE c3_ick;
		END IF;
		IF (c1a_rec.age_group_field_name IS NOT NULL AND c1a_rec.age_group_field_name::text <> '') THEN
			OPEN c3_ick(owner, table_or_view, c1a_rec.age_group_field_name);
			FETCH c3_ick INTO c3_rec;
			IF NOT FOUND THEN
				CLOSE c3_ick;
				PERFORM rif40_log_pkg.rif40_error(-20720, 'trigger_fct_t_rif40_investigations_checks',
					'T_RIF40_INVESTIGATIONS study: % investigation: % numerator RIF40_TABLES age group field name column: %.%.% NOT found',
					NEW.study_id::VARCHAR			/* Study */,
					NEW.inv_id::VARCHAR			/* Investigation */,
					owner::VARCHAR				/* Numerator owner */,
					table_or_view::VARCHAR			/* Numerator */,
					c1a_rec.age_group_field_name::VARCHAR	/* Age group field name */);
			ELSE
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_investigations_checks',
					'[20720] T_RIF40_INVESTIGATIONS study: % investigation: % numerator RIF40_TABLES age group field name column: %.%.% found',
					NEW.study_id::VARCHAR			/* Study */,
					NEW.inv_id::VARCHAR			/* Investigation */,
					owner::VARCHAR				/* Numerator owner */,
					table_or_view::VARCHAR			/* Numerator */,
					c1a_rec.age_group_field_name::VARCHAR	/* Age group field name */);
			END IF;
			CLOSE c3_ick;
		END IF;
		IF (c1a_rec.age_sex_group_field_name IS NOT NULL AND c1a_rec.age_sex_group_field_name::text <> '') THEN
			OPEN c3_ick(owner, table_or_view, c1a_rec.age_sex_group_field_name);
			FETCH c3_ick INTO c3_rec;
			IF NOT FOUND THEN
				CLOSE c3_ick;
				PERFORM rif40_log_pkg.rif40_error(-20721, 'trigger_fct_t_rif40_investigations_checks',
					'T_RIF40_INVESTIGATIONS study: % investigation: % numerator RIF40_TABLES age sex group field column: %.%.% NOT found',
					NEW.study_id::VARCHAR				/* Study */,
					NEW.inv_id::VARCHAR				/* Investigation */,
					owner::VARCHAR					/* Numerator owner */,
					table_or_view::VARCHAR				/* Numerator */,
					c1a_rec.age_sex_group_field_name::VARCHAR	/* Age sex group field name */);
			ELSE
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_investigations_checks',
					'[20721] T_RIF40_INVESTIGATIONS study: % investigation: % numerator RIF40_TABLES age sex group field column: %.%.% found',
					NEW.study_id::VARCHAR				/* Study */,
					NEW.inv_id::VARCHAR				/* Investigation */,
					owner::VARCHAR					/* Numerator owner */,
					table_or_view::VARCHAR				/* Numerator */,
					c1a_rec.age_sex_group_field_name::VARCHAR	/* Age sex group field name */);
			END IF;
			CLOSE c3_ick;
		END IF;
	END IF;

--
-- Verify AGE_GROUP_ID, AGE_SEX_GROUP/AGE_GROUP/SEX_FIELD_NAMES are the same between numerator, denonminator and direct standardisation tables
--
	OPEN c1_ick(c2_rec.denom_tab);
	FETCH c1_ick INTO c1b_rec; /* RIF40_TABLES denominator settings */
	CLOSE c1_ick;
	IF (c2_rec.direct_stand_tab IS NOT NULL AND c2_rec.direct_stand_tab::text <> '') THEN
		OPEN c1_ick(c2_rec.direct_stand_tab);
		FETCH c1_ick INTO c1c_rec; /* RIF40_TABLES Direct standardisation table settings */
		CLOSE c1_ick;
		IF c1a_rec.age_group_id != c1b_rec.age_group_id OR c1a_rec.age_group_id != c1c_rec.age_group_id THEN
			PERFORM rif40_log_pkg.rif40_error(-20722, 'trigger_fct_t_rif40_investigations_checks',
				'T_RIF40_INVESTIGATIONS study: % investigation: % age_group ID mismatch; numerator %, denominator:: %, direct standardisation table: %',
				NEW.study_id::VARCHAR		/* Study */,
				NEW.inv_id::VARCHAR		/* Investigation */,
				c1a_rec.age_group_id::VARCHAR	/* Numerator age group ID */,
				c1a_rec.age_group_id::VARCHAR	/* Denominator age group ID */,
				c1b_rec.age_group_id::VARCHAR	/* Direct standardisation age group ID */);
		END IF;
		IF ((c1a_rec.age_sex_group_field_name IS NOT NULL AND c1a_rec.age_sex_group_field_name::text <> '') AND (c1b_rec.age_sex_group_field_name IS NOT NULL AND c1b_rec.age_sex_group_field_name::text <> '') AND
		    (c1c_rec.age_sex_group_field_name IS NOT NULL AND c1c_rec.age_sex_group_field_name::text <> '')) OR
                   (
		     ((c1a_rec.age_group_field_name IS NOT NULL AND c1a_rec.age_group_field_name::text <> '') AND (c1b_rec.age_group_field_name IS NOT NULL AND c1b_rec.age_group_field_name::text <> '') AND (c1c_rec.age_group_field_name IS NOT NULL AND c1c_rec.age_group_field_name::text <> '')) AND
		     ((c1a_rec.sex_field_name IS NOT NULL AND c1a_rec.sex_field_name::text <> '') AND (c1b_rec.sex_field_name IS NOT NULL AND c1b_rec.sex_field_name::text <> '') AND (c1c_rec.sex_field_name IS NOT NULL AND c1c_rec.sex_field_name::text <> ''))) THEN
			NULL;

		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20723, 'trigger_fct_t_rif40_investigations_checks',
				'T_RIF40_INVESTIGATIONS study: % investigation: % differing AGE_SEX_GROUP/AGE_GROUP/SEX_FIELD_NAMES used',
				NEW.study_id::VARCHAR		/* Study */,
				NEW.inv_id::VARCHAR		/* Investigation */);
		END IF;
	ELSE
		IF c1a_rec.age_group_id != c1b_rec.age_group_id  THEN
			PERFORM rif40_log_pkg.rif40_error(-20724, 'trigger_fct_t_rif40_investigations_checks',
				'T_RIF40_INVESTIGATIONS study: % investigation: % age_group ID mismatch; numerator %, denominator:: %',
				NEW.study_id::VARCHAR		/* Study */,
				NEW.inv_id::VARCHAR		/* Investigation */,
				c1a_rec.age_group_id::VARCHAR	/* Numerator age group ID */,
				c1a_rec.age_group_id::VARCHAR	/* Denominator age group ID */);
		END IF;
		IF ((c1a_rec.age_sex_group_field_name IS NOT NULL AND c1a_rec.age_sex_group_field_name::text <> '') AND (c1b_rec.age_sex_group_field_name IS NOT NULL AND c1b_rec.age_sex_group_field_name::text <> '')) OR
                   (
		     ((c1a_rec.age_group_field_name IS NOT NULL AND c1a_rec.age_group_field_name::text <> '') AND (c1b_rec.age_group_field_name IS NOT NULL AND c1b_rec.age_group_field_name::text <> '')) AND
		     ((c1a_rec.sex_field_name IS NOT NULL AND c1a_rec.sex_field_name::text <> '') AND (c1b_rec.sex_field_name IS NOT NULL AND c1b_rec.sex_field_name::text <> ''))) THEN
			NULL;

		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20725, 'trigger_fct_t_rif40_investigations_checks',
				'T_RIF40_INVESTIGATIONS study: % investigation: % differing AGE_SEX_GROUP/AGE_GROUP/SEX_FIELD_NAMES used',
				NEW.study_id::VARCHAR		/* Study */,
				NEW.inv_id::VARCHAR		/* Investigation */);
		END IF;
	END IF;
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_investigations_checks',
		'[20722-5] T_RIF40_INVESTIGATIONS study: % investigation: % age_group IDs match; %, same AGE_SEX_GROUP/AGE_GROUP/SEX_FIELD_NAMES used',
		NEW.study_id::VARCHAR		/* Study */,
		NEW.inv_id::VARCHAR		/* Investigation */,
		c1a_rec.age_group_id::VARCHAR	/* Numerator age group ID */);

--
-- Error message end: -20759, last message: -20725
--
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
]]></definition>
</function>

<function name="trigger_fct_t_rif40_num_denom_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check numerator_table really is a numerator and likewise for the denominator]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_t_rif40_num_denom_checks_description>
<para>
Check numerator_table really is a numerator and likewise for the denominator
</para>
</trigger_t_rif40_num_denom_checks_description>
 */
--
-- $Author: peterh $
-- $timestamp: 2012/04/26 15:49:46 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c1_rnd CURSOR (l_table varchar) FOR
		SELECT *
		  FROM rif40_tables
		 WHERE table_name = UPPER(l_table);
	c1_rec RECORD;
BEGIN

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
 
	OPEN c1_rnd(NEW.numerator_table);
	FETCH c1_rnd INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1_rnd;
		PERFORM rif40_log_pkg.rif40_error(-20291, 'trigger_fct_t_rif40_num_denom_checks',  
			'T_RIF40_NUM_DENOM numerator not found in RIF40_TABLES: %',
			NEW.numerator_table::VARCHAR /* numerator table */);
	ELSIF c1_rec.isnumerator != 1 THEN
		CLOSE c1_rnd;
		PERFORM rif40_log_pkg.rif40_error(-20292, 'trigger_fct_t_rif40_num_denom_checks',  
			'T_RIF40_NUM_DENOM numerator in RIF40_TABLES: % is not a numerator table,',
			NEW.numerator_table::VARCHAR /* numerator table */);
	END IF;
	CLOSE c1_rnd;
--
	OPEN c1_rnd(NEW.denominator_table);
	FETCH c1_rnd INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1_rnd;
		PERFORM rif40_log_pkg.rif40_error(-20293, 'trigger_fct_t_rif40_num_denom_checks',  
			EXCEPTION 'T_RIF40_NUM_DENOM denominator not found in RIF40_TABLES: %',
			NEW.denominator_table::VARCHAR /* denominator table */);
	ELSIF c1_rec.isnumerator = 1 THEN
		CLOSE c1_rnd;
		PERFORM rif40_log_pkg.rif40_error(-20294, 'trigger_fct_t_rif40_num_denom_checks',  
			'T_RIF40_NUM_DENOM denominator in RIF40_TABLES: % is not a denominator table,',
			NEW.denominator_table::VARCHAR /* denominator table */);
	END IF;
	CLOSE c1_rnd;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
]]></definition>
</function>

<function name="trigger_fct_t_rif40_results_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
Check - relative_risk, smoothed_relative_risk, posterior_probability, posterior_probability_lower95, posterior_probability_upper95,
  	smoothed_smr, smoothed_smr_lower95, smoothed_smr_upper95, residual_relative_risk, residual_rr_lower95, residual_rr_upper95
	are NULL for directly standardised results   ]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_t_rif40_results_checks_description>
<para>
Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
Check - relative_risk, smoothed_relative_risk, posterior_probability, posterior_probability_lower95, posterior_probability_upper95,
  	smoothed_smr, smoothed_smr_lower95, smoothed_smr_upper95, residual_relative_risk, residual_rr_lower95, residual_rr_upper95
	are NULL for directly standardised results
</para>
</trigger_t_rif40_results_checks_description>
 */
--
-- -20340 to -20359 - T_RIF40_RESULTS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c4_resck CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_contextual_stats /* Loaded after t_rif40_results */
		 LIMIT 1) a;    
	c4_rec RECORD;
BEGIN
	OPEN c4_resck;
	FETCH c4_resck INTO c4_rec;
	CLOSE c4_resck;

--
-- T_RIF40_RESULTS: Check - USERNAME is Kerberos USER on INSERT
--			Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records
--
	IF NOT TG_OP = 'DELETE' AND NEW.username != USER THEN
		IF USER = 'rif40' AND c4_rec.total = 0 THEN /* Allowed during build before first result is added to system */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20340, 'trigger_fct_t_rif40_results_checks',
		 		'T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % username: % is not USER: %',
				NEW.study_id::VARCHAR	/* Study id */,
				NEW.inv_id::VARCHAR	/* Investigation */,
				NEW.band_id::VARCHAR	/* Band ID */,
				NEW.genders::VARCHAR 	/* genders */,
				NEW.adjusted::VARCHAR	/* adjusted */,
				NEW.direct_standardisation::VARCHAR	/* Direct standardisation */,
				NEW.username::VARCHAR 	/* Record username */,
				USER::VARCHAR		/* User */);
		END IF;
/*	ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20341, 'trigger_fct_t_rif40_results_checks',
		 	'T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR	/- Study id -/,
			NEW.inv_id::VARCHAR	/- Investigation -/,
			NEW.band_id::VARCHAR	/- Band ID -/,
			NEW.genders::VARCHAR 	/- genders -/,
			NEW.adjusted::VARCHAR	/- adjusted -/,
			NEW.direct_standardisation::VARCHAR	/- Direct standardisation -/,
			NEW.username::VARCHAR 	/- Record username -/,
			USER::VARCHAR		/- User -/);           */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20342, 'trigger_fct_t_rif40_results_checks',
		 	'T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % UPDATE not allowed on T_RIF40_RESULTS',
			NEW.study_id::VARCHAR	/* Study id */,
			NEW.inv_id::VARCHAR	/* Investigation */,
			NEW.band_id::VARCHAR	/* Band ID */,
			NEW.genders::VARCHAR 	/* genders */,
			NEW.adjusted::VARCHAR	/* adjusted */,
			NEW.direct_standardisation::VARCHAR	/* Direct standardisation */);
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20343, 'trigger_fct_t_rif40_results_checks',
		 	'T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % DELETE only allowed on own records in T_RIF40_RESULTS, record owned by: %',
			OLD.study_id::VARCHAR	/* Study id */,
			OLD.inv_id::VARCHAR	/* Investigation */,
			OLD.username::VARCHAR	/* INSERT username */,
			OLD.band_id::VARCHAR	/* Band ID */,
			OLD.genders::VARCHAR 	/* genders */,
			OLD.adjusted::VARCHAR	/* adjusted */,
			OLD.direct_standardisation::VARCHAR	/* Direct standardisation */);
	END IF;
--

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
--       	PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_results_checks',
--	       	 	'[20340-3] T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % CRUD checks OK',
--       		OLD.study_id::VARCHAR	/* Study id */,
--			OLD.inv_id::VARCHAR	/* Investigation */,
--			OLD.band_id::VARCHAR	/* Band ID */,
--			OLD.genders::VARCHAR 	/* genders */,
--			OLD.adjusted::VARCHAR	/* adjusted */,
--			OLD.direct_standardisation::VARCHAR	/* Direct standardisation */);
--
		RETURN OLD;
	END IF;
--	PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_results_checks',
--		  '[20340-3] T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % CRUD checks OK',
--		NEW.study_id::VARCHAR	/* Study id */,
--		NEW.inv_id::VARCHAR	/* Investigation */,
--		NEW.band_id::VARCHAR	/* Band ID */,
--		NEW.genders::VARCHAR 	/* genders */,
--		NEW.adjusted::VARCHAR	/* adjusted */,
--		NEW.direct_standardisation::VARCHAR	/* Direct standardisation */);

             
--
-- Check - relative_risk, smoothed_relative_risk, posterior_probability, posterior_probability_lower95, posterior_probability_upper95
--   	   smoothed_smr, smoothed_smr_lower95, smoothed_smr_upper95, residual_relative_risk, residual_rr_lower95, residual_rr_upper95
--	   are NULL for directly standardised results
--
	IF NEW.direct_standardisation = 1 AND c4_rec.total > 0 /* Not during build before first result is added to system */ AND (
		(NEW.relative_risk IS NOT NULL AND NEW.relative_risk::text <> '') OR
		(NEW.smoothed_relative_risk IS NOT NULL AND NEW.smoothed_relative_risk::text <> '') OR
		(NEW.posterior_probability IS NOT NULL AND NEW.posterior_probability::text <> '') OR
		(NEW.posterior_probability_lower95 IS NOT NULL AND NEW.posterior_probability_lower95::text <> '') OR
		(NEW.posterior_probability_upper95 IS NOT NULL AND NEW.posterior_probability_upper95::text <> '') OR
		(NEW.smoothed_smr IS NOT NULL AND NEW.smoothed_smr::text <> '') OR
		(NEW.smoothed_smr_lower95 IS NOT NULL AND NEW.smoothed_smr_lower95::text <> '') OR
		(NEW.smoothed_smr_upper95 IS NOT NULL AND NEW.smoothed_smr_upper95::text <> '') OR
		(NEW.residual_relative_risk IS NOT NULL AND NEW.residual_relative_risk::text <> '') OR
		(NEW.residual_rr_lower95 IS NOT NULL AND NEW.residual_rr_lower95::text <> '') OR
		(NEW.residual_rr_upper95 IS NOT NULL AND NEW.residual_rr_upper95::text <> '')) THEN
		PERFORM rif40_log_pkg.rif40_error(-20344, 'trigger_fct_t_rif40_results_checks',
			'T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % Expecting NULL relative_risk with direct standardised results',
			NEW.study_id::VARCHAR	/* Study id */,
			NEW.inv_id::VARCHAR	/* Inverstigation */,
			NEW.band_id::VARCHAR	/* Band ID */,
			NEW.genders::VARCHAR	/* genders */,
			NEW.adjusted::VARCHAR	/* adjusted */,
			NEW.direct_standardisation::VARCHAR	/* Direct standardisation */);
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END; 
]]></definition>
</function>

<function name="trigger_fct_t_rif40_studies_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check - USERNAME exists.
Check - USERNAME is Kerberos USER on INSERT.
Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT.
Check - UPDATE not allowed except for IG admin and state changes.
Check - DELETE only allowed on own records.
Check - EXTRACT_TABLE Oracle name.
Check - Comparison area geolevel name. Must be a valid GEOLEVEL_NAME for the study GEOGRPAHY in T_RIF40_GEOLEVELS, with COMPAREA=1
Check - DENOM_TAB, DIRECT_STAND_TAB are valid Oracle names and appropriate denominators, and user has access.
Check - Study area resolution (GEOLEVEL_ID) >= comparision area resolution (GEOLEVEL_ID)  [i.e study area has the same or higher resolution]

Check - suppression_value - Suppress results with low cell counts below this value. If the role RIF_NO_SUPRESSION is granted and the user is not a RIF_STUDENT then SUPPRESSION_VALUE=0; otherwise is equals the parameter "SuppressionValue". If >0 all results with the value or below will be set to 0.
Check - extract_permitted - Is extract permitted from the database: 0/1. Only a RIF MANAGER may change this value. This user is still permitted to create and run a RIF study and to view the results. Geolevel access is rectricted by the RIF40_GEOLEVELS.RESTRICTED Inforamtion Governance restrictions (0/1). If 1 (Yes) then a) students cannot access this geolevel and b) if the system parameter ExtractControl=1 then the user must be granted permission by a RIF_MANAGER to extract from the database the results, data extract and maps tables. All students must be granted permission by a RIF_MANAGER for any extract if the system parameter ExtractControl=1. This is enforced by the RIF application.

Check - authorised_by - must be a RIF MANAGER.

Check - transfer_permitted - Is transfer permitted from the Secure or Private Network: 0/1. This is for purely documentatary purposes only. Only a RIF MANAGER may change this value. The value defaults to the same as EXTRACT_PERMITTED. Only geolevels where RIF40_GEOLEVELS.RESTRICTED=0 may be transferred

Check - authorised_notes -IG authorisation notes. Must be filled in if EXTRACT_PERMITTED=1

Delayed RIF40_TABLES denominator and direct standardisation checks:
Check - Column <TABLE_NAME>.TOTAL_FIELD, SEX_FIELD_NAME, AGE_GROUP_FIELD_NAME, AGE_SEX_GROUP_FIELD_NAME exists

IF USER = NEW.username (i.e. not initial RIF40 INSERT) THEN
	grant to all shared users if not already granted]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_t_rif40_studies_checks_description>
<para>
Check - USERNAME exists.
Check - USERNAME is Kerberos USER on INSERT.
Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT.
Check - UPDATE not allowed except for IG admin and state changes.
Check - DELETE only allowed on own records.
Check - EXTRACT_TABLE Oracle name.
Check - Comparison area geolevel name. Must be a valid GEOLEVEL_NAME for the study GEOGRPAHY in T_RIF40_GEOLEVELS, with COMPAREA=1
Check - DENOM_TAB, DIRECT_STAND_TAB are valid Oracle names and appropriate denominators, and user has access.
Check - Study area resolution (GEOLEVEL_ID) >= comparision area resolution (GEOLEVEL_ID)  [i.e study area has the same or higher resolution]

Check - suppression_value - Suppress results with low cell counts below this value. If the role RIF_NO_SUPRESSION is granted and the user is not a RIF_STUDENT then SUPPRESSION_VALUE=0; otherwise is equals the parameter "SuppressionValue". If >0 all results with the value or below will be set to 0.
Check - extract_permitted - Is extract permitted from the database: 0/1. Only a RIF MANAGER may change this value. This user is still permitted to create and run a RIF study and to view the results. Geolevel access is rectricted by the RIF40_GEOLEVELS.RESTRICTED Inforamtion Governance restrictions (0/1). If 1 (Yes) then a) students cannot access this geolevel and b) if the system parameter ExtractControl=1 then the user must be granted permission by a RIF_MANAGER to extract from the database the results, data extract and maps tables. All students must be granted permission by a RIF_MANAGER for any extract if the system parameter ExtractControl=1. This is enforced by the RIF application.

Check - authorised_by - must be a RIF MANAGER.

Check - transfer_permitted - Is transfer permitted from the Secure or Private Network: 0/1. This is for purely documentatary purposes only. Only a RIF MANAGER may change this value. The value defaults to the same as EXTRACT_PERMITTED. Only geolevels where RIF40_GEOLEVELS.RESTRICTED=0 may be transferred

Check - authorised_notes -IG authorisation notes. Must be filled in if EXTRACT_PERMITTED=1

Delayed RIF40_TABLES denominator and direct standardisation checks:
Check - Column <TABLE_NAME>.TOTAL_FIELD, SEX_FIELD_NAME, AGE_GROUP_FIELD_NAME, AGE_SEX_GROUP_FIELD_NAME exists

IF USER = NEW.username (i.e. not initial RIF40 INSERT) THEN
	grant to all shared users if not already granted
 </para>
</trigger_t_rif40_studies_checks_description>
 */
--
-- Error range: -20200 to -20259 - T_RIF40_STUDIES
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
-- $Log: v4_0_postgres_triggers.sql,v $
-- Revision 1.6  2014/02/24 10:50:28  peterh
-- Full build from Oracle, including default study area and removal of year_start/stop min/max_age_group from T_RIF40_STUDIES
--
-- Still present in view
--
-- Revision 1.5  2013/09/25 12:12:22  peterh
-- Baseline after 2x full clean builds at Postgres level
-- TODO.txt uptodate
--
-- Revision 1.4  2013/09/18 15:20:32  peterh
-- Checkin at end of 6 week RIF focus. Got as far as SAHSULAND run study to completion for observed only
--
-- Revision 1.3  2013/09/02 14:08:33  peterh
--
-- Baseline after full trigger implmentation
--
--
	c1_stck CURSOR(l_table_name VARCHAR) FOR
		SELECT a.year_start, a.year_stop, a.isindirectdenominator, a.isdirectdenominator, a.isnumerator,
		       a.age_sex_group_field_name, a.sex_field_name, a.age_group_field_name, a.total_field,
                       MIN(g.offset) AS min_age_group, MAX(g.offset) AS max_age_group
		  FROM rif40_tables a
			LEFT OUTER JOIN rif40_age_groups g ON (g.age_group_id  = a.age_group_id)
		 WHERE table_name = l_table_name
		 GROUP BY a.year_start, a.year_stop, a.isindirectdenominator, a.isdirectdenominator, a.isnumerator,
  		          a.age_sex_group_field_name, a.sex_field_name, a.age_group_field_name, a.total_field;
	c1b_rec RECORD; /* Denominator */
	c1c_rec RECORD; /* Direct standardisation table */
	c2_stck CURSOR(l_geography VARCHAR, l_geolevel_name VARCHAR) FOR
		SELECT *
		  FROM t_rif40_geolevels
		 WHERE l_geography     = geography
		   AND l_geolevel_name = geolevel_name;
	c2a_rec RECORD;
	c2b_rec RECORD;
	c3_stck CURSOR (l_study_id INTEGER) FOR
		SELECT comparison_geolevel_name
		  FROM t_rif40_studies
		 WHERE study_id = l_study_id;
	c3_rec RECORD;
	c4_stck CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c4_rec RECORD;
	c5_stck CURSOR(l_username VARCHAR /* Study owner/IG role */) FOR
		SELECT CASE WHEN rif40_sql_pkg.does_role_exist(l_username) AND
		      		pg_has_role(l_username, 'rif_manager', 'USAGE') THEN 1 /* Not RIF_MANAGER */ ELSE 0 END AS rif_manager,
     		       CASE WHEN rif40_sql_pkg.does_role_exist(l_username) AND
		      		rif40_sql_pkg.rif40_does_role_exist('rif_student') AND
				pg_has_role(l_username, 'rif_student', 'USAGE') THEN 1 /* Not RIF_STUDENT */ ELSE 0 END AS rif_student,
		       c.param_value AS suppressionvalue,
     		       p1.param_value::INTEGER AS extractcontrol
		  FROM (
			SELECT p2.param_name, 
			       CASE WHEN rif40_sql_pkg.does_role_exist(l_username) AND
		      		pg_has_role(l_username, 'rif_no_suppression', 'USAGE') THEN 1 /* Not Suppressed */ ELSE p2.param_value::INTEGER END param_value
			  FROM rif40.t_rif40_parameters p2
			 WHERE p2.param_name = 'SuppressionValue') c
			LEFT OUTER JOIN t_rif40_parameters p1 ON (p1.param_name = 'ExtractControl');
	c5_rec RECORD;
	c6_stck CURSOR (l_schema VARCHAR, l_table VARCHAR, l_column VARCHAR) IS
		SELECT column_name
		  FROM information_schema.columns
		 WHERE table_schema = LOWER(l_schema)
		   AND table_name   = LOWER(l_table)
		   AND column_name  = LOWER(l_column);
	c6_rec RECORD;
--
	schema			VARCHAR(30);
	denom_owner		VARCHAR(30);
	denom_table		VARCHAR(30);
	direct_stand_owner	VARCHAR(30);
	direct_stand_table	VARCHAR(30);
--
	study_state_only_flag 	BOOLEAN:=FALSE;
	ig_state_only_flag 	BOOLEAN:=FALSE;
BEGIN
--
-- T_RIF40_STUDIES:	Check - USERNAME is Kerberos USER on INSERT
--			Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT
-- 			Check - UPDATE not allowed except for IG admin and state changes
--			Check - DELETE only allowed on own records
--
	OPEN c4_stck;	/* Initial RIF40 insert */
	FETCH c4_stck INTO c4_rec;
	CLOSE c4_stck;
            
	IF NOT TG_OP = 'DELETE' THEN
		OPEN c5_stck(NEW.username); /* Study owner/IG role */
		FETCH c5_stck INTO c5_rec;
		CLOSE c5_stck;
        END IF;

--
-- Determine if the study state only has changed
--
	IF TG_OP = 'UPDATE' AND
	   coalesce(NEW.study_id::text, '') = coalesce(OLD.study_id::text, '') AND
	   coalesce(NEW.username::text, '') = coalesce(OLD.username::text, '') AND
	   coalesce(NEW.geography::text, '') = coalesce(OLD.geography::text, '') AND
	   coalesce(NEW.project::text, '') = coalesce(OLD.project::text, '') AND
	   coalesce(NEW.study_name::text, '') = coalesce(OLD.study_name::text, '') AND
	   coalesce(NEW.extract_table::text, '') = coalesce(OLD.extract_table::text, '') AND
	   coalesce(NEW.map_table::text, '') = coalesce(OLD.map_table::text, '') AND
	   coalesce(NEW.study_date::text, '') = coalesce(OLD.study_date::text, '') AND
	   coalesce(NEW.study_type::text, '') = coalesce(OLD.study_type::text, '') AND
	   coalesce(NEW.comparison_geolevel_name::text, '') = coalesce(OLD.comparison_geolevel_name::text, '') AND
	   coalesce(NEW.study_geolevel_name::text, '') = coalesce(OLD.study_geolevel_name::text, '') AND
	   coalesce(NEW.denom_tab::text, '') = coalesce(OLD.denom_tab::text, '') AND
	   coalesce(NEW.direct_stand_tab::text, '') = coalesce(OLD.direct_stand_tab::text, '') AND
/*
Year_stop/start, min/max_age_group removed from t_rif40_studies. Still in view

	   coalesce(NEW.year_start::text, '') = coalesce(OLD.year_start::text, '') AND
	   coalesce(NEW.year_stop::text, '') = coalesce(OLD.year_stop::text, '') AND
	   coalesce(NEW.max_age_group::text, '') = coalesce(OLD.max_age_group::text, '') AND
	   coalesce(NEW.min_age_group::text, '') = coalesce(OLD.min_age_group::text, '') AND
*/
	   coalesce(NEW.suppression_value::text, '') = coalesce(OLD.suppression_value::text, '') AND
	   coalesce(NEW.extract_permitted::text, '') = coalesce(OLD.extract_permitted::text, '') AND
	   coalesce(NEW.transfer_permitted::text, '') = coalesce(OLD.transfer_permitted::text, '') AND
	   coalesce(NEW.authorised_by::text, '') = coalesce(OLD.authorised_by::text, '') AND
	   coalesce(NEW.authorised_on::text, '') = coalesce(OLD.authorised_on::text, '') AND
	   coalesce(NEW.authorised_notes::text, '') = coalesce(OLD.authorised_notes::text, '') AND
	   coalesce(NEW.audsid::text, '') = coalesce(OLD.audsid::text, '') AND
/*
	   NEW.study_id = OLD.study_id AND
	   NEW.username = OLD.username AND
	   NEW.geography = OLD.geography AND
	   NEW.project = OLD.project AND
	   NEW.study_name = OLD.study_name AND
	   NEW.extract_table = OLD.extract_table AND
	   NEW.map_table = OLD.map_table AND
	   NEW.study_date = OLD.study_date AND
	   NEW.study_type = OLD.study_type AND
	   NEW.comparison_geolevel_name = OLD.comparison_geolevel_name AND
	   NEW.study_geolevel_name = OLD.study_geolevel_name AND
	   NEW.denom_tab = OLD.denom_tab AND
	   NEW.direct_stand_tab = OLD.direct_stand_tab AND
	   NEW.year_start = OLD.year_start AND
	   NEW.year_stop = OLD.year_stop AND
	   NEW.max_age_group = OLD.max_age_group AND
	   NEW.min_age_group = OLD.min_age_group AND
	   NEW.suppression_value = OLD.suppression_value AND
	   NEW.extract_permitted = OLD.extract_permitted AND
	   NEW.transfer_permitted = OLD.transfer_permitted AND
	   NEW.authorised_by = OLD.authorised_by AND
	   NEW.authorised_on = OLD.authorised_on AND
	   NEW.authorised_notes = OLD.authorised_notes AND
	   NEW.audsid = OLD.audsid AND       */
 	 	  NEW.study_state != OLD.study_state THEN
		study_state_only_flag:=TRUE;
	END IF;

--
-- Determine if the IG state only has changed
--
	IF TG_OP = 'UPDATE' AND
/*
	   NEW.study_id = OLD.study_id AND
	   NEW.username = OLD.username AND
	   NEW.geography = OLD.geography AND
	   NEW.project = OLD.project AND
	   NEW.study_name = OLD.study_name AND
	   NEW.extract_table = OLD.extract_table AND
	   NEW.map_table = OLD.map_table AND
	   NEW.study_date = OLD.study_date AND
	   NEW.study_type = OLD.study_type AND
	   NEW.study_state = OLD.study_state AND
	   NEW.comparison_geolevel_name = OLD.comparison_geolevel_name AND
	   NEW.study_geolevel_name = OLD.study_geolevel_name AND
	   NEW.denom_tab = OLD.denom_tab AND
	   NEW.direct_stand_tab = OLD.direct_stand_tab AND
	   NEW.year_start = OLD.year_start AND
	   NEW.year_stop = OLD.year_stop AND
	   NEW.max_age_group = OLD.max_age_group AND
	   NEW.min_age_group = OLD.min_age_group AND
	   NEW.suppression_value = OLD.suppression_value AND
	   NEW.audsid = OLD.audsid AND (
	 	   NEW.extract_permitted != OLD.extract_permitted OR
		   NEW.transfer_permitted != OLD.transfer_permitted OR
		   NEW.authorised_by != OLD.authorised_by OR
		   NEW.authorised_on != OLD.authorised_on OR
		   NEW.authorised_notes != OLD.authorised_notes) THEN  */

           coalesce(NEW.study_id::text, '') = coalesce(OLD.study_id::text, '') AND
	   coalesce(NEW.username::text, '') = coalesce(OLD.username::text, '') AND
	   coalesce(NEW.geography::text, '') = coalesce(OLD.geography::text, '') AND
	   coalesce(NEW.project::text, '') = coalesce(OLD.project::text, '') AND
	   coalesce(NEW.study_name::text, '') = coalesce(OLD.study_name::text, '') AND
	   coalesce(NEW.extract_table::text, '') = coalesce(OLD.extract_table::text, '') AND
	   coalesce(NEW.map_table::text, '') = coalesce(OLD.map_table::text, '') AND
	   coalesce(NEW.study_date::text, '') = coalesce(OLD.study_date::text, '') AND
	   coalesce(NEW.study_type::text, '') = coalesce(OLD.study_type::text, '') AND
	   coalesce(NEW.comparison_geolevel_name::text, '') = coalesce(OLD.comparison_geolevel_name::text, '') AND
	   coalesce(NEW.study_geolevel_name::text, '') = coalesce(OLD.study_geolevel_name::text, '') AND
	   coalesce(NEW.denom_tab::text, '') = coalesce(OLD.denom_tab::text, '') AND
	   coalesce(NEW.direct_stand_tab::text, '') = coalesce(OLD.direct_stand_tab::text, '') AND
/*
Year_stop/start, min/max_age_group removed from t_rif40_studies. Still in view

	   coalesce(NEW.year_start::text, '') = coalesce(OLD.year_start::text, '') AND
	   coalesce(NEW.year_stop::text, '') = coalesce(OLD.year_stop::text, '') AND
	   coalesce(NEW.max_age_group::text, '') = coalesce(OLD.max_age_group::text, '') AND
	   coalesce(NEW.min_age_group::text, '') = coalesce(OLD.min_age_group::text, '') AND
 */
	   coalesce(NEW.suppression_value::text, '') = coalesce(OLD.suppression_value::text, '') AND
	   coalesce(NEW.audsid::text, '') = coalesce(OLD.audsid::text, '') AND (      
	   	coalesce(NEW.extract_permitted::text, '') != coalesce(OLD.extract_permitted::text, '') OR
	   	coalesce(NEW.transfer_permitted::text, '') != coalesce(OLD.transfer_permitted::text, '') OR
	   	coalesce(NEW.authorised_by::text, '') != coalesce(OLD.authorised_by::text, '') OR
	   	coalesce(NEW.authorised_on::text, '') != coalesce(OLD.authorised_on::text, '') OR
	   	coalesce(NEW.authorised_notes::text, '') != coalesce(OLD.authorised_notes::text, '') ) THEN  

		ig_state_only_flag:=TRUE;
	END IF;
--
	IF TG_OP = 'INSERT' AND NEW.username != USER THEN
		IF USER = 'rif40' AND c4_rec.total = 0 THEN 
			/* Allowed duing build before first result is added to system or when converting Kerberos users */
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
				'[20200] T_RIF40_STUDIES study % username: % is not USER: %; allowed duing build before first result is added to system',
				NEW.study_id::VARCHAR	/* Study id */,
				NEW.username::VARCHAR	/* New username */,
				USER::VARCHAR		/* Username */);
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20200, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study % username: % is not USER: %',
				NEW.study_id::VARCHAR	/* Study id */,
				NEW.username::VARCHAR	/* New username */,
				USER::VARCHAR		/* Username */);
		END IF;
	ELSIF TG_OP = 'UPDATE' AND NEW.username != USER THEN
		IF USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN 
			/* Allowed duing build before first result is added to system or when converting Kerberos users */
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
				'[20200] T_RIF40_STUDIES study % new username: % is not USER: %; allowed duing build before first result is added to system; Old: %',
				NEW.study_id::VARCHAR	/* Study id */,
				NEW.username::VARCHAR	/* New username */,
				USER::VARCHAR		/* Username */,
				OLD.username::VARCHAR	/* Old username */);
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20200, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study % new username: % is not USER: %; Old: %',
				NEW.study_id::VARCHAR	/* Study id */,
				NEW.username::VARCHAR	/* New username */,
				USER::VARCHAR		/* Username */,
				OLD.username::VARCHAR	/* Old username */);
		END IF;
/* Kerberos checks no longer possible 
	ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20201, 'T_RIF40_STUDIES study % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR	-* Study id *-,
			NEW.username::VARCHAR 	-* Insert username *-,
			USER::VARCHAR -* User *-); */
	END IF;
	IF TG_OP = 'INSERT' THEN
		NEW.audsid:=SYS_CONTEXT('USERENV', 'SESSIONID');
	ELSIF TG_OP = 'UPDATE' THEN /* Allow */
		IF NEW.username = OLD.username THEN
--
-- Only allow state changes
--
			IF study_state_only_flag THEN
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
					'[20202] T_RIF40_STUDIES study % UPDATE state changes allowed on T_RIF40_STUDIES by user: %',
					NEW.study_id::VARCHAR	/* Study id */,
					USER::VARCHAR 		/* username */);
--
-- Verify state change
--
				NEW.study_state:=rif40_sm_pkg.rif40_verify_state_change(NEW.study_id, OLD.study_state, NEW.study_state);
			ELSE
				PERFORM rif40_log_pkg.rif40_error(-20202, 'trigger_fct_t_rif40_studies_checks', 
					'T_RIF40_STUDIES study % non state change UPDATE not allowed on T_RIF40_STUDIES by user: %',
					NEW.study_id::VARCHAR	/* Study id */,
					USER::VARCHAR 		/* username */);
			END IF;
		ELSE
			IF c5_rec.rif_manager = 1 THEN
--
-- Only allow IG changes
--
				IF USER = 'rif40' AND strpos(OLD.username, '@PRIVATE.NET') > 0 THEN
					NULL; 		/* RIF studies update OK from @PRIVATE.NET to postgres */
				ELSIF ig_state_only_flag THEN
					NEW.username :=OLD.username; /* Keep the original user name */
					PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
						'[20203] T_RIF40_STUDIES study % UPDATE IG changes allowed on T_RIF40_STUDIES by user: %',
						NEW.study_id::VARCHAR	/* Study id */,
						USER::VARCHAR 		/* username */);
				ELSE
					PERFORM rif40_log_pkg.rif40_error(-20203, 'trigger_fct_t_rif40_studies_checks', 
						'T_RIF40_STUDIES study % non IG UPDATE not allowed on T_RIF40_STUDIES by user: %',
						NEW.study_id::VARCHAR	/* Study id */,
						USER::VARCHAR 		/* username */);
				END IF;
			ELSIF USER = 'rif40' AND strpos(OLD.username, '@PRIVATE.NET') > 0 THEN
				NULL; 		/* RIF studies update OK from @PRIVATE.NET to postgres */
			ELSE
				PERFORM rif40_log_pkg.rif40_error(-20204, 'trigger_fct_t_rif40_studies_checks', 
					'T_RIF40_STUDIES study % UPDATE not allowed on T_RIF40_STUDIES by user: %',
					NEW.study_id::VARCHAR	/* Study id */,
					USER::VARCHAR 		/* username */);
			END IF;
		END IF;
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20205, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % DELETE only allowed on own records in T_RIF40_STUDIES, record created by: %',
			OLD.study_id::VARCHAR			/* Study id */,
			OLD.username::VARCHAR 			/* Insert (old) user name */);
	END IF;

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
			'[20200-5] T_RIF40_STUDIES study % CRUD checks OK',
			OLD.study_id::VARCHAR			/* Study id */);
		RETURN OLD;
	END IF;
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
	       	'[20200-5] T_RIF40_STUDIES study % CRUD checks OK',
       		NEW.study_id::VARCHAR			/* Study id */);
    
--
-- Check - Comparison area geolevel name(COMPARISON_GEOLEVEL_NAME). Must be a valid GEOLEVEL_NAME for the study GEOGRPAHY in T_RIF40_GEOLEVELS, with COMPAREA=1.
--
	IF (NEW.comparison_geolevel_name IS NOT NULL AND NEW.comparison_geolevel_name::text <> '') THEN
		OPEN c2_stck(NEW.geography, NEW.comparison_geolevel_name);
		FETCH c2_stck INTO c2a_rec;
		IF NOT FOUND THEN
			CLOSE c2_stck;
			PERFORM rif40_log_pkg.rif40_error(-20206, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study % comparison area geolevel name: "%" not found in RIF40_GEOLEVELS',
				NEW.study_id::VARCHAR			/* Study id */,
				NEW.comparison_geolevel_name::VARCHAR 	/* comparison area geolevel name */ );
		END IF;
		IF c2a_rec.comparea != 1 THEN
			CLOSE c2_stck;
			PERFORM rif40_log_pkg.rif40_error(-20207, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study % comparison area geolevel name: "%" in RIF40_GEOLEVELS is not a comparison area',
				NEW.study_id::VARCHAR			/* Study id */,
				NEW.comparison_geolevel_name 		/* comparison area geolevel name */ );
		END IF;
		CLOSE c2_stck;
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
			'[20206-7] T_RIF40_STUDIES study % comparison area geolevel name: "%" OK',
			NEW.study_id::VARCHAR				/* Study id */,
			NEW.comparison_geolevel_name::VARCHAR 		/* comparison area geolevel name */ );
	ELSE
		PERFORM rif40_log_pkg.rif40_error(-20208, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % NULL comparison area geolevel name',
			NEW.study_id::VARCHAR				/* Study id */);
	END IF;
--
-- Check - STUDY_GEOLEVEL_NAME. Must be a valid GEOLEVEL_NAME for the study GEOGRPAHY in T_RIF40_GEOLEVELS
--
	IF (NEW.study_geolevel_name IS NOT NULL AND NEW.study_geolevel_name::text <> '') THEN
		OPEN c2_stck(NEW.geography, NEW.study_geolevel_name);
		FETCH c2_stck INTO c2b_rec;
		IF NOT FOUND THEN
			CLOSE c2_stck;
			PERFORM rif40_log_pkg.rif40_error(-20209, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study % study area geolevel name: "%" not found in RIF40_GEOLEVELS',
				NEW.study_id::VARCHAR			/* Study id */,
				NEW.study_geolevel_name::VARCHAR 	/* Study area geolevel name */);
		END IF;
/*
 * Wrong - all areas are assummed to be mappable
 *
		IF c2b_rec.resolution != 1 THEN
			CLOSE c2;
			PERFORM rif40_log_pkg.rif40x_error(-202xx, 'T_RIF40_STUDIES study area geolevel name: '||NEW.study_geolevel_name||
				' in RIF40_GEOLEVELS is not a mappable area');
		END IF;
 */
		CLOSE c2_stck;
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
			'[20209] T_RIF40_STUDIES study % study area geolevel name: "%" OK',
			NEW.study_id::VARCHAR				/* Study id */,
			NEW.study_geolevel_name::VARCHAR 		/* Study area geolevel name */);
	ELSE
		PERFORM rif40_log_pkg.rif40_error(-20210, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % NULL study area geolevel name',
			NEW.study_id::VARCHAR				/* Study id */);
	END IF;

--
-- Check - DENOM_TAB, DIRECT_STAND_TAB are valid Oracle names and appropriate denominators, and user has access.
--
	PERFORM rif40_trg_pkg.rif40_db_name_check('DENOM_TAB', NEW.denom_tab);
	IF (NEW.direct_stand_tab IS NOT NULL AND NEW.direct_stand_tab::text <> '') THEN
		PERFORM rif40_trg_pkg.rif40_db_name_check('DIRECT_STAND_TAB', NEW.direct_stand_tab);
	END IF;
--
	OPEN c1_stck(NEW.denom_tab);
	FETCH c1_stck INTO c1b_rec;
	IF NOT FOUND THEN
		CLOSE c1_stck;
		PERFORM rif40_log_pkg.rif40_error(-20211, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % denominator: % not found in RIF40_TABLES',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.denom_tab::VARCHAR 		/* Denominator */);
	END IF;
	denom_owner:=rif40_sql_pkg.rif40_object_resolve(NEW.denom_tab::VARCHAR);
	IF USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN 
		/* Allowed duing build before first result is added to system or when converting Kerberos users */
		NULL;
	ELSIF coalesce(denom_owner::text, '') = '' THEN
		CLOSE c1_stck;
		PERFORM rif40_log_pkg.rif40_error(-20212, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % denominator: % cannot be accessed',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.denom_tab::VARCHAR 		/* Denominator */);
	ELSE
		denom_table:=NEW.denom_tab::VARCHAR;
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
			'[20212] T_RIF40_STUDIES study % denominator accessible as: %.%',
			NEW.study_id::VARCHAR		/* Study id */,
			denom_owner::VARCHAR		/* Denominator owner */,
			denom_table::VARCHAR 		/* Denominator table */);
	END IF;
	CLOSE c1_stck;
--
	IF (NEW.direct_stand_tab IS NOT NULL AND NEW.direct_stand_tab::text <> '') THEN
		OPEN c1_stck(NEW.direct_stand_tab);
		FETCH c1_stck INTO c1c_rec;
		IF NOT FOUND THEN
			CLOSE c1_stck;
			PERFORM rif40_log_pkg.rif40_error(-20213, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study % direct standardisation: % not found in RIF40_TABLES',
				NEW.study_id::VARCHAR		/* Study id */,
				NEW.direct_stand_tab::VARCHAR	/* direct standardisation table */);
		END IF;
		direct_stand_owner:=rif40_sql_pkg.rif40_object_resolve(NEW.direct_stand_tab::VARCHAR);
		IF coalesce(direct_stand_owner::text, '') = '' THEN
			CLOSE c1_stck;
			PERFORM rif40_log_pkg.rif40_error(-20214, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study % direct standardisation table: % cannot be accessed',
				NEW.study_id::VARCHAR		/* Study id */,
				NEW.direct_stand_tab::VARCHAR	/* direct standardisation table */);
		ELSE
			direct_stand_table:=NEW.direct_stand_tab::VARCHAR;
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
				'[20214] T_RIF40_STUDIES study % direct standardisation table accessible as: %.%',
				NEW.study_id::VARCHAR		/* Study id */,
				direct_stand_owner::VARCHAR	/* direct standardisation owner */,
				direct_stand_table::VARCHAR	/* direct standardisation table */);
		END IF;
		CLOSE c1_stck;
	END IF;
--
-- Check -  direct denominator
--
	IF NEW.direct_stand_tab IS NOT NULL AND NEW.direct_stand_tab::text <> '' THEN
		IF c1c_rec.isdirectdenominator != 1 THEN
			PERFORM rif40_log_pkg.rif40_error(-20215, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study % direct standardisation table: % is not a direct denominator table',
				NEW.study_id::VARCHAR			/* Study id */,
				NEW.direct_stand_tab::VARCHAR		/* direct standardisation table */);
		ELSIF c1c_rec.isdirectdenominator = 1 THEN
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
				'[20215] T_RIF40_STUDIES study % direct standardisation table: % is a direct denominator table',
				NEW.study_id::VARCHAR			/* Study id */,
				NEW.direct_stand_tab::VARCHAR		/* direct standardisation table */);
		END IF;
	END IF;
/*
ONLY NEEDED IF RIF40_STUDIES_DENOMINATORS is created

	OPEN c3(NEW.study_id);
	FETCH c3 INTO c3_rec;
	IF NOT FOUND THEN
		CLOSE c3;
		PERFORM rif40_log_pkg.rif40x_error(-202xx, 'RIF40_STUDIES_DENOMINATORS no study found for study_id: '||TO_CHAR(NEW.study_id));
	END IF;
	CLOSE c3;
 */

--
-- This has been removed as analysis of the RIF30 data shows that the data is present. COMPARISON_GEOLEVEL_NAME has been made NOT NULL
-- TODO: verify this from math
--
--	IF (coalesce(NEW.comparison_geolevel_name::text, '') = ''     AND coalesce(NEW.direct_stand_tab::text, '') = '') OR
--	   ((NEW.comparison_geolevel_name IS NOT NULL AND NEW.comparison_geolevel_name::text <> '') AND (NEW.direct_stand_tab IS NOT NULL AND NEW.direct_stand_tab::text <> '')) THEN
--		PERFORM rif40_log_pkg.rif40x_error(-202xx, 'T_RIF40_STUDIES study % one and only one of COMPARISON_GEOLEVEL_NAME and DIRECT_STAND_TAB must be set',
--			NEW.study_id			/* Study id */);
--	END IF;

/*
Year_stop/start, min/max_age_group removed from t_rif40_studies. Still in view

	IF (c1b_rec.year_stop IS NOT NULL AND c1b_rec.year_stop::text <> '') AND NEW.year_start > c1b_rec.year_stop  THEN
		PERFORM rif40_log_pkg.rif40_error(-20216, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % denominator: % year stop: % is after RIF40_TABLES year stop: %',
			NEW.study_id::VARCHAR			/- Study id -/,
			NEW.denom_tab::VARCHAR 			/- Denominator -/,
			NEW.year_stop::VARCHAR			/- Denominator year stop -/,
			c1b_rec.year_stop::VARCHAR		/- RIF TABLES year stop -/);
	END IF;
	IF (c1b_rec.min_age_group IS NOT NULL AND c1b_rec.min_age_group::text <> '') AND NEW.min_age_group < c1b_rec.min_age_group  THEN
		PERFORM rif40_log_pkg.rif40_error(-20217, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % denominator: % min age group: % is before RIF40_TABLES min age group: %',
			NEW.study_id::VARCHAR			/- Study id -/,
			NEW.denom_tab::VARCHAR 			/- Denominator -/,
			NEW.min_age_group::VARCHAR		/- Denominator min age group -/,
			c1b_rec.min_age_group::VARCHAR		/- RIF TABLES min age group -/);
	END IF;
	IF (c1b_rec.max_age_group IS NOT NULL AND c1b_rec.max_age_group::text <> '') AND NEW.max_age_group > c1b_rec.max_age_group  THEN
		PERFORM rif40_log_pkg.rif40_error(-20218, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % denominator: % max age group: % is after RIF40_TABLES max age group: %',
			NEW.study_id::VARCHAR			/- Study id -/,
			NEW.denom_tab::VARCHAR 			/- Denominator -/,
			NEW.max_age_group::VARCHAR		/- Denominator max age group -/,
			c1b_rec.max_age_group::VARCHAR		/- RIF TABLES max age group -/);
	END IF;
	IF (c1b_rec.year_start IS NOT NULL AND c1b_rec.year_start::text <> '') AND NEW.year_start < c1b_rec.year_start  THEN
		PERFORM rif40_log_pkg.rif40_error(-20219, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % denominator: % year start: % is before RIF40_TABLES year start: %',
			NEW.study_id::VARCHAR			/- Study id -/,
			NEW.denom_tab::VARCHAR 			/- Denominator -/,
			NEW.year_start::VARCHAR			/- Denominator year start -/,
			c1b_rec.year_start::VARCHAR		/- RIF TABLES year start -/);
	END IF;
 */
	IF c1b_rec.isindirectdenominator != 1 THEN
		PERFORM rif40_log_pkg.rif40_error(-20220, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % denominator: % is not a denominator table',
			NEW.study_id::VARCHAR			/* Study id */,
			NEW.denom_tab::VARCHAR 			/* Denominator */);
	END IF;
	IF coalesce(c1b_rec.max_age_group::text, '') = '' OR coalesce(c1b_rec.min_age_group::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20221, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % denominator: % no age group linkage',
			NEW.study_id::VARCHAR			/* Study id */,
			NEW.denom_tab::VARCHAR			/* Denominator */);
	END IF;
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
		'[20216-21] T_RIF40_STUDIES study % year/age bands checks OK against RIF40_TABLES',
		NEW.study_id::VARCHAR				/* Study id */);

--
-- Check - Study area resolution (GEOLEVEL_ID) >= comparision area resolution (GEOLEVEL_ID)
--
	IF c2b_rec.geolevel_id /* study */ >= c2a_rec.geolevel_id /* comparision */ THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 
			'trigger_fct_t_rif40_studies_checks', 
			'[20222] T_RIF40_STUDIES study % study area geolevel id (%/%) >= comparision area (%/%) [i.e study area has the same or higher resolution]',
			NEW.study_id::VARCHAR			/* Study id */,
			c2b_rec.geolevel_id::VARCHAR		/* Study area geolevel ID */,
			NEW.study_geolevel_name::VARCHAR 	/* Study area geolevel name */,
			c2a_rec.geolevel_id::VARCHAR		/* Comparison area geolevel ID */,
			NEW.comparison_geolevel_name::VARCHAR 	/* Comparison area geolevel name */ );
	ELSIF USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN 
		/* Allowed duing build before first result is added to system or when converting Kerberos users */
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 
			'trigger_fct_t_rif40_studies_checks', 
			'[20222] WARNING [OLD] T_RIF40_STUDIES study % study area geolevel id (%/%) < comparision area (%/%) [i.e study area a lower resolution]',
			NEW.study_id::VARCHAR			/* Study id */,
			c2b_rec.geolevel_id::VARCHAR		/* Study area geolevel ID */,
			NEW.study_geolevel_name::VARCHAR 	/* Study area geolevel name */,
			c2a_rec.geolevel_id::VARCHAR		/* Comparison area geolevel ID */,
			NEW.comparison_geolevel_name::VARCHAR 	/* Comparison area geolevel name */ );
	ELSE
		PERFORM rif40_log_pkg.rif40_error(-20222, 
			'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % study area geolevel id (%/%) < comparision area (%/%) [i.e study area a lower resolution than the comparison area]',
			NEW.study_id::VARCHAR			/* Study id */,
			c2b_rec.geolevel_id::VARCHAR		/* Study area geolevel ID */,
			NEW.study_geolevel_name::VARCHAR 	/* Study area geolevel name */,
			c2a_rec.geolevel_id::VARCHAR		/* Comparison area geolevel ID */,
			NEW.comparison_geolevel_name::VARCHAR 	/* Comparison area geolevel name */ );
	END IF;

--
-- Check - suppression_value - Suppress results with low cell counts below this value. If the role RIF_NO_SUPRESSION is granted and the user is not a
-- RIF_STUDENT then SUPPRESSION_VALUE=0; otherwise is equals the parameter "SuppressionValue". If >0 all results with the value or below will be set to 0.
--
	NEW.suppression_value:=c5_rec.suppressionvalue;
	IF NEW.suppression_value > 0 THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
			'[20223] T_RIF40_STUDIES study % suppressed at: %',
			NEW.study_id::VARCHAR			/* Study id */,
			NEW.suppression_value::VARCHAR		/* Suppression value*/);
	ELSIF c5_rec.rif_student = 1 THEN
		PERFORM rif40_log_pkg.rif40_error(-20223, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % not suppressed, but user % is a RIF_STUDENT',
			NEW.study_id::VARCHAR			/* Study id */,
			NEW.username::VARCHAR			/* Username */);
	END IF;

--
-- Check - extract_permitted - Is extract permitted from the database: 0/1. Only a RIF MANAGER may change this value. This user is still permitted to create
-- and run a RIF study and to view the results. Geolevel access is rectricted by the RIF40_GEOLEVELS.RESTRICTED Inforamtion Governance restrictions (0/1).
-- If 1 (Yes) then a) students cannot access this geolevel and b) if the system parameter ExtractControl=1 then the user must be granted permission by a
-- RIF_MANAGER to extract from the database the results, data extract and maps tables. All students must be granted permission by a RIF_MANAGER for any
-- extract if the system parameter ExtractControl=1. This is enforced by the RIF application.
--
	IF c5_rec.extractcontrol = 0 THEN
		NEW.extract_permitted:=1;
		NEW.transfer_permitted:=1;
		NEW.authorised_by:=NEW.username;
		NEW.authorised_on:=LOCALTIMESTAMP;
		NEW.authorised_notes:='Auto authorised; extract control is disabled';
	ELSE
		IF TG_OP = 'INSERT' THEN /* Force through IG process */
			IF c2b_rec.restricted = 0 AND c5_rec.rif_student = 1 THEN
				NEW.extract_permitted:=0;
				NEW.transfer_permitted:=0;
				NEW.authorised_by:=NULL;
				NEW.authorised_on:=NULL;
				NEW.authorised_notes:=NULL;
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 
					'trigger_fct_t_rif40_studies_checks', 
					'[20224-5] T_RIF40_STUDIES study % may NOT be extracted, study geolevel % is not restricted but the user: % is a RIF_STUDENT',
					NEW.study_id::VARCHAR			/* Study id */,
					NEW.study_geolevel_name::VARCHAR 	/* Study area geolevel name */,
					NEW.username::VARCHAR			/* Username */);
			ELSIF c2b_rec.restricted = 0 AND c5_rec.rif_student = 0 THEN
				NEW.extract_permitted:=1;
				NEW.transfer_permitted:=1;
				NEW.authorised_by:=NEW.username;
				NEW.authorised_on:=LOCALTIMESTAMP;
				NEW.authorised_notes:='Auto authorised; study geolevel is not restricted';
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 
					'trigger_fct_t_rif40_studies_checks', 
					'[20224-5] T_RIF40_STUDIES study % may be extracted, study geolevel % is not restricted for user: %',
					NEW.study_id::VARCHAR			/* Study id */,
					NEW.study_geolevel_name::VARCHAR 	/* Study area geolevel name */,
					NEW.username::VARCHAR			/* Username */);
			ELSE
				NEW.extract_permitted:=0;
				NEW.transfer_permitted:=0;
				NEW.authorised_by:=NULL;
				NEW.authorised_on:=NULL;
				NEW.authorised_notes:=NULL;
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 
					'trigger_fct_t_rif40_studies_checks', 
					'[20224-5] T_RIF40_STUDIES study % may NOT be extracted, study geolevel % is restricted for user: %. Requires authorisation by a RIF_MANAGER',
					NEW.study_id::VARCHAR			/* Study id */,
					NEW.study_geolevel_name::VARCHAR 	/* Study area geolevel name */,
					NEW.username::VARCHAR			/* Username */);
			END IF;
--
-- Check - authorised_by - must be a RIF MANAGER.
--
		ELSIF TG_OP = 'UPDATE' THEN
			IF NEW.extract_permitted = 1 THEN /* Attempting permit extraction */
				IF c5_rec.rif_student = 1 THEN
					PERFORM rif40_log_pkg.rif40_error(-20224, 'trigger_fct_t_rif40_studies_checks', 
						'T_RIF40_STUDIES study % may not be extracted, user % is a RIF_STUDENT',
						NEW.study_id::VARCHAR			/* Study id */,
						NEW.username::VARCHAR			/* Username */);
				ELSIF c5_rec.rif_manager = 1 THEN
					NEW.extract_permitted:=1;
					NEW.authorised_by:=NEW.username;
					NEW.authorised_on:=LOCALTIMESTAMP;
					PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
						'[20224-5] T_RIF40_STUDIES study % may be extracted, user % RIF_STUDENT/RIF_MANAGER tests passed',
						NEW.study_id::VARCHAR			/* Study id */,
						NEW.username::VARCHAR			/* Username */);
				ELSIF USER = 'rif40' AND strpos(OLD.username, '@PRIVATE.NET') > 0 THEN
					NULL; 		/* RIF studies update OK from @PRIVATE.NET to postgres */
				ELSE
					PERFORM rif40_log_pkg.rif40_error(-20225, 'trigger_fct_t_rif40_studies_checks', 
						'T_RIF40_STUDIES study % may not be extracted, modifying user % is NOT a RIF_MANAGER',
						NEW.study_id::VARCHAR			/* Study id */,
						USER::VARCHAR				/* Username */);
				END IF;
			END IF;
--
-- Check - transfer_permitted - Is transfer permitted from the Secure or Private Network: 0/1. This is for purely documentatary purposes only. Only a
-- RIF_MANAGER may change this value. The value defaults to the same as EXTRACT_PERMITTED. Only geolevels where RIF40_GEOLEVELS.RESTRICTED=0 may be
-- transferred
--
			IF c2b_rec.restricted = 1 THEN
				 NEW.transfer_permitted:=0;
			ELSE
				 NEW.transfer_permitted:=NEW.extract_permitted;
			END IF;
--
-- Check - authorised_notes - IG authorisation notes. Must be filled in if EXTRACT_PERMITTED=1
--
			IF NEW.transfer_permitted = 1 AND NEW.extract_permitted = 0 THEN
				PERFORM rif40_log_pkg.rif40_error(-20226, 'trigger_fct_t_rif40_studies_checks', 
					'T_RIF40_STUDIES study % may not be transferred, extract not permitted',
					NEW.study_id::VARCHAR				/* Study id */);
			ELSIF NEW.extract_permitted =  1 AND coalesce(NEW.authorised_notes::text, '') = '' THEN
				PERFORM rif40_log_pkg.rif40_error(-20227, 'trigger_fct_t_rif40_studies_checks', 
					'T_RIF40_STUDIES study % may not be extracted, no IG authorisation notes',
					NEW.study_id::VARCHAR				/* Study id */);
			ELSE
				IF NEW.transfer_permitted = 1 AND NEW.extract_permitted = 1 THEN
					PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
						'[20226-7] T_RIF40_STUDIES study % may be extracted and transferred',
						NEW.study_id::VARCHAR			/* Study id */);
				ELSIF NEW.transfer_permitted = 0 AND NEW.extract_permitted = 1 THEN
					PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
						'[20226-7] T_RIF40_STUDIES study % may be extracted but not transferred',
						NEW.study_id::VARCHAR			/* Study id */);
				END IF;
			END IF;
		END IF;
	END IF;

--
-- TODO
--
-- IF USER = NEW.username (i.e. not initial RIF40 INSERT) THEN
--	grant to all shared users if not already granted
--
	IF NEW.username != USER THEN
		NULL;
	END IF;

--
-- Check extract_table, map_table Oracle name, access (dependent on state)
--
	IF coalesce(NEW.extract_table::text, '') = '' THEN
		NEW.extract_table:='S'||NEW.study_id::Text||'_EXTRACT';
	END IF;
	PERFORM rif40_trg_pkg.rif40_db_name_check('EXTRACT_TABLE', NEW.extract_table);
	schema:=rif40_sql_pkg.rif40_object_resolve(NEW.extract_table::VARCHAR);
	IF (schema IS NOT NULL AND schema::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
			'[20228] T_RIF40_STUDIES study % extract table: % accessible',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.extract_table::VARCHAR 	/* extract_table */);
	ELSIF NEW.study_state NOT IN ('C', 'V', 'U') /* i.e. E, R */ THEN
		PERFORM rif40_log_pkg.rif40_error(-20228, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % extract table: % cannot be accessed; state: %',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.extract_table::VARCHAR 	/* extract_table */,
			NEW.study_state::VARCHAR	/* State */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
			'[20228] T_RIF40_STUDIES study % extract table: % cannot be accessed; state: % [IGNORED]',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.extract_table::VARCHAR 	/* extract_table */,
			NEW.study_state::VARCHAR	/* State */);
	END IF;
	IF coalesce(NEW.map_table::text, '') = '' THEN
		NEW.map_table:='S'||NEW.study_id::Text||'_MAP';
	END IF;
	PERFORM rif40_trg_pkg.rif40_db_name_check('MAP_TABLE', NEW.map_table);
	schema:=rif40_sql_pkg.rif40_object_resolve(NEW.map_table::VARCHAR);
	IF (schema IS NOT NULL AND schema::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
			'[20229] T_RIF40_STUDIES study % map table: % accessible',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.map_table::VARCHAR 		/* map_table */);
	ELSIF NEW.study_state NOT IN ('C', 'V', 'U', 'E') /* i.e. R */ THEN
		PERFORM rif40_log_pkg.rif40_error(-20229, 'trigger_fct_t_rif40_studies_checks', 
			'T_RIF40_STUDIES study % map table: % cannot be accessed; state: %',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.map_table::VARCHAR	 	/* map_table */,
			NEW.study_state::VARCHAR	/* State */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
			'[20229] T_RIF40_STUDIES study % map table: % cannot be accessed; state: % [IGNORED]',
			NEW.study_id::VARCHAR		/* Study id */,
			NEW.map_table::VARCHAR 		/* map_table */,
			NEW.study_state::VARCHAR	/* State */);
	END IF;

--
-- Delayed RIF40_TABLES denominator checks:
-- Check - Column <TABLE_NAME>.TOTAL_FIELD, SEX_FIELD_NAME, AGE_GROUP_FIELD_NAME, AGE_SEX_GROUP_FIELD_NAME exists
--
	IF USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN 
		/* Allowed duing build before first result is added to system or when converting Kerberos users */
		NULL;
	ELSIF c1b_rec.total_field IS NOT NULL AND c1b_rec.total_field IS NOT NULL THEN
		OPEN c6_stck(denom_owner, denom_table, c1b_rec.total_field);
		FETCH c6_stck INTO c6_rec;
		IF NOT FOUND THEN
			CLOSE c6_stck;
			PERFORM rif40_log_pkg.rif40_error(-20230, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study: % denominator RIF40_TABLES total field column: %.%.% NOT found',
				NEW.study_id::VARCHAR			/* Study */,
				denom_owner::VARCHAR			/* Denominator owner */,
				denom_table::VARCHAR			/* Denominator table */,
				c1b_rec.total_field::VARCHAR		/* Total field name */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
				'[20230] T_RIF40_STUDIES study: % denominator RIF40_TABLES total field column: %.%.% found',
				NEW.study_id::VARCHAR			/* Study */,
				denom_owner::VARCHAR			/* Denominator owner */,
				denom_table::VARCHAR			/* Denominator table */,
				c1b_rec.total_field::VARCHAR		/* Total field name */);
		END IF;
		CLOSE c6_stck;
	END IF;
	IF USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN 
		/* Allowed duing build before first result is added to system or when converting Kerberos users */
		NULL;
	ELSIF c1b_rec.sex_field_name IS NOT NULL AND c1b_rec.sex_field_name IS NOT NULL THEN
		OPEN c6_stck(denom_owner, denom_table, c1b_rec.sex_field_name);
		FETCH c6_stck INTO c6_rec;
		IF NOT FOUND THEN
			CLOSE c6_stck;
			PERFORM rif40_log_pkg.rif40_error(-20231, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study: % denominator RIF40_TABLES sex field column: %.%.% NOT found',
				NEW.study_id::VARCHAR			/* Study */,
				denom_owner::VARCHAR			/* Denominator owner */,
				denom_table::VARCHAR			/* Denominator table */,
				c1b_rec.sex_field_name::VARCHAR		/* Sex field name */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
				'[20231] T_RIF40_STUDIES study: % denominator RIF40_TABLES sex field column: %.%.% found',
				NEW.study_id::VARCHAR			/* Study */,
				denom_owner::VARCHAR			/* Denominator owner */,
				denom_table::VARCHAR			/* Denominator table */,
				c1b_rec.sex_field_name::VARCHAR		/* Sex field name */);
		END IF;
		CLOSE c6_stck;
	END IF;
	IF USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN 
		/* Allowed duing build before first result is added to system or when converting Kerberos users */
		NULL;
	ELSIF c1b_rec.age_group_field_name IS NOT NULL AND c1b_rec.age_group_field_name IS NOT NULL THEN
		OPEN c6_stck(denom_owner, denom_table, c1b_rec.age_group_field_name);
		FETCH c6_stck INTO c6_rec;
		IF NOT FOUND THEN
			CLOSE c6_stck;
			PERFORM rif40_log_pkg.rif40_error(-20232, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study: % denominator RIF40_TABLES age group field name column: %.%.% NOT found',
				NEW.study_id::VARCHAR			/* Study */,
				denom_owner::VARCHAR			/* Denominator owner */,
				denom_table::VARCHAR			/* Denominator table */,
				c1b_rec.age_group_field_name::VARCHAR	/* Age group field name */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
				'[20232] T_RIF40_STUDIES study: % denominator RIF40_TABLES age group field name column: %.%.% found',
				NEW.study_id::VARCHAR			/* Study */,
				denom_owner::VARCHAR			/* Denominator owner */,
				denom_table::VARCHAR			/* Denominator table */,
				c1b_rec.age_group_field_name::VARCHAR	/* Age group field name */);
		END IF;
		CLOSE c6_stck;
	END IF;
	IF USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN 
		/* Allowed duing build before first result is added to system or when converting Kerberos users */
		NULL;
	ELSIF c1b_rec.age_sex_group_field_name IS NOT NULL AND c1b_rec.age_sex_group_field_name IS NOT NULL THEN
		OPEN c6_stck(denom_owner, denom_table, c1b_rec.age_sex_group_field_name);
		FETCH c6_stck INTO c6_rec;
		IF NOT FOUND THEN
			CLOSE c6_stck;
			PERFORM rif40_log_pkg.rif40_error(-20233, 'trigger_fct_t_rif40_studies_checks', 
				'T_RIF40_STUDIES study: % denominator RIF40_TABLES age sex group field column: %.%.% NOT found',
				NEW.study_id::VARCHAR				/* Study */,
				denom_owner::VARCHAR				/* Denominator owner */,
				denom_table::VARCHAR				/* Denominator table */,
				c1b_rec.age_sex_group_field_name::VARCHAR	/* Age sex group field name */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
				'[20233] T_RIF40_STUDIES study: % denominator RIF40_TABLES age sex group field column: %.%.% found',
				NEW.study_id::VARCHAR				/* Study */,
				denom_owner::VARCHAR				/* Denominator owner */,
				denom_table::VARCHAR				/* Denominator table */,
				c1b_rec.age_sex_group_field_name::VARCHAR	/* Age sex group field name */);
		END IF;
		CLOSE c6_stck;
	END IF;

	IF USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN 
		/* Allowed duing build before first result is added to system or when converting Kerberos users */
		NULL;
	ELSIF direct_stand_owner IS NOT NULL AND direct_stand_owner::text <> '' THEN /* Direct standardisation table exists */
--
-- Delayed RIF40_TABLES direct standardisation table checks:
-- Check - Column <TABLE_NAME>.TOTAL_FIELD, SEX_FIELD_NAME, AGE_GROUP_FIELD_NAME, AGE_SEX_GROUP_FIELD_NAME exists
--
		IF c1c_rec.total_field IS NOT NULL AND c1c_rec.total_field::text <> '' THEN
			OPEN c6_stck(direct_stand_owner, direct_stand_table, c1c_rec.total_field);
			FETCH c6_stck INTO c6_rec;
			IF NOT FOUND THEN
				CLOSE c6_stck;
				PERFORM rif40_log_pkg.rif40_error(-20234, 'trigger_fct_t_rif40_studies_checks', 
					'T_RIF40_STUDIES study: % direct standardisation RIF40_TABLES total field column: %.%.% NOT found',
					NEW.study_id::VARCHAR			/* Study */,
					direct_stand_owner::VARCHAR		/* Direct standardisation owner */,
					direct_stand_table::VARCHAR		/* Direct standardisation table */,
					c1c_rec.total_field::VARCHAR		/* Total field name */);
			ELSE
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
					'[20234] T_RIF40_STUDIES study: % direct standardisation RIF40_TABLES total field column: %.%.% found',
					NEW.study_id::VARCHAR			/* Study */,
					direct_stand_owner::VARCHAR		/* Direct standardisation owner */,
					direct_stand_table::VARCHAR		/* Direct standardisation table */,
					c1c_rec.total_field::VARCHAR		/* Total field name */);
			END IF;
			CLOSE c6_stck;
		END IF;
		IF c1c_rec.sex_field_name IS NOT NULL AND c1c_rec.sex_field_name::text <> '' THEN
			OPEN c6_stck(direct_stand_owner, direct_stand_table, c1c_rec.sex_field_name);
			FETCH c6_stck INTO c6_rec;
			IF NOT FOUND THEN
				CLOSE c6_stck;
				PERFORM rif40_log_pkg.rif40_error(-20235, 'trigger_fct_t_rif40_studies_checks', 
					'T_RIF40_STUDIES study: % direct standardisation RIF40_TABLES sex field column: %.%.% NOT found',
					NEW.study_id::VARCHAR			/* Study */,
					direct_stand_owner::VARCHAR		/* Direct standardisation owner */,
					direct_stand_table::VARCHAR		/* Direct standardisation table */,
					c1c_rec.sex_field_name::VARCHAR		/* Sex field name */);
			ELSE
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_studies_checks', 
					'[20235] T_RIF40_STUDIES study: % direct standardisation RIF40_TABLES sex field column: %.%.% found',
					NEW.study_id::VARCHAR			/* Study */,
					direct_stand_owner::VARCHAR		/* Direct standardisation owner */,
					direct_stand_table::VARCHAR		/* Direct standardisation table */,
					c1c_rec.sex_field_name::VARCHAR		/* Sex field name */);
			END IF;
			CLOSE c6_stck;
		END IF;
		IF c1c_rec.age_group_field_name IS NOT NULL AND c1c_rec.age_group_field_name::text <> '' THEN
			OPEN c6_stck(direct_stand_owner, direct_stand_table, c1c_rec.age_group_field_name);
			FETCH c6_stck INTO c6_rec;
			IF NOT FOUND THEN
				CLOSE c6_stck;
				PERFORM rif40_log_pkg.rif40_error(-20236, 
					'trigger_fct_t_rif40_studies_checks', 
					'T_RIF40_STUDIES study: % direct standardisation RIF40_TABLES age group field name column: %.%.% NOT found',
					NEW.study_id::VARCHAR			/* Study */,
					direct_stand_owner::VARCHAR		/* Direct standardisation owner */,
					direct_stand_table::VARCHAR		/* Direct standardisation table */,
					c1c_rec.age_group_field_name::VARCHAR	/* Age group field name */);
			ELSE
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 
					'trigger_fct_t_rif40_studies_checks', 
					'[20236] T_RIF40_STUDIES study: % direct standardisation RIF40_TABLES age group field name column: %.%.% found',
					NEW.study_id::VARCHAR			/* Study */,
					direct_stand_owner::VARCHAR		/* Direct standardisation owner */,
					direct_stand_table::VARCHAR		/* Direct standardisation table */,
					c1c_rec.age_group_field_name::VARCHAR	/* Age group field name */);
			END IF;
			CLOSE c6_stck;
		END IF;
		IF c1c_rec.age_sex_group_field_name IS NOT NULL AND c1c_rec.age_sex_group_field_name::text <> '' THEN
			OPEN c6_stck(direct_stand_owner, direct_stand_table, c1c_rec.age_sex_group_field_name);
			FETCH c6_stck INTO c6_rec;
			IF NOT FOUND THEN
				CLOSE c6_stck;
				PERFORM rif40_log_pkg.rif40_error(-20237, 
					'trigger_fct_t_rif40_studies_checks', 
					'T_RIF40_STUDIES study: % direct standardisation RIF40_TABLES age sex group field column: %.%.% NOT found',
					NEW.study_id::VARCHAR				/* Study */,
					direct_stand_owner::VARCHAR			/* Direct standardisation owner */,
					direct_stand_table::VARCHAR			/* Direct standardisation table */,
					c1c_rec.age_sex_group_field_name::VARCHAR	/* Age sex group field name */);
			ELSE
				PERFORM rif40_log_pkg.rif40_log('DEBUG1', 
					'trigger_fct_t_rif40_studies_checks', 
					'[20237] T_RIF40_STUDIES study: % direct standardisation RIF40_TABLES age sex group field column: %.%.% found',
					NEW.study_id::VARCHAR				/* Study */,
					direct_stand_owner::VARCHAR			/* Direct standardisation owner */,
					direct_stand_table::VARCHAR			/* Direct standardisation table */,
					c1c_rec.age_sex_group_field_name::VARCHAR	/* Age sex group field name */);
			END IF;
			CLOSE c6_stck;
		END IF;
	END IF;

--
-- Error message end: -20259, last message: -20237
--
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
]]></definition>
</function>

<function name="trigger_fct_t_rif40_study_areas_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_t_rif40_study_areas_checks_description>
<para>
Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
</para>
</trigger_t_rif40_study_areas_checks_description>
 */
--
-- -20280 to -20299 - T_RIF40_STUDY_AREAS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c4_cksa CURSOR IS
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c4_rec RECORD;
BEGIN
--
-- T_RIF40_STUDY_AREAS: Check - USERNAME is Kerberos USER on INSERT
--			Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records
--
	OPEN c4_cksa;
	FETCH c4_cksa INTO c4_rec;
	CLOSE c4_cksa;
	IF NOT TG_OP = 'DELETE' AND NEW.username != USER THEN
		IF USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN 
			/* Allowed duing build before first result is added to system or when converting Kerberos users */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20280,  'trigger_fct_t_rif40_study_areas_checks',
				'T_RIF40_STUDY_AREAS study: % area_id: % band_id: % username: % is not USER: %',
				NEW.study_id::VARCHAR		/* Study id */,
				NEW.area_id::VARCHAR		/* Area */,
			 	NEW.band_id::VARCHAR		/* Band */,
				NEW.username::VARCHAR		/* Record username */,
				USER::VARCHAR			/* Logon username */);
		END IF;
/*	ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20281,  't_rif40_study_areas_checks',
			'T_RIF40_STUDY_AREAS study: % area_id: % band_id: % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR		/- Study id -/,
			NEW.area_id::VARCHAR		/- Area -/,
			NEW.band_id::VARCHAR		/- Band -/,
			NEW.username::VARCHAR 		/- Record username -/,
			USER::VARCHAR			/- Logon username -/); */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20282,  'trigger_fct_t_rif40_study_areas_checks',
			'T_RIF40_STUDY_AREAS UPDATE study: % area_id: % band_id: % not allowed on T_RIF40_STUDY_AREAS',
			NEW.study_id::VARCHAR		/* Study id */);
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20283,  'trigger_fct_t_rif40_study_areas_checks',
			'T_RIF40_STUDY_AREAS DELETE study: % area_id: % band_id: % only allowed on own records in T_RIF40_STUDY_AREAS, record owned by: %',
			OLD.study_id::VARCHAR		/* Study id */,
			OLD.area_id::VARCHAR		/* Area */,
			OLD.band_id::VARCHAR		/* Band */,
			OLD.username::VARCHAR		/* INSERT username */);
	END IF;
--
	IF TG_OP = 'DELETE' THEN
--
--		PERFORM rif40_log_pkg.rif40_log('DEBUG4', 'trigger_fct_t_rif40_study_areas_checks',
--	     	 	'[20280-3] T_RIF40_STUDY_AREAS study: % area_id: % band_id % CRUD checks OK',
--			OLD.study_id::VARCHAR		/* Study id */,
--			OLD.area_id::VARCHAR		/* Area */,
--		 	OLD.band_id::VARCHAR		/* Band */);
--
		RETURN OLD;
	ELSE  	
--
--		PERFORM rif40_log_pkg.rif40_log('DEBUG4', 'trigger_fct_t_rif40_study_areas_checks',
--			'[20280-3] T_RIF40_STUDY_AREAS study: % area_id: % band_id % CRUD checks OK',
--			NEW.study_id::VARCHAR		/* Study id */,
--			NEW.area_id::VARCHAR		/* Area */,
--		 	NEW.band_id::VARCHAR		/* Band */);
--
		RETURN NEW;
	END IF;
END;
]]></definition>
</function>

<function name="trigger_fct_t_rif40_study_areas_checks2"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check - area_id]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_t_rif40_study_areas_checks2_description>
<para>
Check - area_id
</para>
</trigger_t_rif40_study_areas_checks2_description>
 */
--
-- -20280 to -20299 - T_RIF40_STUDY_AREAS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
-- $Log: v4_0_postgres_triggers.sql,v $
-- Revision 1.6  2014/02/24 10:50:28  peterh
-- Full build from Oracle, including default study area and removal of year_start/stop min/max_age_group from T_RIF40_STUDIES
--
-- Still present in view
--
-- Revision 1.5  2013/09/25 12:12:22  peterh
-- Baseline after 2x full clean builds at Postgres level
-- TODO.txt uptodate
--
-- Revision 1.4  2013/09/18 15:20:32  peterh
-- Checkin at end of 6 week RIF focus. Got as far as SAHSULAND run study to completion for observed only
--
-- Revision 1.3  2013/09/02 14:08:33  peterh
--
-- Baseline after full trigger implmentation
--
-- Revision 1.2  2013/03/14 17:35:38  peterh
-- Baseline for TX to laptop
--
-- Revision 1.4  2013/02/14 10:48:39  peterh
-- Baseline aftyer clean build with screen mockup changes
--
-- Revision 1.12  2012/10/23 09:05:57  peterh
--
-- Baseline after full build of SAHSUland RIF schema including data
-- No triggers, Geo data and system error/logon triggers to be done
--
-- Revision 1.11  2012/09/14 15:44:53  peterh
-- Baseline after full review of check code and error messages
-- IG functionality added
--
-- Revision 1.10  2012/09/05 15:16:37  peterh
--
-- RIF update after initial build of postgres DB
--
-- Revision 1.9  2012/07/03 12:28:55  peterh
--
-- RIF schema as at 3/6/2012. All entities complete
--
-- Revision 1.8  2012/06/15 11:05:26  peterh
-- Check with working SQL generator (CREATE stmt only); bones of XML generator
-- Numerous lookup tables added.
-- Prepare for documentation
--
-- Revision 1.7  2012/05/22 15:29:41  peterh
--
-- Added RIF40_RESULTS, contextual_stats; more verification
--
-- Revision 1.6  2012/05/21 11:11:28  peterh
--
-- RIF investigattion, inv_covariates, study shares checks + SAHSU land example data
--
-- Revision 1.5  2012/04/26 15:49:48  peterh
-- Fixed view security problems
--
-- Revision 1.4  2012/04/13 15:05:02  peterh
--
-- Added RIF studies, investigations etc
--
-- Revision 1.3  2012/04/04 15:22:51  peterh
-- Easter baseline
--
-- Revision 1.2  2012/03/30 11:45:40  peterh
--
-- Baseline with working RIF40_NUM_DENOM
--
-- Revision 1.1  2012/03/28 15:39:19  peterh
--
-- Added check constraints and basic object table+column existance checks
--
-- Revision 1.2  2012/03/27 15:54:33  peterh
--
-- Added more V4 tables
--
-- Revision 1.1  2012/03/23 15:21:18  peterh
--
-- Moved from old RIF directory
--
-- Revision 1.2  2011/07/12 13:18:40  peterh
-- RIF baseline after Kerberosisation, re-doc and N_POP add
--
-- Revision 1.1  2011/05/27 10:31:21  peterh
--
-- Start of user level suppression support in RIF
--
	c1_cksa2 CURSOR (l_study_id  integer) IS
		SELECT a.study_id, a.study_geolevel_name, a.comparison_geolevel_name, b.hierarchytable
		  FROM t_rif40_studies a, rif40_geographies b
		 WHERE a.geography = b.geography
		   AND a.study_id  = l_study_id;
	c3_cksa2 CURSOR IS
		SELECT currval('rif40_study_id_seq'::regclass) AS study_id;
	c1_rec RECORD;
	c3_rec RECORD;
	c4_cksa2 CURSOR IS
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c4_rec RECORD;
--
	c2_cksa2 REFCURSOR;
	sql_stmt	varchar(2000);
	total		integer;
BEGIN
--
-- Efffectively disable check during initial system load
--
	IF NOT TG_OP = 'DELETE' AND USER = 'rif40' THEN
		OPEN c4_cksa2;
		FETCH c4_cksa2 INTO c4_rec;
		CLOSE c4_cksa2;
		IF c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0 THEN  
			/* Allowed during build before first result is added to system or before Kerberos update */
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_study_areas_checks2',
				'[20300] T_RIF40_STUDY_AREAS username: % allowed during build before first result is added to system [CHECK DISABLED]',
				USER::VARCHAR		/* User */);
			RETURN NEW;
		END IF;
	END IF;

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
     
--
-- Check - area_id
--
	OPEN c3_cksa2;
	FETCH c3_cksa2 INTO c3_rec;
	IF NOT FOUND OR coalesce(c3_rec.study_id::text, '') = '' THEN
		CLOSE c3_cksa2;
		PERFORM rif40_log_pkg.rif40_error(-20284, 'trigger_fct_t_rif40_study_areas_checks2',
			'T_RIF40_STUDY_AREAS no rif40_study_id_seq.CURRVAL study_id sequence found');
	END IF;
--
	CLOSE c3_cksa2;
	OPEN c1_cksa2(c3_rec.study_id);
	FETCH c1_cksa2 INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1_cksa2;
		PERFORM rif40_log_pkg.rif40_error(-20285, 'trigger_fct_t_rif40_study_areas_checks2',
			'T_RIF40_STUDY_AREAS no study found for study_id: %',
			c3_rec.study_id::VARCHAR		/* rif40_study_id_seq.CURRVAL study_id sequence */);
	END IF;
	CLOSE c1_cksa2;
	sql_stmt:='SELECT COUNT(area_id) AS total FROM ('||E'\n'||
			'SELECT area_id FROM t_rif40_study_areas WHERE study_id = $1'||E'\n'||
			'EXCEPT '||E'\n'||
			'SELECT '||LOWER(c1_rec.study_geolevel_name)||' FROM '||c1_rec.hierarchytable||') a';
	BEGIN
		OPEN c2_cksa2 FOR EXECUTE sql_stmt USING c3_rec.study_id;
		FETCH c2_cksa2 INTO total;
		CLOSE c2_cksa2;
	EXCEPTION
		WHEN others THEN
			PERFORM rif40_log_pkg.rif40_error(-20286, 'trigger_fct_t_rif40_study_areas_checks2',
				'T_RIF40_STUDY_AREAS study_id: % % raised by: %',
				c3_rec.study_id::VARCHAR	/* rif40_study_id_seq.CURRVAL study_id sequence */,
				sqlerrm::VARCHAR		/* Error */,
				sql_stmt::VARCHAR		/* SQL */);

	END;
	IF total > 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20287, 'trigger_fct_t_rif40_study_areas_checks2',
			'T_RIF40_STUDY_AREAS study_id: %; found % areas not in: %.%'||E'\n'||'SQL> %;',
			total::VARCHAR				/* Total */,
			c3_rec.study_id::VARCHAR		/* rif40_study_id_seq.CURRVAL study_id sequence */,
			c1_rec.hierarchytable::VARCHAR		/* Hierarchy table */,
			c1_rec.study_geolevel_name::VARCHAR	/* Study geolevel column name */,
		        sql_stmt::VARCHAR			/* SQL */ );
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END; 
]]></definition>
</function>

<function name="trigger_fct_t_rif40_study_sql_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_fct_t_rif40_study_sql_checks_description>
<para>
Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
</para>
</trigger_fct_t_rif40_study_sql_checks_description>

-- -20540 to -20549 - T_RIF40_STUDY_SQL_LOG  
 */
	c4_sqllogck CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;    
	c4_rec RECORD;
BEGIN
	OPEN c4_sqllogck;
	FETCH c4_sqllogck INTO c4_rec;
	CLOSE c4_sqllogck; 
--
-- T_RIF40_STUDY_SQL: Check - USERNAME is Kerberos USER on INSERT
--			Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records
--
	IF NOT TG_OP = 'DELETE' AND NEW.username != USER THEN
		IF USER = 'rif40' /* AND c4_rec.total = 0 */ THEN /* [ALWAYS] Allowed during build before first result is added to system */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20540, 'trigger_fct_t_rif40_study_sql_checks',
			 	'T_RIF40_STUDY_SQL study: % statement number: % line: % username: % is not USER: %',
				NEW.study_id::VARCHAR		/* Study */,
				NEW.statement_number::VARCHAR	/* Statement number */,
		       		NEW.line_number::VARCHAR	/* Line number */,
				NEW.username::VARCHAR		/* New user */,
				USER::VARCHAR			/* Database user */);
		END IF;
 /*       ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20541, 'trigger_fct_t_rif40_study_sql_checks',
		 	'T_RIF40_STUDY_SQL study: % statement number: % line: % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR	-* Study *-,
			NEW.statement_number::VARCHAR	-* statement_number *,   
		       	NEW.line_number::VARCHAR	-* Line number *-,
			NEW.username::VARCHAR		-* New user *-,
			USER::VARCHAR			-* Database user *-);    */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20542, 'trigger_fct_t_rif40_study_sql_checks',
		 	'T_RIF40_STUDY_SQL study: % statement number: % line: % UPDATE not allowed on T_RIF40_STUDY_SQL',
			NEW.study_id::VARCHAR		/* Study */,
		       	NEW.statement_number::VARCHAR	/* Statement number */,   
		       	NEW.line_number::VARCHAR	/* Line number */);
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20543, 'trigger_fct_t_rif40_study_sql_checks',
			'T_RIF40_STUDY_SQL study: % statement number: % line: % DELETE only allowed on own records in T_RIF40_STUDY_SQL, record owned by: %',
			OLD.study_id::VARCHAR		/* Study */,
		       	OLD.statement_number::VARCHAR	/* Statement number */,   
		       	OLD.line_number::VARCHAR	/* Line number */,
			OLD.username::VARCHAR		/* INSERT username */);
	END IF;
--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_study_sql_checks',
	       	 	'[20360-3] T_RIF40_STUDY_SQL study: % statement number: % line: % CRUD checks OK',
			OLD.study_id::VARCHAR		/* Study id */,
		       	OLD.statement_number::VARCHAR	/* Statement number */,   
		       	OLD.line_number::VARCHAR	/* Line number */);
		RETURN OLD;
	ELSE  	
--		PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_study_sql_checks',
--			'[20340-3] T_RIF40_STUDY_SQL study: % statement number: % line: % CRUD checks OK',
-- 	     		NEW.study_id::VARCHAR		/* Study id */,
-- 		     	NEW.statement_number::VARCHAR	/* Statement number */,    
--		       	NEW.line_number::VARCHAR	/* Line number */);

		RETURN NEW;
	END IF;      
END; 
]]></definition>
</function>

<function name="trigger_fct_t_rif40_study_sql_log_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_fct_t_rif40_study_sql_log_checks_description>
<para>
Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
</para>
</trigger_fct_t_rif40_study_sql_log_checks_description>

-- -20560 to -20579 - T_RIF40_STUDY_SQL_LOG  
*/
	c4_sqllogck CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;    
	c4_rec RECORD;
BEGIN
	OPEN c4_sqllogck;
	FETCH c4_sqllogck INTO c4_rec;
	CLOSE c4_sqllogck; 
--
-- T_RIF40_STUDY_SQL_LOG: Check - USERNAME is Kerberos USER on INSERT
--			Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records
--
	IF NOT TG_OP = 'DELETE' AND NEW.username != USER THEN
		IF USER = 'rif40' /* AND c4_rec.total = 0 */ THEN /* [ALWAYS] Allowed during build before first result is added to system */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20560, 'trigger_fct_t_rif40_study_sql_log_checks',
			 	'T_RIF40_STUDY_SQL_LOG study: % statement number: % username: % is not USER: %',
				NEW.study_id::VARCHAR	/* Study */,
				NEW.statement_number::VARCHAR	/* Statement number */,
				NEW.username::VARCHAR	/* New user */,
				USER::VARCHAR		/* Database user */);
		END IF;
 /*       ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20561, 'trigger_fct_t_rif40_study_sql_log_checks',
		 	'T_RIF40_STUDY_SQL_LOG study: % statement number: % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR	-* Study *-,
			NEW.statement_number::VARCHAR	-* statement_number *-,
			NEW.username::VARCHAR	-* New user *-,
			USER::VARCHAR		-* Database user *-);    */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20562, 'trigger_fct_t_rif40_study_sql_log_checks',
		 	'T_RIF40_STUDY_SQL_LOG study: % statement number: % UPDATE not allowed on T_RIF40_STUDY_SQL_LOG',
			NEW.study_id::VARCHAR	/* Study */,
		       	NEW.statement_number::VARCHAR	/* Statement number */);
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20563, 'trigger_fct_t_rif40_study_sql_log_checks',
			'T_RIF40_STUDY_SQL_LOG study: % statement number: % DELETE only allowed on own records in T_RIF40_STUDY_SQL_LOG, record owned by: %',
			OLD.study_id::VARCHAR	/* Study */,
		       	OLD.statement_number::VARCHAR	/* Statement number */,
			OLD.username::VARCHAR	/* INSERT username */);
	END IF;
--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_study_sql_log_checks',
	       	 	'[20360-3] T_RIF40_STUDY_SQL_LOG study: % statement number: % CRUD checks OK',
			OLD.study_id::VARCHAR	/* Study id */,
		       	OLD.statement_number::VARCHAR	/* Statement number */);
		RETURN OLD;
	ELSE  	
--	      	PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_study_sql_log_checks',
--			'[20340-3] T_RIF40_STUDY_SQL_LOG study: % statement number: % CRUD checks OK',
--			NEW.study_id::VARCHAR	/* Study id */,
--			NEW.statement_number::VARCHAR	/* Statement number */);    

		RETURN NEW;
	END IF;
END; 
]]></definition>
</function>

<function name="trigger_fct_t_rif40_user_projects_checks"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="rif40_trg_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[Check username exists and is a RIF user Check project has not ended]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
/*
<trigger_t_rif40_geolevels_checks_description>
<para>
Check username exists and is a RIF user
Check project has not ended
</para>
</trigger_t_rif40_geolevels_checks_description>
 */
--
-- Error range: -20520 to -20529 - T_RIF40_USER_PROJECTS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
-- $Id: v4_0_postgres_triggers.sql,v 1.6 2014/02/24 10:50:28 peterh Exp $
--
	c2_rup CURSOR(l_project  varchar) IS
		SELECT *
		  FROM t_rif40_projects
		 WHERE project = l_project;
	c4_rup CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;  
        c2_rec RECORD;
        c4_rec RECORD;
BEGIN
	OPEN c4_rup;
	FETCH c4_rup INTO c4_rec;
	CLOSE c4_rup;    
--
-- Check username exists and is a RIF user
--
	IF USER = 'rif40' THEN
		IF NOT TG_OP = 'DELETE' AND USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN
			/* Allowed during build before first result is added to system or before Kerberos update */
			RETURN NEW;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20522,  'trigger_fct_t_rif40_user_projects_checks',
				'T_RIF40_USER_PROJECTS project: % rif40 user insert only allowed during build before first result is added to system',
				OLD.project::VARCHAR 		/* project */);
		END IF; 
        ELSIF NOT (pg_has_role(USER, 'rif_user', 'USAGE') AND pg_has_role(USER, 'rif_manager', 'USAGE')) THEN
		PERFORM rif40_log_pkg.rif40_error(-20520, 'trigger_fct_t_rif40_user_projects_checks',
		 	'Error: T_RIF40_USER_PROJECTS user: % is not a RIF_USER',
			USER::VARCHAR 	/* username */);
	END IF;

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_user_projects_checks',
		 	'[20520] T_RIF40_USER_PROJECTS user: % is a RIF_USER',
			OLD.username::VARCHAR 	/* username */);
		RETURN OLD;
	END IF;
--
-- Check table username is a RIF user
--
	IF c4_rec.total = 0 THEN /* Allowed during build before first result is added to system */ 
		NULL;
        ELSIF NOT (pg_has_role(NEW.username, 'rif_user', 'USAGE') AND pg_has_role(NEW.username, 'rif_manager', 'USAGE')) THEN 
		PERFORM rif40_log_pkg.rif40_error(-20520, 'trigger_fct_t_rif40_user_projects_checks',
		 	'Error: T_RIF40_USER_PROJECTS username: % is not a RIF_USER',
			NEW.username::VARCHAR 	/* username */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_user_projects_checks',
		       	'[20520] T_RIF40_USER_PROJECTS username: % is a RIF_USER',
   	            	NEW.username::VARCHAR 	/* username */);
      	END IF;         
--
-- Check project has not ended
--
	OPEN c2_rup(NEW.project);
	FETCH c2_rup INTO c2_rec;
	IF coalesce(c2_rec.date_ended::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_user_projects_checks',
		  	'[20521] T_RIF40_USER_PROJECTS project: % no end set',
			NEW.project::VARCHAR 		/* project */);
	ELSIF c2_rec.date_ended < LOCALTIMESTAMP AND c4_rec.total = 0 THEN /* Allowed during build before first result is added to system */
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_user_projects_checks',
		  	'Error: T_RIF40_USER_PROJECTS project: % ended on: % [IGNORED INITIAL LOAD]',
			NEW.project::VARCHAR 		/* project */,
			c2_rec.date_ended::VARCHAR	/* date_ended */);
	ELSIF c2_rec.date_ended < LOCALTIMESTAMP AND c4_rec.total > 0 THEN 
		PERFORM rif40_log_pkg.rif40_error(-20521, 'trigger_fct_t_rif40_user_projects_checks',
		  	'Error: T_RIF40_USER_PROJECTS project: % ended on: %',
			NEW.project::VARCHAR 		/* project */,
			c2_rec.date_ended::VARCHAR	/* date_ended */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_user_projects_checks',
			'[20521] T_RIF40_USER_PROJECTS project: % ends on: %',
			NEW.project::VARCHAR 		/* project */,
			c2_rec.date_ended::VARCHAR	/* date_ended */);
	END IF;
	CLOSE c2_rup;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END; 
]]></definition>
</function>

<table name="rif40_geographies">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Pre-defined hierarchial geographies. Usually based on Census geography. Beware of the foreign key from RIF40_GEOGRAPHIES.DEFAULTCOMPAREA to RIF40_GEOLEVELS. When inserting a new geography do NOT set DEFAULTCOMPAREA, update it after adding geolevels to T_RIF40_GEOLEVELS]]></comment>
	<position x="50" y="50"/>
	<column name="geography" not-null="true">
		<type name="character varying" length="50"/>
		<comment><![CDATA[Geography name]]></comment>
	</column>
	<column name="description" not-null="true">
		<type name="character varying" length="250"/>
		<comment><![CDATA[Description]]></comment>
	</column>
	<column name="hierarchytable" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Hierarchy table]]></comment>
	</column>
	<column name="srid" default-value="0">
		<type name="integer"/>
		<comment><![CDATA[Postgres projection SRID]]></comment>
	</column>
	<column name="defaultcomparea">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Default comparison area]]></comment>
	</column>
	<column name="defaultstudyarea">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Default study area]]></comment>
	</column>
	<column name="postal_population_table">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Postal population table. Table of postal points (e.g. postcodes, ZIP codes); geolevels; X and YCOORDINATES (in projection SRID); male, female and total populations. Converted to SRID points by loader [not in 4326 Web Mercator lat/long]. Used in creating population wieght centroids and in converting postal points to geolevels. Expected columns &lt;postal_point_column&gt;, XCOORDINATE, YCOORDINATE, 1+ &lt;GEOLEVEL_NAME&gt;, MALES, FEMALES, TOTAL]]></comment>
	</column>
	<column name="postal_point_column">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Column name for postal points (e.g. POSTCODE, ZIP_CODE)]]></comment>
	</column>
	<column name="partition" default-value="0">
		<type name="smallint"/>
		<comment><![CDATA[Enable partitioning. Extract tables will be partition if the number of years >= 2x the RIF40_PARAMETERS parameters Parallelisation [which has a default of 4, so extracts covering 8 years or more will be partitioned]. ]]></comment>
	</column>
	<column name="max_geojson_digits" default-value="8">
		<type name="smallint"/>
		<comment><![CDATA[Max digits in ST_AsGeoJson() [optimises file size by removing unecessary precision, the default value of 8 is normally fine.]]]></comment>
	</column>
	<constraint name="partition_ck" type="ck-constr" table="rif40.rif40_geographies">
			<expression><![CDATA[(partition = ANY (ARRAY[0, 1]))]]></expression>
	</constraint>
	<constraint name="postal_population_table_ck" type="ck-constr" table="rif40.rif40_geographies">
			<expression><![CDATA[(((postal_population_table IS NOT NULL) AND (postal_point_column IS NOT NULL)) OR ((postal_population_table IS NULL) AND (postal_point_column IS NULL)))]]></expression>
	</constraint>
	<constraint name="rif40_geographies_pk" type="pk-constr" factor="100" table="rif40.rif40_geographies">
		<columns names="geography" ref-type="src-columns"/>
	</constraint>
	<trigger name="rif40_geog_hierarchytable" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="rif40.rif40_geographies">
		<comment><![CDATA[INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_geog_hierarchytable()]]></comment>
	<condition><![CDATA[((((new.hierarchytable IS NOT NULL) AND ((new.hierarchytable)::text <> ''::text)) OR ((new.postal_population_table IS NOT NULL) AND ((new.postal_population_table)::text <> ''::text))) OR ((new.postal_point_column IS NOT NULL) AND ((new.postal_point_column)::text <> ''::text)))]]></condition>
		<function signature="rif40_trg_pkg.trigger_fct_rif40_geog_hierarchytable()"/>
	</trigger>
	<trigger name="rif40_geog_hierarchytable_del" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="rif40.rif40_geographies">
		<comment><![CDATA[DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_geog_hierarchytable()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_rif40_geog_hierarchytable()"/>
	</trigger>
</table>

<table name="rif40_health_study_themes">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF health study themes]]></comment>
	<position x="471.766" y="50"/>
	<column name="theme" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Theme]]></comment>
	</column>
	<column name="description" not-null="true">
		<type name="character varying" length="200"/>
		<comment><![CDATA[Description]]></comment>
	</column>
	<constraint name="rif40_health_study_themes_pk" type="pk-constr" factor="100" table="rif40.rif40_health_study_themes">
		<columns names="theme" ref-type="src-columns"/>
	</constraint>
</table>

<table name="rif40_tables">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF numerator and denominator tables]]></comment>
	<position x="793.766" y="50"/>
	<column name="theme" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Health Study theme]]></comment>
	</column>
	<column name="table_name" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[RIF table name. Normally the schema owner will not be able to see the health data tables, so no error is raised if the table cannot be resolved to an acceisble object. The schema owner must have access to automatic indirect standardisation denominators.]]></comment>
	</column>
	<column name="description" not-null="true">
		<type name="character varying" length="250"/>
		<comment><![CDATA[Description]]></comment>
	</column>
	<column name="year_start" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Year table starts]]></comment>
	</column>
	<column name="year_stop" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Year table stops]]></comment>
	</column>
	<column name="total_field">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Total field (when used aggregated tables)]]></comment>
	</column>
	<column name="isindirectdenominator" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Is table a denominator to be used in indirect standardisation (0/1)]]></comment>
	</column>
	<column name="isdirectdenominator" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Is table a denominator to be used in direct standardisation (0/1). E.g. POP_WORLD, POP_EUROPE.]]></comment>
	</column>
	<column name="isnumerator" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Is table a numerator  (0/1)]]></comment>
	</column>
	<column name="automatic" default-value="0">
		<type name="smallint"/>
		<comment><![CDATA[Able to be used in automatic RIF40_NUM_DENOM (0/1, default 0). Cannot be applied to direct standardisation denominator. Restricted to 1 denominator per geography to prevent the automatic RIF40_NUM_DENOM having &gt;1 pair per numerator. This restriction is actually enforced in RIF40_NUM_DENOM because of the &quot;ORA-04091: table RIF40.RIF40_TABLES is mutating, trigger/function may not see it&quot; error. A user specific T_RIF40_NUM_DENOM is supplied for other combinations. The default is 0 because of the restrictions.]]></comment>
	</column>
	<column name="sex_field_name">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Name of SEX field. No default. AGE_GROUP_FIELD_NAME must be set, AGE_SEX_GROUP_FIELD_NAME must not be set.]]></comment>
	</column>
	<column name="age_group_field_name">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Name of AGE_GROUP field. No default. SEX_FIELD_NAME must be set, AGE_SEX_GROUP_FIELD_NAME must not be set.]]></comment>
	</column>
	<column name="age_sex_group_field_name" default-value="'AGE_SEX_GROUP'::character varying">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Name of AGE_SEX_GROUP field. Default: AGE_SEX_GROUP; AGE_GROUP_FIELD_NAME and SEX_FIELD_NAME must not be set.]]></comment>
	</column>
	<column name="age_group_id">
		<type name="smallint"/>
		<comment><![CDATA[Type of RIF age group in use. Link to RIF40_AGE_GROUP_NAMES. No default.]]></comment>
	</column>
	<column name="validation_date">
		<type name="timestamp"/>
		<comment><![CDATA[Date table contents were validated OK.]]></comment>
	</column>
	<constraint name="rif40_tab_asg_ck" type="ck-constr" table="rif40.rif40_tables">
			<expression><![CDATA[((((age_sex_group_field_name IS NOT NULL) AND (age_group_field_name IS NULL)) AND (sex_field_name IS NULL)) OR (((age_sex_group_field_name IS NULL) AND (age_group_field_name IS NOT NULL)) AND (sex_field_name IS NOT NULL)))]]></expression>
	</constraint>
	<constraint name="rif40_tab_automatic_ck" type="ck-constr" table="rif40.rif40_tables">
			<expression><![CDATA[(((automatic = 0) OR ((automatic = 1) AND (isnumerator = 1))) OR ((automatic = 1) AND (isindirectdenominator = 1)))]]></expression>
	</constraint>
	<constraint name="rif40_tab_exclusive_ck" type="ck-constr" table="rif40.rif40_tables">
			<expression><![CDATA[(((((isnumerator = 1) AND (isdirectdenominator = 0)) AND (isindirectdenominator = 0)) OR (((isnumerator = 0) AND (isdirectdenominator = 1)) AND (isindirectdenominator = 0))) OR (((isnumerator = 0) AND (isdirectdenominator = 0)) AND (isindirectdenominator = 1)))]]></expression>
	</constraint>
	<constraint name="rif40_tab_isdirectdenom_ck" type="ck-constr" table="rif40.rif40_tables">
			<expression><![CDATA[(isdirectdenominator = ANY (ARRAY[0, 1]))]]></expression>
	</constraint>
	<constraint name="rif40_tab_isindirectdenom_ck" type="ck-constr" table="rif40.rif40_tables">
			<expression><![CDATA[(isindirectdenominator = ANY (ARRAY[0, 1]))]]></expression>
	</constraint>
	<constraint name="rif40_tab_isnumerator_ck" type="ck-constr" table="rif40.rif40_tables">
			<expression><![CDATA[(isnumerator = ANY (ARRAY[0, 1]))]]></expression>
	</constraint>
	<constraint name="rif40_tab_years_ck" type="ck-constr" table="rif40.rif40_tables">
			<expression><![CDATA[(year_start <= year_stop)]]></expression>
	</constraint>
	<constraint name="rif40_tables_pk" type="pk-constr" factor="100" table="rif40.rif40_tables">
		<columns names="table_name" ref-type="src-columns"/>
	</constraint>
	<trigger name="rif40_tables_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="rif40.rif40_tables">
		<comment><![CDATA[INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_tables_checks()]]></comment>
	<condition><![CDATA[((((((((new.table_name IS NOT NULL) AND ((new.table_name)::text <> ''::text)) OR ((new.isdirectdenominator IS NOT NULL) AND ((new.isdirectdenominator)::text <> ''::text))) OR ((new.table_name IS NOT NULL) AND ((new.table_name)::text <> ''::text))) OR ((new.total_field IS NOT NULL) AND ((new.total_field)::text <> ''::text))) OR ((new.sex_field_name IS NOT NULL) AND ((new.sex_field_name)::text <> ''::text))) OR ((new.age_group_field_name IS NOT NULL) AND ((new.age_group_field_name)::text <> ''::text))) OR ((new.age_sex_group_field_name IS NOT NULL) AND ((new.age_sex_group_field_name)::text <> ''::text)))]]></condition>
		<function signature="rif40_trg_pkg.trigger_fct_rif40_tables_checks()"/>
	</trigger>
	<trigger name="rif40_tables_checks_del" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="rif40.rif40_tables">
		<comment><![CDATA[DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_tables_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_rif40_tables_checks()"/>
	</trigger>
</table>

<table name="t_rif40_fdw_tables">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF numerator tables which are Foreign data wrappers in Postgres]]></comment>
	<position x="1210.77" y="50"/>
	<column name="username" default-value="&quot;current_user&quot;()">
		<type name="character varying" length="90"/>
		<comment><![CDATA[User name]]></comment>
	</column>
	<column name="table_name" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[RIF table name. Normally the schema owner will not be able to see the health data tables, so no error is raised if the table cannot be resolved to an acceisble object. The schema owner must have access to automatic indirect standardisation denominators.]]></comment>
	</column>
	<column name="create_status" not-null="true">
		<type name="character varying"/>
		<comment><![CDATA[Create status: C (Created, no errors), E(Created, errors in test SELECT), N(Not created, errors)]]></comment>
	</column>
	<column name="error_message">
		<type name="character varying" length="300"/>
		<comment><![CDATA[Error message when create status is: E(Created, errors in test SELECT, N(Not created, errors)]]></comment>
	</column>
	<column name="date_created" default-value="('now'::text)::timestamp without time zone">
		<type name="timestamp"/>
		<comment><![CDATA[Date FDW table created (or attempted to be)]]></comment>
	</column>
	<column name="rowtest_passed" default-value="0">
		<type name="smallint"/>
		<comment><![CDATA[SELECT rowtest passed (0/1)]]></comment>
	</column>
	<constraint name="t_rif40_fdw_tables_ck1" type="ck-constr" table="rif40.t_rif40_fdw_tables">
			<expression><![CDATA[((create_status)::text = ANY (ARRAY[('C'::character varying)::text, ('E'::character varying)::text, ('N'::character varying)::text]))]]></expression>
	</constraint>
	<constraint name="t_rif40_fdw_tables_ck2" type="ck-constr" table="rif40.t_rif40_fdw_tables">
			<expression><![CDATA[(rowtest_passed = ANY (ARRAY[0, 1]))]]></expression>
	</constraint>
	<constraint name="t_rif40_fdw_tables_pk" type="pk-constr" factor="100" table="rif40.t_rif40_fdw_tables">
		<columns names="table_name" ref-type="src-columns"/>
	</constraint>
</table>

<view name="rif40_fdw_tables">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF numerator tables which are Foreign data wrappers in Postgres]]></comment>
	<position x="477.766" y="3760.2"/>
	<reference>
		<expression><![CDATA[ SELECT t_rif40_fdw_tables.username,
    t_rif40_fdw_tables.table_name,
    t_rif40_fdw_tables.create_status,
    t_rif40_fdw_tables.error_message,
    t_rif40_fdw_tables.date_created,
    t_rif40_fdw_tables.rowtest_passed
   FROM t_rif40_fdw_tables
  WHERE ((t_rif40_fdw_tables.username)::name = "current_user"());]]></expression>
	</reference>
</view>

<table name="rif40_a_and_e">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[A&amp;E clinical diagnosis (3 char)]]></comment>
	<position x="1574.77" y="50"/>
	<column name="a_and_e_3char" not-null="true">
		<type name="character varying" length="4"/>
		<comment><![CDATA[Clinical diagnosis]]></comment>
	</column>
	<column name="text_3char">
		<type name="character varying" length="200"/>
		<comment><![CDATA[Clinical diagnosis chapter textual description]]></comment>
	</column>
	<constraint name="rif40_a_and_e_pk" type="pk-constr" factor="100" table="rif40.rif40_a_and_e">
		<columns names="a_and_e_3char" ref-type="src-columns"/>
	</constraint>
</table>

<table name="rif40_age_group_names">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF Age group names]]></comment>
	<position x="50" y="383.2"/>
	<column name="age_group_id" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[AGE_GROUP_ID]]></comment>
	</column>
	<column name="age_group_name" not-null="true">
		<type name="character varying" length="50"/>
		<comment><![CDATA[Age Group Name]]></comment>
	</column>
	<constraint name="rif40_age_group_names_pk" type="pk-constr" factor="100" table="rif40.rif40_age_group_names">
		<columns names="age_group_id" ref-type="src-columns"/>
	</constraint>
</table>

<table name="rif40_age_groups">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF age groups]]></comment>
	<position x="404" y="383.2"/>
	<column name="age_group_id" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[AGE_GROUP_ID]]></comment>
	</column>
	<column name="offset" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Offset]]></comment>
	</column>
	<column name="low_age" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Low age]]></comment>
	</column>
	<column name="high_age" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[High age]]></comment>
	</column>
	<column name="fieldname" not-null="true">
		<type name="character varying" length="50"/>
		<comment><![CDATA[Fieldname]]></comment>
	</column>
	<constraint name="rif40_age_groups_pk" type="pk-constr" factor="100" table="rif40.rif40_age_groups">
		<columns names="age_group_id,offset" ref-type="src-columns"/>
	</constraint>
	<index name="rif40_age_groups_pk2" table="rif40.rif40_age_groups"
		 concurrent="false" unique="true" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="age_group_id"/>
		</idxelement>
		<idxelement use-sorting="false">
			<column name="fieldname"/>
		</idxelement>
	</index>
</table>

<table name="rif40_columns">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF40 Columns]]></comment>
	<position x="759.766" y="383.2"/>
	<column name="table_or_view_name_hide">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Table name]]></comment>
	</column>
	<column name="column_name_hide">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Column name]]></comment>
	</column>
	<column name="table_or_view_name_href">
		<type name="character varying" length="522"/>
		<comment><![CDATA[Table name (web version)]]></comment>
	</column>
	<column name="column_name_href">
		<type name="character varying" length="847"/>
		<comment><![CDATA[Column name (web version)]]></comment>
	</column>
	<column name="nullable">
		<type name="character varying" length="8"/>
		<comment><![CDATA[Nollable]]></comment>
	</column>
	<column name="oracle_data_type">
		<type name="character varying" length="189"/>
		<comment><![CDATA[Oracle data type]]></comment>
	</column>
	<column name="comments">
		<type name="character varying" length="4000"/>
		<comment><![CDATA[Comments]]></comment>
	</column>
</table>

<sequence name="rif40_study_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Used as sequence for unique study index: study_id; auto populated.]]></comment>
</sequence>

<table name="rif40_study_shares">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Users granted access by a RIF_MANAGER to study data]]></comment>
	<position x="1117.77" y="383.2"/>
	<column name="study_id" not-null="true" default-value="(currval('rif40_study_id_seq'::regclass))::integer">
		<type name="integer"/>
		<comment><![CDATA[Unique study index: study_id. Created by SEQUENCE rif40_study_id_seq]]></comment>
	</column>
	<column name="grantor" default-value="&quot;current_user&quot;()">
		<type name="character varying" length="90"/>
		<comment><![CDATA[Username doing grant]]></comment>
	</column>
	<column name="grantee_username" not-null="true">
		<type name="character varying" length="90"/>
		<comment><![CDATA[Username granted access by a RIF_MANAGER to study data]]></comment>
	</column>
	<constraint name="rif40_study_shares_pk" type="pk-constr" factor="100" table="rif40.rif40_study_shares">
		<columns names="study_id,grantee_username" ref-type="src-columns"/>
	</constraint>
	<index name="rif40_study_shares_grantee_bm" table="rif40.rif40_study_shares"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="grantee_username"/>
		</idxelement>
	</index>
	<index name="rif40_study_shares_grantor_bm" table="rif40.rif40_study_shares"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="grantor"/>
		</idxelement>
	</index>
	<trigger name="rif40_study_shares_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="rif40.rif40_study_shares">
		<comment><![CDATA[INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_study_shares_checks()]]></comment>
	<condition><![CDATA[((((new.grantor IS NOT NULL) AND ((new.grantor)::text <> ''::text)) OR ((new.grantee_username IS NOT NULL) AND ((new.grantee_username)::text <> ''::text))) OR ((new.study_id IS NOT NULL) AND ((new.study_id)::text <> ''::text)))]]></condition>
		<function signature="rif40_trg_pkg.trigger_fct_rif40_study_shares_checks()"/>
	</trigger>
	<trigger name="rif40_study_shares_checks_del" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="rif40.rif40_study_shares">
		<comment><![CDATA[DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_study_shares_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_rif40_study_shares_checks()"/>
	</trigger>
</table>

<table name="t_rif40_comparison_areas">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Links comparison areas and bands for a given study.]]></comment>
	<position x="1541.53" y="383.2"/>
	<column name="username" default-value="&quot;current_user&quot;()">
		<type name="character varying" length="90"/>
		<comment><![CDATA[Username]]></comment>
	</column>
	<column name="study_id" not-null="true" default-value="(currval('rif40_study_id_seq'::regclass))::integer">
		<type name="integer"/>
		<comment><![CDATA[Unique study index: study_id. Created by SEQUENCE rif40_study_id_seq]]></comment>
	</column>
	<column name="area_id" not-null="true">
		<type name="character varying" length="300"/>
		<comment><![CDATA[An area id, the value of a geolevel; i.e. the value of the column T_RIF40_GEOLEVELS.GEOLEVEL_NAME in table T_RIF40_GEOLEVELS.LOOKUP_TABLE]]></comment>
	</column>
	<constraint name="t_rif40_comparison_areas_pk" type="pk-constr" factor="100" table="rif40.t_rif40_comparison_areas">
		<columns names="study_id,area_id" ref-type="src-columns"/>
	</constraint>
	<index name="t_rif40_comp_areas_uname" table="rif40.t_rif40_comparison_areas"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="username"/>
		</idxelement>
	</index>
	<trigger name="t_rif40_comp_areas_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="rif40.t_rif40_comparison_areas">
		<comment><![CDATA[INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks()]]></comment>
	<condition><![CDATA[(((new.username IS NOT NULL) AND ((new.username)::text <> ''::text)) OR ((new.study_id IS NOT NULL) AND ((new.study_id)::text <> ''::text)))]]></condition>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks()"/>
	</trigger>
	<trigger name="t_rif40_comp_areas_checks2" firing-type="AFTER" per-line="false" constraint="false"
		 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="rif40.t_rif40_comparison_areas">
		<comment><![CDATA[INSERT trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks2()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks2()"/>
	</trigger>
	<trigger name="t_rif40_comp_areas_checks_del" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="rif40.t_rif40_comparison_areas">
		<comment><![CDATA[DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks()"/>
	</trigger>
</table>

<view name="user_role_privs">
	<schema name="rif40_sql_pkg"/>
	<role name="rif40"/>
	<comment><![CDATA[All roles granted to user]]></comment>
	<position x="2258.77" y="50"/>
	<reference>
		<expression><![CDATA[ SELECT upper((enabled_roles.role_name)::text) AS granted_role
   FROM information_schema.enabled_roles;]]></expression>
	</reference>
</view>

<view name="rif40_comparison_areas">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Links study areas and bands for a given study.]]></comment>
	<position x="707.366" y="3760.2"/>
	<reference>
		<expression><![CDATA[ SELECT c.username,
    c.study_id,
    c.area_id
   FROM (t_rif40_comparison_areas c
   LEFT JOIN rif40_study_shares s ON (((c.study_id = s.study_id) AND ((s.grantee_username)::name = "current_user"()))))
  WHERE ((((c.username)::name = "current_user"()) OR ('RIF_MANAGER'::text = ( SELECT user_role_privs.granted_role
      FROM user_role_privs
     WHERE (user_role_privs.granted_role = 'RIF_MANAGER'::text)))) OR ((s.grantee_username IS NOT NULL) AND ((s.grantee_username)::text <> ''::text)))
  ORDER BY c.username;]]></expression>
	</reference>
</view>

<sequence name="rif40_inv_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Used as sequence for unique study index: study_id; auto populated.]]></comment>
</sequence>

<table name="t_rif40_contextual_stats">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Contextual stats for results map. Also includes values used in internal calculations.]]></comment>
	<position x="50" y="566.4"/>
	<column name="username" default-value="&quot;current_user&quot;()">
		<type name="character varying" length="90"/>
		<comment><![CDATA[Username]]></comment>
	</column>
	<column name="study_id" not-null="true" default-value="(currval('rif40_study_id_seq'::regclass))::integer">
		<type name="integer"/>
		<comment><![CDATA[Unique study index: study_id. Created by SEQUENCE rif40_study_id_seq]]></comment>
	</column>
	<column name="inv_id" not-null="true" default-value="(currval('rif40_inv_id_seq'::regclass))::integer">
		<type name="integer"/>
		<comment><![CDATA[Unique investigation index: inv_id. Created by SEQUENCE rif40_inv_id_seq]]></comment>
	</column>
	<column name="area_id" not-null="true">
		<type name="integer"/>
		<comment><![CDATA[An area id, the value of a geolevel; i.e. the value of the column T_RIF40_GEOLEVELS.GEOLEVEL_NAME in table T_RIF40_GEOLEVELS.LOOKUP_TABLE]]></comment>
	</column>
	<column name="area_population">
		<type name="double precision"/>
		<comment><![CDATA[Total population in area]]></comment>
	</column>
	<column name="area_observed">
		<type name="double precision"/>
		<comment><![CDATA[Total observed in area]]></comment>
	</column>
	<column name="total_comparision_population">
		<type name="double precision"/>
		<comment><![CDATA[Total comparison population. Used for internal calculations.]]></comment>
	</column>
	<column name="variance_high">
		<type name="double precision"/>
		<comment><![CDATA[Variance (observed &gt; 100). Used for internal calculations.]]></comment>
	</column>
	<column name="variance_low">
		<type name="double precision"/>
		<comment><![CDATA[Variance (observed &lt;= 100). Used for internal calculations.]]></comment>
	</column>
	<constraint name="t_rif40_contextual_stats_pk" type="pk-constr" factor="100" table="rif40.t_rif40_contextual_stats">
		<columns names="study_id,area_id,inv_id" ref-type="src-columns"/>
	</constraint>
	<index name="t_rif40_constats_inv_id_fk" table="rif40.t_rif40_contextual_stats"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="inv_id"/>
		</idxelement>
	</index>
	<index name="t_rif40_constats_uname_bm" table="rif40.t_rif40_contextual_stats"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="username"/>
		</idxelement>
	</index>
	<trigger name="t_rif40_contextualstats_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="rif40.t_rif40_contextual_stats">
		<comment><![CDATA[INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_contextualstats_checks()]]></comment>
	<condition><![CDATA[(((((new.username IS NOT NULL) AND ((new.username)::text <> ''::text)) OR ((new.study_id IS NOT NULL) AND ((new.study_id)::text <> ''::text))) OR ((new.inv_id IS NOT NULL) AND ((new.inv_id)::text <> ''::text))) OR ((new.area_id IS NOT NULL) AND ((new.area_id)::text <> ''::text)))]]></condition>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_contextualstats_checks()"/>
	</trigger>
	<trigger name="t_rif40_contextualstats_checks_del" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="rif40.t_rif40_contextual_stats">
		<comment><![CDATA[DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_contextualstats_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_contextualstats_checks()"/>
	</trigger>
</table>

<view name="rif40_contextual_stats">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Contextual stats for results map. Also includes values used in internal calculations.]]></comment>
	<position x="939.966" y="3760.2"/>
	<reference>
		<expression><![CDATA[ SELECT c.username,
    c.study_id,
    c.inv_id,
    c.area_id,
    c.area_population,
    c.area_observed,
    c.total_comparision_population,
    c.variance_high,
    c.variance_low
   FROM (t_rif40_contextual_stats c
   LEFT JOIN rif40_study_shares s ON (((c.study_id = s.study_id) AND ((s.grantee_username)::name = "current_user"()))))
  WHERE ((((c.username)::name = "current_user"()) OR ('RIF_MANAGER'::text = ( SELECT user_role_privs.granted_role
      FROM user_role_privs
     WHERE (user_role_privs.granted_role = 'RIF_MANAGER'::text)))) OR ((s.grantee_username IS NOT NULL) AND ((s.grantee_username)::text <> ''::text)))
  ORDER BY c.username;]]></expression>
	</reference>
</view>

<table name="rif40_covariates">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF multiple covariates]]></comment>
	<position x="487.766" y="566.4"/>
	<column name="geography" not-null="true">
		<type name="character varying" length="50"/>
		<comment><![CDATA[Geography (e.g EW2001)]]></comment>
	</column>
	<column name="geolevel_name" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Name of geolevel. This will be a column name in the numerator/denominator tables]]></comment>
	</column>
	<column name="covariate_name" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Covariate name. This will be a column name in RIF40_GEOLEVELS.COVARIATE_TABLE]]></comment>
	</column>
	<column name="min" not-null="true">
		<type name="double precision"/>
		<comment><![CDATA[Minimum value]]></comment>
	</column>
	<column name="max" not-null="true">
		<type name="double precision"/>
		<comment><![CDATA[Maximum value]]></comment>
	</column>
	<column name="type" not-null="true">
		<type name="double precision"/>
		<comment><![CDATA[TYPE of covariate (1=integer score/2=continuous variable). Min &lt; max  max/min precison is appropriate to type. Continuous variables are not currently supported. Integer scores can be a binary variable 0/1 or an NTILE e.g. 1..5 for a quintile.]]></comment>
	</column>
	<constraint name="rif40_covariates_listing_ck" type="ck-constr" table="rif40.rif40_covariates">
			<expression><![CDATA[(type = ANY (ARRAY[(1)::double precision, (2)::double precision]))]]></expression>
	</constraint>
	<constraint name="rif40_covariates_pk" type="pk-constr" factor="100" table="rif40.rif40_covariates">
		<columns names="geography,geolevel_name,covariate_name" ref-type="src-columns"/>
	</constraint>
	<trigger name="rif40_covariates_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="rif40.rif40_covariates">
		<comment><![CDATA[INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_covariates_checks()]]></comment>
	<condition><![CDATA[(((((new.covariate_name IS NOT NULL) AND ((new.covariate_name)::text <> ''::text)) OR ((new.max IS NOT NULL) AND ((new.max)::text <> ''::text))) OR ((new.min IS NOT NULL) AND ((new.min)::text <> ''::text))) OR ((new.type IS NOT NULL) AND ((new.type)::text <> ''::text)))]]></condition>
		<function signature="rif40_trg_pkg.trigger_fct_rif40_covariates_checks()"/>
	</trigger>
	<trigger name="rif40_covariates_checks_del" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="rif40.rif40_covariates">
		<comment><![CDATA[DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_covariates_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_rif40_covariates_checks()"/>
	</trigger>
</table>

<table name="rif40_dual">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF40 version of dual table (for remote execution on Postgres)]]></comment>
	<position x="890.531" y="566.4"/>
	<column name="dummy">
		<type name="character varying"/>
		<comment><![CDATA[Dummy column]]></comment>
	</column>
</table>

<table name="rif40_error_messages">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF error messages resulting from schema violations]]></comment>
	<position x="1108.53" y="566.4"/>
	<column name="error_code" not-null="true">
		<type name="integer"/>
		<comment><![CDATA[Error code]]></comment>
	</column>
	<column name="tag" not-null="true">
		<type name="character varying" length="80"/>
		<comment><![CDATA[Contextual tag for error code]]></comment>
	</column>
	<column name="table_name">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Table raising error. If NULL, procedure or other code.]]></comment>
	</column>
	<column name="cause" not-null="true">
		<type name="character varying" length="4000"/>
		<comment><![CDATA[Cause of error]]></comment>
	</column>
	<column name="action" not-null="true">
		<type name="character varying" length="512"/>
		<comment><![CDATA[Action to resolve error]]></comment>
	</column>
	<column name="message" not-null="true">
		<type name="character varying" length="512"/>
		<comment><![CDATA[Error message]]></comment>
	</column>
	<constraint name="rif40_error_messages_code_ck" type="ck-constr" table="rif40.rif40_error_messages">
			<expression><![CDATA[((error_code = ANY (ARRAY[(-1), (-4088), (-2290), (-2291)])) OR ((error_code >= (-20999)) AND (error_code <= (-20000))))]]></expression>
	</constraint>
	<constraint name="rif40_error_messages_pk" type="pk-constr" factor="100" table="rif40.rif40_error_messages">
		<columns names="error_code,tag" ref-type="src-columns"/>
	</constraint>
	<trigger name="rif40_error_messages_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="rif40.rif40_error_messages">
		<comment><![CDATA[INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_error_messages_checks()]]></comment>
	<condition><![CDATA[((new.table_name IS NOT NULL) AND ((new.table_name)::text <> ''::text))]]></condition>
		<function signature="rif40_trg_pkg.trigger_fct_rif40_error_messages_checks()"/>
	</trigger>
	<trigger name="rif40_error_messages_checks_del" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="rif40.rif40_error_messages">
		<comment><![CDATA[DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_error_messages_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_rif40_error_messages_checks()"/>
	</trigger>
</table>

<table name="t_rif40_geolevels">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Geolevels: hierarchy of level with a geography. Use this table for INSERT/UPDATE/DELETE; use RIF40_GEOLEVELS for SELECT. In RIF40_GEOLEVELS if the user has the RIF_STUDENT role the geolevels are restricted to LADUA/DISTRICT level resolution or lower.]]></comment>
	<position x="1559.3" y="566.4"/>
	<column name="geography" not-null="true">
		<type name="character varying" length="50"/>
		<comment><![CDATA[Geography (e.g EW2001)]]></comment>
	</column>
	<column name="geolevel_name" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Name of geolevel. This will be a column name in the numerator/denominator tables]]></comment>
	</column>
	<column name="geolevel_id" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[ID for ordering (1=lowest resolution). Up to 99 supported.]]></comment>
	</column>
	<column name="description" not-null="true">
		<type name="character varying" length="250"/>
		<comment><![CDATA[Description]]></comment>
	</column>
	<column name="lookup_table" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Lookup table name. This is used to translate codes to the common names, e.g a LADUA of 00BK is &quot;Westminster&quot;]]></comment>
	</column>
	<column name="lookup_desc_column" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Lookup table description column name.]]></comment>
	</column>
	<column name="centroidxcoordinate_column">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Lookup table centroid X co-ordinate column name. Can also use CENTROIDSFILE instead.]]></comment>
	</column>
	<column name="centroidycoordinate_column">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Lookup table centroid Y co-ordinate column name.]]></comment>
	</column>
	<column name="shapefile">
		<type name="character varying" length="512"/>
		<comment><![CDATA[Location of the GIS shape file. NULL if PostGress/PostGIS used. Can also use SHAPEFILE_GEOMETRY instead,]]></comment>
	</column>
	<column name="centroidsfile">
		<type name="character varying" length="512"/>
		<comment><![CDATA[Location of the GIS centroids file. Can also use CENTROIDXCOORDINATE_COLUMN, CENTROIDYCOORDINATE_COLUMN instead.]]></comment>
	</column>
	<column name="shapefile_table">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Table containing GIS shape file data (created using shp2pgsql).]]></comment>
	</column>
	<column name="shapefile_area_id_column">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Column containing the AREA_IDs in SHAPEFILE_TABLE]]></comment>
	</column>
	<column name="shapefile_desc_column">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Column containing the AREA_ID descriptions in SHAPEFILE_TABLE]]></comment>
	</column>
	<column name="st_simplify_tolerance">
		<type name="integer"/>
		<comment><![CDATA[ST_SimplifyPreserveTopology(geom, st_simplify_tolerance) simplification parameter. Minimum length of a vector in the Douglas-Peucker alogorithm. The actual minimum length (see: ?) is normally 3-4x this parameter. Setting this parameter >20 will result in small slivers as ST_SimplifyPreserveTopology() processes on an object by object basis. Where two objects touch there is no guarantee that vectors in each object will be processed in the same way. Values of up to 1 (the projection unit is usually a metre) massively reduce points with minimal loss in resolution. Values up to 20 result in very small slivers for small objects (e.g. Census output area). Unfortunately the number of points effects the size of the GeoJSON files, so for most geolevels values of 20-500 are needed to create a sanely sized GeoJSON file. The best way to resolve the problem is to reduce to resolution of the input shapefile in ArcGIS to the amount that produces an optimal map at the highest resolution geolevel and simplify from there. It is also possible to sinmplify using the PostGIS Topolgy extension if the shapefile is well formed.]]></comment>
	</column>
	<column name="centroids_table">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Table containing GIS shape file data with Arc GIS calculated population weighted centroids (created using shp2pgsql). PostGIS does not support population weighted centroids.]]></comment>
	</column>
	<column name="centroids_area_id_column">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Column containing the AREA_IDs in CENTROIDS_TABLE. X and Y co-ordinates ciolumns are asummed to be named after CENTROIDXCOORDINATE_COLUMN and CENTROIDYCOORDINATE_COLUMN.]]></comment>
	</column>
	<column name="avg_npoints_geom">
		<type name="bigint"/>
		<comment><![CDATA[Average number of points in a geometry object (AREA_ID). Used to evaluation the impact of ST_SIMPLIFY_TOLERANCE.]]></comment>
	</column>
	<column name="avg_npoints_opt">
		<type name="bigint"/>
		<comment><![CDATA[Average number of points in a ST_SimplifyPreserveTopology() optimsed geometry object (AREA_ID). Used to evaluation the impact of ST_SIMPLIFY_TOLERANCE.]]></comment>
	</column>
	<column name="file_geojson_len">
		<type name="bigint"/>
		<comment><![CDATA[File length estimate (in bytes) for conversion of the entire geolevel geometry to GeoJSON. Used to evaluation the impact of ST_SIMPLIFY_TOLERANCE.]]></comment>
	</column>
	<column name="leg_geom">
		<type name="double precision"/>
		<comment><![CDATA[The average length (in projection units - usually metres) of a vector leg. Used to evaluation the impact of ST_SIMPLIFY_TOLERANCE.]]></comment>
	</column>
	<column name="leg_opt">
		<type name="double precision"/>
		<comment><![CDATA[The average length (in projection units - usually metres) of a ST_SimplifyPreserveTopology() optimsed geometryvector leg. Used to evaluation the impact of ST_SIMPLIFY_TOLERANCE.]]></comment>
	</column>
	<column name="covariate_table">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Name of table used for covariates at this geolevel]]></comment>
	</column>
	<column name="restricted" default-value="0">
		<type name="smallint"/>
		<comment><![CDATA[Is geolevel access rectricted by Inforamtion Governance restrictions (0/1). If 1 (Yes) then a) students cannot access this geolevel and b) if the system parameter ExtractControl=1 then the user must be granted permission by a RIF_MANAGER to extract from the database the results, data extract and maps tables. This is enforced by the RIF application.]]></comment>
	</column>
	<column name="resolution" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Can use a map for selection at this resolution (0/1)]]></comment>
	</column>
	<column name="comparea" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Able to be used as a comparison area (0/1)]]></comment>
	</column>
	<column name="listing" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Able to be used in a disease map listing (0/1)]]></comment>
	</column>
	<constraint name="t_rif40_geol_comparea_ck" type="ck-constr" table="rif40.t_rif40_geolevels">
			<expression><![CDATA[(comparea = ANY (ARRAY[0, 1]))]]></expression>
	</constraint>
	<constraint name="t_rif40_geol_listing_ck" type="ck-constr" table="rif40.t_rif40_geolevels">
			<expression><![CDATA[(listing = ANY (ARRAY[0, 1]))]]></expression>
	</constraint>
	<constraint name="t_rif40_geol_resolution_ck" type="ck-constr" table="rif40.t_rif40_geolevels">
			<expression><![CDATA[(resolution = ANY (ARRAY[0, 1]))]]></expression>
	</constraint>
	<constraint name="t_rif40_geol_restricted_ck" type="ck-constr" table="rif40.t_rif40_geolevels">
			<expression><![CDATA[(restricted = ANY (ARRAY[0, 1]))]]></expression>
	</constraint>
	<constraint name="t_rif40_geolevels_pk" type="pk-constr" factor="100" table="rif40.t_rif40_geolevels">
		<columns names="geography,geolevel_name" ref-type="src-columns"/>
	</constraint>
	<index name="t_rif40_geolevels_uk2" table="rif40.t_rif40_geolevels"
		 concurrent="false" unique="true" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="geography"/>
		</idxelement>
		<idxelement use-sorting="false">
			<column name="geolevel_id"/>
		</idxelement>
	</index>
	<trigger name="t_rif40_geolevels_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="rif40.t_rif40_geolevels">
		<comment><![CDATA[INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_geolevels_checks()]]></comment>
	<condition><![CDATA[((((((((new.lookup_table IS NOT NULL) AND ((new.lookup_table)::text <> ''::text)) OR ((new.covariate_table IS NOT NULL) AND ((new.covariate_table)::text <> ''::text))) OR ((new.lookup_desc_column IS NOT NULL) AND ((new.lookup_desc_column)::text <> ''::text))) OR ((new.centroidxcoordinate_column IS NOT NULL) AND ((new.centroidxcoordinate_column)::text <> ''::text))) OR ((new.centroidycoordinate_column IS NOT NULL) AND ((new.centroidycoordinate_column)::text <> ''::text))) OR ((new.geography IS NOT NULL) AND ((new.geography)::text <> ''::text))) OR ((new.geolevel_name IS NOT NULL) AND ((new.geolevel_name)::text <> ''::text)))]]></condition>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_geolevels_checks()"/>
	</trigger>
	<trigger name="t_rif40_geolevels_checks_del" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="rif40.t_rif40_geolevels">
		<comment><![CDATA[DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_geolevels_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_geolevels_checks()"/>
	</trigger>
</table>

<view name="rif40_geolevels">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Geolevels: hierarchy of level with a geography. Use this table for SELECT; use T_RIF40_GEOLEVELS for INSERT/UPDATE/DELETE. View with RIF_STUDENT security context support. If the user has the RIF_STUDENT role the geolevels are restricted to e.g. LADUA/DISTRICT level resolution or lower. This is controlled by the RESTRICTED field.]]></comment>
	<position x="1172.57" y="3760.2"/>
	<reference>
		<expression><![CDATA[         SELECT a.geography,
            a.geolevel_name,
            a.geolevel_id,
            a.description,
            a.lookup_table,
            a.lookup_desc_column,
            a.shapefile,
            a.centroidsfile,
            a.shapefile_table,
            a.shapefile_area_id_column,
            a.shapefile_desc_column,
            a.st_simplify_tolerance,
            a.centroids_table,
            a.centroids_area_id_column,
            a.avg_npoints_geom,
            a.avg_npoints_opt,
            a.file_geojson_len,
            a.leg_geom,
            a.leg_opt,
            a.covariate_table,
            a.resolution,
            a.comparea,
            a.listing,
            a.restricted,
            a.centroidxcoordinate_column,
            a.centroidycoordinate_column
           FROM t_rif40_geolevels a
          WHERE (((sys_context('SAHSU_CONTEXT'::character varying, 'RIF_STUDENT'::character varying))::text = 'YES'::text) AND (a.restricted <> 1))
UNION
         SELECT a.geography,
            a.geolevel_name,
            a.geolevel_id,
            a.description,
            a.lookup_table,
            a.lookup_desc_column,
            a.shapefile,
            a.centroidsfile,
            a.shapefile_table,
            a.shapefile_area_id_column,
            a.shapefile_desc_column,
            a.st_simplify_tolerance,
            a.centroids_table,
            a.centroids_area_id_column,
            a.avg_npoints_geom,
            a.avg_npoints_opt,
            a.file_geojson_len,
            a.leg_geom,
            a.leg_opt,
            a.covariate_table,
            a.resolution,
            a.comparea,
            a.listing,
            a.restricted,
            a.centroidxcoordinate_column,
            a.centroidycoordinate_column
           FROM t_rif40_geolevels a
          WHERE ((sys_context('SAHSU_CONTEXT'::character varying, 'RIF_STUDENT'::character varying) IS NULL) OR ((sys_context('SAHSU_CONTEXT'::character varying, 'RIF_STUDENT'::character varying))::text = 'NO'::text))
  ORDER BY 1, 3 DESC;]]></expression>
	</reference>
</view>

<table name="rif40_icd10">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[ICD10 code (SAHSU historic version, needs to be updated)]]></comment>
	<position x="50" y="1079.6"/>
	<column name="icd10_1char">
		<type name="character varying" length="20"/>
		<comment><![CDATA[ICD10 chapter]]></comment>
	</column>
	<column name="icd10_3char">
		<type name="character varying" length="3"/>
		<comment><![CDATA[3 Character ICD10 code]]></comment>
	</column>
	<column name="icd10_4char" not-null="true">
		<type name="character varying" length="4"/>
		<comment><![CDATA[4 Character ICD10 code]]></comment>
	</column>
	<column name="text_1char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[ICD10 chapter textual description]]></comment>
	</column>
	<column name="text_3char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[3 Character ICD10 textual description]]></comment>
	</column>
	<column name="text_4char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[4 Character ICD10 textual description]]></comment>
	</column>
	<constraint name="rif40_icd10_pk" type="pk-constr" factor="100" table="rif40.rif40_icd10">
		<columns names="icd10_4char" ref-type="src-columns"/>
	</constraint>
	<index name="rif40_icd10_1char_bm" table="rif40.rif40_icd10"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="icd10_1char"/>
		</idxelement>
	</index>
	<index name="rif40_icd10_3char_bm" table="rif40.rif40_icd10"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="icd10_3char"/>
		</idxelement>
	</index>
</table>

<table name="rif40_icd9">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[ICD9 code (SAHSU historic version, needs to be updated)]]></comment>
	<position x="384" y="1079.6"/>
	<column name="icd9_3char">
		<type name="character varying" length="3"/>
		<comment><![CDATA[3 Character ICD9 code]]></comment>
	</column>
	<column name="icd9_4char" not-null="true">
		<type name="character varying" length="4"/>
		<comment><![CDATA[4 Character ICD9 code]]></comment>
	</column>
	<column name="text_3char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[3 Character ICD9 textual description]]></comment>
	</column>
	<column name="text_4char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[4 Character ICD9 textual description]]></comment>
	</column>
	<constraint name="rif40_icd9_pk" type="pk-constr" factor="100" table="rif40.rif40_icd9">
		<columns names="icd9_4char" ref-type="src-columns"/>
	</constraint>
	<index name="rif40_icd9_3char_bm" table="rif40.rif40_icd9"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="icd9_3char"/>
		</idxelement>
	</index>
</table>

<table name="rif40_icd_o_3">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[International Classification of Disease for Oncology]]></comment>
	<position x="711" y="1079.6"/>
	<column name="icd_o_3_1char">
		<type name="character varying" length="20"/>
		<comment><![CDATA[ICD-O-3 chapter]]></comment>
	</column>
	<column name="icd_o_3_4char" not-null="true">
		<type name="character varying" length="4"/>
		<comment><![CDATA[4 Character ICD-O-3 code]]></comment>
	</column>
	<column name="text_1char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[ICD-O-3 chapter textual description]]></comment>
	</column>
	<column name="text_4char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[4 Character ICD-O-3 textual description]]></comment>
	</column>
	<constraint name="rif40_icd_o_3_pk" type="pk-constr" factor="100" table="rif40.rif40_icd_o_3">
		<columns names="icd_o_3_4char" ref-type="src-columns"/>
	</constraint>
	<index name="rif40_icd_o_3_1char_bm" table="rif40.rif40_icd_o_3"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="icd_o_3_1char"/>
		</idxelement>
	</index>
</table>

<table name="t_rif40_inv_conditions">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Lines of SQL conditions pertinent to an investigation.]]></comment>
	<position x="1059" y="1079.6"/>
	<column name="inv_id" not-null="true" default-value="(currval('rif40_inv_id_seq'::regclass))::integer">
		<type name="integer"/>
		<comment><![CDATA[Unique investigation index: inv_id. Created by SEQUENCE rif40_inv_id_seq]]></comment>
	</column>
	<column name="study_id" not-null="true" default-value="(currval('rif40_study_id_seq'::regclass))::integer">
		<type name="integer"/>
		<comment><![CDATA[Unique study index: study_id. Created by SEQUENCE rif40_study_id_seq]]></comment>
	</column>
	<column name="username" default-value="&quot;current_user&quot;()">
		<type name="character varying" length="90"/>
		<comment><![CDATA[Username]]></comment>
	</column>
	<column name="line_number" not-null="true" default-value="1">
		<type name="integer"/>
		<comment><![CDATA[Line number]]></comment>
	</column>
	<column name="condition" default-value="'1=1'::character varying">
		<type name="character varying" length="4000"/>
		<comment><![CDATA[SQL WHERE clause, with the WHERE keyword omitted). Default to 1=1 (use all records matching year/age/sex criteria). Checked for SQL injection.]]></comment>
	</column>
	<constraint name="t_rif40_inv_conditions_pk" type="pk-constr" factor="100" table="rif40.t_rif40_inv_conditions">
		<columns names="study_id,inv_id,line_number" ref-type="src-columns"/>
	</constraint>
	<trigger name="t_rif40_inv_conditions_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="true" upd-event="true" trunc-event="false"
	 table="rif40.t_rif40_inv_conditions">
		<comment><![CDATA[INSERT OR UPDATE OR DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_inv_conditions_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_inv_conditions_checks()"/>
	</trigger>
</table>

<view name="rif40_inv_conditions">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Lines of SQL conditions pertinent to an investigation.]]></comment>
	<position x="50" y="3928.4"/>
	<reference>
		<expression><![CDATA[ SELECT c.username,
    c.study_id,
    c.inv_id,
    c.line_number,
    c.condition
   FROM (t_rif40_inv_conditions c
   LEFT JOIN rif40_study_shares s ON (((c.study_id = s.study_id) AND ((s.grantee_username)::name = "current_user"()))))
  WHERE ((((c.username)::name = "current_user"()) OR ('RIF_MANAGER'::text = ( SELECT user_role_privs.granted_role
      FROM user_role_privs
     WHERE (user_role_privs.granted_role = 'RIF_MANAGER'::text)))) OR ((s.grantee_username IS NOT NULL) AND ((s.grantee_username)::text <> ''::text)))
  ORDER BY c.username;]]></expression>
	</reference>
</view>

<table name="t_rif40_inv_covariates">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Details of each covariate used by an investigation in a study]]></comment>
	<position x="1490.77" y="1079.6"/>
	<column name="inv_id" not-null="true" default-value="(currval('rif40_inv_id_seq'::regclass))::integer">
		<type name="integer"/>
		<comment><![CDATA[Unique investigation index: inv_id. Created by SEQUENCE rif40_inv_id_seq]]></comment>
	</column>
	<column name="study_id" not-null="true" default-value="(currval('rif40_study_id_seq'::regclass))::integer">
		<type name="integer"/>
		<comment><![CDATA[Unique study index: study_id. Created by SEQUENCE rif40_study_id_seq]]></comment>
	</column>
	<column name="covariate_name" not-null="true">
		<type name="character varying" length="20"/>
		<comment><![CDATA[Covariate name]]></comment>
	</column>
	<column name="username" default-value="&quot;current_user&quot;()">
		<type name="character varying" length="90"/>
		<comment><![CDATA[Username]]></comment>
	</column>
	<column name="geography" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Geography (e.g EW2001). Cannot be changed by the user; present to allow a foreign key to be enforced.]]></comment>
	</column>
	<column name="study_geolevel_name">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Study area geolevel name. Must be a valid GEOLEVEL_NAME for the study GEOGRPAHY in T_RIF40_GEOLEVELS. Cannot be changed by the user; present to allow a foreign key to be enforced.]]></comment>
	</column>
	<column name="min" not-null="true">
		<type name="double precision"/>
		<comment><![CDATA[Minimum value for a covariate]]></comment>
	</column>
	<column name="max" not-null="true">
		<type name="double precision"/>
		<comment><![CDATA[Maximum value for a covariate]]></comment>
	</column>
	<constraint name="t_rif40_inv_covariates_pk" type="pk-constr" factor="100" table="rif40.t_rif40_inv_covariates">
		<columns names="study_id,inv_id,covariate_name" ref-type="src-columns"/>
	</constraint>
	<trigger name="t_rif40_inv_covariates_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="true" upd-event="true" trunc-event="false"
	 table="rif40.t_rif40_inv_covariates">
		<comment><![CDATA[INSERT OR UPDATE OR DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_inv_covariates_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_inv_covariates_checks()"/>
	</trigger>
</table>

<view name="rif40_inv_covariates">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Details of each covariate used by an investigation in a study]]></comment>
	<position x="282.6" y="3928.4"/>
	<reference>
		<expression><![CDATA[ SELECT c.username,
    c.study_id,
    c.inv_id,
    c.covariate_name,
    c.min,
    c.max,
    c.geography,
    c.study_geolevel_name
   FROM (t_rif40_inv_covariates c
   LEFT JOIN rif40_study_shares s ON (((c.study_id = s.study_id) AND ((s.grantee_username)::name = "current_user"()))))
  WHERE ((((c.username)::name = "current_user"()) OR ('RIF_MANAGER'::text = ( SELECT user_role_privs.granted_role
      FROM user_role_privs
     WHERE (user_role_privs.granted_role = 'RIF_MANAGER'::text)))) OR ((s.grantee_username IS NOT NULL) AND ((s.grantee_username)::text <> ''::text)))
  ORDER BY c.username;]]></expression>
	</reference>
</view>

<table name="t_rif40_investigations">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Details of each investigation in a study]]></comment>
	<position x="50" y="1292.8"/>
	<column name="inv_id" not-null="true" default-value="(nextval('rif40_inv_id_seq'::regclass))::integer">
		<type name="integer"/>
		<comment><![CDATA[Unique investigation index: inv_id. Created by SEQUENCE rif40_inv_id_seq]]></comment>
	</column>
	<column name="study_id" not-null="true" default-value="(currval('rif40_study_id_seq'::regclass))::integer">
		<type name="integer"/>
		<comment><![CDATA[Unique study index: study_id. Created by SEQUENCE rif40_study_id_seq]]></comment>
	</column>
	<column name="username" default-value="&quot;current_user&quot;()">
		<type name="character varying" length="90"/>
		<comment><![CDATA[Username]]></comment>
	</column>
	<column name="geography" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Geography (e.g EW2001)]]></comment>
	</column>
	<column name="inv_name" not-null="true">
		<type name="character varying" length="20"/>
		<comment><![CDATA[Name of investigation. Must be a valid database column name, i.e. only contain A-Z0-9_ and start with a letter.]]></comment>
	</column>
	<column name="inv_description" not-null="true">
		<type name="character varying" length="250"/>
		<comment><![CDATA[Description of investigation]]></comment>
	</column>
	<column name="classifier" default-value="'QUANTILE'::character varying">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Maps classifier. EQUAL_INTERVAL: each classifier band represents the same sized range and intervals change based on max an min, JENKS: Jenks natural breaks, QUANTILE: equiheight (even number) distribution, STANDARD_DEVIATION, UNIQUE_INTERVAL: a version of EQUAL_INTERVAL that takes into account unique values, &lt;BESPOKE&gt;; default QUANTILE. &lt;BESPOKE&gt; classification bands are defined in: RIF40_CLASSFIER_BANDS, RIF40_CLASSFIER_BAND_NAMES and are used to create maps that are comparable accross investigations]]></comment>
	</column>
	<column name="classifier_bands" default-value="5">
		<type name="smallint"/>
		<comment><![CDATA[Map classifier bands; default 5. Must be between 2 and 20]]></comment>
	</column>
	<column name="genders" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Genders to be investigated: 1 - males, 2 female or 3 - both]]></comment>
	</column>
	<column name="numer_tab" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Numerator table name. May be &quot;DUMMY&quot; if extract created outside of the RIF.]]></comment>
	</column>
	<column name="year_start" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Year investigation is to start. Must be between the limnits specified in the numerator and denominator tables]]></comment>
	</column>
	<column name="year_stop" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Year investigation is to stop]]></comment>
	</column>
	<column name="max_age_group" not-null="true">
		<type name="integer"/>
		<comment><![CDATA[Maximum age group (LOW_AGE to HIGH_AGE) in RIF40_AGE_GROUPS. OFFSET must be &gt; MIN_AGE_GROUP OFFSET, and a valid AGE_GROUP_ID in RIF40_AGE_GROUP_NAMES.AGE_GROUP_NAME]]></comment>
	</column>
	<column name="min_age_group" not-null="true">
		<type name="integer"/>
		<comment><![CDATA[Minimum age group (LOW_AGE to HIGH_AGE) in RIF40_AGE_GROUPS. OFFSET must be &lt; MAX_AGE_GROUP OFFSET, and a valid AGE_GROUP_ID in RIF40_AGE_GROUP_NAMES.AGE_GROUP_NAME]]></comment>
	</column>
	<column name="investigation_state" default-value="'C'::character varying">
		<type name="character varying"/>
		<comment><![CDATA[Investigation state - C: created, not verfied; V: verified, but no other work done; E - extracted imported or created, but no results or maps created; R: results computed; U: upgraded record from V3.1 RIF (has an indeterminate state; probably R.]]></comment>
	</column>
	<column name="mh_test_type" default-value="'No Test'::character varying">
		<type name="character varying" length="50"/>
		<comment><![CDATA[Mantel-Haenszel test type: &quot;No test&quot;, &quot;Comparison Areas&quot;, &quot;Unexposed Area&quot;.]]></comment>
	</column>
	<constraint name="t_rif40_inv_class_bands_ck" type="ck-constr" table="rif40.t_rif40_investigations">
			<expression><![CDATA[((classifier_bands >= 2) AND (classifier_bands <= 20))]]></expression>
	</constraint>
	<constraint name="t_rif40_inv_classifier_ck" type="ck-constr" table="rif40.t_rif40_investigations">
			<expression><![CDATA[((classifier)::text = ANY (ARRAY[('EQUAL_INTERVAL'::character varying)::text, ('JENKS'::character varying)::text, ('QUANTILE'::character varying)::text, ('STANDARD_DEVIATION'::character varying)::text, ('UNIQUE_INTERVAL'::character varying)::text]))]]></expression>
	</constraint>
	<constraint name="t_rif40_inv_genders_ck" type="ck-constr" table="rif40.t_rif40_investigations">
			<expression><![CDATA[((genders >= 1) AND (genders <= 3))]]></expression>
	</constraint>
	<constraint name="t_rif40_inv_mh_test_type_ck" type="ck-constr" table="rif40.t_rif40_investigations">
			<expression><![CDATA[((mh_test_type)::text = ANY (ARRAY[('No Test'::character varying)::text, ('Comparison Areas'::character varying)::text, ('Unexposed Area'::character varying)::text]))]]></expression>
	</constraint>
	<constraint name="t_rif40_inv_state_ck" type="ck-constr" table="rif40.t_rif40_investigations">
			<expression><![CDATA[((investigation_state)::text = ANY (ARRAY[('C'::character varying)::text, ('V'::character varying)::text, ('E'::character varying)::text, ('R'::character varying)::text, ('U'::character varying)::text]))]]></expression>
	</constraint>
	<constraint name="t_rif40_investigations_pk" type="pk-constr" factor="100" table="rif40.t_rif40_investigations">
		<columns names="study_id,inv_id" ref-type="src-columns"/>
	</constraint>
	<trigger name="t_rif40_investigations_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="rif40.t_rif40_investigations">
		<comment><![CDATA[DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_investigations_checks()]]></comment>
	<condition><![CDATA[(((((((((((((((((new.username IS NOT NULL) AND ((new.username)::text <> ''::text)) OR ((new.inv_name IS NOT NULL) AND ((new.inv_name)::text <> ''::text))) OR ((new.inv_description IS NOT NULL) AND ((new.inv_description)::text <> ''::text))) OR ((new.year_start IS NOT NULL) AND ((new.year_start)::text <> ''::text))) OR ((new.year_stop IS NOT NULL) AND ((new.year_stop)::text <> ''::text))) OR ((new.max_age_group IS NOT NULL) AND ((new.max_age_group)::text <> ''::text))) OR ((new.min_age_group IS NOT NULL) AND ((new.min_age_group)::text <> ''::text))) OR ((new.genders IS NOT NULL) AND ((new.genders)::text <> ''::text))) OR ((new.investigation_state IS NOT NULL) AND ((new.investigation_state)::text <> ''::text))) OR ((new.numer_tab IS NOT NULL) AND ((new.numer_tab)::text <> ''::text))) OR ((new.geography IS NOT NULL) AND ((new.geography)::text <> ''::text))) OR ((new.study_id IS NOT NULL) AND ((new.study_id)::text <> ''::text))) OR ((new.inv_id IS NOT NULL) AND ((new.inv_id)::text <> ''::text))) OR ((new.classifier IS NOT NULL) AND ((new.classifier)::text <> ''::text))) OR ((new.classifier_bands IS NOT NULL) AND ((new.classifier_bands)::text <> ''::text))) OR ((new.mh_test_type IS NOT NULL) AND ((new.mh_test_type)::text <> ''::text)))]]></condition>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_investigations_checks()"/>
	</trigger>
	<trigger name="t_rif40_investigations_checks_del" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="rif40.t_rif40_investigations">
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_investigations_checks()"/>
	</trigger>
</table>

<view name="rif40_investigations">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Details of each investigation in a study]]></comment>
	<position x="515.2" y="3928.4"/>
	<reference>
		<expression><![CDATA[ SELECT c.username,
    c.inv_id,
    c.study_id,
    c.inv_name,
    c.year_start,
    c.year_stop,
    c.max_age_group,
    c.min_age_group,
    c.genders,
    c.numer_tab,
    c.mh_test_type,
    c.geography,
    c.inv_description,
    c.classifier,
    c.classifier_bands,
    c.investigation_state
   FROM (t_rif40_investigations c
   LEFT JOIN rif40_study_shares s ON (((c.study_id = s.study_id) AND ((s.grantee_username)::name = "current_user"()))))
  WHERE ((((c.username)::name = "current_user"()) OR ('RIF_MANAGER'::text = ( SELECT user_role_privs.granted_role
      FROM user_role_privs
     WHERE (user_role_privs.granted_role = 'RIF_MANAGER'::text)))) OR ((s.grantee_username IS NOT NULL) AND ((s.grantee_username)::text <> ''::text)))
  ORDER BY c.username;]]></expression>
	</reference>
</view>

<view name="rif40_num_denom">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Numerator and indirect standardisation denominator pairs. Use RIF40_NUM_DENOM_ERROR if your numerator and denominator table pair is missing. You must have your own copy of RIF40_NUM_DENOM or you will only see the tables RIF40 has access to. Tables not rejected if the user does not have access or the table does not contain the correct geography geolevel fields.]]></comment>
	<position x="747.8" y="3928.4"/>
	<reference>
		<expression><![CDATA[ WITH n AS (
         SELECT n1.geography,
            n1.numerator_table,
            n1.numerator_description,
            n1.automatic,
            n1.theme_description
           FROM ( SELECT g.geography,
                    n_1.table_name AS numerator_table,
                    n_1.description AS numerator_description,
                    n_1.automatic,
                    t.description AS theme_description
                   FROM rif40_geographies g,
                    rif40_tables n_1,
                    rif40_health_study_themes t
                  WHERE ((((n_1.isnumerator = 1) AND (n_1.automatic = 1)) AND (rif40_is_object_resolvable(n_1.table_name) = 1)) AND ((n_1.theme)::text = (t.theme)::text))) n1
          WHERE (rif40_num_denom_validate(n1.geography, n1.numerator_table) = 1)
        ), d AS (
         SELECT d1.geography,
            d1.denominator_table,
            d1.denominator_description
           FROM ( SELECT g.geography,
                    d_1.table_name AS denominator_table,
                    d_1.description AS denominator_description
                   FROM rif40_geographies g,
                    rif40_tables d_1
                  WHERE (((d_1.isindirectdenominator = 1) AND (d_1.automatic = 1)) AND (rif40_is_object_resolvable(d_1.table_name) = 1))) d1
          WHERE ((rif40_num_denom_validate(d1.geography, d1.denominator_table) = 1) AND (rif40_auto_indirect_checks(d1.denominator_table) IS NULL))
        )
 SELECT n.geography,
    n.numerator_table,
    n.numerator_description,
    n.theme_description,
    d.denominator_table,
    d.denominator_description,
    n.automatic
   FROM n,
    d
  WHERE ((n.geography)::text = (d.geography)::text)
  ORDER BY n.geography, n.numerator_table, n.theme_description;]]></expression>
	</reference>
</view>

<view name="rif40_num_denom_errors">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[All possible numerator and indirect standardisation denominator pairs with error diagnostic fields. As this is a CROSS JOIN the will be a lot of output as tables are not rejected on the basis of user access or containing the correct geography geolevel fields.]]></comment>
	<position x="985.4" y="3928.4"/>
	<reference>
		<expression><![CDATA[ WITH n AS (
         SELECT n1.geography,
            n1.numerator_table,
            n1.numerator_description,
            n1.automatic,
            n1.is_object_resolvable,
            n1.n_num_denom_validated,
            n1.numerator_owner
           FROM ( SELECT g.geography,
                    n_1.table_name AS numerator_table,
                    n_1.description AS numerator_description,
                    n_1.automatic,
                    rif40_is_object_resolvable(n_1.table_name) AS is_object_resolvable,
                    rif40_num_denom_validate(g.geography, n_1.table_name) AS n_num_denom_validated,
                    rif40_object_resolve(n_1.table_name) AS numerator_owner
                   FROM rif40_geographies g,
                    rif40_tables n_1
                  WHERE ((n_1.isnumerator = 1) AND (n_1.automatic = 1))) n1
        ), d AS (
         SELECT d1.geography,
            d1.denominator_table,
            d1.denominator_description,
            d1.is_object_resolvable,
            d1.d_num_denom_validated,
            d1.denominator_owner,
            (rif40_auto_indirect_checks(d1.denominator_table))::text AS auto_indirect_error
           FROM ( SELECT g.geography,
                    d_1.table_name AS denominator_table,
                    d_1.description AS denominator_description,
                    rif40_is_object_resolvable(d_1.table_name) AS is_object_resolvable,
                    rif40_num_denom_validate(g.geography, d_1.table_name) AS d_num_denom_validated,
                    rif40_object_resolve(d_1.table_name) AS denominator_owner
                   FROM rif40_geographies g,
                    rif40_tables d_1
                  WHERE ((d_1.isindirectdenominator = 1) AND (d_1.automatic = 1))) d1
        )
 SELECT n.geography,
    n.numerator_owner,
    n.numerator_table,
    n.is_object_resolvable AS is_numerator_resolvable,
    n.n_num_denom_validated,
    n.numerator_description,
    d.denominator_owner,
    d.denominator_table,
    d.is_object_resolvable AS is_denominator_resolvable,
    d.d_num_denom_validated,
    d.denominator_description,
    n.automatic,
        CASE
            WHEN (d.auto_indirect_error IS NULL) THEN 0
            ELSE 1
        END AS auto_indirect_error_flag,
    d.auto_indirect_error,
    f.create_status AS n_fdw_create_status,
    f.error_message AS n_fdw_error_message,
    f.date_created AS n_fdw_date_created,
    f.rowtest_passed AS n_fdw_rowtest_passed
   FROM d,
    (n
   LEFT JOIN rif40_fdw_tables f ON (((n.numerator_table)::text = (f.table_name)::text)))
  WHERE ((n.geography)::text = (d.geography)::text)
  ORDER BY n.geography, n.numerator_owner, n.n_num_denom_validated;]]></expression>
	</reference>
</view>

<table name="rif40_opcs4">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Office of Population Censuses and Surveys [OPCS] Classification of Interventions and Procedures]]></comment>
	<position x="488.766" y="1292.8"/>
	<column name="opcs4_1char">
		<type name="character varying" length="20"/>
		<comment><![CDATA[OPCS4 chapter]]></comment>
	</column>
	<column name="opcs4_3char">
		<type name="character varying" length="3"/>
		<comment><![CDATA[3 Character OPCS4 code]]></comment>
	</column>
	<column name="opcs4_4char">
		<type name="character varying" length="4"/>
		<comment><![CDATA[4 Character OPCS4 code]]></comment>
	</column>
	<column name="text_1char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[OPCS4 chapter textual description]]></comment>
	</column>
	<column name="text_3char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[3 Character OPCS4 textual description]]></comment>
	</column>
	<column name="text_4char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[4 Character OPCS4 textual description]]></comment>
	</column>
</table>

<table name="rif40_outcome_groups">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Collection of Health outcomes into logical groups. E.g. Single variable ICD9 and 10]]></comment>
	<position x="765.766" y="1292.8"/>
	<column name="outcome_type" not-null="true">
		<type name="character varying" length="20"/>
		<comment><![CDATA[Outcome type: ICD, ICD-0 or OPCS]]></comment>
	</column>
	<column name="outcome_group_name" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Outcome Group Name. E.g SINGLE_VARIABLE_ICD]]></comment>
	</column>
	<column name="outcome_group_description" not-null="true">
		<type name="character varying" length="250"/>
		<comment><![CDATA[Outcome Group Description. E.g. &quot;Single variable ICD&quot;]]></comment>
	</column>
	<column name="field_name" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Outcome field name, e.g. ICD_SAHSU_01, ICD_SAHSU]]></comment>
	</column>
	<column name="multiple_field_count" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Outcome Group multiple field count (0-99). E.g if NULL then field is ICD_SAHSU_01; if 20 then fields are ICD_SAHSU_01 to ICD_SAHSU_20. Field numbers are assumed to tbe left padded to 2 characters with &quot;0&quot; and preceeded by an &quot;_&quot;]]></comment>
	</column>
	<constraint name="outcome_type_ck2" type="ck-constr" table="rif40.rif40_outcome_groups">
			<expression><![CDATA[((outcome_type)::text = ANY (ARRAY[('A&E'::character varying)::text, ('ICD'::character varying)::text, ('ICD-O'::character varying)::text, ('OPCS'::character varying)::text, ('BIRTHWEIGHT'::character varying)::text]))]]></expression>
	</constraint>
	<constraint name="rif40_outcome_groups_pk" type="pk-constr" factor="100" table="rif40.rif40_outcome_groups">
		<columns names="outcome_group_name" ref-type="src-columns"/>
	</constraint>
</table>

<table name="rif40_outcomes">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Health Outcomes. This table give the locations of the various Health Outcomes lookup tables, e.g RIF40_ICD10. Outcomes typically supported are ICD 9, 10, OPCS4 operation codes, ICD-0 Histology]]></comment>
	<position x="1181.77" y="1292.8"/>
	<column name="outcome_type" not-null="true">
		<type name="character varying" length="20"/>
		<comment><![CDATA[Outcome type: ICD, ICD-0 or OPCS]]></comment>
	</column>
	<column name="outcome_description" not-null="true">
		<type name="character varying" length="250"/>
		<comment><![CDATA[Outcome Description]]></comment>
	</column>
	<column name="current_version" not-null="true">
		<type name="character varying" length="20"/>
		<comment><![CDATA[Current Version, e.g 10 for ICD]]></comment>
	</column>
	<column name="current_sub_version">
		<type name="character varying" length="20"/>
		<comment><![CDATA[Current Sub Version, e.g. 11th Revision - 2010]]></comment>
	</column>
	<column name="previous_version">
		<type name="character varying" length="20"/>
		<comment><![CDATA[Previous version, e.g. 9]]></comment>
	</column>
	<column name="previous_sub_version">
		<type name="character varying" length="20"/>
		<comment><![CDATA[Previous sub version]]></comment>
	</column>
	<column name="current_lookup_table">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Current lookup table, e.g. RIF40_ICD10. If this is NULL there is no lookup table]]></comment>
	</column>
	<column name="previous_lookup_table">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Previous lookup table, e.g. RIF40_ICD9]]></comment>
	</column>
	<column name="current_value_1char">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Field name containing values for current version 1 character code (may be NULL)]]></comment>
	</column>
	<column name="current_value_2char">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Field name containing values for current version 2 character code (may be NULL)]]></comment>
	</column>
	<column name="current_value_3char">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Field name containing values for current version 3 character code (may be NULL)]]></comment>
	</column>
	<column name="current_value_4char">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Field name containing values for current version 4 character code (may be NULL)]]></comment>
	</column>
	<column name="current_value_5char">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Field name containing values for current version 5 character code (may be NULL)]]></comment>
	</column>
	<column name="current_description_1char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[Field name contianing descriptions for current version 1 character code (may be NULL)]]></comment>
	</column>
	<column name="current_description_2char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[Field name contianing descriptions for current version 2 character code (may be NULL)]]></comment>
	</column>
	<column name="current_description_3char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[Field name contianing descriptions for current version 3 character code (may be NULL)]]></comment>
	</column>
	<column name="current_description_4char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[Field name contianing descriptions for current version 4 character code (may be NULL)]]></comment>
	</column>
	<column name="current_description_5char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[Field name contianing descriptions for current version 5 character code (may be NULL)]]></comment>
	</column>
	<column name="previous_value_1char">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Field name containing values for previous version 1 character code (may be NULL)]]></comment>
	</column>
	<column name="previous_value_2char">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Field name containing values for previous version 2 character code (may be NULL)]]></comment>
	</column>
	<column name="previous_value_3char">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Field name containing values for previous version 3 character code (may be NULL)]]></comment>
	</column>
	<column name="previous_value_4char">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Field name containing values for previous version 4 character code (may be NULL)]]></comment>
	</column>
	<column name="previous_value_5char">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Field name containing values for previous version 5 character code (may be NULL)]]></comment>
	</column>
	<column name="previous_description_1char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[Field name contianing descriptions for previous version 1 character code (may be NULL)]]></comment>
	</column>
	<column name="previous_description_2char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[Field name contianing descriptions for previous version 2 character code (may be NULL)]]></comment>
	</column>
	<column name="previous_description_3char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[Field name contianing descriptions for previous version 3 character code (may be NULL)]]></comment>
	</column>
	<column name="previous_description_4char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[Field name contianing descriptions for previous version 4 character code (may be NULL)]]></comment>
	</column>
	<column name="previous_description_5char">
		<type name="character varying" length="250"/>
		<comment><![CDATA[Field name contianing descriptions for previous version 5 character code (may be NULL)]]></comment>
	</column>
	<constraint name="current_lookup_table_ck" type="ck-constr" table="rif40.rif40_outcomes">
			<expression><![CDATA[((((current_lookup_table IS NOT NULL) AND (current_version IS NOT NULL)) AND (((((current_value_1char IS NOT NULL) OR (current_value_2char IS NOT NULL)) OR (current_value_3char IS NOT NULL)) OR (current_value_4char IS NOT NULL)) OR (current_value_5char IS NOT NULL))) OR (current_lookup_table IS NULL))]]></expression>
	</constraint>
	<constraint name="current_value_nchar_ck" type="ck-constr" table="rif40.rif40_outcomes">
			<expression><![CDATA[((((current_lookup_table IS NOT NULL) AND (current_version IS NOT NULL)) AND ((((((current_value_1char IS NOT NULL) AND (current_description_1char IS NOT NULL)) OR ((current_value_2char IS NOT NULL) AND (current_description_2char IS NOT NULL))) OR ((current_value_3char IS NOT NULL) AND (current_description_3char IS NOT NULL))) OR ((current_value_4char IS NOT NULL) AND (current_description_4char IS NOT NULL))) OR ((current_value_5char IS NOT NULL) AND (current_description_5char IS NOT NULL)))) OR (current_lookup_table IS NULL))]]></expression>
	</constraint>
	<constraint name="outcome_type_ck1" type="ck-constr" table="rif40.rif40_outcomes">
			<expression><![CDATA[((outcome_type)::text = ANY (ARRAY[('A&E'::character varying)::text, ('ICD'::character varying)::text, ('ICD-O'::character varying)::text, ('OPCS'::character varying)::text, ('BIRTHWEIGHT'::character varying)::text]))]]></expression>
	</constraint>
	<constraint name="previous_lookup_table_ck" type="ck-constr" table="rif40.rif40_outcomes">
			<expression><![CDATA[((((previous_lookup_table IS NOT NULL) AND (previous_version IS NOT NULL)) AND (((((previous_value_1char IS NOT NULL) OR (previous_value_2char IS NOT NULL)) OR (previous_value_3char IS NOT NULL)) OR (previous_value_4char IS NOT NULL)) OR (previous_value_5char IS NOT NULL))) OR ((previous_lookup_table IS NULL) AND (previous_version IS NULL)))]]></expression>
	</constraint>
	<constraint name="previous_value_nchar_ck" type="ck-constr" table="rif40.rif40_outcomes">
			<expression><![CDATA[(((previous_lookup_table IS NOT NULL) AND ((((((previous_value_1char IS NOT NULL) AND (previous_description_1char IS NOT NULL)) OR ((previous_value_2char IS NOT NULL) AND (previous_description_2char IS NOT NULL))) OR ((previous_value_3char IS NOT NULL) AND (previous_description_3char IS NOT NULL))) OR ((previous_value_4char IS NOT NULL) AND (previous_description_4char IS NOT NULL))) OR ((previous_value_5char IS NOT NULL) AND (previous_description_5char IS NOT NULL)))) OR ((previous_lookup_table IS NULL) AND (previous_version IS NULL)))]]></expression>
	</constraint>
	<constraint name="rif40_outcomes_pk" type="pk-constr" factor="100" table="rif40.rif40_outcomes">
		<columns names="outcome_type" ref-type="src-columns"/>
	</constraint>
	<trigger name="rif40_outcomes_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="rif40.rif40_outcomes">
		<comment><![CDATA[INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_outcomes_checks()]]></comment>
	<condition><![CDATA[(((((new.outcome_type IS NOT NULL) AND ((new.outcome_type)::text <> ''::text)) OR ((new.outcome_description IS NOT NULL) AND ((new.outcome_description)::text <> ''::text))) OR ((new.current_version IS NOT NULL) AND ((new.current_version)::text <> ''::text))) OR ((new.current_lookup_table IS NOT NULL) AND ((new.current_lookup_table)::text <> ''::text)))]]></condition>
		<function signature="rif40_trg_pkg.trigger_fct_rif40_outcomes_checks()"/>
	</trigger>
	<trigger name="rif40_outcomes_checks_del" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="rif40.rif40_outcomes">
		<comment><![CDATA[DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_outcomes_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_rif40_outcomes_checks()"/>
	</trigger>
</table>

<table name="t_rif40_parameters">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF40 parameters. Use this table for INSERT/UPDATE/DELETE; use RIF40_PARAMETERS for SELECT. User needs RIF_NO_SUPPRESSION granted as a role to see unsuppressed results]]></comment>
	<position x="1596.77" y="1292.8"/>
	<column name="param_name" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Parameter]]></comment>
	</column>
	<column name="param_value" not-null="true">
		<type name="character varying" length="50"/>
		<comment><![CDATA[Value]]></comment>
	</column>
	<column name="param_description" not-null="true">
		<type name="character varying" length="250"/>
		<comment><![CDATA[Description]]></comment>
	</column>
	<constraint name="t_rif40_parameters_pk" type="pk-constr" factor="100" table="rif40.t_rif40_parameters">
		<columns names="param_name" ref-type="src-columns"/>
	</constraint>
</table>

<view name="rif40_parameters">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF40 parameters with automatic SuppressionValue parameter.  Use this table for SELECT; use T_RIF40_PARAMETERS for INSERT/UPDATE/DELETE. User needs RIF_NO_SUPPRESSION granted as a role to see unsuppressed results]]></comment>
	<position x="50" y="4017.8"/>
	<reference>
		<expression><![CDATA[        (         SELECT t_rif40_parameters.param_name,
                    t_rif40_parameters.param_value,
                    t_rif40_parameters.param_description
                   FROM t_rif40_parameters
                  WHERE ((t_rif40_parameters.param_name)::text <> 'SuppressionValue'::text)
        UNION
                 SELECT p.param_name,
                        CASE
                            WHEN (a.total = 1) THEN '0'::character varying
                            ELSE p.param_value
                        END AS param_value,
                    p.param_description
                   FROM t_rif40_parameters p,
                    ( SELECT count(*) AS total
                           FROM user_role_privs
                          WHERE (user_role_privs.granted_role = 'RIF_NO_SUPPRESSION'::text)) a
                  WHERE ((p.param_name)::text = 'SuppressionValue'::text))
UNION
         SELECT 'RifParametersTable'::character varying AS param_name,
            'Virtual'::character varying AS param_value,
            'Is this the T_RIF40_PARAMETERS table or the VIRTUAL view'::character varying AS param_description
  ORDER BY 1;]]></expression>
	</reference>
</view>

<table name="rif40_population_europe">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[1991 European standarised populations (to be updated)]]></comment>
	<position x="50" y="1821"/>
	<column name="year" default-value="1991">
		<type name="smallint"/>
		<comment><![CDATA[Year]]></comment>
	</column>
	<column name="age_sex_group" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Age sex group (standard 21)]]></comment>
	</column>
	<column name="total" not-null="true">
		<type name="double precision"/>
		<comment><![CDATA[Total (each sex sums to 100,000)]]></comment>
	</column>
	<constraint name="rif40_population_europe_pk" type="pk-constr" factor="100" table="rif40.rif40_population_europe">
		<columns names="age_sex_group" ref-type="src-columns"/>
	</constraint>
</table>

<table name="rif40_population_us">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[2000 United States of America standarised populations (to be updated)]]></comment>
	<position x="363" y="1821"/>
	<column name="year" default-value="2000">
		<type name="smallint"/>
		<comment><![CDATA[Year]]></comment>
	</column>
	<column name="age_sex_group" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Age sex group (standard 21)]]></comment>
	</column>
	<column name="total" not-null="true">
		<type name="double precision"/>
		<comment><![CDATA[Total (each sex sums to 100,000)]]></comment>
	</column>
	<constraint name="rif40_population_us_pk" type="pk-constr" factor="100" table="rif40.rif40_population_us">
		<columns names="age_sex_group" ref-type="src-columns"/>
	</constraint>
</table>

<table name="rif40_population_world">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[1991 World standarised populations (to be updated)]]></comment>
	<position x="676" y="1821"/>
	<column name="year" default-value="1991">
		<type name="smallint"/>
		<comment><![CDATA[Year]]></comment>
	</column>
	<column name="age_sex_group" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Age sex group (standard 21)]]></comment>
	</column>
	<column name="total" not-null="true">
		<type name="double precision"/>
		<comment><![CDATA[Total (each sex sums to 100,000)]]></comment>
	</column>
	<constraint name="rif40_population_world_pk" type="pk-constr" factor="100" table="rif40.rif40_population_world">
		<columns names="age_sex_group" ref-type="src-columns"/>
	</constraint>
</table>

<table name="rif40_predefined_groups">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Predefined Health Outcomes]]></comment>
	<position x="989" y="1821"/>
	<column name="predefined_group_name" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Predefined Group Name. E.g LUNG_CANCER]]></comment>
	</column>
	<column name="predefined_group_description" not-null="true">
		<type name="character varying" length="250"/>
		<comment><![CDATA[Predefined Group Description. E.g. &quot;Lung Cancer&quot;]]></comment>
	</column>
	<column name="outcome_type" not-null="true">
		<type name="character varying" length="20"/>
		<comment><![CDATA[Outcome type: ICD, ICD-0 or OPCS]]></comment>
	</column>
	<column name="condition" default-value="'1=1'::character varying">
		<type name="character varying" length="4000"/>
		<comment><![CDATA[SQL WHERE clause, with the WHERE keyword omitted). Default to 1=1 (use all records matching year/age/sex criteria). Checked for SQL injection.]]></comment>
	</column>
	<constraint name="outcome_type_ck3" type="ck-constr" table="rif40.rif40_predefined_groups">
			<expression><![CDATA[((outcome_type)::text = ANY (ARRAY[('A&E'::character varying)::text, ('ICD'::character varying)::text, ('ICD-O'::character varying)::text, ('OPCS'::character varying)::text, ('BIRTHWEIGHT'::character varying)::text]))]]></expression>
	</constraint>
	<constraint name="rif40_predefined_groups_pk" type="pk-constr" factor="100" table="rif40.rif40_predefined_groups">
		<columns names="predefined_group_name" ref-type="src-columns"/>
	</constraint>
	<trigger name="rif40_predefined_groups_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="rif40.rif40_predefined_groups">
		<comment><![CDATA[INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_predefined_groups_checks()]]></comment>
	<condition><![CDATA[(((((new.predefined_group_name IS NOT NULL) AND ((new.predefined_group_name)::text <> ''::text)) OR ((new.predefined_group_description IS NOT NULL) AND ((new.predefined_group_description)::text <> ''::text))) OR ((new.outcome_type IS NOT NULL) AND ((new.outcome_type)::text <> ''::text))) OR ((new.condition IS NOT NULL) AND ((new.condition)::text <> ''::text)))]]></condition>
		<function signature="rif40_trg_pkg.trigger_fct_rif40_predefined_groups_checks()"/>
	</trigger>
	<trigger name="rif40_predefined_groups_checks_del" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="rif40.rif40_predefined_groups">
		<comment><![CDATA[DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_predefined_groups_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_rif40_predefined_groups_checks()"/>
	</trigger>
</table>

<table name="t_rif40_projects">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF projects]]></comment>
	<position x="1453.77" y="1821"/>
	<column name="project" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Project name]]></comment>
	</column>
	<column name="description" not-null="true">
		<type name="character varying" length="250"/>
		<comment><![CDATA[Project description]]></comment>
	</column>
	<column name="date_started" default-value="('now'::text)::timestamp without time zone">
		<type name="timestamp"/>
		<comment><![CDATA[Date project started]]></comment>
	</column>
	<column name="date_ended">
		<type name="timestamp"/>
		<comment><![CDATA[Date project ended]]></comment>
	</column>
	<constraint name="t_rif40_projects_date_ck" type="ck-constr" table="rif40.t_rif40_projects">
			<expression><![CDATA[((date_ended IS NULL) OR (date_ended >= date_started))]]></expression>
	</constraint>
	<constraint name="t_rif40_projects_pk" type="pk-constr" factor="100" table="rif40.t_rif40_projects">
		<columns names="project" ref-type="src-columns"/>
	</constraint>
</table>

<table name="t_rif40_user_projects">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF project users]]></comment>
	<position x="50" y="1989.2"/>
	<column name="project" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Project name]]></comment>
	</column>
	<column name="username" not-null="true" default-value="&quot;current_user&quot;()">
		<type name="character varying" length="90"/>
		<comment><![CDATA[Username]]></comment>
	</column>
	<column name="grant_date" default-value="('now'::text)::timestamp without time zone">
		<type name="timestamp"/>
		<comment><![CDATA[Date project access granted]]></comment>
	</column>
	<column name="revoke_date">
		<type name="timestamp"/>
		<comment><![CDATA[Date project access revoke_date]]></comment>
	</column>
	<constraint name="t_rif40_user_projects_date_ck" type="ck-constr" table="rif40.t_rif40_user_projects">
			<expression><![CDATA[((revoke_date IS NULL) OR (revoke_date > grant_date))]]></expression>
	</constraint>
	<constraint name="t_rif40_user_projects_pk" type="pk-constr" factor="100" table="rif40.t_rif40_user_projects">
		<columns names="project,username" ref-type="src-columns"/>
	</constraint>
	<trigger name="t_rif40_user_projects_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="rif40.t_rif40_user_projects">
		<comment><![CDATA[INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_user_projects_checks()]]></comment>
	<condition><![CDATA[(((new.project IS NOT NULL) AND ((new.project)::text <> ''::text)) OR ((new.username IS NOT NULL) AND ((new.username)::text <> ''::text)))]]></condition>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_user_projects_checks()"/>
	</trigger>
	<trigger name="t_rif40_user_projects_checks_del" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="rif40.t_rif40_user_projects">
		<comment><![CDATA[DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_user_projects_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_user_projects_checks()"/>
	</trigger>
</table>

<view name="rif40_projects">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF projects (restricted to those granted to the user)]]></comment>
	<position x="280.6" y="4017.8"/>
	<reference>
		<expression><![CDATA[ SELECT t_rif40_projects.project,
    t_rif40_projects.description,
    t_rif40_projects.date_started,
    t_rif40_projects.date_ended
   FROM t_rif40_projects
  WHERE ((t_rif40_projects.project)::text IN ( SELECT t_rif40_user_projects.project
           FROM t_rif40_user_projects
          WHERE (((t_rif40_user_projects.username)::name = "current_user"()) OR ('RIF_MANAGER'::text = ( SELECT user_role_privs.granted_role
                   FROM user_role_privs
                  WHERE (user_role_privs.granted_role = 'RIF_MANAGER'::text))))))
  ORDER BY t_rif40_projects.project;]]></expression>
	</reference>
</view>

<table name="rif40_reference_tables">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[List of references tables without constraints]]></comment>
	<position x="480.766" y="1989.2"/>
	<column name="table_name" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Table name]]></comment>
	</column>
	<constraint name="rif40_reference_tables_pk" type="pk-constr" factor="100" table="rif40.rif40_reference_tables">
		<columns names="table_name" ref-type="src-columns"/>
	</constraint>
</table>

<table name="t_rif40_results">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF Results Table]]></comment>
	<position x="802.766" y="1989.2"/>
	<column name="username" default-value="&quot;current_user&quot;()">
		<type name="character varying" length="90"/>
		<comment><![CDATA[Username]]></comment>
	</column>
	<column name="study_id" not-null="true" default-value="(currval('rif40_study_id_seq'::regclass))::integer">
		<type name="integer"/>
		<comment><![CDATA[Unique study index: study_id. Created by SEQUENCE rif40_study_id_seq]]></comment>
	</column>
	<column name="inv_id" not-null="true" default-value="(currval('rif40_inv_id_seq'::regclass))::integer">
		<type name="integer"/>
		<comment><![CDATA[Unique investigation inde:inv_id. Created by SEQUENCE rif40_inv_id_seq]]></comment>
	</column>
	<column name="band_id" not-null="true">
		<type name="integer"/>
		<comment><![CDATA[A band allocated to the area]]></comment>
	</column>
	<column name="genders" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Genders to be investigated: 1 - males, 2 female or 3 - both]]></comment>
	</column>
	<column name="adjusted" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Covariate adjustment: Unadjusted (0) or adjusted (1)]]></comment>
	</column>
	<column name="direct_standardisation" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Standardisation: indirect (0) or direct (1)]]></comment>
	</column>
	<column name="observed">
		<type name="double precision"/>
		<comment><![CDATA[The number of observed cases]]></comment>
	</column>
	<column name="expected">
		<type name="double precision"/>
		<comment><![CDATA[The number of expected cases or the rate (for direct standardised results)]]></comment>
	</column>
	<column name="lower95">
		<type name="double precision"/>
		<comment><![CDATA[The lower 95% confidence interval for the relative risk (for indirectly standarised results) or the lower 95% confidence interval for the rate (for directly standardised results)]]></comment>
	</column>
	<column name="upper95">
		<type name="double precision"/>
		<comment><![CDATA[The upper 95% confidence interval for the relative risk (for indirectly standarised results) or the upper 95% confidence interval for the rate (for directly standardised results)]]></comment>
	</column>
	<column name="relative_risk">
		<type name="double precision"/>
		<comment><![CDATA[Relaitive risk (for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="smoothed_relative_risk">
		<type name="double precision"/>
		<comment><![CDATA[Smoothed relaive risk (for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="posterior_probability">
		<type name="double precision"/>
		<comment><![CDATA[The posterior probability (for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="posterior_probability_lower95">
		<type name="double precision"/>
		<comment><![CDATA[The lower 95% confidence interval of the posterior probability (for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="posterior_probability_upper95">
		<type name="double precision"/>
		<comment><![CDATA[The upper 95% confidence interval of the posterior probability (for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="residual_relative_risk">
		<type name="double precision"/>
		<comment><![CDATA[The residual relative risk(for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="residual_rr_lower95">
		<type name="double precision"/>
		<comment><![CDATA[The lower 95% confidence interval of the residual relative risk(for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="residual_rr_upper95">
		<type name="double precision"/>
		<comment><![CDATA[The upper 95% confidence interval of the residual relative risk(for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="smoothed_smr">
		<type name="double precision"/>
		<comment><![CDATA[The smoothed SMR [fully Bayesian smoothing] (for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="smoothed_smr_lower95">
		<type name="double precision"/>
		<comment><![CDATA[The lower 95% confidence interval of the smoothed SMR [fully Bayesian smoothing] (for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="smoothed_smr_upper95">
		<type name="double precision"/>
		<comment><![CDATA[The upper 95% confidence interval of the smoothed SMR [fully Bayesian smoothing] (for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<constraint name="t_rif40_res_adjusted_ck" type="ck-constr" table="rif40.t_rif40_results">
			<expression><![CDATA[((adjusted >= 0) AND (adjusted <= 1))]]></expression>
	</constraint>
	<constraint name="t_rif40_res_dir_stand_ck" type="ck-constr" table="rif40.t_rif40_results">
			<expression><![CDATA[((direct_standardisation >= 0) AND (direct_standardisation <= 1))]]></expression>
	</constraint>
	<constraint name="t_rif40_results_genders_ck" type="ck-constr" table="rif40.t_rif40_results">
			<expression><![CDATA[((genders >= 1) AND (genders <= 3))]]></expression>
	</constraint>
	<constraint name="t_rif40_results_pk" type="pk-constr" factor="100" table="rif40.t_rif40_results">
		<columns names="study_id,band_id,inv_id,genders,adjusted,direct_standardisation" ref-type="src-columns"/>
	</constraint>
	<index name="t_rif40_results_band_id_bm" table="rif40.t_rif40_results"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="band_id"/>
		</idxelement>
	</index>
	<index name="t_rif40_results_inv_id_fk" table="rif40.t_rif40_results"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="inv_id"/>
		</idxelement>
	</index>
	<index name="t_rif40_results_username_bm" table="rif40.t_rif40_results"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="username"/>
		</idxelement>
	</index>
	<trigger name="t_rif40_results_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="rif40.t_rif40_results">
		<comment><![CDATA[INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_results_checks()]]></comment>
	<condition><![CDATA[(((new.username IS NOT NULL) AND ((new.username)::text <> ''::text)) OR ((new.study_id IS NOT NULL) AND ((new.study_id)::text <> ''::text)))]]></condition>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_results_checks()"/>
	</trigger>
	<trigger name="t_rif40_results_checks_del" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="rif40.t_rif40_results">
		<comment><![CDATA[DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_results_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_results_checks()"/>
	</trigger>
</table>

<view name="rif40_results">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF Results Table]]></comment>
	<position x="504.2" y="4017.8"/>
	<reference>
		<expression><![CDATA[ SELECT c.username,
    c.study_id,
    c.inv_id,
    c.band_id,
    c.genders,
    c.direct_standardisation,
    c.adjusted,
    c.observed,
    c.expected,
    c.lower95,
    c.upper95,
    c.relative_risk,
    c.smoothed_relative_risk,
    c.posterior_probability,
    c.posterior_probability_upper95,
    c.posterior_probability_lower95,
    c.residual_relative_risk,
    c.residual_rr_lower95,
    c.residual_rr_upper95,
    c.smoothed_smr,
    c.smoothed_smr_lower95,
    c.smoothed_smr_upper95
   FROM (t_rif40_results c
   LEFT JOIN rif40_study_shares s ON (((c.study_id = s.study_id) AND ((s.grantee_username)::name = "current_user"()))))
  WHERE ((((c.username)::name = "current_user"()) OR ('RIF_MANAGER'::text = ( SELECT user_role_privs.granted_role
      FROM user_role_privs
     WHERE (user_role_privs.granted_role = 'RIF_MANAGER'::text)))) OR ((s.grantee_username IS NOT NULL) AND ((s.grantee_username)::text <> ''::text)))
  ORDER BY c.username;]]></expression>
	</reference>
</view>

<table name="t_rif40_studies">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF studies]]></comment>
	<position x="1235.77" y="1989.2"/>
	<column name="study_id" not-null="true" default-value="(nextval('rif40_study_id_seq'::regclass))::integer">
		<type name="integer"/>
		<comment><![CDATA[Unique study index: study_id. Created by SEQUENCE rif40_study_id_seq]]></comment>
	</column>
	<column name="username" default-value="&quot;current_user&quot;()">
		<type name="character varying" length="90"/>
		<comment><![CDATA[Username]]></comment>
	</column>
	<column name="geography" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Geography (e.g EW2001)]]></comment>
	</column>
	<column name="project" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Project running the study. The user must be allocated to the project.]]></comment>
	</column>
	<column name="study_name" not-null="true">
		<type name="character varying" length="200"/>
		<comment><![CDATA[Study name]]></comment>
	</column>
	<column name="summary">
		<type name="character varying" length="200"/>
		<comment><![CDATA[Study summary]]></comment>
	</column>
	<column name="description">
		<type name="character varying" length="2000"/>
		<comment><![CDATA[Study description]]></comment>
	</column>
	<column name="other_notes">
		<type name="character varying" length="2000"/>
		<comment><![CDATA[Study other notes]]></comment>
	</column>
	<column name="extract_table" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Extract table. Must only contain A-Z0-9_ and start with a letter.]]></comment>
	</column>
	<column name="map_table" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Map table. Must only contain A-Z0-9_ and start with a letter.]]></comment>
	</column>
	<column name="study_date" default-value="('now'::text)::timestamp without time zone">
		<type name="timestamp"/>
		<comment><![CDATA[Study date]]></comment>
	</column>
	<column name="study_type" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Study type: 1 - disease mapping, 11 - Risk Analysis (many areas, one band), 12 - Risk Analysis (point sources), 13 - Risk Analysis (exposure covariates), 14 - Risk Analysis (coverage shapefile), 15 - Risk Analysis (exposure shapefile)]]></comment>
	</column>
	<column name="study_state" default-value="'C'::character varying">
		<type name="character varying"/>
		<comment><![CDATA[Study state - C: created, not verfied; V: verified, but no other work done; E - extracted imported or created, but no results or maps created; R: results computed; U: upgraded record from V3.1 RIF (has an indeterminate state; probably R.]]></comment>
	</column>
	<column name="comparison_geolevel_name" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Comparison area geolevel name. Must be a valid GEOLEVEL_NAME for the study GEOGRPAHY in T_RIF40_GEOLEVELS, with COMPAREA=1]]></comment>
	</column>
	<column name="study_geolevel_name" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Study area geolevel name]]></comment>
	</column>
	<column name="denom_tab" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Denominator table name. May be &quot;DUMMY&quot; if extract created outside of the RIF. Note the old RIF allowed studies to have different denominators between investigations; this capability has been removed to simplify the extract SQL and to allow a single rotated high performance extract table to be used for all investigations in a study. The extract table is then based on the standard rotated denominator (i.e. in age_sex_group, total format rather than M0 .. M5-9 ... etc) with one extract column per covariate and investigation. Multiple investigations may use a different numerator (1 per investigation).]]></comment>
	</column>
	<column name="direct_stand_tab">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Name of table to be used in direct standardisation. COMPARISON_GEOLEVEL_NAME must be NULL. May be &quot;DUMMY&quot; if extract created outside of the RIF. Note the old RIF allowed studies to have different denominators between investigations; this capability has been removed to simplify the extract SQL and to allow a single rotated high performance extract table to be used for all investigations in a study. The extract table is then based on the standard rotated denominator (i.e. in age_sex_group, total format rather than M0 ... M5-9 ... etc) with one extract column per covariate and investigation. Multiple investigations may use a different numerator (1 per investigation).]]></comment>
	</column>
	<column name="suppression_value" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Suppress results with low cell counts below this value. If the role RIF_NO_SUPRESSION is granted and the user is not a RIF_STUDENT then SUPPRESSION_VALUE=0; otherwise is equals the parameter &quot;SuppressionValue&quot;. If >0 all results with the value or below will be set to 0.]]></comment>
	</column>
	<column name="extract_permitted" default-value="0">
		<type name="smallint"/>
		<comment><![CDATA[Is extract permitted from the database: 0/1. Only a RIF MANAGER may change this value. This user is still permitted to create and run a RIF study and to view the results. Geolevel access is rectricted by the RIF40_GEOLEVELS.RESTRICTED Inforamtion Governance restrictions (0/1). If 1 (Yes) then a) students cannot access this geolevel and b) if the system parameter ExtractControl=1 then the user must be granted permission by a RIF_MANAGER to extract from the database the results, data extract and maps tables. All students must be granted permission by a RIF_MANAGER for any extract if the system parameter ExtractControl=1. This is enforced by the RIF application.]]></comment>
	</column>
	<column name="transfer_permitted" default-value="0">
		<type name="smallint"/>
		<comment><![CDATA[Is transfer permitted from the Secure or Private Network: 0/1. This is for purely documentatary purposes only. Only a RIF MANAGER may change this value. The value defaults to the same as EXTRACT_PERMITTED. Only geolevels where RIF40_GEOLEVELS.RESTRICTED=0 may be transferred.]]></comment>
	</column>
	<column name="authorised_by">
		<type name="character varying" length="90"/>
		<comment><![CDATA[Who authorised extract and/or transfer. Must be a RIF MANAGER.]]></comment>
	</column>
	<column name="authorised_on">
		<type name="timestamp"/>
		<comment><![CDATA[When was the extract and/or transfer authorised]]></comment>
	</column>
	<column name="authorised_notes">
		<type name="character varying" length="200"/>
		<comment><![CDATA[IG authorisation notes. Must be filled in if EXTRACT_PERMITTED=1.]]></comment>
	</column>
	<column name="audsid" default-value="rif40_sql_pkg.sys_context('USERENV'::character varying, 'SESSIONID'::character varying)">
		<type name="character varying" length="90"/>
		<comment><![CDATA[Link to Oracle audit subsystem. On Postgres is &quot;backend PID.Julian day.Seconds from midnight.uSeconds (backend start time)&quot;. This can be correlated to the logging messages.]]></comment>
	</column>
	<constraint name="t_rif40_stud_extract_perm_ck" type="ck-constr" table="rif40.t_rif40_studies">
			<expression><![CDATA[(extract_permitted = ANY (ARRAY[0, 1]))]]></expression>
	</constraint>
	<constraint name="t_rif40_stud_transfer_perm_ck" type="ck-constr" table="rif40.t_rif40_studies">
			<expression><![CDATA[(transfer_permitted = ANY (ARRAY[0, 1]))]]></expression>
	</constraint>
	<constraint name="t_rif40_studies_study_state_ck" type="ck-constr" table="rif40.t_rif40_studies">
			<expression><![CDATA[((study_state)::text = ANY (ARRAY[('C'::character varying)::text, ('V'::character varying)::text, ('E'::character varying)::text, ('R'::character varying)::text, ('U'::character varying)::text]))]]></expression>
	</constraint>
	<constraint name="t_rif40_studies_study_type_ck" type="ck-constr" table="rif40.t_rif40_studies">
			<expression><![CDATA[(study_type = ANY (ARRAY[1, 11, 12, 13, 14, 15]))]]></expression>
	</constraint>
	<constraint name="t_rif40_studies_pk" type="pk-constr" factor="100" table="rif40.t_rif40_studies">
		<columns names="study_id" ref-type="src-columns"/>
	</constraint>
	<index name="t_rif40_extract_table_uk" table="rif40.t_rif40_studies"
		 concurrent="false" unique="true" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="extract_table"/>
		</idxelement>
	</index>
	<index name="t_rif40_map_table_uk" table="rif40.t_rif40_studies"
		 concurrent="false" unique="true" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="map_table"/>
		</idxelement>
	</index>
	<trigger name="t_rif40_studies_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="true" upd-event="true" trunc-event="false"
	 table="rif40.t_rif40_studies">
		<comment><![CDATA[INSERT OR UPDATE OR DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_version_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_studies_checks()"/>
	</trigger>
</table>

<view name="rif40_studies">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF studies]]></comment>
	<position x="736.8" y="4017.8"/>
	<reference>
		<expression><![CDATA[ SELECT c.username,
    c.study_id,
    c.extract_table,
    c.study_name,
    c.summary,
    c.description,
    c.other_notes,
    c.study_date,
    c.geography,
    c.study_type,
    c.study_state,
    c.comparison_geolevel_name,
    c.denom_tab,
    c.direct_stand_tab,
    i.year_start,
    i.year_stop,
    i.max_age_group,
    i.min_age_group,
    c.study_geolevel_name,
    c.map_table,
    c.suppression_value,
    c.extract_permitted,
    c.transfer_permitted,
    c.authorised_by,
    c.authorised_on,
    c.authorised_notes,
    c.audsid,
        CASE
            WHEN ((g.partition = 1) AND (((i.year_stop - i.year_start))::numeric >= ((2)::numeric * p.parallelisation))) THEN p.parallelisation
            ELSE (0)::numeric
        END AS partition_parallelisation,
    l.covariate_table,
    c.project,
    pj.description AS project_description
   FROM ((((((t_rif40_studies c
   LEFT JOIN rif40_study_shares s ON (((c.study_id = s.study_id) AND ((s.grantee_username)::name = "current_user"()))))
   LEFT JOIN ( SELECT i2.study_id,
       max(i2.year_stop) AS year_stop,
       min(i2.year_start) AS year_start,
       max(i2.max_age_group) AS max_age_group,
       min(i2.min_age_group) AS min_age_group
      FROM t_rif40_investigations i2
     GROUP BY i2.study_id) i ON ((c.study_id = i.study_id)))
   LEFT JOIN rif40_geographies g ON (((c.geography)::text = (g.geography)::text)))
   LEFT JOIN ( SELECT to_number((t_rif40_parameters.param_value)::text, '999990'::text) AS parallelisation
   FROM t_rif40_parameters
  WHERE ((t_rif40_parameters.param_name)::text = 'Parallelisation'::text)) p ON ((1 = 1)))
   LEFT JOIN t_rif40_geolevels l ON ((((c.geography)::text = (l.geography)::text) AND ((c.study_geolevel_name)::text = (l.geolevel_name)::text))))
   LEFT JOIN t_rif40_projects pj ON (((pj.project)::text = (c.project)::text)))
  WHERE ((((c.username)::name = "current_user"()) OR ('RIF_MANAGER'::text = ( SELECT user_role_privs.granted_role
   FROM user_role_privs
  WHERE (user_role_privs.granted_role = 'RIF_MANAGER'::text)))) OR ((s.grantee_username IS NOT NULL) AND ((s.grantee_username)::text <> ''::text)))
  ORDER BY c.username;]]></expression>
	</reference>
</view>

<table name="t_rif40_study_areas">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Links study areas and bands for a given study.]]></comment>
	<position x="1662.77" y="1989.2"/>
	<column name="username" default-value="&quot;current_user&quot;()">
		<type name="character varying" length="90"/>
		<comment><![CDATA[Username]]></comment>
	</column>
	<column name="study_id" not-null="true" default-value="(currval('rif40_study_id_seq'::regclass))::integer">
		<type name="integer"/>
		<comment><![CDATA[Unique study index: study_id. Created by SEQUENCE rif40_study_id_seq]]></comment>
	</column>
	<column name="area_id" not-null="true">
		<type name="character varying" length="300"/>
		<comment><![CDATA[An area id, the value of a geolevel; i.e. the value of the column T_RIF40_GEOLEVELS.GEOLEVEL_NAME in table T_RIF40_GEOLEVELS.LOOKUP_TABLE]]></comment>
	</column>
	<column name="band_id">
		<type name="integer"/>
		<comment><![CDATA[A band allocated to the area]]></comment>
	</column>
	<constraint name="t_rif40_study_areas_pk" type="pk-constr" factor="100" table="rif40.t_rif40_study_areas">
		<columns names="study_id,area_id" ref-type="src-columns"/>
	</constraint>
	<index name="t_rif40_study_areas_band_id" table="rif40.t_rif40_study_areas"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="band_id"/>
		</idxelement>
	</index>
	<index name="t_rif40_study_areas_uname" table="rif40.t_rif40_study_areas"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="username"/>
		</idxelement>
	</index>
	<trigger name="t_rif40_study_areas_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="rif40.t_rif40_study_areas">
		<comment><![CDATA[INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks()]]></comment>
	<condition><![CDATA[((((new.band_id IS NOT NULL) AND ((new.band_id)::text <> ''::text)) OR ((new.username IS NOT NULL) AND ((new.username)::text <> ''::text))) OR ((new.study_id IS NOT NULL) AND ((new.study_id)::text <> ''::text)))]]></condition>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks()"/>
	</trigger>
	<trigger name="t_rif40_study_areas_checks2" firing-type="AFTER" per-line="false" constraint="false"
		 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="rif40.t_rif40_study_areas">
		<comment><![CDATA[INSERT OR UPDATE OR DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks2()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks2()"/>
	</trigger>
	<trigger name="t_rif40_study_areas_checks_del" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="rif40.t_rif40_study_areas">
		<comment><![CDATA[DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks()"/>
	</trigger>
</table>

<view name="rif40_study_areas">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Links study areas and bands for a given study.]]></comment>
	<position x="969.4" y="4017.8"/>
	<reference>
		<expression><![CDATA[ SELECT c.username,
    c.study_id,
    c.area_id,
    c.band_id
   FROM (t_rif40_study_areas c
   LEFT JOIN rif40_study_shares s ON (((c.study_id = s.study_id) AND ((s.grantee_username)::name = "current_user"()))))
  WHERE ((((c.username)::name = "current_user"()) OR ('RIF_MANAGER'::text = ( SELECT user_role_privs.granted_role
      FROM user_role_privs
     WHERE (user_role_privs.granted_role = 'RIF_MANAGER'::text)))) OR ((s.grantee_username IS NOT NULL) AND ((s.grantee_username)::text <> ''::text)))
  ORDER BY c.username;]]></expression>
	</reference>
</view>

<table name="t_rif40_study_sql">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[SQL created for study execution.]]></comment>
	<position x="50" y="2472.4"/>
	<column name="username" default-value="&quot;current_user&quot;()">
		<type name="character varying" length="90"/>
		<comment><![CDATA[Username]]></comment>
	</column>
	<column name="study_id" not-null="true" default-value="(currval('rif40_study_id_seq'::regclass))::integer">
		<type name="integer"/>
		<comment><![CDATA[Unique study index: study_id. Created by SEQUENCE rif40_study_id_seq]]></comment>
	</column>
	<column name="statement_type" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Statement type: CREATE, INSERT, POST_INSERT, NUMERATOR_CHECK, DENOMINATOR_CHECK]]></comment>
	</column>
	<column name="statement_number" not-null="true">
		<type name="integer"/>
		<comment><![CDATA[Statement number]]></comment>
	</column>
	<column name="sql_text" not-null="true">
		<type name="character varying" length="4000"/>
		<comment><![CDATA[SQL text]]></comment>
	</column>
	<column name="line_number" not-null="true">
		<type name="integer"/>
		<comment><![CDATA[Line number]]></comment>
	</column>
	<column name="status">
		<type name="character varying"/>
		<comment><![CDATA[Status: C(reated) or R(un)]]></comment>
	</column>
	<constraint name="statement_type_ck2" type="ck-constr" table="rif40.t_rif40_study_sql">
			<expression><![CDATA[((statement_type)::text = ANY (ARRAY[('CREATE'::character varying)::text, ('INSERT'::character varying)::text, ('POST_INSERT'::character varying)::text, ('NUMERATOR_CHECK'::character varying)::text, ('DENOMINATOR_CHECK'::character varying)::text]))]]></expression>
	</constraint>
	<constraint name="t_rif40_study_sql_pk" type="pk-constr" factor="100" table="rif40.t_rif40_study_sql">
		<columns names="study_id,statement_number,line_number" ref-type="src-columns"/>
	</constraint>
	<index name="t_rif40_study_sql_type_bm" table="rif40.t_rif40_study_sql"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="statement_type"/>
		</idxelement>
	</index>
	<index name="t_rif40_study_sql_uname_bm" table="rif40.t_rif40_study_sql"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="username"/>
		</idxelement>
	</index>
	<trigger name="t_rif40_study_sql_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="rif40.t_rif40_study_sql">
		<comment><![CDATA[INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_study_sql_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_study_sql_checks()"/>
	</trigger>
	<trigger name="t_rif40_study_sql_checks_del" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="rif40.t_rif40_study_sql">
		<comment><![CDATA[DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_study_sql_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_study_sql_checks()"/>
	</trigger>
</table>

<view name="rif40_study_sql">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[SQL created for study execution.]]></comment>
	<position x="50" y="4107.2"/>
	<reference>
		<expression><![CDATA[ SELECT c.username,
    c.study_id,
    c.statement_type,
    c.statement_number,
    c.sql_text,
    c.line_number,
    c.status
   FROM (t_rif40_study_sql c
   LEFT JOIN rif40_study_shares s ON (((c.study_id = s.study_id) AND ((s.grantee_username)::name = "current_user"()))))
  WHERE ((((c.username)::name = "current_user"()) OR ('RIF_MANAGER'::text = ( SELECT user_role_privs.granted_role
      FROM user_role_privs
     WHERE (user_role_privs.granted_role = 'RIF_MANAGER'::text)))) OR ((s.grantee_username IS NOT NULL) AND ((s.grantee_username)::text <> ''::text)))
  ORDER BY c.username;]]></expression>
	</reference>
</view>

<table name="t_rif40_study_sql_log">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Log of SQL executed for study.]]></comment>
	<position x="473.766" y="2472.4"/>
	<column name="username" default-value="&quot;current_user&quot;()">
		<type name="character varying" length="90"/>
		<comment><![CDATA[Username]]></comment>
	</column>
	<column name="study_id" not-null="true" default-value="(currval('rif40_study_id_seq'::regclass))::integer">
		<type name="integer"/>
		<comment><![CDATA[Unique study index: study_id. Created by SEQUENCE rif40_study_id_seq]]></comment>
	</column>
	<column name="statement_type" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Statement type: CREATE, INSERT, POST_INSERT, NUMERATOR_CHECK, DENOMINATOR_CHECK]]></comment>
	</column>
	<column name="statement_number" not-null="true">
		<type name="integer"/>
		<comment><![CDATA[Statement number]]></comment>
	</column>
	<column name="log_message" not-null="true">
		<type name="character varying" length="4000"/>
		<comment><![CDATA[Log message]]></comment>
	</column>
	<column name="log_sqlcode" not-null="true">
		<type name="character varying" length="5"/>
		<comment><![CDATA[SQL code (SQLSTATE hex code in Postgres)]]></comment>
	</column>
	<column name="rowcount" not-null="true">
		<type name="bigint"/>
		<comment><![CDATA[Row count]]></comment>
	</column>
	<column name="start_time" default-value="rif40_sql_pkg.systimestamp((9)::bigint)">
		<type name="timestamp"/>
		<comment><![CDATA[Start time]]></comment>
	</column>
	<column name="elapsed_time" not-null="true">
		<type name="double precision"/>
		<comment><![CDATA[Elapsed time]]></comment>
	</column>
	<column name="audsid" default-value="rif40_sql_pkg.sys_context('USERENV'::character varying, 'SESSIONID'::character varying)">
		<type name="character varying" length="90"/>
		<comment><![CDATA[Link to Oracle audit subsystem. On Postgres is &quot;backend PID.Julian day.Seconds from midnight.uSeconds (backend start time)&quot;. This can be correlated to the logging messages.]]></comment>
	</column>
	<constraint name="statement_type_ck1" type="ck-constr" table="rif40.t_rif40_study_sql_log">
			<expression><![CDATA[((statement_type)::text = ANY (ARRAY[('CREATE'::character varying)::text, ('INSERT'::character varying)::text, ('POST_INSERT'::character varying)::text, ('NUMERATOR_CHECK'::character varying)::text, ('DENOMINATOR_CHECK'::character varying)::text]))]]></expression>
	</constraint>
	<constraint name="t_rif40_study_sql_log_pk" type="pk-constr" factor="100" table="rif40.t_rif40_study_sql_log">
		<columns names="study_id,statement_number" ref-type="src-columns"/>
	</constraint>
	<index name="t_rif40_study_sqllog_type_bm" table="rif40.t_rif40_study_sql_log"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="statement_type"/>
		</idxelement>
	</index>
	<index name="t_rif40_study_sqllog_uname_bm" table="rif40.t_rif40_study_sql_log"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="username"/>
		</idxelement>
	</index>
	<trigger name="t_rif40_study_sql_log_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="rif40.t_rif40_study_sql_log">
		<comment><![CDATA[INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_study_sql_log_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_study_sql_log_checks()"/>
	</trigger>
	<trigger name="t_rif40_study_sql_log_checks_del" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="rif40.t_rif40_study_sql_log">
		<comment><![CDATA[DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_study_sql_log_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_study_sql_log_checks()"/>
	</trigger>
</table>

<view name="rif40_study_sql_log">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Log of SQL executed for study.]]></comment>
	<position x="282.6" y="4107.2"/>
	<reference>
		<expression><![CDATA[ SELECT c.username,
    c.study_id,
    c.statement_type,
    c.statement_number,
    c.log_message,
    c.audsid,
    c.log_sqlcode,
    c.rowcount,
    c.start_time,
    c.elapsed_time
   FROM (t_rif40_study_sql_log c
   LEFT JOIN rif40_study_shares s ON (((c.study_id = s.study_id) AND ((s.grantee_username)::name = "current_user"()))))
  WHERE ((((c.username)::name = "current_user"()) OR ('RIF_MANAGER'::text = ( SELECT user_role_privs.granted_role
      FROM user_role_privs
     WHERE (user_role_privs.granted_role = 'RIF_MANAGER'::text)))) OR ((s.grantee_username IS NOT NULL) AND ((s.grantee_username)::text <> ''::text)))
  ORDER BY c.username;]]></expression>
	</reference>
</view>

<table name="rif40_table_outcomes">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Intersection of health outcomes in logical groups and Health tables. Mutliple groups supported per table]]></comment>
	<position x="920.531" y="2472.4"/>
	<column name="outcome_group_name" not-null="true">
		<type name="character varying" length="20"/>
		<comment><![CDATA[Outcome Group Name. E.g SINGLE_VARIABLE_ICD]]></comment>
	</column>
	<column name="numer_tab" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Numerator table name.]]></comment>
	</column>
	<column name="current_version_start_year">
		<type name="smallint"/>
		<comment><![CDATA[Year of change from current version to previous version]]></comment>
	</column>
	<constraint name="rif40_table_outcomes_pk" type="pk-constr" factor="100" table="rif40.rif40_table_outcomes">
		<columns names="outcome_group_name,numer_tab" ref-type="src-columns"/>
	</constraint>
	<trigger name="rif40_table_outcomes_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="rif40.rif40_table_outcomes">
		<comment><![CDATA[INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_table_outcomes_checks()]]></comment>
	<condition><![CDATA[((((new.outcome_group_name IS NOT NULL) AND ((new.outcome_group_name)::text <> ''::text)) OR ((new.numer_tab IS NOT NULL) AND ((new.numer_tab)::text <> ''::text))) OR ((new.current_version_start_year IS NOT NULL) AND ((new.current_version_start_year)::text <> ''::text)))]]></condition>
		<function signature="rif40_trg_pkg.trigger_fct_rif40_table_outcomes_checks()"/>
	</trigger>
	<trigger name="rif40_table_outcomes_checks_del" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="rif40.rif40_table_outcomes">
		<comment><![CDATA[DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_table_outcomes_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_rif40_table_outcomes_checks()"/>
	</trigger>
</table>

<table name="rif40_tables_and_views">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF40 Tables and Views]]></comment>
	<position x="1356.3" y="2472.4"/>
	<column name="class">
		<type name="character varying" length="13"/>
		<comment><![CDATA[Class]]></comment>
	</column>
	<column name="table_or_view">
		<type name="character varying" length="178"/>
		<comment><![CDATA[Table name]]></comment>
	</column>
	<column name="table_or_view_name_href">
		<type name="character varying" length="413"/>
		<comment><![CDATA[Table name (web version)]]></comment>
	</column>
	<column name="table_or_view_name_hide">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Table name (web version)]]></comment>
	</column>
	<column name="comments">
		<type name="character varying" length="4000"/>
		<comment><![CDATA[Comments]]></comment>
	</column>
</table>

<table name="rif40_triggers">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF40 Triggers]]></comment>
	<position x="1714.3" y="2472.4"/>
	<column name="table_name">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Table name]]></comment>
	</column>
	<column name="column_name">
		<type name="character varying" length="4000"/>
		<comment><![CDATA[Column name]]></comment>
	</column>
	<column name="trigger_name">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Trigger name]]></comment>
	</column>
	<column name="trigger_type">
		<type name="character varying" length="16"/>
		<comment><![CDATA[Type type]]></comment>
	</column>
	<column name="triggering_event">
		<type name="character varying" length="227"/>
		<comment><![CDATA[Triggering event]]></comment>
	</column>
	<column name="when_clause">
		<type name="character varying" length="4000"/>
		<comment><![CDATA[When clause]]></comment>
	</column>
	<column name="action_type">
		<type name="character varying" length="11"/>
		<comment><![CDATA[Action type]]></comment>
	</column>
	<column name="comments">
		<type name="character varying" length="4000"/>
		<comment><![CDATA[Comments]]></comment>
	</column>
</table>

<view name="rif40_user_projects">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF project users]]></comment>
	<position x="515.2" y="4107.2"/>
	<reference>
		<expression><![CDATA[ SELECT a.project,
    a.username,
    a.grant_date,
    a.revoke_date,
    b.description,
    b.date_started,
    b.date_ended
   FROM t_rif40_user_projects a,
    t_rif40_projects b
  WHERE ((((a.project)::text = (b.project)::text) AND ((a.username)::name = "current_user"())) OR ('RIF_MANAGER'::text = ( SELECT user_role_privs.granted_role
           FROM user_role_privs
          WHERE (user_role_privs.granted_role = 'RIF_MANAGER'::text))))
  ORDER BY a.project;]]></expression>
	</reference>
</view>

<view name="rif40_user_version">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[User schema revision control view.]]></comment>
	<position x="738.8" y="4107.2"/>
	<reference>
		<expression><![CDATA[ SELECT '$Revision: 1.11 $'::character varying AS user_schema_revision;]]></expression>
	</reference>
</view>

<table name="rif40_version">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[RIF version]]></comment>
	<position x="50" y="2760.6"/>
	<column name="version" not-null="true">
		<type name="character varying" length="50"/>
		<comment><![CDATA[Version. Used for change control to ensure front end matches database.]]></comment>
	</column>
	<column name="schema_created" default-value="('now'::text)::timestamp without time zone">
		<type name="timestamp"/>
		<comment><![CDATA[Date schema created]]></comment>
	</column>
	<column name="schema_amended">
		<type name="timestamp"/>
		<comment><![CDATA[Date schema amended]]></comment>
	</column>
	<column name="cvs_revision" not-null="true">
		<type name="character varying" length="50"/>
		<comment><![CDATA[CVS revison control information for last amendment]]></comment>
	</column>
	<trigger name="rif40_version_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="rif40.rif40_version">
		<comment><![CDATA[INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_version_checks()]]></comment>
	<condition><![CDATA[((new.version IS NOT NULL) AND ((new.version)::text <> ''::text))]]></condition>
		<function signature="rif40_trg_pkg.trigger_fct_rif40_version_checks()"/>
	</trigger>
	<trigger name="rif40_version_checks_del" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="rif40.rif40_version">
		<comment><![CDATA[INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_version_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_rif40_version_checks()"/>
	</trigger>
</table>

<table name="sahsuland_cancer">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[SAHSU land Population]]></comment>
	<position x="436.766" y="2760.6"/>
	<column name="year" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Year]]></comment>
	</column>
	<column name="age_sex_group" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Age sex group]]></comment>
	</column>
	<column name="level1" not-null="true">
		<type name="character varying" length="20"/>
		<comment><![CDATA[level1]]></comment>
	</column>
	<column name="level2" not-null="true">
		<type name="character varying" length="20"/>
		<comment><![CDATA[level2]]></comment>
	</column>
	<column name="level3" not-null="true">
		<type name="character varying" length="20"/>
		<comment><![CDATA[level3]]></comment>
	</column>
	<column name="level4" not-null="true">
		<type name="character varying" length="20"/>
		<comment><![CDATA[level4]]></comment>
	</column>
	<column name="icd" not-null="true">
		<type name="character varying" length="4"/>
		<comment><![CDATA[ICD]]></comment>
	</column>
	<column name="total" not-null="true">
		<type name="double precision"/>
		<comment><![CDATA[Total]]></comment>
	</column>
	<index name="sahsuland_cancer_age_group" table="rif40.sahsuland_cancer"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<expression><![CDATA[mod((age_sex_group)::integer]]></expression>
		</idxelement>
	</index>
	<index name="sahsuland_cancer_age_sex_group" table="rif40.sahsuland_cancer"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="age_sex_group"/>
		</idxelement>
	</index>
	<index name="sahsuland_cancer_icd" table="rif40.sahsuland_cancer"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="icd"/>
		</idxelement>
	</index>
	<index name="sahsuland_cancer_level1" table="rif40.sahsuland_cancer"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="level1"/>
		</idxelement>
	</index>
	<index name="sahsuland_cancer_level2" table="rif40.sahsuland_cancer"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="level2"/>
		</idxelement>
	</index>
	<index name="sahsuland_cancer_level3" table="rif40.sahsuland_cancer"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="level3"/>
		</idxelement>
	</index>
	<index name="sahsuland_cancer_level4" table="rif40.sahsuland_cancer"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="level4"/>
		</idxelement>
	</index>
	<index name="sahsuland_cancer_pk" table="rif40.sahsuland_cancer"
		 concurrent="false" unique="true" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="year"/>
		</idxelement>
		<idxelement use-sorting="false">
			<column name="level4"/>
		</idxelement>
		<idxelement use-sorting="false">
			<column name="age_sex_group"/>
		</idxelement>
		<idxelement use-sorting="false">
			<column name="icd"/>
		</idxelement>
	</index>
	<index name="sahsuland_cancer_sex" table="rif40.sahsuland_cancer"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<expression><![CDATA["trunc(((age_sex_group / 100))::double precision)"]]></expression>
		</idxelement>
	</index>
	<index name="sahsuland_cancer_year" table="rif40.sahsuland_cancer"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="year"/>
		</idxelement>
	</index>
</table>

<table name="sahsuland_covariates_level3">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[SAHSU land covariates - level3]]></comment>
	<position x="861.531" y="2760.6"/>
	<column name="year" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Year]]></comment>
	</column>
	<column name="level3" not-null="true">
		<type name="character varying" length="20"/>
		<comment><![CDATA[Level3]]></comment>
	</column>
	<column name="ses" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Social Economic Status (quintiles)]]></comment>
	</column>
	<column name="ethnicity" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Ethnicity % non white - 1: <5%, 2: 5 to 10%, 3: >= 10%]]></comment>
	</column>
	<index name="sahsuland_covariates_level3_pk" table="rif40.sahsuland_covariates_level3"
		 concurrent="false" unique="true" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="year"/>
		</idxelement>
		<idxelement use-sorting="false">
			<column name="level3"/>
		</idxelement>
	</index>
</table>

<table name="sahsuland_covariates_level4">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[SAHSU land covariates - level4]]></comment>
	<position x="1274.3" y="2760.6"/>
	<column name="year" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Year]]></comment>
	</column>
	<column name="level4" not-null="true">
		<type name="character varying" length="20"/>
		<comment><![CDATA[Level4]]></comment>
	</column>
	<column name="ses" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Social Economic Status (quintiles)]]></comment>
	</column>
	<column name="areatri1km" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Toxic Release Inventory within 1km of area (0=no/1=yes)]]></comment>
	</column>
	<column name="near_dist" not-null="true">
		<type name="double precision"/>
		<comment><![CDATA[Distance (m) from area centroid to nearest TRI site]]></comment>
	</column>
	<column name="tri_1km" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Toxic Release Inventory within 1km of areai centroid (0=no/1=yes)]]></comment>
	</column>
	<index name="sahsuland_covariates_level4_pk" table="rif40.sahsuland_covariates_level4"
		 concurrent="false" unique="true" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="year"/>
		</idxelement>
		<idxelement use-sorting="false">
			<column name="level4"/>
		</idxelement>
	</index>
</table>

<table name="sahsuland_geography">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[SAHSU example database geo-level hierarchy table]]></comment>
	<position x="1687.06" y="2760.6"/>
	<column name="level1">
		<type name="character varying" length="100"/>
		<comment><![CDATA[Lowest level of resolution]]></comment>
	</column>
	<column name="level2">
		<type name="character varying" length="100"/>
		<comment><![CDATA[2nd level of resolution]]></comment>
	</column>
	<column name="level3">
		<type name="character varying" length="100"/>
		<comment><![CDATA[3rd level of resolution]]></comment>
	</column>
	<column name="level4">
		<type name="character varying" length="100"/>
		<comment><![CDATA[Highest level of resolution]]></comment>
	</column>
	<index name="level1_idx1" table="rif40.sahsuland_geography"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="level1"/>
		</idxelement>
	</index>
	<index name="level2_idx2" table="rif40.sahsuland_geography"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="level2"/>
		</idxelement>
	</index>
	<index name="level3_idx3" table="rif40.sahsuland_geography"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="level3"/>
		</idxelement>
	</index>
	<index name="level4_idx4" table="rif40.sahsuland_geography"
		 concurrent="false" unique="true" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="level4"/>
		</idxelement>
	</index>
</table>

<table name="sahsuland_level1">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Lowest level of resolution lookup table]]></comment>
	<position x="50" y="3108.8"/>
	<column name="level1">
		<type name="character varying" length="5"/>
		<comment><![CDATA[level1]]></comment>
	</column>
	<column name="name" not-null="true">
		<type name="character varying" length="100"/>
		<comment><![CDATA[level1 name]]></comment>
	</column>
	<index name="sahsuland_level1_pk" table="rif40.sahsuland_level1"
		 concurrent="false" unique="true" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="level1"/>
		</idxelement>
	</index>
	<index name="sahsuland_level1_uk2" table="rif40.sahsuland_level1"
		 concurrent="false" unique="true" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="name"/>
		</idxelement>
	</index>
</table>

<table name="sahsuland_level2">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[2nd level of resolution lookup table]]></comment>
	<position x="412.766" y="3108.8"/>
	<column name="level2">
		<type name="character varying" length="6"/>
		<comment><![CDATA[level2]]></comment>
	</column>
	<column name="name" not-null="true">
		<type name="character varying" length="100"/>
		<comment><![CDATA[level2 name]]></comment>
	</column>
	<index name="sahsuland_level2_pk" table="rif40.sahsuland_level2"
		 concurrent="false" unique="true" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="level2"/>
		</idxelement>
	</index>
</table>

<table name="sahsuland_level3">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[3rd level of resolution lookup table]]></comment>
	<position x="769.531" y="3108.8"/>
	<column name="level3">
		<type name="character varying" length="15"/>
		<comment><![CDATA[level3]]></comment>
	</column>
	<column name="name" not-null="true">
		<type name="character varying" length="100"/>
		<comment><![CDATA[level3 name]]></comment>
	</column>
	<index name="sahsuland_level3_pk" table="rif40.sahsuland_level3"
		 concurrent="false" unique="true" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="level3"/>
		</idxelement>
	</index>
	<index name="sahsuland_level3_uk2" table="rif40.sahsuland_level3"
		 concurrent="false" unique="true" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="name"/>
		</idxelement>
	</index>
</table>

<table name="sahsuland_level4">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Highest level of resolution lookup table]]></comment>
	<position x="1132.3" y="3108.8"/>
	<column name="level4">
		<type name="character varying" length="15"/>
		<comment><![CDATA[level4]]></comment>
	</column>
	<column name="name" not-null="true">
		<type name="character varying" length="100"/>
		<comment><![CDATA[level4 name]]></comment>
	</column>
	<index name="sahsuland_level4_pk" table="rif40.sahsuland_level4"
		 concurrent="false" unique="true" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="level4"/>
		</idxelement>
	</index>
	<index name="sahsuland_level4_uk2" table="rif40.sahsuland_level4"
		 concurrent="false" unique="true" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="name"/>
		</idxelement>
	</index>
</table>

<table name="sahsuland_pop">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[SAHSU land Population]]></comment>
	<position x="1495.06" y="3108.8"/>
	<column name="year" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Year]]></comment>
	</column>
	<column name="age_sex_group" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Age sex group]]></comment>
	</column>
	<column name="level1" not-null="true">
		<type name="character varying" length="20"/>
		<comment><![CDATA[level1]]></comment>
	</column>
	<column name="level2" not-null="true">
		<type name="character varying" length="20"/>
		<comment><![CDATA[level2]]></comment>
	</column>
	<column name="level3" not-null="true">
		<type name="character varying" length="20"/>
		<comment><![CDATA[level3]]></comment>
	</column>
	<column name="level4" not-null="true">
		<type name="character varying" length="20"/>
		<comment><![CDATA[level4]]></comment>
	</column>
	<column name="total" not-null="true">
		<type name="double precision"/>
		<comment><![CDATA[Total]]></comment>
	</column>
	<index name="sahsuland_pop_age_group" table="rif40.sahsuland_pop"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<expression><![CDATA[mod((age_sex_group)::integer]]></expression>
		</idxelement>
	</index>
	<index name="sahsuland_pop_age_sex_group" table="rif40.sahsuland_pop"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="age_sex_group"/>
		</idxelement>
	</index>
	<index name="sahsuland_pop_level1" table="rif40.sahsuland_pop"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="level1"/>
		</idxelement>
	</index>
	<index name="sahsuland_pop_level2" table="rif40.sahsuland_pop"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="level2"/>
		</idxelement>
	</index>
	<index name="sahsuland_pop_level3" table="rif40.sahsuland_pop"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="level3"/>
		</idxelement>
	</index>
	<index name="sahsuland_pop_level4" table="rif40.sahsuland_pop"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="level4"/>
		</idxelement>
	</index>
	<index name="sahsuland_pop_pk" table="rif40.sahsuland_pop"
		 concurrent="false" unique="true" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="year"/>
		</idxelement>
		<idxelement use-sorting="false">
			<column name="level4"/>
		</idxelement>
		<idxelement use-sorting="false">
			<column name="age_sex_group"/>
		</idxelement>
	</index>
	<index name="sahsuland_pop_sex" table="rif40.sahsuland_pop"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<expression><![CDATA["trunc(((age_sex_group / 100))::double precision)"]]></expression>
		</idxelement>
	</index>
	<index name="sahsuland_pop_year" table="rif40.sahsuland_pop"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="year"/>
		</idxelement>
	</index>
</table>

<table name="t_rif40_sahsu_geometry">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Geolevels geometry: geometry for hierarchy of level with a geography. Use this table for INSERT/UPDATE/DELETE; use RIF40_GEOLEVELS for SELECT. In RIF40_GEOLEVELS if the user has the RIF_STUDENT role the geolevels are restricted to LADUA/DISTRICT level resolution or lower. This table contains no data on Oracle. This replaces the shapefiles used in previous RIF releases. Populating this table checks the lookup and hierarchy tables and thus it must be populated last. Any insert into T_RIF40_GEOLEVELS_GEOMETRY must be a single statement insert.]]></comment>
	<position x="50" y="3427"/>
	<column name="geography" not-null="true">
		<type name="character varying" length="50"/>
		<comment><![CDATA[Geography (e.g EW2001)]]></comment>
	</column>
	<column name="geolevel_name" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Name of geolevel. This will be a column name in the numerator/denominator tables]]></comment>
	</column>
	<column name="area_id" not-null="true">
		<type name="character varying" length="300"/>
		<comment><![CDATA[An area id, the value of a geolevel; i.e. the value of the column T_RIF40_GEOLEVELS.GEOLEVEL_NAME in table T_RIF40_GEOLEVELS.LOOKUP_TABLE]]></comment>
	</column>
	<column name="name" not-null="true">
		<type name="character varying" length="300"/>
		<comment><![CDATA[The name of an area id]]></comment>
	</column>
	<column name="optimised_geojson" not-null="true">
		<type name="character varying"/>
		<comment><![CDATA[Shapefile multipolygon in optimised GeoJSON format. RIF40_GEOGRAPHIES.MAX_GEOJSON_DIGITS determines the number of digits in the GeoJSON output and RIF40_GEOLEVELS.ST_SIMPLIFY_TOLERANCE determines the minimum distance (in metres for most projections) between simplified points. Will contain small slivers and overlaps due to limitation in the Douglas-Peucker algorithm (it works onj an object by object basis; the edge between two areas will therefore be processed independently and not necessarily in the same manner). This can be fixed using the PostGIS Topology extension and processing as edges. See also TOPO_OPTIMISED_GEOJSON; i.e. GeoJson optimised using ST_ChangeEdgeGeometry() and ST_Simplify(). The SRID is always 4326.]]></comment>
	</column>
	<column name="area" not-null="true">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[The area in square km of an area id]]></comment>
	</column>
	<column name="total_males">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[Total males]]></comment>
	</column>
	<column name="total_females">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[Total females]]></comment>
	</column>
	<column name="population_year">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[Year of population data]]></comment>
	</column>
	<column name="gid" not-null="true">
		<type name="integer"/>
		<comment><![CDATA[Geographic ID (artificial primary key originally created by shp2pgsql, equals RIF40_GEOLEVELS.GEOLEVEL_ID after ST_Union() conversion to single multipolygon per AREA_ID)]]></comment>
	</column>
	<column name="shapefile_geometry" not-null="true">
		<type name="geometry" spatial-type="MULTIPOLYGON" variation="0" srid="27700"/>
		<comment><![CDATA[Spatial data for geolevel (PostGress/PostGIS only). Can also use SHAPEFILE instead,]]></comment>
	</column>
	<column name="optimised_geometry" not-null="true">
		<type name="geometry" spatial-type="MULTIPOLYGON" variation="0" srid="4326"/>
		<comment><![CDATA[Optimised spatial data for geolevel in SRID 4326 [WGS84] (PostGress/PostGIS only). Can also use SHAPEFILE instead. RIF40_GEOGRAPHIES.MAX_GEOJSON_DIGITS determines the number of digits in the GeoJSON output and RIF40_GEOLEVELS.ST_SIMPLIFY_TOLERANCE determines the minimum distance (in metres for most projections) between simplified points. Will contain small slivers and overlaps due to limitation in the Douglas-Peucker algorithm (it works onj an object by object basis; the edge between two areas will therefore be processed independently and not necessarily in the same manner. This is fixed using the PostGIS Topology extension and processing as edges.]]></comment>
	</column>
	<constraint name="t_rif40_sahsu_geometry_pk" type="pk-constr" factor="100" table="rif40.t_rif40_sahsu_geometry">
		<columns names="geography,geolevel_name,area_id" ref-type="src-columns"/>
	</constraint>
	<index name="t_rif40_sahsu_geo_gin1" table="rif40.t_rif40_sahsu_geometry"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="gist" factor="0">
		<idxelement use-sorting="false">
			<column name="shapefile_geometry"/>
		</idxelement>
	</index>
	<index name="t_rif40_sahsu_geo_gin2" table="rif40.t_rif40_sahsu_geometry"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="gist" factor="0">
		<idxelement use-sorting="false">
			<column name="optimised_geometry"/>
		</idxelement>
	</index>
	<index name="t_rif40_sahsu_geometry_uk" table="rif40.t_rif40_sahsu_geometry"
		 concurrent="false" unique="true" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="geography"/>
		</idxelement>
		<idxelement use-sorting="false">
			<column name="gid"/>
		</idxelement>
		<idxelement use-sorting="false">
			<column name="area_id"/>
		</idxelement>
	</index>
	<index name="t_rif40_sahsu_geometry_uk2" table="rif40.t_rif40_sahsu_geometry"
		 concurrent="false" unique="true" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="name"/>
		</idxelement>
	</index>
	<trigger name="t_rif40_sahsu_geometry_insert" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="rif40.t_rif40_sahsu_geometry">
		<comment><![CDATA[Partition INSERT trigger for geography: SAHSU]]></comment>
		<function signature="rif40.t_rif40_sahsu_geometry_insert()"/>
	</trigger>
</table>

<table name="t_rif40_geolevels_geometry_sahsu_level1">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Geolevels geometry: geometry for hierarchy of level with a geography. Use this table for INSERT/UPDATE/DELETE; use RIF40_GEOLEVELS for SELECT. In RIF40_GEOLEVELS if the user has the RIF_STUDENT role the geolevels are restricted to LADUA/DISTRICT level resolution or lower. This table contains no data on Oracle. This replaces the shapefiles used in previous RIF releases. Populating this table checks the lookup and hierarchy tables and thus it must be populated last. Any insert into T_RIF40_GEOLEVELS_GEOMETRY must be a single statement insert. This is the partition for geogrpahy: sahsu, geo level: level1]]></comment>
	<position x="534.766" y="3427"/>
	<column name="geography" not-null="true">
		<type name="character varying" length="50"/>
		<comment><![CDATA[Geography (e.g EW2001)]]></comment>
	</column>
	<column name="geolevel_name" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Name of geolevel. This will be a column name in the numerator/denominator tables]]></comment>
	</column>
	<column name="area_id" not-null="true">
		<type name="character varying" length="300"/>
		<comment><![CDATA[An area id, the value of a geolevel; i.e. the value of the column T_RIF40_GEOLEVELS.GEOLEVEL_NAME in table T_RIF40_GEOLEVELS.LOOKUP_TABLE]]></comment>
	</column>
	<column name="name" not-null="true">
		<type name="character varying" length="300"/>
		<comment><![CDATA[The name of an area id]]></comment>
	</column>
	<column name="optimised_geojson" not-null="true">
		<type name="character varying"/>
		<comment><![CDATA[Shapefile multipolygon in optimised GeoJSON format. RIF40_GEOGRAPHIES.MAX_GEOJSON_DIGITS determines the number of digits in the GeoJSON output and RIF40_GEOLEVELS.ST_SIMPLIFY_TOLERANCE determines the minimum distance (in metres for most projections) between simplified points. Will contain small slivers and overlaps due to limitation in the Douglas-Peucker algorithm (it works on an object by object basis; the edge between two areas will therefore be processed independently and not necessarily in the same manner). This can be` fixed using the PostGIS Topology extension and processing as edges. See also TOPO_OPTIMISED_GEOJSON; i.e. GeoJson optimised using ST_ChangeEdgeGeometry() and ST_Simplify().]]></comment>
	</column>
	<column name="area" not-null="true">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[The area in square km of an area id]]></comment>
	</column>
	<column name="total_males">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[Total males.]]></comment>
	</column>
	<column name="total_females">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[Total females.]]></comment>
	</column>
	<column name="population_year">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[Population year.]]></comment>
	</column>
	<column name="gid" not-null="true">
		<type name="integer"/>
		<comment><![CDATA[Geographic ID (artificial primary key originally created by shp2pgsql, equals RIF40_GEOLEVELS.GEOLEVEL_ID after ST_Union() conversion to single multipolygon per AREA_ID)]]></comment>
	</column>
	<column name="shapefile_geometry" not-null="true">
		<type name="geometry" spatial-type="MULTIPOLYGON" variation="0" srid="27700"/>
		<comment><![CDATA[Spatial data for geolevel (PostGress/PostGIS only). Can also use SHAPEFILE instead,]]></comment>
	</column>
	<column name="optimised_geometry" not-null="true">
		<type name="geometry" spatial-type="MULTIPOLYGON" variation="0" srid="4326"/>
		<comment><![CDATA[Optimised spatial data for geolevel in SRID 4326 [WGS84] (PostGress/PostGIS only). Can also use SHAPEFILE instead. RIF40_GEOGRAPHIES.MAX_GEOJSON_DIGITS determines the number of digits in the GeoJSON output and RIF40_GEOLEVELS.ST_SIMPLIFY_TOLERANCE determines the minimum distance (in metres for most projections) between simplified points. Will contain small slivers and overlaps due to limitation in the Douglas-Peucker algorithm (it works onj an object by object basis; the edge between two areas will therefore be processed independently and not necessarily in the same manner. This is fixed using the PostGIS Topology extension and processing as edges.]]></comment>
	</column>
	<constraint name="t_rif40_geolevels_geometry_sahsu_level1_check" type="ck-constr" table="rif40.t_rif40_geolevels_geometry_sahsu_level1">
			<expression><![CDATA[(((geography)::text = 'SAHSU'::text) AND ((geolevel_name)::text = 'LEVEL1'::text))]]></expression>
	</constraint>
</table>

<table name="t_rif40_geolevels_geometry_sahsu_level2">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Geolevels geometry: geometry for hierarchy of level with a geography. Use this table for INSERT/UPDATE/DELETE; use RIF40_GEOLEVELS for SELECT. In RIF40_GEOLEVELS if the user has the RIF_STUDENT role the geolevels are restricted to LADUA/DISTRICT level resolution or lower. This table contains no data on Oracle. This replaces the shapefiles used in previous RIF releases. Populating this table checks the lookup and hierarchy tables and thus it must be populated last. Any insert into T_RIF40_GEOLEVELS_GEOMETRY must be a single statement insert. This is the partition for geogrpahy: sahsu, geo level: level2]]></comment>
	<position x="962.766" y="3427"/>
	<column name="geography" not-null="true">
		<type name="character varying" length="50"/>
		<comment><![CDATA[Geography (e.g EW2001)]]></comment>
	</column>
	<column name="geolevel_name" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Name of geolevel. This will be a column name in the numerator/denominator tables]]></comment>
	</column>
	<column name="area_id" not-null="true">
		<type name="character varying" length="300"/>
		<comment><![CDATA[An area id, the value of a geolevel; i.e. the value of the column T_RIF40_GEOLEVELS.GEOLEVEL_NAME in table T_RIF40_GEOLEVELS.LOOKUP_TABLE]]></comment>
	</column>
	<column name="name" not-null="true">
		<type name="character varying" length="300"/>
		<comment><![CDATA[The name of an area id]]></comment>
	</column>
	<column name="optimised_geojson" not-null="true">
		<type name="character varying"/>
		<comment><![CDATA[Shapefile multipolygon in optimised GeoJSON format. RIF40_GEOGRAPHIES.MAX_GEOJSON_DIGITS determines the number of digits in the GeoJSON output and RIF40_GEOLEVELS.ST_SIMPLIFY_TOLERANCE determines the minimum distance (in metres for most projections) between simplified points. Will contain small slivers and overlaps due to limitation in the Douglas-Peucker algorithm (it works on an object by object basis; the edge between two areas will therefore be processed independently and not necessarily in the same manner). This can be` fixed using the PostGIS Topology extension and processing as edges. See also TOPO_OPTIMISED_GEOJSON; i.e. GeoJson optimised using ST_ChangeEdgeGeometry() and ST_Simplify().]]></comment>
	</column>
	<column name="area" not-null="true">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[The area in square km of an area id]]></comment>
	</column>
	<column name="total_males">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[Total males.]]></comment>
	</column>
	<column name="total_females">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[Total females.]]></comment>
	</column>
	<column name="population_year">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[Population year.]]></comment>
	</column>
	<column name="gid" not-null="true">
		<type name="integer"/>
		<comment><![CDATA[Geographic ID (artificial primary key originally created by shp2pgsql, equals RIF40_GEOLEVELS.GEOLEVEL_ID after ST_Union() conversion to single multipolygon per AREA_ID)]]></comment>
	</column>
	<column name="shapefile_geometry" not-null="true">
		<type name="geometry" spatial-type="MULTIPOLYGON" variation="0" srid="27700"/>
		<comment><![CDATA[Spatial data for geolevel (PostGress/PostGIS only). Can also use SHAPEFILE instead,]]></comment>
	</column>
	<column name="optimised_geometry" not-null="true">
		<type name="geometry" spatial-type="MULTIPOLYGON" variation="0" srid="4326"/>
		<comment><![CDATA[Optimised spatial data for geolevel in SRID 4326 [WGS84] (PostGress/PostGIS only). Can also use SHAPEFILE instead. RIF40_GEOGRAPHIES.MAX_GEOJSON_DIGITS determines the number of digits in the GeoJSON output and RIF40_GEOLEVELS.ST_SIMPLIFY_TOLERANCE determines the minimum distance (in metres for most projections) between simplified points. Will contain small slivers and overlaps due to limitation in the Douglas-Peucker algorithm (it works onj an object by object basis; the edge between two areas will therefore be processed independently and not necessarily in the same manner. This is fixed using the PostGIS Topology extension and processing as edges.]]></comment>
	</column>
	<constraint name="t_rif40_geolevels_geometry_sahsu_level2_check" type="ck-constr" table="rif40.t_rif40_geolevels_geometry_sahsu_level2">
			<expression><![CDATA[(((geography)::text = 'SAHSU'::text) AND ((geolevel_name)::text = 'LEVEL2'::text))]]></expression>
	</constraint>
</table>

<table name="t_rif40_geolevels_geometry_sahsu_level3">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Geolevels geometry: geometry for hierarchy of level with a geography. Use this table for INSERT/UPDATE/DELETE; use RIF40_GEOLEVELS for SELECT. In RIF40_GEOLEVELS if the user has the RIF_STUDENT role the geolevels are restricted to LADUA/DISTRICT level resolution or lower. This table contains no data on Oracle. This replaces the shapefiles used in previous RIF releases. Populating this table checks the lookup and hierarchy tables and thus it must be populated last. Any insert into T_RIF40_GEOLEVELS_GEOMETRY must be a single statement insert. This is the partition for geogrpahy: sahsu, geo level: level3]]></comment>
	<position x="1390.77" y="3427"/>
	<column name="geography" not-null="true">
		<type name="character varying" length="50"/>
		<comment><![CDATA[Geography (e.g EW2001)]]></comment>
	</column>
	<column name="geolevel_name" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Name of geolevel. This will be a column name in the numerator/denominator tables]]></comment>
	</column>
	<column name="area_id" not-null="true">
		<type name="character varying" length="300"/>
		<comment><![CDATA[An area id, the value of a geolevel; i.e. the value of the column T_RIF40_GEOLEVELS.GEOLEVEL_NAME in table T_RIF40_GEOLEVELS.LOOKUP_TABLE]]></comment>
	</column>
	<column name="name" not-null="true">
		<type name="character varying" length="300"/>
		<comment><![CDATA[The name of an area id]]></comment>
	</column>
	<column name="optimised_geojson" not-null="true">
		<type name="character varying"/>
		<comment><![CDATA[Shapefile multipolygon in optimised GeoJSON format. RIF40_GEOGRAPHIES.MAX_GEOJSON_DIGITS determines the number of digits in the GeoJSON output and RIF40_GEOLEVELS.ST_SIMPLIFY_TOLERANCE determines the minimum distance (in metres for most projections) between simplified points. Will contain small slivers and overlaps due to limitation in the Douglas-Peucker algorithm (it works on an object by object basis; the edge between two areas will therefore be processed independently and not necessarily in the same manner). This can be` fixed using the PostGIS Topology extension and processing as edges. See also TOPO_OPTIMISED_GEOJSON; i.e. GeoJson optimised using ST_ChangeEdgeGeometry() and ST_Simplify().]]></comment>
	</column>
	<column name="area" not-null="true">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[The area in square km of an area id]]></comment>
	</column>
	<column name="total_males">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[Total males.]]></comment>
	</column>
	<column name="total_females">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[Total females.]]></comment>
	</column>
	<column name="population_year">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[Population year.]]></comment>
	</column>
	<column name="gid" not-null="true">
		<type name="integer"/>
		<comment><![CDATA[Geographic ID (artificial primary key originally created by shp2pgsql, equals RIF40_GEOLEVELS.GEOLEVEL_ID after ST_Union() conversion to single multipolygon per AREA_ID)]]></comment>
	</column>
	<column name="shapefile_geometry" not-null="true">
		<type name="geometry" spatial-type="MULTIPOLYGON" variation="0" srid="27700"/>
		<comment><![CDATA[Spatial data for geolevel (PostGress/PostGIS only). Can also use SHAPEFILE instead,]]></comment>
	</column>
	<column name="optimised_geometry" not-null="true">
		<type name="geometry" spatial-type="MULTIPOLYGON" variation="0" srid="4326"/>
		<comment><![CDATA[Optimised spatial data for geolevel in SRID 4326 [WGS84] (PostGress/PostGIS only). Can also use SHAPEFILE instead. RIF40_GEOGRAPHIES.MAX_GEOJSON_DIGITS determines the number of digits in the GeoJSON output and RIF40_GEOLEVELS.ST_SIMPLIFY_TOLERANCE determines the minimum distance (in metres for most projections) between simplified points. Will contain small slivers and overlaps due to limitation in the Douglas-Peucker algorithm (it works onj an object by object basis; the edge between two areas will therefore be processed independently and not necessarily in the same manner. This is fixed using the PostGIS Topology extension and processing as edges.]]></comment>
	</column>
	<constraint name="t_rif40_geolevels_geometry_sahsu_level3_check" type="ck-constr" table="rif40.t_rif40_geolevels_geometry_sahsu_level3">
			<expression><![CDATA[(((geography)::text = 'SAHSU'::text) AND ((geolevel_name)::text = 'LEVEL3'::text))]]></expression>
	</constraint>
</table>

<table name="t_rif40_geolevels_geometry_sahsu_level4">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Geolevels geometry: geometry for hierarchy of level with a geography. Use this table for INSERT/UPDATE/DELETE; use RIF40_GEOLEVELS for SELECT. In RIF40_GEOLEVELS if the user has the RIF_STUDENT role the geolevels are restricted to LADUA/DISTRICT level resolution or lower. This table contains no data on Oracle. This replaces the shapefiles used in previous RIF releases. Populating this table checks the lookup and hierarchy tables and thus it must be populated last. Any insert into T_RIF40_GEOLEVELS_GEOMETRY must be a single statement insert. This is the partition for geogrpahy: sahsu, geo level: level4]]></comment>
	<position x="1818.77" y="3427"/>
	<column name="geography" not-null="true">
		<type name="character varying" length="50"/>
		<comment><![CDATA[Geography (e.g EW2001)]]></comment>
	</column>
	<column name="geolevel_name" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Name of geolevel. This will be a column name in the numerator/denominator tables]]></comment>
	</column>
	<column name="area_id" not-null="true">
		<type name="character varying" length="300"/>
		<comment><![CDATA[An area id, the value of a geolevel; i.e. the value of the column T_RIF40_GEOLEVELS.GEOLEVEL_NAME in table T_RIF40_GEOLEVELS.LOOKUP_TABLE]]></comment>
	</column>
	<column name="name" not-null="true">
		<type name="character varying" length="300"/>
		<comment><![CDATA[The name of an area id]]></comment>
	</column>
	<column name="optimised_geojson" not-null="true">
		<type name="character varying"/>
		<comment><![CDATA[Shapefile multipolygon in optimised GeoJSON format. RIF40_GEOGRAPHIES.MAX_GEOJSON_DIGITS determines the number of digits in the GeoJSON output and RIF40_GEOLEVELS.ST_SIMPLIFY_TOLERANCE determines the minimum distance (in metres for most projections) between simplified points. Will contain small slivers and overlaps due to limitation in the Douglas-Peucker algorithm (it works on an object by object basis; the edge between two areas will therefore be processed independently and not necessarily in the same manner). This can be` fixed using the PostGIS Topology extension and processing as edges. See also TOPO_OPTIMISED_GEOJSON; i.e. GeoJson optimised using ST_ChangeEdgeGeometry() and ST_Simplify().]]></comment>
	</column>
	<column name="area" not-null="true">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[The area in square km of an area id]]></comment>
	</column>
	<column name="total_males">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[Total males.]]></comment>
	</column>
	<column name="total_females">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[Total females.]]></comment>
	</column>
	<column name="population_year">
		<type name="numeric" length="12" precision="2"/>
		<comment><![CDATA[Population year.]]></comment>
	</column>
	<column name="gid" not-null="true">
		<type name="integer"/>
		<comment><![CDATA[Geographic ID (artificial primary key originally created by shp2pgsql, equals RIF40_GEOLEVELS.GEOLEVEL_ID after ST_Union() conversion to single multipolygon per AREA_ID)]]></comment>
	</column>
	<column name="shapefile_geometry" not-null="true">
		<type name="geometry" spatial-type="MULTIPOLYGON" variation="0" srid="27700"/>
		<comment><![CDATA[Spatial data for geolevel (PostGress/PostGIS only). Can also use SHAPEFILE instead,]]></comment>
	</column>
	<column name="optimised_geometry" not-null="true">
		<type name="geometry" spatial-type="MULTIPOLYGON" variation="0" srid="4326"/>
		<comment><![CDATA[Optimised spatial data for geolevel in SRID 4326 [WGS84] (PostGress/PostGIS only). Can also use SHAPEFILE instead. RIF40_GEOGRAPHIES.MAX_GEOJSON_DIGITS determines the number of digits in the GeoJSON output and RIF40_GEOLEVELS.ST_SIMPLIFY_TOLERANCE determines the minimum distance (in metres for most projections) between simplified points. Will contain small slivers and overlaps due to limitation in the Douglas-Peucker algorithm (it works onj an object by object basis; the edge between two areas will therefore be processed independently and not necessarily in the same manner. This is fixed using the PostGIS Topology extension and processing as edges.]]></comment>
	</column>
	<constraint name="t_rif40_geolevels_geometry_sahsu_level4_check" type="ck-constr" table="rif40.t_rif40_geolevels_geometry_sahsu_level4">
			<expression><![CDATA[(((geography)::text = 'SAHSU'::text) AND ((geolevel_name)::text = 'LEVEL4'::text))]]></expression>
	</constraint>
</table>

<table name="t_rif40_num_denom">
	<schema name="rif40"/>
	<role name="rif40"/>
	<comment><![CDATA[Private copy of extra numerator and denominator pairs not added automatically.]]></comment>
	<position x="50" y="3760.2"/>
	<column name="geography" not-null="true">
		<type name="character varying" length="50"/>
		<comment><![CDATA[Geography (e.g EW2001)]]></comment>
	</column>
	<column name="numerator_table" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Numerator table]]></comment>
	</column>
	<column name="denominator_table" not-null="true">
		<type name="character varying" length="30"/>
		<comment><![CDATA[Denominator table]]></comment>
	</column>
	<index name="rif40_num_denom_pk" table="rif40.t_rif40_num_denom"
		 concurrent="false" unique="true" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="geography"/>
		</idxelement>
		<idxelement use-sorting="false">
			<column name="numerator_table"/>
		</idxelement>
		<idxelement use-sorting="false">
			<column name="denominator_table"/>
		</idxelement>
	</index>
	<trigger name="t_rif40_num_denom_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="rif40.t_rif40_num_denom">
		<comment><![CDATA[INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks()]]></comment>
	<condition><![CDATA[((((new.geography IS NOT NULL) AND ((new.geography)::text <> ''::text)) OR ((new.numerator_table IS NOT NULL) AND ((new.numerator_table)::text <> ''::text))) OR ((new.denominator_table IS NOT NULL) AND ((new.denominator_table)::text <> ''::text)))]]></condition>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks()"/>
	</trigger>
	<trigger name="t_rif40_num_denom_checks_del" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="rif40.t_rif40_num_denom">
		<comment><![CDATA[DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks()]]></comment>
		<function signature="rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks()"/>
	</trigger>
</table>

<table name="s1_extract">
	<schema name="rif_studies"/>
	<role name="rif40"/>
	<position x="2507.37" y="50"/>
	<column name="year" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Year]]></comment>
	</column>
	<column name="study_or_comparison" not-null="true">
		<type name="character varying"/>
		<comment><![CDATA[Study (S) or comparison (C) area]]></comment>
	</column>
	<column name="study_id" not-null="true">
		<type name="integer"/>
		<comment><![CDATA[Study ID]]></comment>
	</column>
	<column name="area_id" not-null="true">
		<type name="character varying"/>
		<comment><![CDATA[Area ID]]></comment>
	</column>
	<column name="band_id">
		<type name="integer"/>
		<comment><![CDATA[Band ID]]></comment>
	</column>
	<column name="sex">
		<type name="smallint"/>
		<comment><![CDATA[Sex]]></comment>
	</column>
	<column name="age_group">
		<type name="smallint"/>
		<comment><![CDATA[Age group]]></comment>
	</column>
	<column name="ses">
		<type name="character varying"/>
		<comment><![CDATA[SES]]></comment>
	</column>
	<column name="inv_1">
		<type name="bigint"/>
		<comment><![CDATA[Lung cancer]]></comment>
	</column>
	<column name="total_pop">
		<type name="double precision"/>
		<comment><![CDATA[Total population]]></comment>
	</column>
	<index name="s1_extract_age_group" table="rif_studies.s1_extract"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="age_group"/>
		</idxelement>
	</index>
	<index name="s1_extract_area_id" table="rif_studies.s1_extract"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="area_id"/>
		</idxelement>
	</index>
	<index name="s1_extract_band_id" table="rif_studies.s1_extract"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="band_id"/>
		</idxelement>
	</index>
	<index name="s1_extract_sex" table="rif_studies.s1_extract"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="sex"/>
		</idxelement>
	</index>
	<index name="s1_extract_study_or_comparison" table="rif_studies.s1_extract"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="study_or_comparison"/>
		</idxelement>
	</index>
	<index name="s1_extract_year" table="rif_studies.s1_extract"
		 concurrent="false" unique="false" fast-update="false"
		 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="year"/>
		</idxelement>
	</index>
</table>

<table name="s1_map">
	<schema name="rif_studies"/>
	<role name="rif40"/>
	<comment><![CDATA[Study :1 extract table]]></comment>
	<position x="2843.37" y="50"/>
	<column name="username">
		<type name="character varying" length="90"/>
		<comment><![CDATA[Username]]></comment>
	</column>
	<column name="study_id" not-null="true">
		<type name="integer"/>
		<comment><![CDATA[Unique study index: study_id. Created by SEQUENCE rif40_study_id_seq]]></comment>
	</column>
	<column name="inv_id" not-null="true">
		<type name="integer"/>
		<comment><![CDATA[Unique investigation inde:inv_id. Created by SEQUENCE rif40_inv_id_seq]]></comment>
	</column>
	<column name="band_id" not-null="true">
		<type name="integer"/>
		<comment><![CDATA[A band allocated to the area]]></comment>
	</column>
	<column name="genders" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Genders to be investigated: 1 - males, 2 female or 3 - both]]></comment>
	</column>
	<column name="direct_standardisation" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Standardisation: indirect (0) or direct (1)]]></comment>
	</column>
	<column name="adjusted" not-null="true">
		<type name="smallint"/>
		<comment><![CDATA[Covariate adjustment: Unadjusted (0) or adjusted (1)]]></comment>
	</column>
	<column name="observed">
		<type name="double precision"/>
		<comment><![CDATA[The number of observed cases]]></comment>
	</column>
	<column name="expected">
		<type name="double precision"/>
		<comment><![CDATA[The number of expected cases or the rate (for direct standardised results)]]></comment>
	</column>
	<column name="lower95">
		<type name="double precision"/>
		<comment><![CDATA[The lower 95% confidence interval for the relative risk (for indirectly standarised results) or the lower 95% confidence interval for the rate (for directly standardised results)]]></comment>
	</column>
	<column name="upper95">
		<type name="double precision"/>
		<comment><![CDATA[The upper 95% confidence interval for the relative risk (for indirectly standarised results) or the upper 95% confidence interval for the rate (for directly standardised results)]]></comment>
	</column>
	<column name="relative_risk">
		<type name="double precision"/>
		<comment><![CDATA[Relaitive risk (for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="smoothed_relative_risk">
		<type name="double precision"/>
		<comment><![CDATA[Smoothed relaive risk (for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="posterior_probability">
		<type name="double precision"/>
		<comment><![CDATA[The posterior probability (for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="posterior_probability_upper95">
		<type name="double precision"/>
		<comment><![CDATA[The upper 95% confidence interval of the posterior probability (for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="posterior_probability_lower95">
		<type name="double precision"/>
		<comment><![CDATA[The lower 95% confidence interval of the posterior probability (for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="residual_relative_risk">
		<type name="double precision"/>
		<comment><![CDATA[The residual relative risk(for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="residual_rr_lower95">
		<type name="double precision"/>
		<comment><![CDATA[The lower 95% confidence interval of the residual relative risk(for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="residual_rr_upper95">
		<type name="double precision"/>
		<comment><![CDATA[The upper 95% confidence interval of the residual relative risk(for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="smoothed_smr">
		<type name="double precision"/>
		<comment><![CDATA[The smoothed SMR [fully Bayesian smoothing] (for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="smoothed_smr_lower95">
		<type name="double precision"/>
		<comment><![CDATA[The lower 95% confidence interval of the smoothed SMR [fully Bayesian smoothing] (for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<column name="smoothed_smr_upper95">
		<type name="double precision"/>
		<comment><![CDATA[The upper 95% confidence interval of the smoothed SMR [fully Bayesian smoothing] (for indirectly standarised results) or NULL (for directly standardised results)]]></comment>
	</column>
	<constraint name="s1_map_pk" type="pk-constr" factor="100" table="rif_studies.s1_map">
		<columns names="study_id,band_id,inv_id,genders,adjusted,direct_standardisation" ref-type="src-columns"/>
	</constraint>
</table>

<relationship name="t_rif40_geolevels_geometry_sahsu_level1_inherits_t_rif40_sahsu_" type="relgen"
	 pk-pattern="{dt}_pk"
	 src-table="rif40.t_rif40_geolevels_geometry_sahsu_level1"
	 dst-table="rif40.t_rif40_sahsu_geometry"/>

<relationship name="t_rif40_geolevels_geometry_sahsu_level2_inherits_t_rif40_sahsu_" type="relgen"
	 pk-pattern="{dt}_pk"
	 src-table="rif40.t_rif40_geolevels_geometry_sahsu_level2"
	 dst-table="rif40.t_rif40_sahsu_geometry"/>

<relationship name="t_rif40_geolevels_geometry_sahsu_level3_inherits_t_rif40_sahsu_" type="relgen"
	 pk-pattern="{dt}_pk"
	 src-table="rif40.t_rif40_geolevels_geometry_sahsu_level3"
	 dst-table="rif40.t_rif40_sahsu_geometry"/>

<relationship name="t_rif40_geolevels_geometry_sahsu_level4_inherits_t_rif40_sahsu_" type="relgen"
	 pk-pattern="{dt}_pk"
	 src-table="rif40.t_rif40_geolevels_geometry_sahsu_level4"
	 dst-table="rif40.t_rif40_sahsu_geometry"/>

<constraint name="rif40_tables_age_group_id_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.rif40_age_group_names" table="rif40.rif40_tables">
	<columns names="age_group_id" ref-type="src-columns"/>
	<columns names="age_group_id" ref-type="dst-columns"/>
</constraint>
<constraint name="rif40_tables_theme_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.rif40_health_study_themes" table="rif40.rif40_tables">
	<columns names="theme" ref-type="src-columns"/>
	<columns names="theme" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_fdw_tables_tn_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.rif40_tables" table="rif40.t_rif40_fdw_tables">
	<columns names="table_name" ref-type="src-columns"/>
	<columns names="table_name" ref-type="dst-columns"/>
</constraint>
<constraint name="rif40_age_group_id_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.rif40_age_group_names" table="rif40.rif40_age_groups">
	<columns names="age_group_id" ref-type="src-columns"/>
	<columns names="age_group_id" ref-type="dst-columns"/>
</constraint>
<constraint name="rif40_study_shares_study_id_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.t_rif40_studies" table="rif40.rif40_study_shares">
	<columns names="study_id" ref-type="src-columns"/>
	<columns names="study_id" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_compareas_study_id_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.t_rif40_studies" table="rif40.t_rif40_comparison_areas">
	<columns names="study_id" ref-type="src-columns"/>
	<columns names="study_id" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_constats_study_id_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.t_rif40_investigations" table="rif40.t_rif40_contextual_stats">
	<columns names="study_id,inv_id" ref-type="src-columns"/>
	<columns names="study_id,inv_id" ref-type="dst-columns"/>
</constraint>
<constraint name="rif40_covariates_geog_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.rif40_geographies" table="rif40.rif40_covariates">
	<columns names="geography" ref-type="src-columns"/>
	<columns names="geography" ref-type="dst-columns"/>
</constraint>
<constraint name="rif40_covariates_geolevel_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.t_rif40_geolevels" table="rif40.rif40_covariates">
	<columns names="geography,geolevel_name" ref-type="src-columns"/>
	<columns names="geography,geolevel_name" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_geolevels_geog_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.rif40_geographies" table="rif40.t_rif40_geolevels">
	<columns names="geography" ref-type="src-columns"/>
	<columns names="geography" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_inv_conditions_si_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.t_rif40_investigations" table="rif40.t_rif40_inv_conditions">
	<columns names="study_id,inv_id" ref-type="src-columns"/>
	<columns names="study_id,inv_id" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_inv_cov_cov_name_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.rif40_covariates" table="rif40.t_rif40_inv_covariates">
	<columns names="geography,study_geolevel_name,covariate_name" ref-type="src-columns"/>
	<columns names="geography,geolevel_name,covariate_name" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_inv_cov_geography_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.rif40_geographies" table="rif40.t_rif40_inv_covariates">
	<columns names="geography" ref-type="src-columns"/>
	<columns names="geography" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_inv_cov_geolevel_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.t_rif40_geolevels" table="rif40.t_rif40_inv_covariates">
	<columns names="geography,study_geolevel_name" ref-type="src-columns"/>
	<columns names="geography,geolevel_name" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_inv_covariates_si_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.t_rif40_investigations" table="rif40.t_rif40_inv_covariates">
	<columns names="study_id,inv_id" ref-type="src-columns"/>
	<columns names="study_id,inv_id" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_inv_geography_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.rif40_geographies" table="rif40.t_rif40_investigations">
	<columns names="geography" ref-type="src-columns"/>
	<columns names="geography" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_inv_numer_tab_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.rif40_tables" table="rif40.t_rif40_investigations">
	<columns names="numer_tab" ref-type="src-columns"/>
	<columns names="table_name" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_inv_study_id_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.t_rif40_studies" table="rif40.t_rif40_investigations">
	<columns names="study_id" ref-type="src-columns"/>
	<columns names="study_id" ref-type="dst-columns"/>
</constraint>
<constraint name="rif40_outcome_groups_type_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.rif40_outcomes" table="rif40.rif40_outcome_groups">
	<columns names="outcome_type" ref-type="src-columns"/>
	<columns names="outcome_type" ref-type="dst-columns"/>
</constraint>
<constraint name="rif40_predefined_type_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.rif40_outcomes" table="rif40.rif40_predefined_groups">
	<columns names="outcome_type" ref-type="src-columns"/>
	<columns names="outcome_type" ref-type="dst-columns"/>
</constraint>
<constraint name="rif40_user_projects_project_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.t_rif40_projects" table="rif40.t_rif40_user_projects">
	<columns names="project" ref-type="src-columns"/>
	<columns names="project" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_results_study_id_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.t_rif40_investigations" table="rif40.t_rif40_results">
	<columns names="study_id,inv_id" ref-type="src-columns"/>
	<columns names="study_id,inv_id" ref-type="dst-columns"/>
</constraint>
<constraint name="rif40_studies_project_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.t_rif40_projects" table="rif40.t_rif40_studies">
	<columns names="project" ref-type="src-columns"/>
	<columns names="project" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_std_comp_geolevel_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.t_rif40_geolevels" table="rif40.t_rif40_studies">
	<columns names="geography,comparison_geolevel_name" ref-type="src-columns"/>
	<columns names="geography,geolevel_name" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_std_study_geolevel_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.t_rif40_geolevels" table="rif40.t_rif40_studies">
	<columns names="geography,study_geolevel_name" ref-type="src-columns"/>
	<columns names="geography,geolevel_name" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_stud_denom_tab_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.rif40_tables" table="rif40.t_rif40_studies">
	<columns names="denom_tab" ref-type="src-columns"/>
	<columns names="table_name" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_stud_direct_stand_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.rif40_tables" table="rif40.t_rif40_studies">
	<columns names="direct_stand_tab" ref-type="src-columns"/>
	<columns names="table_name" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_studies_geography_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.rif40_geographies" table="rif40.t_rif40_studies">
	<columns names="geography" ref-type="src-columns"/>
	<columns names="geography" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_studyareas_study_id_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.t_rif40_studies" table="rif40.t_rif40_study_areas">
	<columns names="study_id" ref-type="src-columns"/>
	<columns names="study_id" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_study_sql_sid_line_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.t_rif40_study_sql_log" table="rif40.t_rif40_study_sql">
	<columns names="study_id,statement_number" ref-type="src-columns"/>
	<columns names="study_id,statement_number" ref-type="dst-columns"/>
</constraint>
<constraint name="t_rif40_study_sqllog_stdid_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.t_rif40_studies" table="rif40.t_rif40_study_sql_log">
	<columns names="study_id" ref-type="src-columns"/>
	<columns names="study_id" ref-type="dst-columns"/>
</constraint>
<constraint name="rif40_outcome_group_name_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.rif40_outcome_groups" table="rif40.rif40_table_outcomes">
	<columns names="outcome_group_name" ref-type="src-columns"/>
	<columns names="outcome_group_name" ref-type="dst-columns"/>
</constraint>
<constraint name="rif40_outcome_numer_tab_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="rif40.rif40_tables" table="rif40.rif40_table_outcomes">
	<columns names="numer_tab" ref-type="src-columns"/>
	<columns names="table_name" ref-type="dst-columns"/>
</constraint>
<relationship name="rel_rif40_tables_rif40_age_group_names" type="relfk"
	 src-table="rif40.rif40_tables"
	 dst-table="rif40.rif40_age_group_names"
	 src-required="true" dst-required="true"/>

<relationship name="rel_rif40_tables_rif40_health_study_themes" type="relfk"
	 src-table="rif40.rif40_tables"
	 dst-table="rif40.rif40_health_study_themes"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_fdw_tables_rif40_tables" type="relfk"
	 src-table="rif40.t_rif40_fdw_tables"
	 dst-table="rif40.rif40_tables"
	 src-required="true" dst-required="true"/>

<relationship name="rel_rif40_age_groups_rif40_age_group_names" type="relfk"
	 src-table="rif40.rif40_age_groups"
	 dst-table="rif40.rif40_age_group_names"
	 src-required="true" dst-required="true"/>

<relationship name="rel_rif40_study_shares_t_rif40_studies" type="relfk"
	 src-table="rif40.rif40_study_shares"
	 dst-table="rif40.t_rif40_studies"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_comparison_areas_t_rif40_studies" type="relfk"
	 src-table="rif40.t_rif40_comparison_areas"
	 dst-table="rif40.t_rif40_studies"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_contextual_stats_t_rif40_investigations" type="relfk"
	 src-table="rif40.t_rif40_contextual_stats"
	 dst-table="rif40.t_rif40_investigations"
	 src-required="true" dst-required="true"/>

<relationship name="rel_rif40_covariates_rif40_geographies" type="relfk"
	 src-table="rif40.rif40_covariates"
	 dst-table="rif40.rif40_geographies"
	 src-required="true" dst-required="true"/>

<relationship name="rel_rif40_covariates_t_rif40_geolevels" type="relfk"
	 src-table="rif40.rif40_covariates"
	 dst-table="rif40.t_rif40_geolevels"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_geolevels_rif40_geographies" type="relfk"
	 src-table="rif40.t_rif40_geolevels"
	 dst-table="rif40.rif40_geographies"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_inv_conditions_t_rif40_investigations" type="relfk"
	 src-table="rif40.t_rif40_inv_conditions"
	 dst-table="rif40.t_rif40_investigations"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_inv_covariates_rif40_covariates" type="relfk"
	 src-table="rif40.t_rif40_inv_covariates"
	 dst-table="rif40.rif40_covariates"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_inv_covariates_rif40_geographies" type="relfk"
	 src-table="rif40.t_rif40_inv_covariates"
	 dst-table="rif40.rif40_geographies"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_inv_covariates_t_rif40_geolevels" type="relfk"
	 src-table="rif40.t_rif40_inv_covariates"
	 dst-table="rif40.t_rif40_geolevels"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_inv_covariates_t_rif40_investigations" type="relfk"
	 src-table="rif40.t_rif40_inv_covariates"
	 dst-table="rif40.t_rif40_investigations"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_investigations_rif40_geographies" type="relfk"
	 src-table="rif40.t_rif40_investigations"
	 dst-table="rif40.rif40_geographies"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_investigations_rif40_tables" type="relfk"
	 src-table="rif40.t_rif40_investigations"
	 dst-table="rif40.rif40_tables"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_investigations_t_rif40_studies" type="relfk"
	 src-table="rif40.t_rif40_investigations"
	 dst-table="rif40.t_rif40_studies"
	 src-required="true" dst-required="true"/>

<relationship name="rel_rif40_outcome_groups_rif40_outcomes" type="relfk"
	 src-table="rif40.rif40_outcome_groups"
	 dst-table="rif40.rif40_outcomes"
	 src-required="true" dst-required="true"/>

<relationship name="rel_rif40_predefined_groups_rif40_outcomes" type="relfk"
	 src-table="rif40.rif40_predefined_groups"
	 dst-table="rif40.rif40_outcomes"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_user_projects_t_rif40_projects" type="relfk"
	 src-table="rif40.t_rif40_user_projects"
	 dst-table="rif40.t_rif40_projects"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_results_t_rif40_investigations" type="relfk"
	 src-table="rif40.t_rif40_results"
	 dst-table="rif40.t_rif40_investigations"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_studies_t_rif40_projects" type="relfk"
	 src-table="rif40.t_rif40_studies"
	 dst-table="rif40.t_rif40_projects"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_studies_t_rif40_geolevels" type="relfk"
	 src-table="rif40.t_rif40_studies"
	 dst-table="rif40.t_rif40_geolevels"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_studies_rif40_tables" type="relfk"
	 src-table="rif40.t_rif40_studies"
	 dst-table="rif40.rif40_tables"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_studies_rif40_geographies" type="relfk"
	 src-table="rif40.t_rif40_studies"
	 dst-table="rif40.rif40_geographies"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_study_areas_t_rif40_studies" type="relfk"
	 src-table="rif40.t_rif40_study_areas"
	 dst-table="rif40.t_rif40_studies"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_study_sql_t_rif40_study_sql_log" type="relfk"
	 src-table="rif40.t_rif40_study_sql"
	 dst-table="rif40.t_rif40_study_sql_log"
	 src-required="true" dst-required="true"/>

<relationship name="rel_t_rif40_study_sql_log_t_rif40_studies" type="relfk"
	 src-table="rif40.t_rif40_study_sql_log"
	 dst-table="rif40.t_rif40_studies"
	 src-required="true" dst-required="true"/>

<relationship name="rel_rif40_table_outcomes_rif40_outcome_groups" type="relfk"
	 src-table="rif40.rif40_table_outcomes"
	 dst-table="rif40.rif40_outcome_groups"
	 src-required="true" dst-required="true"/>

<relationship name="rel_rif40_table_outcomes_rif40_tables" type="relfk"
	 src-table="rif40.rif40_table_outcomes"
	 dst-table="rif40.rif40_tables"
	 src-required="true" dst-required="true"/>

<permission>
	<object name="rif40" type="schema"/>
	<roles names="rif40"/>
	<privileges create="true" usage="true"/>
</permission>
</dbmodel>
