<head>
<title>
Design for Maintenance
</title>

<meta 
	name="author" 
	lang="en" 
	content="Kevin Garwood">
<meta 
	name="keywords" 
	lang="en" 
	content="Rapid Inquiry Facility, RIF, environmental health, Kevin Garwood">
	
<link rel="stylesheet" href="../rifDesignManual.css" type="text/css">
</head>

<body>

<header>
<!-- Top Banner -->


<table bgcolor="#B9CDE5">

<tr>
<td width="1000">
<img src="../img/RIFMainBanner.jpg">
</td>
</tr>



<tr>
<td width="1000">

<table align="right">
<tr">
<td width="16%">
<a href="../index.html">Welcome</a>
</td>

<td width="16%">
	<a href="../history/DesignHistory.html">History</a>
</td>
<td width="16%">
<a href="../history/Design.html">Design</a>
</td>
<td width="16%">
<a href="../tools/Tools.html">Tools</a>
</td>
<td width="16%">
<a href="../database/Database.html">Tools</a>
</td>
<td width="20%">
<a href="../aboutUs/AboutUs.html">About Us</a>
</td>
</tr>
</table>

</td>
</tr>
</table>

</header>

<nav id="sideBarNavigationLinks">
<!-- Left Side Bar -->

<p>
<b>Client Applications</b>
<p></p>
<p></p>
<p></p>
<br>

<b>Middleware</b>
<br>

<ul>
<li>
<a href="GeneralArchitecture.html">General Architecture</a>
	<ul>
	<li>
		<a href="PresentationLayer.html">Presentation Layer</a>
	</li>
	<li>
		<a href="BusinessConceptLayer.html">Business Concept layer</a>
	</li>
	<li>
		<a href="DataStorageLayer.html">Data Storage Layer</a>
	</li>
	</ul>
</li>
<li>
<b>Design Aspects</b>
	<ul>
	<li>
		<a href="DesignForSecurity.html">Security</a>
	</li>
	<li>
		<a href="DesignForConcurrency.html">Concurrency</a>
	</li>
	<li>
		<a href="DesignForTestability.html">Testability</a>
	</li>
	<li>
		<a href="DesignForValidation.html">Validation</a>
	</li>
	<li>
		<a href="DesignForMaintenance.html">Maintenance</a>
	</li>
	</ul>
</li>
</ul>

<br>
<b>Database</b>
<p></p>
<p></p>
<p></p>

</nav>


<section>
<!-- Main Content Area -->


<h1>Design for Maintenance</h1>
One of the major reasons the RIF was redeveloped was because it could no longer be
maintained. It developed a critical dependence on a piece of software that could not
be substituted and had an impact on the development of the entire code base.  One of 
our major design goals in developing the latest RIF is to make it easier to isolate
the scope of dependencies on different technologies so that the code base is robust
enough to survive aspects of obsolescence.

<p>
Dividing up the code base based on technological dependencies also allows developers 
skilled in different technologies to work efficiently with one another.  For example,
the code used to maintain the JavaScript code for client applications is maintained
independently of either the Java code used to support the middleware or the PostgreSQL
scripts used to set up and configure the RIF database.  Isolating code by technology
allows the project to leverage the value of different languages and libraries where it
will have the most effect.
</p>

<p>
We must also consider the changing composition of our team and the environment within which
we would expect future development to occur.  In the past, versions of the RIF were
maintained by one or two developers.  In the present, multiple developers will work on it
in a part time capacity, making contributions that best suit their strengths.  In a team
of multiple developers, lowering software maintenance costs may mean making it easier to 
maintain coding that is either divided amongst more developers or consolidated by fewer.
</p>

<p>
Another consideration for lowering maintenance costs is to lower the skill required by
new developers being brought onto the project.  Academic projects often have to compete
with industry for skilled talent.  If the project invests in niche technologies and 
advanced design features, there is a risk the project will not be able to maintain the
code base for the long term because of natural staff turnover.  Therefore, it is best
wherever possible to make the code base simple enough so that developers with minimal 
skill can make changes.
</p>

<p>
Our last major consideration for designing for maintenance is minimising repetitive code.
Having fragments of repetitive code in the code base makes the software brittle and more
likely to incur errors should a fragment need to change.
</p>


<h2>
Organising the code to promote a division of labours
</h2>

<h3>Dividing labour by computing concern</h3>
In this section, we will attempt to divide the code base into a grid of work units
that can be easily divided amongst multiple developers.  The first division is made
possible by two general design decisions we made:

<blockquote>
<font color="green">
<i>
<b>
<a href="SummaryOfDesignDecisions.html#gen_design2">
General Design-2
</a>
</b>: 
Organise code using a common three tier architecture that has the following layers: a presentation layer 
for managing GUI code; a business concept layer for managing the way business concepts are expressed 
in the system; and a data storage layer for managing the task of reading data from or writing data 
to the database.
</i>
</font>
</blockquote>

<p>
and
</p>

<blockquote>
<font color="green">
<i>
<b>
<a href="SummaryOfDesignDecisions.html#gen_design3">
General Design-3
</a>
</b>: 
Ensure that the presentation layer only interacts with the data storage layer via the business concept 
layer.  Never let presentation and data storage layer have direct communication with one another.
</i>
</font>
</blockquote>

<p>
These two decisions mean that changes made to electronic forms in the presentation layer
should not cause changes in the data storage layer.  The classes in the business concept
layer are designed, wherever possible, to be neutral with respect to how their data are 
stored or displayed.  Therefore, changes in either the presentation layer or the data storage
layer should have minimal impact on classes in the business concept layer.
</p>

[[[[[diagram

<p>
Changes in the business classes will likely cause changes in both the data storage 
layer and the presentation layer.  However, these changes will appear very predictable
for developers.  For example, if a new field is added to a business class, it will likely
cause a new form field to be added in the presentation layer and another field value to
set in the data storage layer.  A significant number of changes may be needed in the code
base, but because most layers will mirror concepts and properties of the business class
layer, the changes will likely be predictable.
</p>


[[[[[
<p>
Where code in one layer cannot be insulated by changes in another, the cascade of changes
that are needed should be predictable.
</p>


<p>
The powerful influence of changes in the business concept layer on other layers means 
that new developers will learn the codebase most quickly if they consult the business
concept layer first.  Once they learn about the business classes and the service APIs,
most of other code should appear easier to understand.
</p>

[[[[[[


<h3>
Dividing labour by tool
</h3>

<p>
Next, the code base will be divided up by tool rather than by type of computing concern.
The main feature areas of the software are reflected in its four tools, which are
listed in descending order of development priority:

<ul>
<li>
Study Submission Tool
</li>

<li>
Study Result Retrieval Tool
</li>

<li>
Data Loader Tool
</li>

<li>
Information Governance Tool
</li>

</ul>

<p>
Although the Study Submission and Study Result Retrieval tools share many features,
the rest of the tools do not.  Where tools may share an interest in using the same
database table fields, they are not likely to interfere with one another.  For example,
when the Data Loader Tool is loading new data, none of the other tools should be active.
</p>

<p>
That the tools may use different resources at different times does not mean changes made
in one tool will not affect the others.  However, they tend to be isolated from one 
another to help assist a clear division of roles amongst developers.
</p>



<h3>
Dividing labour by service API method
</h3>

<p>
In our discussion of concurrency, we described one measure where we try to reduce the 
state of classes used to support service methods:

XXXX

</p>

<p>
Minimising state can help lower maintenance costs as well.  If two service methods
depend on the same resource, then changes to the way one method uses it may 
cause concerns about side effects in the other.  The less state these classes 
have, the less the coding of one service method may be influenced by the coding of 
another.  
</p>

<p>
Although we know that methods do in fact share common resources, the 
tendency for them to be reasonably independent from one another makes a division of
labour by service call reasonable to do.  In general, two developers can each
be assigned to maintain a specific service method without having too much concern
about how their work would effect one another.
</p>







<h2>
Minimising repetitive code
</h2>
So far, we have organised the code in a way that could allow multiple developers
to work on discrete coding tasks whose scope of effect would be well known.  In
this part of the discussion, we try to minimise the amount of repetitive code. The 
first step is to identify classes which could be adapted to share common super
classes.  
</p>

<p>
For example, we have made separate service implementations for 
production and test environments.  The class 
<code>rifServices.dataStorageLayer.ProductionRIFStudySubmissionService</code> and 
<code>rifServices.dataStorageLayer.TestRIFStudySubmissionService</code> share
almost identical methods, except that the test class has a few additional
methods for resetting the state of the service.  We decided not to have the
test service be a subclass of the production service because we thought it 
important to have the production version retain its <code>final</code> class
designation (see discussions about <a href="DesignForSecurity.html">Security</a>
and <a href="DesignForConcurrency.html">Concurrency</a>.
</p>

<p>
As another example, many of the manager classes in the data storage layer have
a common need to log queries.
</p>

Use inheritance for classes that have many overlapping properties

test service classes production service classes have almost identical methods



Use inheritance to predict areas of future growth


study area and comparison area have identical properties
exposure covariate and adjustable covariate
geographic resolution classes such as <code>Geography, <code>GeoLevelSelect</code>, 
<code>GeoLevelArea</code> and <code>GeoLevelView</code> are all used as objects having
the same main 
GeoLevelToMap





for families of similar classes

Use aggregation for 





<h3>
Dividing labour by sub project and package
</h3>



<h2>
Lowering the skill required
</h2>








<h3>
Dividing labour by technology
</h3>





</section>
</body>
</html>